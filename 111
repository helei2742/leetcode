package com.helei.constants.order;

public enum GroupOrderStatus {

    /**
     * 自定义状态，订单被创建
     */
    CREATED,

    /**
     * 自定义状态，写入到kafka
     */
    WRITE_IN_KAFKA,

    /**
     * 自定义状态，写入到DB
     */
    WRITE_IN_DB,

    /**
     * 资金不足，不能开单
     */
    BALANCE_INSUFFICIENT,
    /**
     * 自定义状态，发送到交易所
     */
    SEND_TO_CEX

}


package com.helei.constants.order;


/**
 * 订单事件
 */
public enum OrderEvent {
    /**
     * 创建订单事件
     */
    CREATED_ORDER,
    /**
     * 发送到DB事件
     */
    SEND_TO_DB,
    /**
     * 发送到kafka事件
     */
    SEND_TO_KAFKA,
    /**
     * 重试发送到db事件
     */
    SEND_TO_DB_RETRY,
    /**
     * 重试发送到kafka事件
     */
    SEND_TO_KAFKA_RETRY,
    /**
     * 发送到db失败
     */
    SEND_TO_DB_FINAL_ERROR,
    /**
     * 发送到kafka失败
     */
    SEND_TO_KAFKA_FINAL_ERROR,
    /**
     * 不支持的事件
     */
    UN_SUPPORT_EVENT_ERROR,
    /**
     * 资金不足
     */
    BALANCE_INSUFFICIENT,
    /**
     * 完成
     */
    COMPLETE,
    /**
     * 错误
     */
    ERROR,
    /**
     * 取消
     */
    CANCEL,

}

package com.helei.constants.order;

import lombok.Getter;


import java.util.HashMap;
import java.util.Map;

/**
 * 可选的响应格式: ACK，RESULT，FULL.
 * MARKET和LIMIT订单默认使用FULL，其他订单类型默认使用ACK。
 */
@Getter
public enum OrderRespType {
    ACK,
    RESULT,
    FULL
}


package com.helei.constants.order;


/**
 * 订单状态
 */
public enum OrderStatus {
    /**
     * 订单被交易引擎接
     */
    NEW,
    /**
     * 部分订单被成交
     */
    PARTIALLY_FILLED,
    /**
     * 订单完全成交
     */
    FILLED,
    /**
     * 用户撤销了订单
     */
    CANCELED,
    /**
     * 订单没有被交易引擎接受，也没被处理
     */
    REJECTED,
    /**
     * 订单被交易引擎取消，比如：
     * 1.LIMIT FOK 订单没有成交
     * 2.市价单没有完全成交
     * 3.强平期间被取消的订单
     * 4.交易所维护期间被取消的订单
     */
    EXPIRED,
    /**
     * 表示订单由于 STP 触发而过期 （e.g. 带有 EXPIRE_TAKER 的订单与订单簿上属于同账户或同 tradeGroupId 的订单撮合）
     */
    EXPIRED_IN_MATCH,

    /**
     * 资金不足，导致无法下单
     */
    BALANCE_INSUFFICIENT,
}




package com.helei.constants.order;

/**
 * 盘口价下单模式:
 */
public enum PriceMatch {
    /**
     *  (盘口对手价)
     */
    OPPONENT,
    /**
     * (盘口对手5档价)
     */
    OPPONENT_5,
    /**
     * (盘口对手10档价)
     */
    OPPONENT_10,
    /**
     * (盘口对手20档价)
     */
    OPPONENT_20,
    /**
     * (盘口同向价)
     */
    QUEUE,
    /**
     * (盘口同向排队5档价)
     */
    QUEUE_5,
    /**
     *  (盘口同向排队10档价)
     */
    QUEUE_10,
    /**
     * (盘口同向排队20档价)
     */
    QUEUE_20,
    ;

}


package com.helei.constants.order;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

/**
 * 防止自成交模式
 */
@Getter
public enum SelfTradePreventionMode {
    NONE,
    EXPIRE_TAKER,
    EXPIRE_BOTH,
    EXPIRE_MAKER,
}


package com.helei.constants.order;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

/**
 * 条件价格触发类型 (workingType)
 */
@Getter
public enum WorkingType {
    MARK_PRICE,
    CONTRACT_PRICE
    ;
}


package com.helei.dto.account;

import com.helei.constants.order.OrderType;
import com.helei.constants.order.PositionSide;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * 账户仓位设置
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AccountPositionConfig implements Serializable {

    /**
     * 订单类型
     */
    private OrderType orderType = OrderType.LIMIT;

    /**
     * 持仓方向
     */
    private PositionSide positionSide = PositionSide.BOTH;

    /**
     * 风险百分比
     */
    private double riskPercent;

    /**
     * 杠杠倍数
     */
    private int leverage;


    /**
     * 止损金额
     */
    private int stopLoss;

}





package com.helei.dto.config;


import com.alibaba.fastjson.annotation.JSONField;
import com.helei.constants.CEXType;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.base.KeyValue;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * 运行类型设置
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class RunTypeConfig {

    private List<RunEnvTradeTypeConfig> configs;

    private SnowFlowConfig snow_flow;


    /**
     * 获取运行类型列表
     *
     * @return 类型列表
     */
    @JSONField(serialize = false)
    public List<KeyValue<RunEnv, TradeType>> getRunTypeList() {
        List<KeyValue<RunEnv, TradeType>> list = new ArrayList<>();
        for (RunEnvTradeTypeConfig runEnvTradeTypeConfig : configs) {
            list.addAll(runEnvTradeTypeConfig.getRunTypeList());
        }
        return list;
    }


    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class RunEnvTradeTypeConfig {
        private RunEnv env;

        private CEXType cexType = CEXType.BINANCE;

        private List<TradeType> trade_type;

        @JSONField(serialize = false)
        public List<KeyValue<RunEnv, TradeType>> getRunTypeList() {
            return trade_type.stream().map(e -> new KeyValue<>(env, e)).toList();
        }
    }
}



package com.helei.dto.config;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class SnowFlowConfig {

    /**
     * 数据中心id
     */
    private int datacenter_id = 0;

    /**
     * 机器id
     */
    private int machine_id = 0;
}

package com.helei.dto.order.access;

import com.helei.constants.order.TimeInForce;

import java.math.BigDecimal;

public interface LimitOrderAccess {

    void setTimeInForce(TimeInForce timeInForce);

    TimeInForce getTimeInForce();

    void setPrice(BigDecimal price);

    BigDecimal getPrice();

    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

}


package com.helei.dto.order.access;

import java.math.BigDecimal;

public interface MarketOrderAccess {

    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

    BigDecimal getQuoteOrderQty();

    void setQuoteOrderQty(BigDecimal quoteOrderQty);
}


package com.helei.dto.order.access;

import com.helei.constants.order.TimeInForce;

import java.math.BigDecimal;

public interface StopLossLimitOrderAccess {
    TimeInForce getTimeInForce();

    void setTimeInForce(TimeInForce timeInForce);

    BigDecimal getPrice();

    void setPrice(BigDecimal price);

    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

    BigDecimal getStopPrice();

    void setStopPrice(BigDecimal stopPrice);


    Integer getTrailingDelta();

    void setTrailingDelta(Integer trailingDelta);
}

package com.helei.dto.order.access;

import java.math.BigDecimal;

public interface StopLossMarketOrderAccess {
    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

    BigDecimal getStopPrice() ;

    void setStopPrice(BigDecimal stopPrice) ;

    Integer getTrailingDelta() ;

    void setTrailingDelta(Integer trailingDelta) ;

}



package com.helei.dto.order.access;

import com.helei.constants.order.TimeInForce;

import java.math.BigDecimal;

public interface TakeProfitLimitOrderAccess {


    TimeInForce getTimeInForce();

    void setTimeInForce(TimeInForce timeInForce);

    BigDecimal getPrice();

    void setPrice(BigDecimal price);

    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

    BigDecimal getStopPrice();

    void setStopPrice(BigDecimal stopPrice);

    Integer getTrailingDelta();

    void setTrailingDelta(Integer trailingDelta);
}



package com.helei.dto.order.access;

import java.math.BigDecimal;

public interface TakeProfitMarketOrderAccess {

    BigDecimal getQuantity();

    void setQuantity(BigDecimal quantity);

    BigDecimal getStopPrice();

    void setStopPrice(BigDecimal stopPrice);

    Integer getTrailingDelta();

    void setTrailingDelta(Integer trailingDelta);

}





package com.helei.dto.order.type;

import com.helei.constants.order.OrderType;
import com.helei.constants.order.TimeInForce;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.LimitOrderAccess;

import java.math.BigDecimal;

/**
 * 限价单
 */
public class LimitOrder extends CEXTradeOrderWrap implements LimitOrderAccess {


    public LimitOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.LIMIT);
    }

    @Override
    public void setTimeInForce(TimeInForce timeInForce) {
        fullFieldOrder.setTimeInForce(timeInForce);
    }

    @Override
    public TimeInForce getTimeInForce() {
        return fullFieldOrder.getTimeInForce();
    }

    @Override
    public void setPrice(BigDecimal price) {
        fullFieldOrder.setPrice(price);
    }

    @Override
    public BigDecimal getPrice() {
        return fullFieldOrder.getPrice();
    }

    @Override
    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    @Override
    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }
}



package com.helei.dto.order.type;

import com.helei.constants.order.OrderType;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.MarketOrderAccess;

import java.math.BigDecimal;

/**
 * 市价单
 */
public class MarketOrder extends CEXTradeOrderWrap implements MarketOrderAccess {
    public MarketOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.MARKET);
    }


    @Override
    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    @Override
    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }

    @Override
    public BigDecimal getQuoteOrderQty() {
        return fullFieldOrder.getQuoteOrderQty();
    }

    @Override
    public void setQuoteOrderQty(BigDecimal quoteOrderQty) {
        fullFieldOrder.setQuoteOrderQty(quoteOrderQty);
    }
}


package com.helei.dto.order.type;

import com.helei.constants.order.TimeInForce;
import com.helei.constants.order.OrderType;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.StopLossLimitOrderAccess;

import java.math.BigDecimal;

/**
 * 限价止损单
 */
public class StopLossLimitOrder extends CEXTradeOrderWrap implements StopLossLimitOrderAccess {

    public StopLossLimitOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.STOP_LIMIT);
    }


    @Override
    public TimeInForce getTimeInForce() {
        return fullFieldOrder.getTimeInForce();
    }

    @Override
    public void setTimeInForce(TimeInForce timeInForce) {
        fullFieldOrder.setTimeInForce(timeInForce);
    }

    @Override
    public BigDecimal getPrice() {
        return fullFieldOrder.getPrice();
    }

    @Override
    public void setPrice(BigDecimal price) {
        fullFieldOrder.setPrice(price);
    }

    @Override
    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    @Override
    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }

    @Override
    public BigDecimal getStopPrice() {
        return fullFieldOrder.getStopPrice();
    }

    @Override
    public void setStopPrice(BigDecimal stopPrice) {
        fullFieldOrder.setStopPrice(stopPrice);
    }

    @Override
    public Integer getTrailingDelta() {
        return fullFieldOrder.getTrailingDelta();
    }

    @Override
    public void setTrailingDelta(Integer trailingDelta) {
        fullFieldOrder.setTrailingDelta(trailingDelta);
    }

}




package com.helei.dto.order.type;

import com.helei.constants.order.OrderType;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.StopLossMarketOrderAccess;

import java.math.BigDecimal;


/**
 * 止损单
 */
public class StopLossMarketOrder extends CEXTradeOrderWrap implements StopLossMarketOrderAccess {

    public StopLossMarketOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.STOP_MARKET);
    }


    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }

    public BigDecimal getStopPrice() {
        return fullFieldOrder.getStopPrice();
    }

    public void setStopPrice(BigDecimal stopPrice) {
        fullFieldOrder.setStopPrice(stopPrice);
    }

    public Integer getTrailingDelta() {
        return fullFieldOrder.getTrailingDelta();
    }

    public void setTrailingDelta(Integer trailingDelta) {
        fullFieldOrder.setTrailingDelta(trailingDelta);
    }
}





package com.helei.dto.order.type;

import com.helei.constants.order.OrderType;
import com.helei.constants.order.TimeInForce;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.TakeProfitLimitOrderAccess;

import java.math.BigDecimal;


/**
 * 限价止盈单
 */
public class TakeProfitLimitOrder extends CEXTradeOrderWrap implements TakeProfitLimitOrderAccess {

    public TakeProfitLimitOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.TAKE_PROFIT_LIMIT);
    }

    @Override
    public TimeInForce getTimeInForce() {
        return fullFieldOrder.getTimeInForce();
    }

    @Override
    public void setTimeInForce(TimeInForce timeInForce) {
        fullFieldOrder.setTimeInForce(timeInForce);
    }

    @Override
    public BigDecimal getPrice() {
        return fullFieldOrder.getPrice();
    }

    @Override
    public void setPrice(BigDecimal price) {
        fullFieldOrder.setPrice(price);
    }

    @Override
    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    @Override
    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }

    @Override
    public BigDecimal getStopPrice() {
        return fullFieldOrder.getStopPrice();
    }

    @Override
    public void setStopPrice(BigDecimal stopPrice) {
        fullFieldOrder.setStopPrice(stopPrice);
    }

    @Override
    public Integer getTrailingDelta() {
        return fullFieldOrder.getTrailingDelta();
    }

    @Override
    public void setTrailingDelta(Integer trailingDelta) {
        fullFieldOrder.setTrailingDelta(trailingDelta);
    }
}



package com.helei.dto.order.type;

import com.helei.constants.order.OrderType;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.dto.order.access.TakeProfitMarketOrderAccess;

import java.math.BigDecimal;

/**
 * 止盈单
 */
public class TakeProfitMarketOrder extends CEXTradeOrderWrap implements TakeProfitMarketOrderAccess {

    public TakeProfitMarketOrder(BaseOrder baseOrder) {
        super(baseOrder, OrderType.TAKE_PROFIT_MARKET);
    }


    @Override
    public BigDecimal getQuantity() {
        return fullFieldOrder.getQuantity();
    }

    @Override
    public void setQuantity(BigDecimal quantity) {
        fullFieldOrder.setQuantity(quantity);
    }


    @Override
    public BigDecimal getStopPrice() {
        return fullFieldOrder.getStopPrice();
    }

    @Override
    public void setStopPrice(BigDecimal stopPrice) {
        fullFieldOrder.setStopPrice(stopPrice);
    }

    @Override
    public Integer getTrailingDelta() {
        return fullFieldOrder.getTrailingDelta();
    }

    @Override
    public void setTrailingDelta(Integer trailingDelta) {
        fullFieldOrder.setTrailingDelta(trailingDelta);
    }
}

package com.helei.dto.order;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.helei.constants.*;
import com.helei.constants.order.OrderStatus;
import com.helei.constants.order.OrderType;
import com.helei.constants.order.PositionSide;
import com.helei.constants.trade.TradeSide;
import com.helei.constants.trade.TradeType;
import lombok.*;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class BaseOrder {

    /**
     * 订单编号, 自定义订单ID
     */
    @TableId(value = "order_id", type = IdType.INPUT)
    protected String orderId;
    /**
     * 用户id
     */
    @TableField("user_id")
    protected Long userId;

    /**
     * 用户的账户id
     */
    @TableField("account_id")
    protected Long accountId;

    /**
     * 交易对，例如 BTCUSDT
     */
    @TableField("symbol")
    protected String symbol;

    /**
     * 交易方向
     */
    @TableField("side")
    protected TradeSide side;

    /**
     * 持仓方向，默认BOTH
     */
    @TableField("position_side")
    protected PositionSide positionSide;




    /**
     * 运行环境
     */
    protected RunEnv runEnv;

    /**
     * 交易类型
     */
    protected TradeType tradeType;

    /**
     * 交易所类型
     */
    protected CEXType cexType = CEXType.BINANCE;


//    ===================================  下面是基础订单不用立刻写的数据 ======================================


    /**
     * 订单类型
     */
    @TableField("type")
    protected OrderType type;

    /**
     * 订单状态
     */
    @TableField("status")
    protected OrderStatus status;

    /**
     * 是否是主订单
     */
    @TableField("main_order")
    protected Boolean mainOrder;

    /**
     * 子订单的id列表，用’,‘号隔开
     */
    @TableField("sub_order_Id_list")
    protected String subOrderIdList;

    /**
     * 如果是辅助单，则必填的关联的主单id
     */
    @TableField("connect_main_order_id")
    protected Long connectMainOrderId;

    /**
     * 订单创建时间
     */
    @TableField(value = "created_datetime", fill = FieldFill.INSERT)
    protected LocalDateTime createdDatetime;

    /**
     * 订单更新时间
     */
    @TableField(value = "updated_datetime", fill = FieldFill.INSERT_UPDATE)
    protected LocalDateTime updatedDatetime;



    /**
     * apikey
     */
    protected String apiKey;

    /**
     * 签名
     */
    protected String signature;

    /**
     * 交易所接口参数
     */
    protected Long recvWindow;

    /**
     * 交易所接口参数
     */
    protected Long timestamp;


}





package com.helei.dto.order;

import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.math.BigDecimal;


import com.helei.constants.order.*;
import lombok.*;

/**
 * <p>
 * 币安合约交易订单表
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_binance_contract_order")
public class CEXTradeOrder extends BaseOrder implements Serializable {

    @Serial
    private static final long serialVersionUID = 1231231419839753841L;

    /**
     * 是否仅减少持仓，仅适用于双向持仓模式
     */
    @TableField("reduce_only")
    protected Boolean reduceOnly;

    /**
     * 交易数量
     */
    @TableField("quantity")
    protected BigDecimal quantity;

    /**
     * 订单价格，仅限限价单
     */
    @TableField("price")
    protected BigDecimal price;

    /**
     *
     */
    @TableField("quote_order_qty")
    protected BigDecimal quoteOrderQty;

    /**
     * 移动止损
     */
    protected Integer trailingDelta;

    /**
     * 用户
     */
    @Deprecated
    @TableField("client_order_id")
    protected String clientOrderId;

    /**
     * 触发价，仅限触发单
     */
    @TableField("stop_price")
    protected BigDecimal stopPrice;

    /**
     * 是否为全平仓单，仅适用于触发单
     */
    @TableField("close_position")
    protected Boolean closePosition;

    /**
     * 追踪止损激活价格，仅TRAILING_STOP_MARKET 需要此参数, 默认为下单当前市场价格(支持不同workingType)
     */
    @TableField("activation_price")
    protected BigDecimal activationPrice;

    /**
     * 追踪止损回调比例，可取值范围[0.1, 10],其中 1代表1% ,仅TRAILING_STOP_MARKET 需要此参数
     */
    @TableField("callback_rate")
    protected BigDecimal callbackRate;

    /**
     * 订单有效期类型
     */
    @TableField("time_in_force")
    protected TimeInForce timeInForce;

    /**
     * 触发价格类型
     */
    @TableField("working_type")
    protected WorkingType workingType;

    /**
     * 价格保护开关
     */
    @TableField("price_protect")
    protected Boolean priceProtect;

    /**
     * 响应类型
     */
    @TableField("order_resp_type")
    protected OrderRespType orderRespType;

    /**
     * 不能与price同时传
     */
    @TableField("price_match")
    protected PriceMatch priceMatch;

    /**
     * 防自成交模式， 默认NONE
     */
    @TableField("self_trade_prevention_mode")
    protected SelfTradePreventionMode selfTradePreventionMode;

    /**
     * TIF为GTD时订单的自动取消时间， 当timeInforce为GTD时必传；传入的时间戳仅保留秒级精度，毫秒级部分会被自动忽略，时间戳需大于当前时间+600s且小于253402300799000
     */
    @TableField("good_till_date")
    protected Long goodTillDate;

    /**
     * 请求时间戳
     */
    @TableField("timestamp")
    protected Long timestamp;



    public CEXTradeOrder(BaseOrder baseOrder) {
        super.setRunEnv(baseOrder.getRunEnv());
        super.setTradeType(baseOrder.getTradeType());
        super.setCexType(baseOrder.getCexType());
        super.setRunEnv(baseOrder.getRunEnv());
        super.setApiKey(baseOrder.getApiKey());
        super.setSignature(baseOrder.getSignature());
        super.setRecvWindow(baseOrder.getRecvWindow());
        super.setRunEnv(baseOrder.getRunEnv());
        super.setTimestamp(baseOrder.getTimestamp());
        super.setOrderId(baseOrder.getOrderId());
        super.setUserId(baseOrder.getUserId());
        super.setAccountId(baseOrder.getAccountId());
        super.setSymbol(baseOrder.getSymbol());
        super.setSide(baseOrder.getSide());
        super.setPositionSide(baseOrder.getPositionSide());
        super.setType(baseOrder.getType());
        super.setStatus(baseOrder.getStatus());
        super.setMainOrder(baseOrder.getMainOrder());
        super.setSubOrderIdList(baseOrder.getSubOrderIdList());
        super.setConnectMainOrderId(baseOrder.getConnectMainOrderId());
        super.setCreatedDatetime(baseOrder.getCreatedDatetime());
        super.setUpdatedDatetime(baseOrder.getUpdatedDatetime());
    }
}






package com.helei.dto.order;

import com.helei.constants.order.OrderType;
import lombok.Getter;

/**
 * CEXTradeOrder 的包装类
 */
@Getter
public abstract class CEXTradeOrderWrap {

    /**
     * -- GETTER --
     *  获取完整订单
     */
    protected final CEXTradeOrder fullFieldOrder;

    public CEXTradeOrderWrap(BaseOrder baseOrder, OrderType type) {
        this.fullFieldOrder = new CEXTradeOrder(baseOrder);
        this.fullFieldOrder.setType(type);
    }
}


package com.helei.dto.trade;

import com.helei.constants.trade.TradeSide;
import com.helei.snowflack.SnowFlakeFactory;
import lombok.*;

import java.math.BigDecimal;


/**
 * 原始订单数据
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class TradeSignal {

    /**
     * 信号id
     */
    private String id;

    /**
     * 交易对
     */
    private String symbol;

    /**
     * 交易方向
     */
    private TradeSide tradeSide;

    /**
     * 目标价格
     */
    private BigDecimal targetPrice;

    /**
     * 进场价格
     */
    private BigDecimal enterPrice;

    /**
     * 止损价格
     */
    private BigDecimal stopPrice;

    /**
     * 信号创建时间戳
     */
    private long createTimestamp;

    /**
     * 信号创建的k线open时间
     */
    private long createKLineOpenTimestamp;
}






package com.helei.snowflack;


import lombok.Getter;

@Getter
public enum BRStyle {
    BINANCE_MAIN_ORDER("binance", "币安订单"),
    TRADE_SIGNAL("trade-signal", "交易信号");

    private final String code;
    private final String info;

    BRStyle(String code, String info) {
        this.code = code;
        this.info = info;
    }
}




package com.helei.snowflack;

import com.helei.dto.config.SnowFlowConfig;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.LockSupport;

/**
 * 雪花算法，解决时间回拨问题
 * 整合业务，需要根据业务编号生成id
 */
public class SnowFlakeFactory {

    /**
     * 起始的时间戳
     * 2020-01-01 00:00:00  毫秒
     */
    private final static long START_STMP = 1577808000000L;

    /**
     * 每一部分占用的位数
     */
    private final static long SEQUENCE_BIT = 12; //序列号占用的位数
    private final static long MACHINE_BIT = 5;   //机器标识占用的位数
    private final static long DATACENTER_BIT = 5;//数据中心占用的位数

    /**
     * 每一部分的最大值
     * MAX_DATACENTER_NUM = 31
     * MAX_MACHINE_NUM = 31
     * MAX_SEQUENCE = 4095
     */
    private final static long MAX_DATACENTER_NUM = ~(-1L << DATACENTER_BIT);
    private final static long MAX_MACHINE_NUM = ~(-1L << MACHINE_BIT);
    private final static long MAX_SEQUENCE = ~(-1L << SEQUENCE_BIT);

    /**
     * 每一部分向左的位移
     */
    private final static long MACHINE_LEFT = SEQUENCE_BIT;
    private final static long DATACENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;
    private final static long TIMESTMP_LEFT = DATACENTER_LEFT + DATACENTER_BIT;

    private long datacenterId = 0;  //数据中心
    private long machineId = 0;     //机器标识
    private long sequence = 0L; //序列号
    private long lastStmp = -1L;//上一次时间戳

    /**
     * 最大容忍时间, 单位毫秒, 即如果时钟只是回拨了该变量指定的时间, 那么等待相应的时间即可;
     * 考虑到sequence服务的高性能, 这个值不易过大
     */
    private static final long MAX_BACKWARD_MS = 5;

    //最大扩展字段
    private final long maxExtension = 2L;

    /**
     * 保留machineId和lastTimestamp, 以及备用machineId和其对应的lastTimestamp
     */
    private static final Map<Long, Long> machineIdLastTimeMap = new ConcurrentHashMap<>();

    /**
     * 初始化数据中心位，和机器标识
     * 0 < datacenterId < MAX_DATACENTER_NUM 31
     * 0 < machineId < MAX_MACHINE_NUM 31
     */
    public SnowFlakeFactory(long datacenterId, long machineId) {
        if (datacenterId > MAX_DATACENTER_NUM || datacenterId < 0) {
            throw new IllegalArgumentException(" datacenterId 必须介于[0,31] ");
        }
        if (machineId > MAX_MACHINE_NUM || machineId < 0) {
            throw new IllegalArgumentException(" machineId 必须介于[0,31] ");
        }
        this.datacenterId = datacenterId;
        this.machineId = machineId;
        //初始化时间 machineIdLastTimeMap
        machineIdLastTimeMap.put(machineId, getNewstmp());
    }

    public SnowFlakeFactory(SnowFlowConfig snowFlow) {
        this(snowFlow.getDatacenter_id(), snowFlow.getMachine_id());
    }


    public synchronized String nextId(BRStyle brStyle, String content) {
        return brStyle.getCode() + "-" + content + "-" + nextId();
    }


    public synchronized String nextId(BRStyle brStyle) {
        return brStyle.getCode() + nextId();
    }


    /**
     * 产生下一个ID
     */
    public synchronized long nextId() {
        //现存的扩展字段
        long extension = 0L;
        //获取当前时间毫秒数
        long currStmp = getNewstmp();
        //lastStmp = currStmp + 100;
        if (currStmp < lastStmp) {
            //throw new RuntimeException("时钟向后移动,拒绝生成id");

            // 如果时钟回拨在可接受范围内, 等待即可
            long offset = lastStmp - currStmp;
            //如果回拨时间不超过5毫秒，就等待相应的时间
            //最大扩展字段
            if (offset <= MAX_BACKWARD_MS) {
                try {
                    //睡（lastTimestamp - currentTimestamp）ms让其追上
                    LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(offset));

                    currStmp = getNewstmp();
                    //如果时间还小于当前时间，那么利用扩展字段加1
                    //或者是采用抛异常并上报
                    if (currStmp < lastStmp) {
                        //扩展字段
                        extension += 1;
                        if (extension > maxExtension) {
                            //服务器时钟被调整了,ID生成器停止服务.
                            throw new RuntimeException(String.format("时钟向后移动。拒绝生成的id %d 毫秒", lastStmp - currStmp));
                        }
                    }
                } catch (Exception e) {
                    throw new RuntimeException("生成id出错", e);
                }
            } else {
                //扩展字段
                extension += 1;
                if (extension > maxExtension) {
                    //服务器时钟被调整了,ID生成器停止服务.
                    throw new RuntimeException(String.format("时钟向后移动，超出扩展位，拒绝生成的id %d 毫秒", lastStmp - currStmp));
                }
                //获取可以用的workid，对应的时间戳，必须大于当前时间戳
                tryGenerateKeyOnBackup(currStmp);
            }
        }

        if (currStmp == lastStmp) {
            //相同毫秒内，序列号自增
            sequence = (sequence + 1) & MAX_SEQUENCE;
            //同一毫秒的序列数已经达到最大
            if (sequence == 0L) {
                currStmp = getNextMill();
            }
        } else {
            //不同毫秒内，序列号置为0
            sequence = 0L;
        }

        lastStmp = currStmp;

        long id = (currStmp - START_STMP) << (TIMESTMP_LEFT - extension)   //时间戳部分
                | datacenterId << DATACENTER_LEFT                       //数据中心部分
                | machineId << MACHINE_LEFT                             //机器标识部分
                | sequence;                                             //序列号部分
        //如果时间戳回拨就让时间少移动一位
        return id;
    }

    /**
     * 自旋锁获取当前时间戳
     */
    private long getNextMill() {
        long mill = getNewstmp();
        while (mill <= lastStmp) {
            mill = getNewstmp();
        }
        return mill;
    }

    /**
     * 获取当前时间毫秒数
     */
    private long getNewstmp() {
        return System.currentTimeMillis();
        //测试时间回拨
        //return 53501026489350000l;
    }

    /**
     * 尝试在machineId的备份machineId上生成
     * 核心优化代码在方法tryGenerateKeyOnBackup()中，BACKUP_COUNT即备份machineId数越多，
     * sequence服务避免时钟回拨影响的能力越强，但是可部署的sequence服务越少，
     * 设置BACKUP_COUNT为3，最多可以部署1024/(3+1)即256个sequence服务，完全够用，
     * 抗时钟回拨影响的能力也得到非常大的保障。
     *
     * @param currentMillis 当前时间
     */
    private long tryGenerateKeyOnBackup(long currentMillis) {
        // 遍历所有machineId(包括备用machineId, 查看哪些machineId可用)
        for (Map.Entry<Long, Long> entry : machineIdLastTimeMap.entrySet()) {
            this.machineId = entry.getKey();
            // 取得备用machineId的lastTime
            Long tempLastTime = entry.getValue();
            lastStmp = tempLastTime == null ? 0L : tempLastTime;

            // 如果找到了合适的machineId，返回合适的时间，
            if (lastStmp <= currentMillis) {
                return lastStmp;
            }
        }

        // 如果所有machineId以及备用machineId都处于时钟回拨, 那么抛出异常
        throw new IllegalStateException("时钟在向后移动，当前时间是 " + currentMillis + " 毫秒，machineId映射 = " + machineIdLastTimeMap);
    }


    public static void main(String[] args) {
        SnowFlakeFactory snowFlakeFactory = new SnowFlakeFactory(25, 25);
        String s = snowFlakeFactory.nextId(BRStyle.BINANCE_MAIN_ORDER);
        System.out.println(s);
    }
}


package com.helei.util;


/**
 * 计算订单 量工具
 */
public class OrderQuantityCalUtil {


    /**
     * 根据风险承受百分比计算还能开的数量
     *
     * @param remainingCapital 剩余资金
     * @param riskPercentage   风险百分比
     * @param currentPrice     当前价格
     * @param entryPrice       已有仓位入场价
     * @param currentQuantity  已有仓位数量
     * @param stopPrice        止损价格
     * @return 能开的数量
     */
    public static double riskPercentBasedQuantityCalculate(
            double remainingCapital,
            double riskPercentage,
            double currentPrice,
            double entryPrice,
            double currentQuantity,
            double stopPrice

    ) {
        double existingRisk = currentQuantity * (entryPrice - stopPrice);

        double riskCapital = remainingCapital * riskPercentage;

        return (riskCapital - existingRisk) / (currentPrice - stopPrice);
    }
}






package com.helei.util;

import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;


public class RedisKeyUtil {

    private static final String USER_Info_PREFIX = "user";

    public static String getUserAccountInfoKey(long userId, long accountId, RunEnv runEnv, TradeType tradeType) {

        return USER_Info_PREFIX + ":" + userId + ":" + accountId + ":" + runEnv + ":" + tradeType;
    }

    /**
     * Redis中存放相应环境数据的前缀
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return prefix
     */
    public static String getEnvKeyPrefix(RunEnv runEnv, TradeType tradeType) {
        return runEnv.getDeclaringClass() + ":" + tradeType.getDescription() + ":";
    }

    /**
     * Redis中存放用户数据的前缀
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return prefix
     */
    public static String getUserEnvKeyPrefix(RunEnv runEnv, TradeType tradeType) {
        return getEnvKeyPrefix(runEnv, tradeType) + USER_Info_PREFIX + ":";
    }

    /**
     * redis中存放用户具体数据的前缀
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return prefix
     */
    public static String getUserInfoKeyPrefix(RunEnv runEnv, TradeType tradeType) {
        return getUserEnvKeyPrefix(runEnv, tradeType) + "id:";
    }

    /**
     * redis中存放用户具体数据的匹配模式
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return pattern
     */
    public static String getUserInfoPattern(RunEnv runEnv, TradeType tradeType) {
        return getUserInfoKeyPrefix(runEnv, tradeType) + "*";
    }

    /**
     * 获取用户账户实时数据的key
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return String
     */
    public static String getUserAccountEnvRTDataKey(RunEnv runEnv, TradeType tradeType) {
        return getUserEnvKeyPrefix(runEnv, tradeType) + "realtime_account_data";
    }
}




package com.helei.binanceapi.dto.accountevent;

import com.helei.binanceapi.constants.AccountEventType;
import com.helei.constants.order.TimeInForce;
import com.helei.constants.trade.TradeSide;
import com.helei.constants.order.*;
import lombok .*;

/**
 * 订单交易更新推送事件
 */
@Getter
@Setter
@ToString

public class OrderTradeUpdateEvent extends AccountEvent {

    /**
     * 撮合时间
     */
    private Long MatchMakingTime;

    /**
     * 发生更新的交易对详情
     */
    private OrderTradeUpdateDetails orderTradeUpdateDetails;

    public OrderTradeUpdateEvent(Long eventTime) {
        super(AccountEventType.ORDER_TRADE_UPDATE, eventTime);
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = false)
    public static class OrderTradeUpdateDetails {
        /**
         * 交易对
         */
        private String symbol;
        /**
         * 客户端自定订单ID
         */
        private String clientOrderId;
        /**
         * 订单方向
         */
        private TradeSide orderSide;
        /**
         * 订单类型
         */
        private OrderType orderType;
        /**
         * 有效方式
         */
        private TimeInForce timeInForce;
        /**
         * 订单原始数量
         */
        private Double originalQuantity;
        /**
         * 订单原始价格
         */
        private Double originalPrice;
        /**
         * 订单平均价格
         */
        private Double averagePrice;
        /**
         * 条件订单触发价格,对追踪止损单无效
         */
        private String stopPrice;
        /**
         * 本次事件的具体执行类型
         */
        private OrderExcuteType executionType;
        /**
         * 订单的当前状态
         */
        private OrderStatus orderStatus;
        /**
         * 订单ID
         */
        private Long orderId;
        /**
         * 订单末次成交量
         */
        private Double lastFilledQuantity;
        /**
         * 订单累计已成交量
         */
        private Double cumulativeFilledQuantity;
        /**
         * 订单末次成交价格
         */
        private Double lastFilledPrice;
        /**
         * 手续费资产类型
         */
        private String commissionAsset;
        /**
         * 手续费数量
         */
        private Double commissionAmount;
        /**
         * 成交时间
         */
        private Long tradeTime;
        /**
         * 成交ID
         */
        private Long tradeId;
        /**
         * 买单净值
         */
        private Double buyerNetValue;
        /**
         * 卖单净值
         */
        private Double sellerNetValue;
        /**
         * 该成交是作为挂单成交吗？
         */
        private boolean maker;
        /**
         * 是否是只减仓单
         */
        private boolean reduceOnly;
        /**
         * 触发价类型
         */
        private WorkingType workingType;
        /**
         * 原始订单类型
         */
        private OrderType originalOrderType;
        /**
         * 持仓方向
         */
        private PositionSide positionSide;
        /**
         * 是否为触发平仓单,仅在条件订单情况下会推送此字段
         */
        private boolean closePosition;
        /**
         * 追踪止损激活价格,仅在追踪止损单时会推送此字段
         */
        private Double activationPrice;
        /**
         * 追踪止损回调比例,仅在追踪止损单时会推送此字段
         */
        private Double callbackRate;
        /**
         * 是否开启条件单触发保护
         */
        private boolean priceProtect;
        /**
         * 该交易实现盈亏
         */
        private Double realizedProfit;
        /**
         * 自成交防止模式
         */
        private SelfTradePreventionMode selfTradePreventionMode;
        /**
         * 价格匹配模式
         */
        private PriceMatch priceMatch;
        /**
         * TIF为GTD的订单自动取消时间
         */
        private long gtdCancelTime;
    }

}




package com.helei.binanceapi.supporter;

import com.alibaba.fastjson.JSONObject;
import com.helei.constants.order.TimeInForce;
import com.helei.binanceapi.constants.strategy.StrategyOPCode;
import com.helei.binanceapi.constants.strategy.StrategyStatus;
import com.helei.binanceapi.constants.strategy.StrategyType;
import com.helei.binanceapi.dto.accountevent.*;
import com.helei.constants.trade.MarginMode;
import com.helei.constants.trade.TradeSide;
import com.helei.constants.order.*;

import java.util.ArrayList;
import java.util.List;

public interface AccountEventConverter {
    AccountEvent convertFromJsonObject(JSONObject jsonObject);


    enum Converter implements AccountEventConverter {
        LISTEN_KEY_EXPIRED {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                return new ListenKeyExpireEvent(jsonObject.getLong("E"));
            }
        },
        ACCOUNT_UPDATE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                BalancePositionUpdateEvent event = new BalancePositionUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject a = jsonObject.getJSONObject("a");
                event.setReason(BalancePositionUpdateEvent.BPUpdateReason.valueOf(a.getString("m")));

                List<BalancePositionUpdateEvent.BalanceChangeInfo> bList = new ArrayList<>();
                for (int i = 0; i < a.getJSONArray("B").size(); i++) {
                    JSONObject jb = a.getJSONArray("B").getJSONObject(i);
                    BalancePositionUpdateEvent.BalanceChangeInfo changeInfo = new BalancePositionUpdateEvent.BalanceChangeInfo();
                    changeInfo.setAsset(jb.getString("a"));
                    changeInfo.setWalletBalance(jb.getDouble("wb"));
                    changeInfo.setBailRemoveWalletBalance(jb.getDouble("cw"));
                    changeInfo.setWalletBalanceChange(jb.getDouble("bc"));
                    bList.add(changeInfo);
                }
                event.setBalanceChangeInfos(bList);

                List<BalancePositionUpdateEvent.PositionChangeInfo> pList = new ArrayList<>();
                for (int i = 0; i < a.getJSONArray("P").size(); i++) {
                    JSONObject jb = a.getJSONArray("P").getJSONObject(i);
                    BalancePositionUpdateEvent.PositionChangeInfo changeInfo = new BalancePositionUpdateEvent.PositionChangeInfo();
                    changeInfo.setSymbol(jb.getString("s"));
                    changeInfo.setPosition(jb.getDouble("pa"));
                    changeInfo.setEnterPosition(jb.getDouble("ep"));
                    changeInfo.setBalanceEqualPrice(jb.getDouble("bep"));
                    changeInfo.setCountProfitOrLoss(jb.getDouble("cr"));
                    changeInfo.setUnrealizedProfitOrLoss(jb.getDouble("up"));
                    changeInfo.setMarginMode(MarginMode.valueOf(jb.getString("mt").toUpperCase()));
                    changeInfo.setBail(jb.getDouble("iw"));
                    changeInfo.setPositionSide(PositionSide.STATUS_MAP.get(jb.getString("ps")));
                    pList.add(changeInfo);
                }
                event.setPositionChangeInfos(pList);
                return event;
            }
        },

        MARGIN_CALL {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                BailNeedEvent event = new BailNeedEvent(jsonObject.getLong("E"));
                event.setBailRemoveWalletBalance(jsonObject.getDouble("cw"));

                JSONObject p = jsonObject.getJSONObject("p");

                BailNeedEvent.PositionNeedInfo positionNeedInfo = new BailNeedEvent.PositionNeedInfo();
                positionNeedInfo.setSymbol(p.getString("s"));
                positionNeedInfo.setPositionSide(PositionSide.STATUS_MAP.get(p.getString("ps")));
                positionNeedInfo.setPosition(p.getDouble("pa"));
                positionNeedInfo.setMarginMode(MarginMode.valueOf(p.getString("mt").toUpperCase()));
                positionNeedInfo.setBail(p.getDouble("iw"));
                positionNeedInfo.setMarkPrice(p.getDouble("mp"));
                positionNeedInfo.setUnrealizedProfitOrLoss(p.getDouble("up"));
                positionNeedInfo.setNeedBail(p.getDouble("mm"));

                return event;
            }
        },

        ORDER_TRADE_UPDATE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                OrderTradeUpdateEvent event = new OrderTradeUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject o = jsonObject.getJSONObject("o");

                OrderTradeUpdateEvent.OrderTradeUpdateDetails details = new OrderTradeUpdateEvent.OrderTradeUpdateDetails();
                details.setSymbol(o.getString("s"));
                details.setClientOrderId(o.getString("c"));
                details.setOrderSide(TradeSide.valueOf(o.getString("S").toUpperCase()));
                details.setOrderType(OrderType.valueOf(o.getString("o").toUpperCase()));
                details.setTimeInForce(TimeInForce.valueOf(o.getString("f").toUpperCase()));
                details.setOriginalQuantity(o.getDouble("q"));
                details.setOriginalPrice(o.getDouble("p"));
                details.setAveragePrice(o.getDouble("ap"));
                details.setStopPrice(o.getString("sp"));
                details.setExecutionType(OrderExcuteType.STATUS_MAP.get(o.getString("x")));
                details.setOrderStatus(OrderStatus.valueOf(o.getString("X").toUpperCase()));
                details.setOrderId(o.getLong("i"));
                details.setLastFilledQuantity(o.getDouble("l"));
                details.setCumulativeFilledQuantity(o.getDouble("z"));
                details.setLastFilledPrice(o.getDouble("L"));
                details.setCommissionAsset(o.getString("N"));
                details.setCommissionAmount(o.getDouble("n"));
                details.setTradeTime(o.getLong("T"));
                details.setTradeId(o.getLong("t"));
                details.setBuyerNetValue(o.getDouble("b"));
                details.setSellerNetValue(o.getDouble("a"));
                details.setMaker(o.getBoolean("m"));
                details.setReduceOnly(o.getBoolean("R"));
                details.setWorkingType(WorkingType.STATUS_MAP.get(o.getString("wt")));
                details.setOriginalOrderType(OrderType.valueOf(o.getString("ot").toUpperCase()));
                details.setPositionSide(PositionSide.STATUS_MAP.get(o.getString("ps")));
                details.setClosePosition(o.getBoolean("cp"));
                details.setActivationPrice(o.getDouble("AP"));
                details.setCallbackRate(o.getDouble("cr"));
                details.setPriceProtect(o.getBoolean("pP"));
                details.setRealizedProfit(o.getDouble("rp"));
                details.setSelfTradePreventionMode(SelfTradePreventionMode.STATUS_MAP.get(o.getString("V")));
                details.setPriceMatch(PriceMatch.STATUS_MAP.get(o.getString("pm")));
                details.setGtdCancelTime(o.getLong("gtd"));

                event.setOrderTradeUpdateDetails(details);
                return event;
            }
        },

        TRADE_LITE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                OrderTradeUpdateLiteEvent event = new OrderTradeUpdateLiteEvent(jsonObject.getLong("E"));
                event.setTradeTime(jsonObject.getLong("T"));
                event.setSymbol(jsonObject.getString("s"));
                event.setOriginalQuantity(jsonObject.getDouble("q"));
                event.setOriginalPrice(jsonObject.getDouble("p"));
                event.setIsMaker(jsonObject.getBoolean("m"));
                event.setClientOrderId(jsonObject.getString("c"));
                event.setOrderSide(TradeSide.valueOf(jsonObject.getString("S").toUpperCase()));
                event.setLastTradePrice(jsonObject.getDouble("L"));
                event.setLastTradeQuantity(jsonObject.getDouble("l"));
                event.setTradeId(jsonObject.getLong("t"));
                event.setOrderId(jsonObject.getLong("i"));
                return event;
            }
        },

        ACCOUNT_CONFIG_UPDATE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                AccountConfigUpdateEvent event = new AccountConfigUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject ac = jsonObject.getJSONObject("ac");
                if (ac != null) {
                    AccountConfigUpdateEvent.AccountLeverConfigChangeInfo leverConfigChangeInfo = new AccountConfigUpdateEvent.AccountLeverConfigChangeInfo();
                    leverConfigChangeInfo.setSymbol(ac.getString("s"));
                    leverConfigChangeInfo.setLever(ac.getInteger("l"));
                    event.setLeverChangeInfo(leverConfigChangeInfo);
                }

                JSONObject ai = jsonObject.getJSONObject("ai");
                if (ai != null) {
                    AccountConfigUpdateEvent.AccountInfoChangeInfo accountInfoChangeInfo = new AccountConfigUpdateEvent.AccountInfoChangeInfo();
                    accountInfoChangeInfo.setUnitBailState(ai.getBoolean("j"));
                    event.setInfoChangeInfo(accountInfoChangeInfo);
                }

                return event;
            }
        },

        STRATEGY_UPDATE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                StrategyUpdateEvent event = new StrategyUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                StrategyUpdateEvent.StrategyUpdateInfo updateInfo = new StrategyUpdateEvent.StrategyUpdateInfo();
                JSONObject su = jsonObject.getJSONObject("su");
                updateInfo.setStrategyId(su.getLong("si"));
                updateInfo.setStrategyType(StrategyType.STATUS_MAP.get(su.getString("st")));
                updateInfo.setStrategyStatus(StrategyStatus.STATUS_MAP.get(su.getString("ss")));
                updateInfo.setSymbol(su.getString("s"));
                updateInfo.setUpdateTime(su.getLong("ut"));
                updateInfo.setStrategyOPCode(StrategyOPCode.STATUS_MAP.get(su.getInteger("c")));
                event.setStrategyUpdateInfo(updateInfo);
                return event;
            }
        },

        GRID_UPDATE {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                GridUpdateEvent event = new GridUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject gu = jsonObject.getJSONObject("gu");
                GridUpdateEvent.GridUpdateInfo updateInfo = new GridUpdateEvent.GridUpdateInfo();
                updateInfo.setStrategyId(gu.getLong("si"));
                updateInfo.setStrategyType(StrategyType.STATUS_MAP.get(gu.getString("st")));
                updateInfo.setStrategyStatus(StrategyStatus.STATUS_MAP.get(gu.getString("ss")));
                updateInfo.setSymbol(gu.getString("s"));
                updateInfo.setRealizedPnl(gu.getDouble("r"));
                updateInfo.setUnpairedAverage(gu.getDouble("up"));
                updateInfo.setUnpairedQuantity(gu.getDouble("uq"));
                updateInfo.setUnpairedFee(gu.getDouble("uf"));
                updateInfo.setMatchedPnl(gu.getDouble("mp"));
                updateInfo.setUpdateTime(gu.getLong("ut"));

                event.setGridUpdateInfo(updateInfo);
                return event;
            }
        },

        CONDITIONAL_ORDER_TRIGGER_REJECT {
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                ConditionalOrderTriggerRejectEvent event = new ConditionalOrderTriggerRejectEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));


                JSONObject or = jsonObject.getJSONObject("or");
                ConditionalOrderTriggerRejectEvent.OrderRejectInfo orderRejectInfo = new ConditionalOrderTriggerRejectEvent.OrderRejectInfo();

                orderRejectInfo.setSymbol(or.getString("s"));
                orderRejectInfo.setOrderId(or.getLong("o"));
                orderRejectInfo.setRejectReason(or.getString("r"));
                event.setOrderRejectInfo(orderRejectInfo);
                return event;
            }
        }
    }
}


package com.helei.tradeapplication.cache;


import com.alibaba.fastjson.JSONObject;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.account.AccountRTData;
import com.helei.dto.account.UserInfo;
import com.helei.dto.base.KeyValue;
import com.helei.tradeapplication.config.TradeAppConfig;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import com.helei.util.RedisKeyUtil;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RBucket;
import org.redisson.api.RKeys;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiConsumer;


@Slf4j
@Component
public class UserInfoCache implements InitializingBean {

    private final TradeAppConfig tradeAppConfig = TradeAppConfig.INSTANCE;

    private final ExecutorService executor;


    /**
     * 用户信息缓存， 放基础的数据，不会放实时的仓位和资金信息
     */
    private final ConcurrentMap<String, UserInfo> userInfoCache = new ConcurrentHashMap<>();

    @Autowired
    private RedissonClient redissonClient;

    public UserInfoCache(ExecutorServiceManager executorServiceManager) {
        this.executor = executorServiceManager.getQueryExecutor();
    }


    /**
     * 获取账户的实时数据，包含资金和仓位信息
     *
     * @param env       运行环境
     * @param tradeType 交易类型
     * @param accountId 账户id
     * @return 实时数据
     */
    public AccountRTData queryAccountRTData(RunEnv env, TradeType tradeType, long accountId) {
        String accountRTDataKey = RedisKeyUtil.getUserAccountEnvRTDataKey(env, tradeType);

        RMap<String, String> rtMap = redissonClient.getMap(accountRTDataKey);

        return JSONObject.parseObject(rtMap.get(String.valueOf(accountId)), AccountRTData.class);
    }


    public void queryAllUserInfoFromCache(RunEnv env, TradeType tradeType) {

    }

    /**
     * 从redis查指定环境的所有用户信息
     *
     * @param env       运行环境
     * @param tradeType 交易类型
     */
    public int queryAllUserInfoFromRemote(RunEnv env, TradeType tradeType, BiConsumer<String, UserInfo> consumer) {
        // Step 1 获取用户的pattern
        String accountPattern = RedisKeyUtil.getUserInfoPattern(env, tradeType);
        RKeys keys = redissonClient.getKeys();

        // Step 2 用pattern筛选key， 再查对应key下的UserInfo
        AtomicInteger total = new AtomicInteger();
        keys.getKeysStreamByPattern(accountPattern).forEach(key -> {
            RBucket<String> bucket = redissonClient.getBucket(key);
            UserInfo userInfo = JSONObject.parseObject(bucket.get(), UserInfo.class);

            consumer.accept(key, userInfo);
            total.getAndIncrement();
        });
        return total.get();
    }


    /**
     * 更新用户账户信息缓存
     *
     * @throws ExecutionException   ExecutionException
     * @throws InterruptedException InterruptedException
     */
    public void updateUserInfo() throws ExecutionException, InterruptedException {
        List<CompletableFuture<Void>> futures = new ArrayList<>();

        /*
         * 获取账户信息，不包括实时的资金信息和仓位信息
         */
        for (KeyValue<RunEnv, TradeType> keyValue : tradeAppConfig.getRun_type().getRunTypeList()) {
            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
                        RunEnv env = keyValue.getKey();
                        TradeType type = keyValue.getValue();

                        log.info("开始更新环境env[{}]-tradeType[{}]的账户信息", env, type);

                        int total = queryAllUserInfoFromRemote(env, type, userInfoCache::put);

                        log.info("环境env[{}]-tradeType[{}]的账户信息初始化完毕, 共[{}]个账户", env, type, total);
                    }, executor)
                    .exceptionallyAsync(throwable -> {
                        if (throwable != null) {
                            log.error("更新用户信息时发生错误", throwable);
                            System.exit(-1);
                        }
                        return null;
                    }, executor);

            futures.add(future);
        }

        futures.forEach(CompletableFuture::join);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
        updateUserInfo();
    }

}





package com.helei.tradeapplication.config;


import com.helei.dto.config.SnowFlowConfig;
import com.helei.snowflack.SnowFlakeFactory;
import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;

import java.util.HashMap;
import java.util.Map;

@EnableKafka
@Configuration
public class SpringConfig {


    private final TradeAppConfig tradeAppConfig = TradeAppConfig.INSTANCE;

    @Bean
    public Map<String, Object> kafkaConfigs() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, tradeAppConfig.getKafka().getBootstrap_servers());
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, tradeAppConfig.getKafka().getGroup_id());  // 消费者组ID
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest");
        return configProps;
    }

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {

        return new DefaultKafkaConsumerFactory<>(kafkaConfigs());
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }


    @Bean(name = "kafkaAdminClient")
    public AdminClient kafkaAdminClient() {
        return AdminClient.create(kafkaConfigs());
    }

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer().setAddress(tradeAppConfig.getRedis().getUrl());
        return Redisson.create(config);
    }


    @Bean
    public SnowFlakeFactory snowFlakeFactory() {
        SnowFlowConfig snowFlow = tradeAppConfig.getRun_type().getSnow_flow();
        return new SnowFlakeFactory(snowFlow.getDatacenter_id(), snowFlow.getMachine_id());
    }
}




package com.helei.tradeapplication.dto;


import com.helei.constants.order.GroupOrderStatus;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.List;


/**
 * 一组订单，包括开的主单，以及跟随的止损单和止盈单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class GroupOrder {


    /**
     * 主订单
     */
    private BaseOrder mainOrder;

    /**
     * 主订单的止损单列表
     */
    private List<CEXTradeOrderWrap> stopOrders;

    /**
     * 主订单的止盈单列表
     */
    private List<CEXTradeOrderWrap> profitOrders;

    /**
     * 订单组的状态
     */
    private GroupOrderStatus groupOrderStatus;


    /**
     * 为最终存到数据库以及发送到kafka的订单列表，保护mainOrder和所有的stopOrder、profitOrder
     */
    private List<CEXTradeOrder> cexTradeOrders;

    @Override
    public String toString() {
        return "GroupOrder{" +
                "  \nmainOrder=" + mainOrder +
                ", \nstopOrders=" + stopOrders +
                ", \nprofitOrders=" + profitOrders +
                ", \ngroupOrderStatus=" + groupOrderStatus +
                ", \ncexTradeOrders=" + cexTradeOrders +
                '}';
    }
}



<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mp.mpdemo.mapper.BinanceContractOrderMapper">


    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.example.mp.mpdemo.entity.BinanceContractOrder">
        <id column="order_id" property="orderId" />
        <result column="user_id" property="userId" />
        <result column="account_id" property="accountId" />
        <result column="symbol" property="symbol" />
        <result column="side" property="side" />
        <result column="position_side" property="positionSide" />
        <result column="type" property="type" />
        <result column="reduce_only" property="reduceOnly" />
        <result column="quantity" property="quantity" />
        <result column="price" property="price" />
        <result column="client_order_id" property="clientOrderId" />
        <result column="stop_price" property="stopPrice" />
        <result column="close_position" property="closePosition" />
        <result column="activation_price" property="activationPrice" />
        <result column="callback_rate" property="callbackRate" />
        <result column="time_in_force" property="timeInForce" />
        <result column="working_type" property="workingType" />
        <result column="price_protect" property="priceProtect" />
        <result column="order_resp_type" property="orderRespType" />
        <result column="price_match" property="priceMatch" />
        <result column="self_trade_prevention_mode" property="selfTradePreventionMode" />
        <result column="good_till_date" property="goodTillDate" />
        <result column="timestamp" property="timestamp" />
        <result column="status" property="status" />
        <result column="main_order" property="mainOrder" />
        <result column="sub_order_Id_list" property="subOrderIdList" />
        <result column="connect_main_order_id" property="connectMainOrderId" />
        <result column="created_datetime" property="createdDatetime" />
        <result column="updated_datetime" property="updatedDatetime" />
    </resultMap>
</mapper>



package com.helei.tradeapplication.mapper;


import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.helei.dto.order.CEXTradeOrder;

/**
 * <p>
 * 币安合约交易订单表 Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
public interface BinanceContractOrderMapper extends BaseMapper<CEXTradeOrder> {

}





package com.helei.tradeapplication.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.tradeapplication.mapper.BinanceContractOrderMapper;
import com.helei.tradeapplication.service.IBinanceContractOrderService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * <p>
 * 币安合约交易订单表 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
@Slf4j
@Service
public class BinanceContractOrderServiceImpl extends ServiceImpl<BinanceContractOrderMapper, CEXTradeOrder> implements IBinanceContractOrderService {


    @Transactional
    @Override
    public List<CEXTradeOrder> saveGroupOrder(GroupOrder groupOrder) {

        List<CEXTradeOrder> orderList = new ArrayList<>();

        // 主单
        orderList.add((CEXTradeOrder) groupOrder.getMainOrder());

        // 止损单
        List<CEXTradeOrderWrap> stopOrders = groupOrder.getStopOrders();
        if (stopOrders != null) {
            for (CEXTradeOrderWrap stopOrder : stopOrders) {
                orderList.add(stopOrder.getFullFieldOrder());
            }
        }

        //止盈单
        List<CEXTradeOrderWrap> profitOrders = groupOrder.getProfitOrders();
        if (profitOrders != null) {
            for (CEXTradeOrderWrap profitOrder : profitOrders) {
                orderList.add(profitOrder.getFullFieldOrder());
            }
        }

        //保存到数据库
        saveBatch(orderList);

        return orderList;
    }
}









