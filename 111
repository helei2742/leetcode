package cn.com.helei.bot.app.depin_3_dos;

import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.RewordInfo;
import cn.com.helei.bot.core.supporter.mail.constants.MailProtocolType;
import cn.com.helei.bot.core.supporter.mail.factory.MailReaderFactory;
import cn.com.helei.bot.core.supporter.mail.reader.MailReader;
import cn.com.helei.bot.core.util.exception.LoginException;
import cn.com.helei.bot.core.util.exception.RegisterException;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.extern.slf4j.Slf4j;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;

import javax.mail.Message;
import javax.mail.internet.MimeMultipart;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public class ThreeDosApi {

    private static final String REGISTER_API = "https://api.dashboard.3dos.io/api/auth/register";

    private static final String LOGIN_API = "";

    private static final String KEEP_ALIVE_API = "https://m8k9mykqqj.us-east-1.awsapprunner.com/api/harvest-data";

    private static final String REWORD_QUERY_API = "https://api.dashboard.3dos.io/api/profile/me";

    private static final String HARVESTED_DATA = "Skip to content\\nNavigation Menu\\nairdropinsiders\\nType / to search\\nOverview\\nRepositories\\n156\\nProjects\\nPackages\\nStars\\n2\\n\uD83C\uDFE0\\nWorking from home\\nINSIDERS\\nairdropinsiders\\nWe show you how to make Free Money here on Crypto, Testnet, Airdrops\\nEdit profile\\n 1.1k followers · 20 following\\nhttps://t.me/AirdropInsiderID\\nhttps://t.me/airdropinsideridchat\\nAchievements\\nType \\nLanguage \\nSort \\n New\\nKiteAi-Auto-Bot Public\\n\\nAn automated interaction bot for Kite AI platform with multi-wallet and proxy support\\n\\nnodejs\\nbot\\nkiteai\\nkiteai-bot\\nkiteai-auto-bot\\n JavaScript  45  18 Updated \\n Star\\nSingulabs-Auto-Bot Public\\n\\nMulti-wallet automation tool for AI image comparison tasks. This bot supports multiple wallets and proxy configurations for distributed operation.\\n\\nnodejs\\nbot\\nairdrop\\nsingulabs\\nsingulabs-bot\\nsingulabs-auto-bot\\n JavaScript  20  6 Updated \\n Star\\nBlockpad-Auto-Bot Public\\n\\nA Node.js bot for automating tasks on BlockPad testnet with multi-account and proxy support\\n\\nnodejs\\nbot\\nblockpad\\nblockpad-auto-reff\\nblockpad-auto-bot\\n JavaScript  8  3 Updated \\n Star\\nBlockpad-AutoReff-Bot Private\\n\\nAn automated bot for creating BlockPad accounts using referral codes\\n\\nnodejs\\nbot\\nblockpad\\nblockpadfun\\nblockpad-bot\\nblockpad-auto-reff\\n JavaScript Updated \\n Star\\nNodeGo-Auto-Bot Public\\n\\nAutomated bot for NodeGo platform with support for multiple accounts and proxy configurations (HTTP/SOCKS).\\n\\nnodejs\\nbot\\njs\\nairdrop\\nnodegoai\\nnodegoai-bot\\nnodego\\n JavaScript  43  13 Updated \\n Star\\nSparkchain-Auto-Bot Public\\n\\nA WebSocket-based bot for automating Sparkchain connections with support for multiple accounts and proxy rotation.\\n\\nnodejs\\nbot\\nsparkchain\\nsparkchain-bot\\nsparkchain-auto-bot\\n JavaScript  14  6 Updated \\n Star\\nkaleido-auto-reff Public\\n\\nAuto Reff Bot Kaleidofinance.xyz\\n\\nnodejs\\nbot\\nautoreff\\nkaleido-finance\\nkaleido-bot\\nkaleido-finance-bot\\nkaleido-auto-reff\\n JavaScript  18  10 Updated \\n Star\\nKaleidoFinance-Auto-Bot Public\\n\\nKaleidoFinance Auto Bot [BETA VERSION]\\n\\nnodejs\\nbot\\nkaleido\\nkaleido-finance\\nkaleido-bot\\nkaleido-auto\\n JavaScript  59  131 Updated \\n Star\\nNaoris-Auto-Bot Public\\n\\nNaoris Network Auto Bot\\n\\nnodejs\\nbot\\nnaoris-network\\nnaoris-network-bot\\nnaoris-bot\\nnaoris-network-farm\\n JavaScript  62  17 Updated \\n Star\\nLayerEdge-Auto-Bot Public\\nlayeredge\\nlayeredge-bot\\nlayer-edge-bot\\nlayeredgeai\\nlayer-edge\\n JavaScript  66  29 MIT License Updated \\n Star\\nMeowtopia-Auto-Bot Public\\nmeowtopia\\nmeowtopia-kaiabot\\nmeowtopia-bot\\nmeowtopia-auto-bot\\n JavaScript  18  1 MIT License Updated \\n Star\\nDeSpeed-Auto-Bot Public\\nnodejs\\nbot\\ndepin\\ndespeed\\ndespeed-ai\\ndespeed-depin\\ndespeed-auto\\n JavaScript  19  5 Updated \\n Star\\nDepined-Auto-Bot Public\\ndepinedorg-bot\\ndepined-bot\\ndepinedbot\\ndepined-org-bot\\n JavaScript  34  16 Updated \\n Star\\nMinionLab-Auto-Bot Public\\nnodejs\\nbot\\nminion-lab\\nminionlab-bot\\nminion-lab-bot\\n JavaScript  13  5 Updated \\n Star\\nFractionAi-Auto-Bot Public\\nfraction-ai\\nfractionai-bot\\nfraction-ai-bot\\nfractionai-auto-bot\\n JavaScript  26  5 MIT License Updated \\n Star\\nMango-Testnet-Auto-Bot Public archive\\nmango-testnet\\nmango-testnet-bot\\nmango-testnet-auto\\nmango-testnet-auto-bot\\n JavaScript  58  30 MIT License Updated \\n Star\\nOpenLedger-Heartbeat-Bot Public\\nopenledger-bot\\nopenledger-auto\\nopenledger-auto-hearbeat\\nopenledgerbot\\n Python  26  9 Updated \\n Star\\nSoSoValue-Auto-Reff-Bot Public\\nsosovalue-bot\\nsosovaluebot\\nsosovalue-auto\\nsosovalue-auto-reff\\n JavaScript  24  4 MIT License Updated \\n Star\\nOpenLedger-Auto-Bot Public\\n\\nOpenLedger Auto Bot\\n\\nopenledger-bot\\nopen-ledger-bot\\nopenledger-auto-bot\\n JavaScript  22  8 Updated \\n Star\\nTaker-Auto-Bot Public\\n\\nAuto Reff + Auto Task\\n\\ntaker-xy\\ntaker-bot\\ntaker-farm\\n Python  15  1 Updated \\n Star\\nPlazaFinance-New Public\\nplazafinance-bot\\nplaza-finance-bot\\nplazafinance-auto\\n JavaScript  7  1 MIT License Updated \\n Star\\nAnimix-Auto-Bot Public\\nanimix-bot\\nanimix-auto\\nanimix-tg\\nanimix-bot-tg\\n JavaScript  9  4 MIT License Updated \\n Star\\nNodepay-Auto-Referral-Bot Public\\nnodepay\\nnodepay-bot\\nnodepay-farmer\\nnodepay-multifarmer\\nnodepay-autofarm\\nnodepayauto\\nnodepay-farm\\n Python  24  3 Updated \\n Star\\nDfsuionAi-AutoReff Public\\ndfusion-bot\\ndfusion-ai-autp-reff\\ndfusion-ai-bot\\n JavaScript  7 MIT License Updated \\n Star\\nCentic-Auto-Claim Public\\ncentic-io-bot\\ncentic-bot\\ncentic-io\\n JavaScript  9  2 MIT License Updated \\n Star\\nDfusions-Auto-Bot Public\\ndfsuion-ai-bot\\ndfsuions-ai\\ndfusion-bot\\n JavaScript  11  1 MIT License Updated \\n Star\\nVChars-Auto-Bot Public\\nvchars-ai\\nvchars-ai-bot\\nvcharsai-bot\\nvchars-ai-vana\\n JavaScript  4  1 MIT License Updated \\n Star\\nHivera-Auto-Bot Public\\nhivera-ai-bot\\nhiveraai-bot\\nhivera-bot\\nhivera-ai\\n JavaScript  8  2 MIT License Updated \\n Star\\nStreamAi-Bot Public\\nstream-ai-bot\\nallstrream-bot\\n JavaScript  8 MIT License Updated \\n Star\\nplazafinance-auto-bot Public\\nplazafinance-bot\\nplazafinance\\nplaza-finance-bot\\nplazafinance-farm\\n Python  6  2 Updated \\n Star\\nPrevious Next\\nFooter\\n© 2025 GitHub, Inc.\\nFooter navigation\\nTerms\\nPrivacy\\nSecurity\\nStatus\\nDocs\\nContact\\nManage cookies\\nDo not share my personal information";

    private static final String HARVESTED_URL = "https://github.com/airdropinsiders?tab=repositories";

    private static final String PASSWORD_KEY = "password";

    private static final String SECRET_KEY = "secret";

    private static final String TOKEN_KEY = "token";

    private static final String MAIL_FROM = "3DOS <noreply@3dos.io>";

    private static final String MAIL_CSS_SELECTOR = "body > div > div.content > div > a";

    private static final MailReader mailReader = MailReaderFactory.getMailReader(MailProtocolType.imap,
            "imap.gmail.com", "993", true);

    private final ThreeDosBot bot;

    public ThreeDosApi(ThreeDosBot bot) {
        this.bot = bot;
    }

    @BotMethod(jobType = BotJobType.REGISTER)
    public Result register(AccountContext exampleAC, List<AccountContext> sameABIIdList, String inviteCode) {

        JSONObject body = new JSONObject();
        body.put("country_id", "233");
        body.put("acceptTerms", true);
        body.put("referred_by", inviteCode);

        AccountBaseInfo accountBaseInfo = exampleAC.getAccountBaseInfo();
        body.put("email", accountBaseInfo.getEmail());
        body.put("password", exampleAC.getParam(PASSWORD_KEY));

        Map<String, String> headers = exampleAC.getBrowserEnv().generateHeaders();
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");


        try {
            CompletableFuture<Boolean> future = bot.syncRequest(
                    exampleAC.getProxy(),
                    REGISTER_API,
                    HttpMethod.POST,
                    headers,
                    null,
                    body,
                    () -> exampleAC.getSimpleInfo() + " 开始注册"
            ).thenApplyAsync(responseStr -> {
                JSONObject result = JSONObject.parseObject(responseStr);

                if (BooleanUtil.isTrue(result.getBoolean("flag"))) {
                    bot.logger.info(exampleAC.getSimpleInfo() + "注册成功");
                    return true;
                } else {
                    JSONArray data = result.getJSONArray("data");
                    for (int i = 0; i < data.size(); i++) {
                        if ("The email has already been taken.".equals(data.getString(i))) {
                            bot.logger.warn(exampleAC.getSimpleInfo() + "邮箱已被注册");
                            return true;
                        }
                    }
                    throw new RegisterException(exampleAC.getSimpleInfo() + "注册失败, " + responseStr);
                }
            }, bot.getExecutorService());

            future.get();
            return Result.ok();
        } catch (Exception e) {
            bot.logger.error(exampleAC.getSimpleInfo() + "注册失败，", e.getCause());
            return Result.fail("注册失败, " + e.getMessage());
        }
    }

    @BotMethod(jobType = BotJobType.ONCE_TASK)
    public void checkEmail(AccountContext accountContext) {
        AccountBaseInfo accountBaseInfo = accountContext.getAccountBaseInfo();

        bot.logger.info("开始验证邮箱 " + accountBaseInfo.getEmail());
        String emailPassword = (String) accountBaseInfo.getParams().get("imap_password");
        emailPassword = emailPassword.replace(" ", "").replace(" ", "");

        AtomicReference<String> link = new AtomicReference<>("");
        mailReader.stoppableReadMessage(
                accountBaseInfo.getEmail(),
                emailPassword,
                3,
                message -> {
                    String newValue = resolveLinkFromMessage(message);
                    link.set(newValue);
                    return StrUtil.isNotBlank(newValue);
                }
        );

        if (StrUtil.isNotBlank(link.get())) {
            bot.logger.info("邮箱[%s]验证链接获取成功, %s".formatted(accountBaseInfo.getEmail(), link));
            try {
                bot.syncRequest(
                        accountContext.getProxy(),
                        link.get(),
                        HttpMethod.GET,
                        accountContext.getBrowserEnv().generateHeaders(),
                        null,
                        null,
                        () -> "点击邮箱[%s]验证链接[%s]".formatted(accountBaseInfo.getEmail(), link),
                        3
                ).get();

            } catch (InterruptedException | ExecutionException e) {
                bot.logger.error("[%s]邮箱验证失败".formatted(accountBaseInfo.getEmail()), e);
            }
        } else {
            bot.logger.error("[%s]验证链接提取失败".formatted(accountBaseInfo.getEmail()));
        }
    }


    private String resolveLinkFromMessage(Message message) {
        try {
            boolean b = Arrays.stream(message.getFrom())
                    .anyMatch(address -> MAIL_FROM.equals(address.toString()));
            if (!b) return null;

            MimeMultipart mimeMultipart = (MimeMultipart) message.getContent();

            String htmlStr = mimeMultipart.getBodyPart(1).getContent().toString();

            Document document = Jsoup.parse(htmlStr);
            // 使用 CSS 选择器提取 a 标签内容
            Elements linkElement = document.select(MAIL_CSS_SELECTOR);
            return linkElement.attr("href");
        } catch (Exception e) {
            throw new RuntimeException("从邮件提取链接出错", e);
        }
    }

    public Result login(AccountContext exampleAC) {
        JSONObject body = new JSONObject();
        body.put("email", exampleAC.getAccountBaseInfo().getEmail());
        body.put("password", exampleAC.getParam(PASSWORD_KEY));

        Map<String, String> headers = exampleAC.getBrowserEnv().generateHeaders();
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");

        CompletableFuture<String> tokenFuture = bot.syncRequest(
                exampleAC.getProxy(),
                LOGIN_API,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> exampleAC.getSimpleInfo() + " 开始登录"
        ).thenApplyAsync(responseStr -> {
            JSONObject result = JSONObject.parseObject(responseStr);

            if (BooleanUtil.isTrue(result.getBoolean("flag"))) {
                bot.logger.info(exampleAC.getSimpleInfo() + "登录成功");
                return result.getJSONObject("data").getString(TOKEN_KEY);
            }
            throw new LoginException("登录获取token失败," + responseStr);
        });

        try {
            String token = tokenFuture.get();
            bot.logger.info("%s 登录成功, token: %s".formatted(exampleAC.getSimpleInfo(), token));
            return Result.ok(token);
        } catch (InterruptedException | ExecutionException e) {
            bot.logger.error("%s 登录失败, %s".formatted(exampleAC.getSimpleInfo(), e.getCause().getMessage()));
            return Result.fail("登录失败, " + e.getMessage());
        }
    }

    public void keepLive(AccountContext accountContext) {
        JSONObject body = new JSONObject();
        body.put("apiSecret", accountContext.getParam(SECRET_KEY));
        body.put("harvestedData", HARVESTED_DATA);
        body.put("url", HARVESTED_URL);

        Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();

        CompletableFuture<String> request = bot.syncRequest(
                accountContext.getProxy(),
                KEEP_ALIVE_API,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> accountContext.getSimpleInfo() + "发生心跳..."
        );

        try {
            String responseStr = request.get();
            bot.logger.info("%s 发送心跳成功, %s".formatted(accountContext.getSimpleInfo(), responseStr));
        } catch (InterruptedException | ExecutionException e) {
            bot.logger.error("%s 发送心跳失败, %s".formatted(accountContext.getSimpleInfo(),
                    e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
        }
    }


    public Result queryReward(AccountContext exampleAC, List<AccountContext> sameABIIdList) {
        String token = exampleAC.getParam(TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            bot.logger.warn("%s token为空".formatted(exampleAC.getSimpleInfo()));
            return Result.fail("token为空");
        }

        Map<String, String> headers = exampleAC.getBrowserEnv().generateHeaders();
        headers.put("Authorization", "Bearer " + token);
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");

        CompletableFuture<String> query = bot.syncRequest(
                exampleAC.getProxy(),
                REWORD_QUERY_API,
                HttpMethod.POST,
                headers,
                null,
                new JSONObject(),
                () -> exampleAC.getSimpleInfo() + " 开始查询奖励"
        );

        try {
            String responseStr = query.get();

            JSONObject result = JSONObject.parseObject(responseStr);
            JSONObject data = result.getJSONObject("data");

            for (AccountContext ac : sameABIIdList) {
                RewordInfo rewordInfo = ac.getRewordInfo();
                rewordInfo.setDailyPoints(data.getDouble("todays_earning"));
                rewordInfo.setTotalPoints(data.getDouble("loyalty_points"));
            }

            bot.logger.info("%s 奖励查询成功".formatted(exampleAC.getSimpleInfo()));
            return Result.ok();
        } catch (InterruptedException | ExecutionException e) {
            String errorMsg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();
            bot.logger.info("%s 奖励查询失败, %s".formatted(exampleAC.getSimpleInfo(), errorMsg));
            return Result.fail("奖励查询失败, " + errorMsg);
        }
    }
}
package cn.com.helei.bot.app.depin_3_dos;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;

import java.util.List;

@BotApplication(name = "three_dos_bot")
public class ThreeDosBot extends AnnoDriveAutoBot<ThreeDosBot> {

    private final ThreeDosApi threeDosApi;

    public ThreeDosBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);
        this.threeDosApi = new ThreeDosApi(this);
    }

    @BotMethod(jobType = BotJobType.REGISTER, jobName = "自动注册")
    public Result autoRegister(AccountContext exampleAC, List<AccountContext> sameABIIdList, String inviteCode) {
        return threeDosApi.register(exampleAC, sameABIIdList, inviteCode);
    }

    @BotMethod(jobType = BotJobType.LOGIN, jobName = "自动获取token")
    public Result login(AccountContext accountContext) {
        return threeDosApi.login(accountContext);
    }

    @BotMethod(jobType = BotJobType.QUERY_REWARD, jobName = "奖励查询", intervalInSecond = 300)
    public Result queryReward(AccountContext exampleAC, List<AccountContext> sameABIIdList) {
        return threeDosApi.queryReward(exampleAC, sameABIIdList);
    }

    @BotMethod(jobType = BotJobType.ONCE_TASK)
    public void checkEmail(AccountContext accountContext) {
        threeDosApi.checkEmail(accountContext);
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 30)
    public void keepLivePing(AccountContext accountContext) {
        threeDosApi.keepLive(accountContext);
    }

    @Override
    protected ThreeDosBot getInstance() {
        return this;
    }
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.bot.AccountWSClientBuilder;
import cn.com.helei.bot.core.bot.WebSocketClientLauncher;
import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.bot.job.AutoBotJobRuntimeParam;
import cn.com.helei.bot.core.bot.job.AutoBotJobWSParam;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.util.exception.BotMethodFormatException;
import cn.com.helei.bot.core.util.exception.BotMethodInvokeException;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;


import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T> extends AccountManageAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher = new WebSocketClientLauncher(this);

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;


    public AnnoDriveAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        super(autoBotConfig, botApi);
    }

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() {
        // 解析bot 基本信息
        return resolveAnnoBotInfo(getBotApi());
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.REGISTER.name(),
                    "未找到注册方法"
            ));
        }

        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> {
                    if (BooleanUtil.isTrue(accountContext.isSignUp())) {
                        // 账户注册过，
                        String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(), accountContext.getName(),
                                accountContext.getAccountBaseInfo().getEmail());

                        log.warn(errorMsg);

                        return CompletableFuture.completedFuture(Result.fail(errorMsg));
                    } else if (registerMethod != null) {
                        // 调用注册方法注册
                        List<AccountContext> accountContexts = accountContextMap.get(accountContext.getAccountBaseInfoId());

                        return invokeBotMethod(
                                registerMethod,
                                accountContext,
                                accountContexts,
                                getAutoBotConfig().getConfig(INVITE_CODE_KEY)
                        ).thenApplyAsync(result -> {
                            if (result.getSuccess()) {
                                for (AccountContext ac : accountContexts) {
                                    AccountContext.signUpSuccess(ac);
                                }
                            }
                            return result;
                        });
                    } else {
                        return CompletableFuture.completedFuture(Result.fail("未知错误"));
                    }
                },
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        //注册成功
                        AccountContext.signUpSuccess(accountContext);
                    }
                    return result;
                },
                BotJobType.REGISTER.name()
        );
    }


    @Override
    protected void doInit() throws DepinBotInitException {
        super.doInit();
    }

    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (loginMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.LOGIN.name(),
                    "未找到登录方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(
                        loginMethod,
                        accountContext
                ),
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        String token = result.getData() == null ? null :
                                (result.getData() instanceof String ? (String) result.getData() : null);

                        // token不为空，设置到accountContext里
                        if (StrUtil.isNotBlank(token)) {
                            accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                        } else {
                            log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                        }
                    }
                    return result;
                },
                BotJobType.LOGIN.name()
        );
    }


    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (updateRewordMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.QUERY_REWARD.name(),
                    "未找到奖励查询方法"
            ));
        }

        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> invokeBotMethod(
                        updateRewordMethod,
                        accountContext,
                        accountContextMap.get(accountContext.getAccountBaseInfoId())
                ),
                (accountContext, result) -> result,
                BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> botJobNameList() {
        return getJobParams().keySet();
    }

    @Override
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().registerJob(getJobRuntimeParamMap().get(jobName), getJobParam(jobName));
    }

    protected abstract T getInstance();


    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }


    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult;
                    CompletableFuture<Result> future;

                    try {
                        botACJobResult = new BotACJobResult(
                                getBotInfo().getId(),
                                getBotInfo().getName(),
                                jobName,
                                accountContext.getId()
                        );

                        future = buildResultFuture.apply(accountContext);

                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        throw new RuntimeException(e);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) success++;

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            log.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInfo().getId(),
                                            getBotInfo().getName(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInfo().getId())
                            .botName(getBotInfo().getName())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 解析注解，添加botInfo
     */
    private BotInfo resolveAnnoBotInfo(BotApi botApi) {

        BotApplication annotation = this.getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            BotInfo botInfo = null;

            BotInfo dbBotInfo = botApi.getBotInfoService().query().eq("name", botName).one();

            // 解析bot job 参数
            Map<String, AutoBotJobParam> jobParamMap = resolveAnnoBotJobParams();

            // 查询bot是否存在，不存在则创建
            if (dbBotInfo == null) {
                botInfo = BotInfo.generateFromAnno(annotation);

                botInfo.setJobParams(jobParamMap);

                logger.warn("不存在bot info, 自动创建...");

                try {
                    if (botApi.getBotInfoService().insertOrUpdate(botInfo) == 1) {
                        // 保存成还需查询botId
                        botInfo = botApi.getBotInfoService().query().eq("name", botName).one();
                        logger.info("保存bot信息成功, id:" + botInfo.getId());
                    }
                } catch (Exception e) {
                    throw new RuntimeException(botName + " 保存Bot信息失败", e);
                }
            } else {
                botInfo = dbBotInfo;

                botInfo.setJobParams(jobParamMap);
                getBotApi().getBotInfoService().insertOrUpdate(botInfo);
            }

            return botInfo;
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }


    /**
     * 解析注解中的方法
     */
    private Map<String, AutoBotJobParam> resolveAnnoBotJobParams() {
        Map<String, AutoBotJobParam> params = new HashMap<>();

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod, params);
                    case ONCE_TASK, TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod, params);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod, params);
                }
            }
        }

        return params;
    }

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 3
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
                && method.getParameters()[2].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                    "应为 Result methodName(AccountContext accountContext, List<AccountContext> sameAccountBaseInfoIdLists, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                    "应为 Result methodName(AccountContext ac");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
        ) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            AutoBotJobParam queryRewardJob = buildAutoBotJobParam(method, botJobMethod);

            params.put(BotJobType.QUERY_REWARD.name(), queryRewardJob);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 Result methodName(AccountContext ac, List<AccountContext> sameAccountBaseInfoIdLists)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            AutoBotJobParam jobParam = buildAutoBotJobParam(method, botJobMethod);
            String jobName = jobParam.getJobName();

            params.put(jobName, jobParam);
        } else {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     * @param params           params
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno, Map<String, AutoBotJobParam> params) {
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                AutoBotJobParam jobParam = buildAutoBotJobParam(WebSocketClientLauncher.lanuchMethod, botJobMethodAnno);

                String jobName = jobParam.getJobName();
                AutoBotJobRuntimeParam runtimeParam = getJobRuntimeParamMap().get(jobName);

                if (runtimeParam != null) {
                    // 更改执行target，添加额外参数
                    runtimeParam.setTarget(webSocketClientLauncher);
                    runtimeParam.setExtraParams(new Object[]{jobParam, new AccountWSClientBuilder() {
                        @Override
                        public BaseBotWSClient<?, ?> build(AccountContext accountContext) throws InvocationTargetException, IllegalAccessException {
                            Object invoke = method.invoke(getInstance(), accountContext);

                            return (BaseBotWSClient<?, ?>) invoke;
                        }
                    }});
                }

                // 添加到jobMap
                params.put(jobName, jobParam);
            } catch (Exception e) {
                throw new BotMethodFormatException(e);
            }
        } else {
            throw new BotMethodFormatException("websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 根据方法注解创建 AutoBotJob
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     * @return AutoBotJobParam
     */
    private @NotNull AutoBotJobParam buildAutoBotJobParam(Method method, BotMethod botJobMethodAnno) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
            } else if (botJobMethodAnno.jobType() != BotJobType.ONCE_TASK) {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            String jobName = StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName();

            // 设置job运行时参数
            getJobRuntimeParamMap().put(
                    jobName,
                    AutoBotJobRuntimeParam.builder().bot(this).method(method).build()
            );

            // 构建job task参数
            autoBotJobParam = new AutoBotJobParam(
                    botJobMethodAnno.jobType(),
                    jobName,
                    botJobMethodAnno.description(),
                    cronExpression,
                    intervalInSecond,
                    botJobMethodAnno.concurrentCount(),
                    AutoBotJobWSParam.generateFromAnno(botJobMethodAnno.bowWsConfig())
            );
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format("[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInfo().getName(), method.getName(), botJobMethodAnno.cronExpression()),
                    e
            );
        }

        return autoBotJobParam;
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInfo().getName(),
                        registerMethod.getName()
                ), e);
            }
        }, getExecutorService());
    }


    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }
}
package cn.com.helei.bot.core.constants;

public enum BotInstanceStatus {
    NEW,
    STOPPED,
    RUNNING
}
package cn.com.helei.bot.core.constants;

/**
 * Depin Bot 状态
 */
public enum BotRunTimeStatus {
    NEW,

    INIT,
    INIT_ERROR,
    INIT_FINISH,

    STARTING,
    RUNNING,
    SHUTDOWN,
}
package cn.com.helei.bot.core.entity;

import com.baomidou.mybatisplus.annotation.*;

        import lombok.*;

        import java.time.LocalDateTime;
import java.util.Map;

/**
 * @author com.helei
 * @since 2025-02-18
 */
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_instance")
public class BotInstance {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("bot_key")
    private String botKey;

    @TableField("account_table_name")
    private String accountTableName;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

    public BotInfo botInfo;
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.entity.BotInstance;
import cn.com.helei.bot.core.mvc.mapper.BotInstanceMapper;
import cn.com.helei.bot.core.mvc.service.IBotInfoService;
import cn.com.helei.bot.core.mvc.service.IBotInstanceService;
import cn.com.helei.bot.core.mvc.util.ConditionBuildUtil;
import cn.com.helei.bot.core.mvc.vo.PageQuery;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.Page;
import com.github.pagehelper.PageHelper;
import com.github.pagehelper.PageInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@Slf4j
@Service
public class BotInstanceServiceImpl extends ServiceImpl<BotInstanceMapper, BotInstance> implements IBotInstanceService {

    @Lazy
    @Autowired
    private IBotInfoService botInfoService;


    @Override
    public Integer insertOrUpdate(BotInstance botInstance) {
        botInstance.setInsertDatetime(LocalDateTime.now());
        botInstance.setUpdateDatetime(LocalDateTime.now());
        botInstance.setIsValid(1);

        return baseMapper.insertOrUpdate(botInstance);
    }

    @Override
    public Result pageQuery(PageQuery query) {

        log.info("收到查询消息 [{}]", query);
        Map<String, Object> filterMap = query.getFilterMap();

        try (Page<BotInstance> page = PageHelper.startPage(query.getPage(), query.getLimit())) {
            BotInstance condition = ConditionBuildUtil.getMapContainsCondition(
                    filterMap,
                    "params",
                    BotInstance.class
            );

            // 执行自定义查询
            List<BotInstance> botInstance = getBaseMapper().multipleConditionQuery(condition);

            // 填充botInfo
            List<Integer> botIds = botInstance.stream().map(BotInstance::getBotId).toList();
            Map<Integer, BotInfo> idMapBotInfo = botInfoService.listByIds(botIds)
                    .stream().collect(Collectors.toMap(BotInfo::getId, botInfo -> botInfo));

            for (BotInstance instance : botInstance) {
                instance.setBotInfo(idMapBotInfo.get(instance.getBotId()));
            }

            // 包装成 PageInfo 对象，便于返回分页结果
            PageInfo<BotInstance> data = new PageInfo<>(botInstance);

            log.info("[{}]查询成功, {}条", query, botInstance.size());

            return Result.ok(data);
        } catch (Exception e) {
            log.error("error", e);
            return Result.fail("error, " + e.getMessage());
        }
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.BotInstanceMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.BotInstance">
        <id column="id" property="id"/>
        <result column="bot_id" property="botId"/>
        <result column="bot_key" property="botKey"/>
        <result column="account_table_name" property="accountTableName"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.helei.bot.core.entity.BotInstance">
        INSERT INTO t_bot_instance
        (bot_id, bot_key, account_table_name, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{botId}, #{botKey}, #{accountTableName}, #{params}, #{insertDatetime}, #{updateDatetime},
                #{isValid}) ON CONFLICT(bot_id, bot_key)
DO
        UPDATE SET
            account_table_name = excluded.account_table_name,
            params = excluded.params,
            params = excluded.params,
            update_datetime = excluded.update_datetime;
    </insert>


    <select id="multipleConditionQuery"
            parameterType="cn.com.helei.bot.core.entity.BotInstance"
            resultType="cn.com.helei.bot.core.entity.BotInstance">
        select
        t.id as id,
        t.bot_id as botId,
        t.bot_key as botKey,
        t.account_table_name as accountTableName,
        t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_bot_instance as t
        <if test="params != null and !params.isEmpty()">
            left join json_each(t.params) json_each
        </if>
        <where>
            is_valid = 1
            <if test="botId != null">
                and t.bot_id = #{botId}
            </if>
            <if test="botKey != null">
                and t.bot_key = #{botKey}
            </if>
            <if test="accountTableName != null">
                and t.account_table_name = #{accountTableName}
            </if>
            <if test="params != null and !params.isEmpty()">
                and
                <foreach collection="params" item='entry' index='key' separator='AND'>
                    json_each.key = #{key} and json_each.value = #{entry}
                </foreach>
            </if>
        </where>
    </select>
</mapper>
