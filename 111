package com.helei.telegramebot.bot.impl;

import com.helei.dto.base.Result;
import com.helei.solanarpc.dto.SolanaAddress;
import com.helei.telegramebot.bot.MenuBaseTelegramBot;
import com.helei.telegramebot.bot.SolanaTelegramBot;
import com.helei.telegramebot.bot.menu.solana.SolanaBotMenu;

import com.helei.telegramebot.config.command.SolanaBotCommand;
import com.helei.telegramebot.config.command.TelegramBotNameSpaceCommand;
import com.helei.telegramebot.service.ISolanaATBotWalletPersistenceService;
import com.helei.telegramebot.service.ITelegramPersistenceService;
import com.helei.telegramebot.service.impl.SolanaATBotPersistenceService;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;
import java.util.concurrent.ExecutorService;


@Setter
@Slf4j
public class SolanaAutoTradeTelegramBot extends MenuBaseTelegramBot implements SolanaTelegramBot {


    private SolanaATBotPersistenceService solanaATBotPersistenceService;


    public SolanaAutoTradeTelegramBot(
            String botUsername,
            String token,
            SolanaATBotPersistenceService solanaATBotPersistenceService,
            ITelegramPersistenceService telegramPersistenceService,
            ExecutorService executor
    ) {
        super(botUsername, token, telegramPersistenceService, executor);
        super.init(new SolanaBotMenu(this, getTelegramPersistenceService(), solanaATBotPersistenceService));
    }


    @Override
    public Result commandMessageHandler(TelegramBotNameSpaceCommand.NameSpace nameSpace, String nameSpaceCommand, List<?> params, Message message) {
        SolanaBotCommand solanaBotCommand = SolanaBotCommand.valueOf(nameSpaceCommand);

        return switch (solanaBotCommand) {
            case BIND_WALLET_ADDRESS -> bindWalletAddress(params, message);
            case ADD_LISTEN_ACCOUNT -> updateTransactionListenAccount(params, message);
            case CANCEL_LISTEN_ACCOUNT -> cancelTransactionListenAccount(params, message);
        };
    }


    @Override
    public Result normalMessageHandler(String messageText, Message message) {
        return null;
    }

    @Override
    public Result bindWalletAddress(List<?> params, Message message) {
        //Step 1 参数校验
        if (params.isEmpty()) return Result.fail("参数错误");

        //Step 2 解析参数
        String privateKey = (String) params.getFirst();

        return solanaATBotPersistenceService.getWallet().bindWalletByPrivateKey(getBotUsername(), String.valueOf(message.getChatId()), privateKey);
    }


    @Override
    public Result updateTransactionListenAccount(List<?> params, Message message) {
        //Step 1 参数校验
        if (params.isEmpty()) return Result.fail("参数错误");

        //Step 2 解析参数
        String address = (String) params.getFirst();
        String name = "";
        if (params.size() >= 2) {
            name = (String) params.get(1);
        }
        String description = "";
        if (params.size() >= 3) {
            description = (String) params.get(2);
        }

        SolanaAddress solanaAddress = SolanaAddress
                .builder()
                .accountAddress(address)
                .name(name)
                .description(description)
                .build();

        //Step 3 保存
        return solanaATBotPersistenceService.getWallet().updateChatListenAddress(getBotUsername(), String.valueOf(message.getChatId()), solanaAddress);
    }

    @Override
    public Result cancelTransactionListenAccount(List<?> params, Message message) {
        //Step 1 参数校验
        if (params.isEmpty()) return Result.fail("参数错误");

        //Step 2 解析参数
        String address = (String) params.getFirst();

        //Step 3 删除
        return solanaATBotPersistenceService.getWallet().deleteChatListenAddress(getBotUsername(), String.valueOf(message.getChatId()), address);
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.transaction;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.BaseTGMenuNode;

import java.util.List;

public class TransactionMenuNode extends BaseTGMenuNode {

    public TransactionMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "交易", "transaction");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {

        return "交易";
    }

}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;

import java.util.List;

public class SendSolSettingAmountCountMenuNode extends AbstractWalletMenuNode {

    public SendSolSettingAmountCountMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "x sol", "amountCount");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请输入转出的sol个数";
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;

import java.util.List;

public class SendSolSettingAmountPercentMenuNode extends AbstractWalletMenuNode {

    public SendSolSettingAmountPercentMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "x%", "amountPercent");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "输入提现百分比";
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;

import java.util.List;

public class SendSolSettingRefreshMenuNode extends AbstractWalletMenuNode {

    public SendSolSettingRefreshMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "刷新", "refresh");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "";
    }
}




package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;

import java.util.List;

public class SendSolSettingStartMenuNode extends AbstractWalletMenuNode {

    public SendSolSettingStartMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "开始提现", "start_send");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "";
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;

import java.util.List;

public class SendSolSettingTargetAddressMenuNode extends AbstractWalletMenuNode {



    public SendSolSettingTargetAddressMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "提现收款钱包", "target_address");
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请输入收款钱包的地址";
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import com.helei.telegramebot.entity.ChatWallet;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;

public class SendSolMenuNode extends AbstractWalletMenuNode {

    public SendSolMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "转出sol", "send_sol");

        getSubMenu().add(new SendSolSettingMenuNode(this));
    }


    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        //Step 1 解析参数
        String chatId = String.valueOf(message.getChatId());

        if (params == null || params.isEmpty()) {
            sendSimpleMessage(chatId, "参数错误");
            return getParentMenu();
        }

        String publicKey = (String) params.getFirst();

        //Step 2 校验地址是否存在
        ChatWallet query = ChatWallet.builder().chatId(chatId).publicKey(publicKey).build();
        ChatWallet chatWallet = getPersistenceService().getWallet().queryChatIdWallet(query);
        if (chatWallet == null) {
            sendSimpleMessage(chatId, "未绑定地址\n" + publicKey);
            return getParentMenu();
        }

        //Step 3 发送子键盘
        params.add(chatWallet);

        return getSubMenu().getFirst();
    }


    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请选择希望转出sol的钱包";
    }
}





package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.child.*;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;

public class SendSolSettingMenuNode extends AbstractWalletMenuNode {

    public SendSolSettingMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "设置", "setting");
        getSubMenu().add(new SendSolSettingAmountCountMenuNode(this));
        getSubMenu().add(new SendSolSettingAmountPercentMenuNode(this));
        getSubMenu().add(new SendSolSettingTargetAddressMenuNode(this));
        getSubMenu().add(new SendSolSettingRefreshMenuNode(this));
        getSubMenu().add(new SendSolSettingStartMenuNode(this));
    }

    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        return null;
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请点击下方输入数量、转账地址后，点击发起提现完成sol转账";
    }
}



package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child;

import cn.hutool.core.util.StrUtil;
import com.helei.dto.base.Result;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ForceReplyKeyboard;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboard;

import java.util.List;

@Slf4j
public class BindWalletMenuNode extends AbstractWalletMenuNode {


    public BindWalletMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "绑定钱包", "bind_wallet");
    }


    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请输入需要绑定的钱包私匙";
    }


    @Override
    public ReplyKeyboard buildDefaultMenuKeyBoard(String chatId, List<Object> params) {
        ForceReplyKeyboard forceReplyKeyboard = new ForceReplyKeyboard();
        forceReplyKeyboard.setSelective(true);

        return forceReplyKeyboard;
    }

    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        String chatId = String.valueOf(message.getChatId());

        //Step 1 参数校验
        String privateKey = (String) params.getFirst();
        if (StrUtil.isBlank(privateKey)) {
            log.error("chatId[{}] - [{}]命令参数为空", getButtonText(), chatId);
            return getParentMenu();
        }

        //Step 2 保存
        Result result = getPersistenceService().getWallet().bindWalletByPrivateKey(
                getBot().getBotUsername(),
                chatId,
                privateKey
        );

        //Step 4 返回结果
        if (!result.getSuccess()) {
            sendSimpleMessage(chatId, "保存钱包信息失败, " + result.getErrorMsg());
        } else {
            sendSimpleMessage(chatId, "保存钱包信息成功");
        }
        sendDeleteMessage(chatId, message.getMessageId());

        if (message.getReplyToMessage() != null) {
            sendDeleteMessage(chatId, (message.getReplyToMessage().getMessageId()));
        }

        //Step 5 返回菜单状态，到上一级
        return getParentMenu();
    }

}



package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;


/**
 * 解除绑定钱包
 */
public class CancelBindWalletMenuNode extends AbstractWalletMenuNode {

    public CancelBindWalletMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "解除绑定", "change_bind_wallet");
    }


    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        //Step 1 解析参数
        if (params == null || params.isEmpty()) {
            return getParentMenu();
        }

        String publicKey = (String) params.getFirst();
        String chatId = String.valueOf(message.getChatId());

        //Step 2 持久化更改
        boolean success = getPersistenceService().getWallet().deleteChatBindWallet(chatId, publicKey);


        //Step 3 返回结果
        if (success) {
            sendSimpleMessage(chatId, "解除绑定钱包[" + publicKey +"]成功");
        } else {
            sendSimpleMessage(chatId, "解除绑定钱包[" + publicKey +"]失败");
        }


        if (message.getReplyToMessage() != null) {
            sendDeleteMessage(chatId, message.getReplyToMessage().getMessageId());
        }


        //Step 4 更改菜单状态，返回上一级
        return getParentMenu();
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请选择希望解除绑定的钱包\n注意,解绑操作无法撤回，请确保已保存好私匙,否则无法恢复钱包，可能会造成资产损失";
    }
}



package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child;

import cn.hutool.core.util.StrUtil;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import com.helei.telegramebot.entity.ChatWallet;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;



/**
 * 修改默认钱包菜单
 */
@Slf4j
public class ChangeDefaultWalletMenuNode extends AbstractWalletMenuNode {


    public ChangeDefaultWalletMenuNode(TGMenuNode parentMenu) {
        super(parentMenu,  "切换默认钱包", "change_default_wallet");
    }

    @Override
    public TGMenuNode menuNodeReplyHandler( List<Object> params, Message message) {
        String chatId = String.valueOf(message.getChatId());

        //Step 1 参数校验
        String pubKey = (String) params.getFirst();
        if (StrUtil.isBlank(pubKey)) {
            log.error("chatId[{}] - [{}]命令参数为空", getButtonText(), chatId);
            return getParentMenu();
        }

        //Step 2 公钥校验
        ChatWallet query = new ChatWallet();
        query.setPublicKey(pubKey);
        query.setChatId(chatId);

        ChatWallet chatWallet = getPersistenceService().getWallet().queryChatIdWallet(query);
        if (chatWallet == null) {
            log.error("chatId[{}]不存在publicKey[{}]的钱包", chatId, pubKey);
            return getParentMenu();
        }

        //Step 3 更新数据
        getPersistenceService().getWallet().updateDefaultWalletAddress(getBot().getBotUsername(), chatId, pubKey, true);


        //Step 4 删除之前的选择消息
        sendDeleteMessage(chatId, message.getMessageId());


        //Step 5 发送消息提示
        sendSimpleMessage(chatId, String.format("默认钱包已更改为[%s]-[%s...]", chatWallet.getId(), pubKey.substring(0, 8)));


        return getParentMenu();
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请点击键盘选择要更换的默认钱包";
    }
}


package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import com.helei.telegramebot.entity.ChatWallet;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;

public class ExportPrivateKeyMenuNode extends AbstractWalletMenuNode {

    public ExportPrivateKeyMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "导出私匙", "export_private_key");
    }

    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        //Step 1 解析参数
        if (params == null || params.isEmpty()) {
            return getParentMenu();
        }

        String publicKey = (String) params.getFirst();
        String chatId = String.valueOf(message.getChatId());


        //Step 2 查询钱包信息
        ChatWallet query = new ChatWallet();
        query.setChatId(chatId);
        query.setPublicKey(publicKey);

        ChatWallet chatWallet = getPersistenceService().getWallet().queryChatIdWallet(query);

        //Step 3 返回结果
        if (chatWallet == null) {
            sendSimpleMessage(chatId, "不存在钱包信息 address:\n" + publicKey);
        } else {
            sendSimpleMessage(chatId, String.format("钱包地址:\n%s\n私匙:\n%s", publicKey, chatWallet.getPrivateKey()));
        }

        if (message.getReplyToMessage() != null) {
            sendDeleteMessage(chatId, message.getReplyToMessage().getMessageId());
        }

        return getParentMenu();
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请选择希望导出私匙的钱包";
    }
}




package com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.AbstractWalletMenuNode;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.util.List;


/**
 * 设置钱包名称菜单节点
 */
public class SetWalletNameMenuNode extends AbstractWalletMenuNode {


    public SetWalletNameMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "设置钱包名称", "set_wallet_name");
    }


    @Override
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {


        return null;
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "请选择希望设置名称的钱包";
    }
}



package com.helei.telegramebot.bot.menu.solana.tree.child.wallet;

import com.helei.telegramebot.bot.MenuBaseTelegramBot;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.BaseTGMenuNode;
import com.helei.telegramebot.entity.ChatWallet;
import com.helei.telegramebot.service.impl.SolanaATBotPersistenceService;
import jakarta.validation.constraints.NotNull;
import lombok.Getter;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboard;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Getter
public abstract class AbstractWalletMenuNode extends BaseTGMenuNode {



    public AbstractWalletMenuNode(TGMenuNode parentMenu, String buttonText, String callbackData) {
        super(parentMenu, buttonText, callbackData);
    }

    /**
     * 初始化
     *
     * @param bot                           bot
     * @param solanaATBotPersistenceService solanaATBotPersistenceService
     */
    public void init(MenuBaseTelegramBot bot, SolanaATBotPersistenceService solanaATBotPersistenceService) {
        super.init(bot, solanaATBotPersistenceService);
    }


    @Override
    public ReplyKeyboard buildDefaultMenuKeyBoard(String chatId, List<Object> params) {
        return buildWalletSelectDynamicKeyBoard(chatId);
    }

    /**
     * 构建选择钱包的动态键盘
     *
     * @param chatId chatId
     * @return 键盘
     */
    private @NotNull ReplyKeyboard buildWalletSelectDynamicKeyBoard(String chatId) {

        //Step 1 查默认钱包公匙
        String pubKey = getPersistenceService().getWallet().queryChatIdDefaultWalletAddress(getBot().getBotUsername(), chatId);

        //Step 2 查询所有钱包
        List<ChatWallet> chatWallets = getPersistenceService().getWallet().queryChatIdAllWallet(getBot().getBotUsername(), chatId);

        //Step 3 分出默认钱包
        ChatWallet defaultWallet = dispatchDefaultWallet(chatWallets, pubKey);

        //Step 5 构建动态键盘
        InlineKeyboardMarkup markup = new InlineKeyboardMarkup();
        List<List<InlineKeyboardButton>> keyboardRows = new ArrayList<>();

        InlineKeyboardButton defaultButton = new InlineKeyboardButton("默认钱包 - " + 0);
        defaultButton.setCallbackData(getCallbackData() + " " + defaultWallet.getPublicKey());
        keyboardRows.add(List.of(defaultButton));

        for (int i = 0; i < chatWallets.size(); i++) {
            ChatWallet chatWallet = chatWallets.get(i);

            InlineKeyboardButton inlineKeyboardButton = new InlineKeyboardButton("钱包 - " + i + 1);
            inlineKeyboardButton.setCallbackData(getCallbackData() + " " + chatWallet.getPublicKey());
            keyboardRows.add(List.of(inlineKeyboardButton));
        }
        markup.setKeyboard(keyboardRows);
        return markup;
    }

    /**
     * 分出默认钱包，会减少chatWallets
     *
     * @param chatWallets 钱包list
     * @param pubKey      默认钱包的公钥
     * @return 默认钱包
     */
    protected ChatWallet dispatchDefaultWallet(List<ChatWallet> chatWallets, String pubKey) {
        ChatWallet defaultWallet = null;
        Optional<ChatWallet> first = chatWallets.stream().filter(c -> !pubKey.equals(c.getPublicKey())).findFirst();
        if (first.isPresent()) {
            defaultWallet = first.get();
            chatWallets.remove(defaultWallet);
        }
        return defaultWallet;
    }
}



package com.helei.telegramebot.bot.menu.solana.tree.child.wallet;

import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.*;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.child.sendsol.SendSolMenuNode;
import com.helei.telegramebot.entity.ChatWallet;
import com.helei.telegramebot.template.SolanaBotWalletTittleTemplate;
import org.jetbrains.annotations.NotNull;

import java.util.List;

public class WalletMenuNode extends AbstractWalletMenuNode {

    public WalletMenuNode(TGMenuNode parentMenu) {
        super(parentMenu, "我的钱包", "wallet");

        getSubMenu().add(new BindWalletMenuNode(this));
        getSubMenu().add(new CancelBindWalletMenuNode(this));
        getSubMenu().add(new ChangeDefaultWalletMenuNode(this));
        getSubMenu().add(new ExportPrivateKeyMenuNode(this));
        getSubMenu().add(new SendSolMenuNode(this));
        getSubMenu().add(new SetWalletNameMenuNode(this));
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {

        //Step 1 查默认钱包公匙
        String pubKey = getPersistenceService().getWallet().queryChatIdDefaultWalletAddress(getBot().getBotUsername(), chatId);

        //Step 2 查询所有钱包
        List<ChatWallet> chatWallets = getPersistenceService().getWallet().queryChatIdAllWallet(getBot().getBotUsername(), chatId);

        //Step 3 找到默认钱包
        ChatWallet defaultWallet = dispatchDefaultWallet(chatWallets, pubKey);

        //Step 3 生成title

        return buildAllWalletInfoStr(defaultWallet, chatWallets);
    }


    /**
     * 构建所有钱包信息字符串
     *
     * @param defaultWallet defaultWallet
     * @param chatWallets   chatWallets
     * @return string
     */
    private static @NotNull String buildAllWalletInfoStr(ChatWallet defaultWallet, List<ChatWallet> chatWallets) {
        StringBuilder tittle = new StringBuilder();

        if (defaultWallet != null) {
            tittle.append("默认钱包:\n").append(SolanaBotWalletTittleTemplate.aChatWalletPrintStr(defaultWallet, defaultWallet.getId()));
        }

        tittle.append("其它钱包:\n");
        for (ChatWallet chatWallet : chatWallets) {
            tittle.append(SolanaBotWalletTittleTemplate.aChatWalletPrintStr(chatWallet, chatWallet.getId())).append("\n");
        }

        return tittle.toString();
    }
}


package com.helei.telegramebot.bot.menu.solana.tree;


import com.helei.telegramebot.bot.menu.solana.BaseTGMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.transaction.TransactionMenuNode;
import com.helei.telegramebot.bot.menu.solana.tree.child.wallet.WalletMenuNode;

import java.util.List;

public class MainMenuNode extends BaseTGMenuNode {

    public MainMenuNode() {
        super(null, "主菜单", "main");
        getSubMenu().add(new WalletMenuNode(this));
        getSubMenu().add(new TransactionMenuNode(this));
    }

    @Override
    public String getTittleContext(String chatId, List<Object> params) {
        return "欢迎来到主菜单";
    }
}



package com.helei.telegramebot.bot.menu.solana;

import cn.hutool.core.lang.Pair;
import com.google.common.collect.Lists;
import com.helei.telegramebot.bot.AbstractTelegramBot;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.service.impl.SolanaATBotPersistenceService;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.methods.BotApiMethod;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.methods.updatingmessages.DeleteMessage;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboard;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.ArrayList;
import java.util.List;


@Getter
@Slf4j
public abstract class BaseTGMenuNode extends TGMenuNode {

    private AbstractTelegramBot bot;

    private SolanaATBotPersistenceService persistenceService;

    public BaseTGMenuNode(
            TGMenuNode parentMenu,
            String buttonText,
            String callbackData
    ) {
        super(parentMenu, buttonText, callbackData);
    }

    protected void init(AbstractTelegramBot bot, SolanaATBotPersistenceService persistenceService) {
        this.bot = bot;
        this.persistenceService = persistenceService;
    }

    @Override
    public Pair<String, ReplyKeyboard> getTittleAndMenuKeyBoard(String chatId, List<Object> params) {
        String tittle = getFullButtonText() + "\n" + getTittleContext(chatId, params);
        return new Pair<>(tittle, buildDefaultMenuKeyBoard(chatId, params));
    }


    public ReplyKeyboard buildDefaultMenuKeyBoard(String chatId, List<Object> params) {
        // 默认， 从subMenu构建

        InlineKeyboardMarkup markup = new InlineKeyboardMarkup();
        List<List<InlineKeyboardButton>> keyboardRows = new ArrayList<>();

        // 一行两个
        List<List<TGMenuNode>> partitions = Lists.partition(new ArrayList<>(getSubMenu()), 2);

        //列表
        for (List<TGMenuNode> partition : partitions) {
            keyboardRows.add(createKeyboardRow(partition, chatId, params));
        }

        //返回父菜单选项
        if (getParentMenu() != null) {
            keyboardRows.add(createKeyboardRow(List.of(getParentMenu()), chatId, params));
        }

        markup.setKeyboard(keyboardRows);
        return markup;
    }

    private List<InlineKeyboardButton> createKeyboardRow(List<TGMenuNode> list, String chatId, List<Object> params) {
        return list.stream().map(kv -> kv.getDynamicKeyboardButton(chatId, params)).toList();
    }


    public abstract String getTittleContext(String chatId, List<Object> params);


    /**
     * 删除消息
     *
     * @param chatId    chatId
     * @param messageId messageId
     */
    protected void sendDeleteMessage(String chatId, Integer messageId) {
        DeleteMessage deleteMessage = new DeleteMessage();
        deleteMessage.setChatId(chatId);
        deleteMessage.setMessageId(messageId);
        execute(deleteMessage);
    }

    /**
     * 发送仅仅只有文本的简单消息
     *
     * @param chatId chatId
     * @param text   文本
     */
    protected void sendSimpleMessage(String chatId, String text) {
        SendMessage sendMessage = new SendMessage();
        sendMessage.setChatId(chatId);
        sendMessage.setText(text);
        execute(sendMessage);
    }

    /**
     * 发送消息到tg
     *
     * @param message message
     */
    protected void execute(BotApiMethod<?> message) {
        try {
            bot.execute(message);
        } catch (TelegramApiException e) {
            log.error("发送消息[{}}出错", message, e);
        }
    }
}


package com.helei.telegramebot.bot.menu.solana;


import com.helei.telegramebot.entity.ChatWallet;
import com.helei.telegramebot.service.ISolanaATBotWalletPersistenceService;
import com.helei.telegramebot.template.SolanaBotWalletTittleTemplate;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

import java.util.List;
import java.util.Optional;

@Slf4j
public class SolanaBotDynamicMenuSupporter {

    private final String botUsername;

    private final ISolanaATBotWalletPersistenceService persistenceService;

    public SolanaBotDynamicMenuSupporter(String botUsername, ISolanaATBotWalletPersistenceService persistenceService) {
        this.botUsername = botUsername;
        this.persistenceService = persistenceService;
    }


//<==================================================================================   主菜单    ========================================================================================================================================>

    /**
     * 主菜单的tittle
     *
     * @param chatId chatId
     * @return tittle
     */
    public String mainMenuTittle(String chatId) {

        return "欢迎来到tg机器人";
    }

//<==================================================================================   设置    ========================================================================================================================================>

    /**
     * 设置菜单的tittle
     *
     * @param chatId chatId
     * @return tittle
     */
    public String settingMenuTittle(String chatId) {
        return "我的设置";
    }
//<==================================================================================   地址追踪    ========================================================================================================================================>

    /**
     * 追踪地址菜单标题
     *
     * @param chatId chatId
     * @return tittle
     */
    public String tranceAddressMenuTittle(String chatId) {
        return "地址追踪 - 未完成";
    }
//<==================================================================================   交易    ========================================================================================================================================>


    /**
     * 交易菜单标题
     *
     * @param chatId chatId
     * @return tittle
     */
    public String transactionMenuTittle(String chatId) {
        return "交易 - 未完成";
    }


//<==================================================================================   钱包    ========================================================================================================================================>

    /**
     * 钱包菜单标题
     *
     * @param chatId chatId
     * @return tittle
     */
    public String walletMenuTittle(String chatId) {
        //Step 1 查默认钱包公匙
        String pubKey = persistenceService.queryChatIdDefaultWalletAddress(botUsername, chatId);

        //Step 2 查询所有钱包
        List<ChatWallet> chatWallets = persistenceService.queryChatIdAllWallet(botUsername, chatId);

        //Step 3 找到默认钱包
        ChatWallet defaultWallet = dispatchDefaultWallet(chatWallets, pubKey);

        //Step 3 生成title

        return buildAllWalletInfoStr(defaultWallet, chatWallets);
    }


    /**
     * 分出默认钱包，会减少chatWallets
     *
     * @param chatWallets 钱包list
     * @param pubKey      默认钱包的公钥
     * @return 默认钱包
     */
    private ChatWallet dispatchDefaultWallet(List<ChatWallet> chatWallets, String pubKey) {
        ChatWallet defaultWallet = null;
        Optional<ChatWallet> first = chatWallets.stream().filter(c -> c.getPublicKey().equals(pubKey)).findFirst();
        if (first.isPresent()) {
            defaultWallet = first.get();
            chatWallets.remove(defaultWallet);
        }
        return defaultWallet;
    }

    /**
     * 构建所有钱包信息字符串
     *
     * @param defaultWallet defaultWallet
     * @param chatWallets   chatWallets
     * @return string
     */
    private static @NotNull String buildAllWalletInfoStr(ChatWallet defaultWallet, List<ChatWallet> chatWallets) {
        StringBuilder tittle = new StringBuilder();

        if (defaultWallet != null) {
            tittle.append("默认钱包:\n").append(SolanaBotWalletTittleTemplate.aChatWalletPrintStr(defaultWallet, defaultWallet.getId()));
        }

        tittle.append("其它钱包:\n");
        for (ChatWallet chatWallet : chatWallets) {
            tittle.append(SolanaBotWalletTittleTemplate.aChatWalletPrintStr(chatWallet, chatWallet.getId())).append("\n");
        }

        return tittle.toString();
    }
    /**
     * 绑定钱包菜单标题
     *
     * @param chatId chatId
     * @return tittle
     */
    public String walletBindWalletMenuTittle(String chatId) {
        return "绑定钱包";
    }

    /**
     * 创建钱包菜单标题
     *
     * @param chatId chatId
     * @return tittle
     */
    public String walletCreateWalletMenuTittle(String chatId) {
        return "创建钱包";
    }
}

package com.helei.telegramebot.bot.menu.solana;


import com.helei.dto.base.Result;
import com.helei.telegramebot.bot.impl.SolanaAutoTradeTelegramBot;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.bot.menu.TelegramBotMenu;
import com.helei.telegramebot.bot.menu.solana.tree.MainMenuNode;
import com.helei.telegramebot.service.ITelegramPersistenceService;
import com.helei.telegramebot.service.impl.SolanaATBotPersistenceService;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.methods.BotApiMethod;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Message;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


/**
 * 机器人菜单
 */
@Slf4j
public class SolanaBotMenu implements Serializable, TelegramBotMenu {

    /**
     * 机器人的username
     */
    private final SolanaAutoTradeTelegramBot bot;

    /**
     * 持久化服务
     */
    private final ITelegramPersistenceService telegramPersistenceService;


    /**
     * 持久化服务
     */
    private final SolanaATBotPersistenceService solanaATBotPersistenceService;

    /**
     * 菜单根节点
     */
    private final TGMenuNode menuRoot;

    public SolanaBotMenu(SolanaAutoTradeTelegramBot bot, ITelegramPersistenceService telegramPersistenceService, SolanaATBotPersistenceService solanaATBotPersistenceService) {
        this.bot = bot;
        this.telegramPersistenceService = telegramPersistenceService;
        this.solanaATBotPersistenceService = solanaATBotPersistenceService;
        this.menuRoot = initMenuGraph();
    }


    @Override
    public SendMessage initChatMenu(String chatId) {
        Result result = telegramPersistenceService.saveChatMenuState(bot.getBotUsername(), chatId, menuRoot);

        if (result.getSuccess()) {
            Integer id = (Integer) result.getData();
            TGMenuNode tgMenuNode = TGMenuNode.nodeIdMap.get(id);

            return tgMenuNode.getMenu(chatId, List.of());
        } else {
            SendMessage sendMessage = new SendMessage();
            sendMessage.setChatId(chatId);
            sendMessage.setText(result.getErrorMsg());
            return sendMessage;
        }
    }

    @Override
    public TGMenuNode getCurrentMenuState(String chatId) {
        Result result = telegramPersistenceService.getChatMenuState(bot.getBotUsername(), chatId);

        if (result.getSuccess()) {
            return TGMenuNode.nodeIdMap.get((Integer) result.getData());
        } else {
            return menuRoot;
        }
    }

    @Override
    public TGMenuNode getPrefer(String chatId) {

        return getCurrentMenuState(chatId).getParentMenu();
    }


    @Override
    public SendMessage getCurrentMenu(String chatId) {
        TGMenuNode currentMenu = getCurrentMenuState(chatId);
        SendMessage menu = currentMenu.getMenu(chatId, List.of());
        return menu;
    }


    @Override
    public BotApiMethod<?> menuCommandHandler(String menuCommand, Message message) {

        //Step 1 参数解析
        String chatId = String.valueOf(message.getChatId());

        String[] split = menuCommand.split(" ");
        String command = split[0];
        List<Object> params = new ArrayList<>();

        if (split.length > 1) {
            params.addAll(Arrays.asList(split).subList(1, split.length));
        }

        TGMenuNode tgMenuNode = TGMenuNode.commandMap.get(command);
        log.info("收到菜单信息[{}], params[{}] menuNode[{}]", command, params, tgMenuNode);

        //Step 2 调用handler处理

        BotApiMethod<?> menuMessage = null;

        if (!params.isEmpty()) {
            // 有参数, 是某个菜单叶节点的回复
            TGMenuNode newtgMenuNode = tgMenuNode.menuNodeReplyHandler(params, message);

            // 不一样了, 并且新菜单是当前菜单的子菜单, 发送新的菜单过去
            if (newtgMenuNode != tgMenuNode && newtgMenuNode.getParentMenu() != null && newtgMenuNode.getParentMenu().equals(tgMenuNode)) {
                menuMessage = newtgMenuNode.getMenu(String.valueOf(chatId), params);
            }

            tgMenuNode = newtgMenuNode;
        } else {
            //无参数，菜单
            menuMessage = tgMenuNode.getMenu(chatId, params);
        }

        //Step 3 保存更改菜单状态
        telegramPersistenceService.saveChatMenuState(bot.getBotUsername(), chatId, tgMenuNode);

        return menuMessage;
    }


    /**
     * 初始化菜单图
     *
     * @return TGMenuNode
     */
    private TGMenuNode initMenuGraph() {
        // 1,主菜单
        TGMenuNode menuRoot = new MainMenuNode();

        // 2.初始化

        TGMenuNode.nodeIdMap.values().forEach(menuNode -> {
            if (menuNode instanceof BaseTGMenuNode baseTGMenuNode) {
                baseTGMenuNode.init(bot, solanaATBotPersistenceService);
            }
        });

        return menuRoot;
    }
}

package com.helei.telegramebot.bot.menu;

import cn.hutool.core.lang.Pair;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.Message;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.ReplyKeyboard;
import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

@Slf4j
@Data
public abstract class TGMenuNode {

    private static final AtomicInteger idGenerator = new AtomicInteger();

    public static final Map<Integer, TGMenuNode> nodeIdMap = new HashMap<>();

    public static final Map<String, TGMenuNode> commandMap = new HashMap<>();

    private final int id;

    private final TGMenuNode parentMenu;

    private final String buttonText;

    private final String callbackData;

    private final List<TGMenuNode> subMenu = new ArrayList<>();

    public TGMenuNode(TGMenuNode parentMenu, String buttonText, String callbackData) {
        this.parentMenu = parentMenu;
        this.buttonText = buttonText;
        this.callbackData = callbackData;
        this.id = idGenerator.incrementAndGet();

        nodeIdMap.put(id, this);

        commandMap.put(getCallbackData(), this);
    }

    public String getCallbackData() {
        if (parentMenu == null) {
            return "/menu." + callbackData;
        }
        return parentMenu.getCallbackData() + "." + callbackData;
    }


    public abstract Pair<String, ReplyKeyboard> getTittleAndMenuKeyBoard(String chatId, List<Object> params);


    public SendMessage getMenu(String chatId, List<Object> params) {
        SendMessage message = new SendMessage();

        message.setChatId(chatId);

        Pair<String, ReplyKeyboard> pair = getTittleAndMenuKeyBoard(chatId, params);

        message.setText(pair.getKey());

        message.setReplyMarkup(pair.getValue());

        return message;
    }


    public String getFullButtonText() {
        StringBuilder full = new StringBuilder();
        TGMenuNode c = this;

        while ((c = c.getParentMenu()) != null) {
            full.insert(0, c.getButtonText() + "-");
        }

        return full.toString();
    }


    public InlineKeyboardButton getDynamicKeyboardButton(String chatId, List<Object> params) {
        InlineKeyboardButton inlineKeyboardButton = new InlineKeyboardButton(getButtonText());
        inlineKeyboardButton.setCallbackData(getCallbackData());
        return inlineKeyboardButton;
    }


    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof TGMenuNode that)) return false;
        return id == that.id;
    }

    @Override
    public int hashCode() {
        return Objects.hashCode(id);
    }

    @Override
    public String toString() {
        return "TGMenuNode{" +
                "callbackData='" + callbackData + '\'' +
                ", buttonText='" + buttonText + '\'' +
                ", parentMenu=" + parentMenu +
                ", id=" + id +
                ", subMenu=" + subMenu.stream().map(TGMenuNode::getId).toList() +
                '}';
    }

    /**
     * 处理给菜单回复的消息
     *
     * @param params  参数
     * @param message 消息
     * @return 接下来的菜单状态
     */
    public TGMenuNode menuNodeReplyHandler(List<Object> params, Message message) {
        log.info("收到chatId[{}]菜单命令[{}] params[{}]", message.getChatId(), this, params);

        return null;
    }
}




package com.helei.telegramebot.bot;

import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.helei.dto.base.Result;
import com.helei.telegramebot.bot.menu.TGMenuNode;
import com.helei.telegramebot.config.command.TelegramBotCommand;
import com.helei.telegramebot.config.command.TelegramBotNameSpaceCommand;
import com.helei.telegramebot.dto.TGBotCommandContext;
import com.helei.telegramebot.service.ITelegramPersistenceService;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.telegram.telegrambots.bots.TelegramLongPollingBot;
import org.telegram.telegrambots.meta.api.methods.groupadministration.GetChat;
import org.telegram.telegrambots.meta.api.methods.groupadministration.GetChatAdministrators;
import org.telegram.telegrambots.meta.api.methods.groupadministration.GetChatMember;
import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
import org.telegram.telegrambots.meta.api.objects.*;
import org.telegram.telegrambots.meta.api.objects.chatmember.ChatMember;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;


/**
 * TG机器人抽象类
 */
@Slf4j
public abstract class AbstractTelegramBot extends TelegramLongPollingBot implements BaseCommandTelegramBot {


    /**
     * 机器人名
     */
    private final String botUsername;

    /**
     * 机器人连接的token
     */
    private final String token;

    /**
     * 持久化服务
     */
    @Getter
    private final ITelegramPersistenceService telegramPersistenceService;

    /**
     * 执行的线程池
     */
    protected final ExecutorService executor;

    protected AbstractTelegramBot(String botUsername, String token, ITelegramPersistenceService telegramPersistenceService, ExecutorService executor) {
        this.botUsername = botUsername;
        this.token = token;
        this.telegramPersistenceService = telegramPersistenceService;
        this.executor = executor;
    }


    @Override
    public String getBotUsername() {
        return botUsername;
    }

    @Override
    public String getBotToken() {
        return token;
    }

    @Override
    public void onUpdateReceived(Update update) {
        executor.execute(() -> {
            Message message = update.getMessage();
            CallbackQuery callbackQuery = update.getCallbackQuery();

            if (message != null) {
                // 1，消息
                messageHandler(message);
            } else if (callbackQuery != null) {
                callbackQueryHandler(callbackQuery);
            }
        });
    }


    /**
     * 处理菜单消息
     *
     * @param message message
     * @return TGMenuNode
     */
    private TGMenuNode getCurrentMenuNode(Message message) {
        Result chatMenuState = telegramPersistenceService.getChatMenuState(botUsername, String.valueOf(message.getChatId()));
        if (chatMenuState != null && chatMenuState.getSuccess()) {
            TGMenuNode menuNode = (TGMenuNode) chatMenuState.getData();
            log.info("chatId[{}]当前菜单为[{}]", message.getChatId(), menuNode);
            return menuNode;
        }
        return null;
    }

    /**
     * 处理callback（由键盘点击产生的）
     *
     * @param callbackQuery callbackQuery
     */
    private void callbackQueryHandler(CallbackQuery callbackQuery) {
        String callbackQueryData = callbackQuery.getData();

        Message message = callbackQuery.getMessage();
        Long chatId = message.getChatId();
        User from = message.getFrom();

        log.info("bot[{}] 收到消息 chatId[{}]-用户[{}] - callbackQuery[{}]", getBotUsername(), chatId, from.getUserName(), callbackQueryData);

        if (callbackQueryData.startsWith("/menu.")) {
            Result result = menuCommandHandler(callbackQueryData, message);

            if (result != null && !result.getSuccess()) {
                log.error("执行callbackQueryData[{}] 命令失败, {}",
                        callbackQueryData, result.getErrorMsg());
            }
        }
    }

    /**
     * 处理消息
     *
     * @param message 消息
     */
    private void messageHandler(Message message) {

        Result result = null;

        String chatId = String.valueOf(message.getChatId());

        try {
            User from = message.getFrom();
            String text = message.getText();

            log.info("bot[{}] 收到消息 chatId[{}]-用户[{}] - 消息[{}]", getBotUsername(), chatId, from.getUserName(), text);

            // 处理命令消息
            if (message.isCommand()) {
                //Step 1 解析命令、参数
                TGBotCommandContext commandContext = resolveCommand(text);

                String nameSpaceStr = commandContext.getNamespace();
                String commandStr = commandContext.getCommand();
                List<String> params = commandContext.getParams();

//                    String botName = commandAndBotName.length > 1 ? commandAndBotName[1] : "";
                //不是本机器人，不管
//                    if (!getBotUsername().equals(botName)) {
//                        return;
//                    }

                // 不是Namespace里的命令, 就是基础bot的命令
                if (StrUtil.isBlank(nameSpaceStr)) {
                    baseCommandHandler(commandStr, message);
                    return;
                }

                // 检查namespace 是否有对应的command
                if (!TelegramBotNameSpaceCommand.isContainCommand(nameSpaceStr, commandStr)) {
                    String format = String.format("不存在[%s]命令[%s]", nameSpaceStr, commandStr);
                    log.error(format);
                    result = Result.fail(format);
                    return;
                }

                TelegramBotNameSpaceCommand.NameSpace nameSpace = TelegramBotNameSpaceCommand.NameSpace.valueOf(nameSpaceStr);


                //Step 2 过滤
                if (commandMessageFilter(nameSpace, commandStr, params, message)) {
                    log.warn("bot[{}] 过滤掉 用户[{}] - 消息[{}]", getBotUsername(), from.getUserName(), text);
                } else {//3 其他命令
                    result = commandMessageHandler(nameSpace, commandStr, params, message);
                }
            } else {
                //处理普通消息

                // 判断当前菜单状态
                TGMenuNode menuNode = getCurrentMenuNode(message);

                // 1 处理菜单的回复
                if (menuNode != null) {
                    // 处理回复菜单某个叶子节点的消息,得到下一个menuNode
                    TGMenuNode newMenuNode = menuNode.menuNodeReplyHandler(List.of(message.getText()), message);

                    //菜单状态发生了改变，说明由叶子菜单节点处理了，不需要再给normalMessageHandler处理
                    if (newMenuNode != null && menuNode != newMenuNode) {
                        telegramPersistenceService.saveChatMenuState(botUsername, String.valueOf(message.getChatId()), newMenuNode);
                        return;
                    }
                }

                // 2 处理普通消息
                result = normalMessageHandler(text, message);
            }
        } catch (Exception e) {
            log.error("处理消息[{}]出错", message, e);
        } finally {
            //Step 3 发送结果
            if (result != null) {
                resolveHandlerResult(chatId, result);
            }
        }
    }


    /**
     * 解析命令
     *
     * @param text text
     * @return String[]{nameSpaceStr, commandStr}
     */
    private TGBotCommandContext resolveCommand(String text) {
        String nameSpaceStr = "";
        String commandStr = "";

        String[] split = text.split(" ");

        String[] commandAndBotName = split[0].split("@");
        String[] nameSpaceAndCommand = commandAndBotName[0].replace("/", "").toUpperCase().split("\\.");

        if (nameSpaceAndCommand.length == 2) {
            nameSpaceStr = nameSpaceAndCommand[0].toUpperCase();
            commandStr = nameSpaceAndCommand[1].toUpperCase();
        } else if (nameSpaceAndCommand.length == 1) {
            commandStr = nameSpaceAndCommand[0].toUpperCase();
        }

        List<String> params = new ArrayList<>(Arrays.asList(split));
        params.removeFirst();

        return TGBotCommandContext
                .builder()
                .namespace(nameSpaceStr)
                .command(commandStr)
                .params(params)
                .build();
    }

    /**
     * 处理handler处理后的结果
     *
     * @param result result
     */
    private void resolveHandlerResult(String chatId, Result result) {
        try {
            if (BooleanUtil.isFalse(result.getSuccess())) {
                sendMessageToChat(chatId, result.getErrorMsg());
            } else if (result.getData() != null) {
                sendMessageToChat(chatId, result.getData().toString());
            }
        } catch (Exception e) {
            log.error("向chat[{}]发送结果[{}]时出现异常", chatId, result);
        }
    }


    /**
     * 处理基础命令
     *
     * @param commandStr 命令字符串
     * @param message    消息
     */
    private void baseCommandHandler(String commandStr, Message message) {

        TelegramBotCommand command = null;
        try {
            command = TelegramBotCommand.valueOf(commandStr);
        } catch (Exception e) {
            log.error("不存在基础命令[{}]", commandStr);
            sendMessageToChat(String.valueOf(message.getChatId()), String.format("不存在基础命令[%s]", commandStr));
            return;
        }

        switch (command) {
            case START -> startCommandHandler(message);
        }
    }


    /**
     * 菜单命令
     *
     * @param commandStr commandStr
     * @param message    message
     */
    public abstract Result menuCommandHandler(String commandStr, Message message);

    /**
     * 过滤命令消息
     *
     * @param nameSpace        nameSpace
     * @param nameSpaceCommand nameSpaceCommand
     * @param params           params
     * @param message          message
     */
    public abstract boolean commandMessageFilter(TelegramBotNameSpaceCommand.NameSpace nameSpace, String nameSpaceCommand, List<String> params, Message message);


    /**
     * 命令消息处理
     *
     * @param nameSpace        nameSpace
     * @param nameSpaceCommand 命令
     * @param params           参数
     * @param message          原消息内容
     */
    public abstract Result commandMessageHandler(TelegramBotNameSpaceCommand.NameSpace nameSpace, String nameSpaceCommand, List<?> params, Message message);


    /**
     * 普通消息处理
     *
     * @param messageText 消息文本
     * @param message     原消息内容
     */
    public abstract Result normalMessageHandler(String messageText, Message message);


    /**
     * 给指定chat发消息
     *
     * @param chatId      chatId
     * @param messageText 消息文本
     */
    public void sendMessageToChat(String chatId, String messageText) {
        SendMessage message = new SendMessage();
        message.setChatId(chatId);
        message.setText(messageText);

        try {
            execute(message);  // 发送消息
        } catch (TelegramApiException e) {
            log.error("给群组 [{}] 发送消息[{}]发生错误", chatId, messageText, e);
        }
    }

    /**
     * 给指定chat发送html消息
     *
     * @param chatId      chatId
     * @param messageText 消息文本
     */
    public void sendHTMLMessageToChat(String chatId, String messageText) {
        SendMessage message = new SendMessage();
        message.setChatId(chatId);
        message.setParseMode("HTML");
        message.setText(messageText);

        try {
            execute(message);  // 发送消息
        } catch (TelegramApiException e) {
            log.error("给群组 [{}] 发送消息[{}]发生错误", chatId, messageText, e);
        }
    }


    /**
     * 获取聊天信息
     *
     * @param chatId chatId
     * @return 详细信息
     */
    public Chat getChat(String chatId) {
        GetChat chat = new GetChat(chatId);
        try {
            return execute(chat);
        } catch (TelegramApiException e) {
            log.error("获取Chat[{}]消息发生错误", chatId);
        }
        return null;
    }


    /**
     * 获取特定成员信息
     *
     * @param chatId 群组id
     * @param userId 消息文本
     */
    public User getChatMemberInfo(String chatId, long userId) {
        GetChatMember getChatMember = new GetChatMember();
        getChatMember.setChatId(chatId);
        getChatMember.setUserId(userId);

        try {
            ChatMember chatMember = execute(getChatMember);
            log.info("获取到群组[{}]成员[{}]的信息, status[{}]", chatId, userId, chatMember.getStatus());
            // 根据需要获取更多信息，例如用户名、权限等
            return chatMember.getUser();
        } catch (TelegramApiException e) {
            throw new RuntimeException(String.format("获取到群组[%s]成员[%s]的信息失败", chatId, userId), e);
        }
    }

    /**
     * 获取群组管理员信息
     *
     * @param chatId 群组id
     */
    public List<ChatMember> getChatAdministratorsInfo(String chatId) {
        GetChatAdministrators getChatAdministrators = new GetChatAdministrators();
        getChatAdministrators.setChatId(chatId);

        try {
            return execute(getChatAdministrators);
        } catch (TelegramApiException e) {
            throw new RuntimeException(String.format("获取到群组[%s]管理员信息出错", chatId), e);
        }
    }

}



package com.helei.telegramebot.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2024-11-21
 */
@Getter
@Setter
@TableName("t_chat_wallet")
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ChatWallet implements Serializable {

    @Serial
    private static final long serialVersionUID = 213928773627186442L;

    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * chatId
     */
    @TableField("chat_id")
    private String chatId;

    /**
     * name
     */
    @TableField("name")
    private String name;


    /**
     * 私钥
     */
    @TableField("private_key")
    private String privateKey;

    /**
     * 公匙
     */
    @TableField("public_key")
    private String publicKey;

    /**
     * 密匙
     */
    @TableField("secret_key")
    private String secretKey;

    /**
     * sol数量
     */
    @TableField("sol_amount")
    private Double solAmount;

    /**
     * 创建时间
     */
    @TableField("create_datetime")
    private LocalDateTime createDatetime;

    /**
     * 更新时间
     */
    @TableField("update_datetime")
    private LocalDateTime updateDatetime;

    /**
     * 是否可用
     */
    @TableField("is_valid")
    private Boolean isValid;
}



package com.helei.telegramebot.service.impl;

import com.helei.telegramebot.service.ISolanaATBotWalletPersistenceService;
import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Getter
@Service
public class SolanaATBotPersistenceService {


    @Autowired
    private ISolanaATBotWalletPersistenceService wallet;

}


package com.helei.telegramebot.service.impl;

import cn.hutool.core.lang.Pair;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.helei.dto.base.Result;
import com.helei.solanarpc.dto.SolanaAddress;
import com.helei.solanarpc.util.SolanaKeyAddressUtil;
import com.helei.telegramebot.entity.ChatDefaultWallet;
import com.helei.telegramebot.entity.ChatWallet;
import com.helei.telegramebot.service.IChatDefaultWalletService;
import com.helei.telegramebot.service.IChatWalletService;
import com.helei.telegramebot.service.ISolanaATBotWalletPersistenceService;
import com.helei.telegramebot.util.TelegramRedisUtil;
import lombok.extern.slf4j.Slf4j;
import org.redisson.api.RMap;
import org.redisson.api.RedissonClient;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;


/**
 * TODO 加redis缓存！
 */
@Slf4j
@Service
public class SolanaATBotWalletPersistenceServiceImpl implements ISolanaATBotWalletPersistenceService {

    @Lazy
    @Autowired
    private RedissonClient redissonClient;

    @Lazy
    @Autowired
    private ISolanaATBotWalletPersistenceService solanaATBotPersistenceService;

    @Autowired
    private IChatWalletService chatWalletService;


    @Autowired
    private IChatDefaultWalletService chatDefaultWalletService;


    @Override
    @Transactional
    public Result bindWalletByPrivateKey(String botUsername, String chatId, String privateKey) {
        try {
            // 1.计算获取公匙和密匙
            Pair<String, String> psKeyPair = SolanaKeyAddressUtil.getPSKeyFromPrivateKey(privateKey);
            String pubKey = psKeyPair.getKey();
            String secretKey = psKeyPair.getValue();

            ChatWallet query = new ChatWallet();
            query.setChatId(chatId);
            query.setPublicKey(pubKey);
            ChatWallet one = chatWalletService.getBaseMapper().selectOne(new QueryWrapper<>(query));

            // 2.1绑定过该地址
            if (one != null) {
                return Result.fail("已绑定过钱包地址[" + pubKey.substring(0, 8) + "...]");
            } else {
                // 2.2 没有绑定过
                ChatWallet chatWallet = ChatWallet.builder().publicKey(pubKey).privateKey(privateKey).secretKey(secretKey).chatId(chatId).build();

                // 保存数据库
                chatWalletService.save(chatWallet);

                // 更新默认钱包地址
                solanaATBotPersistenceService.updateDefaultWalletAddress(botUsername, chatId, pubKey, false);

                return Result.ok();
            }
        } catch (Exception e) {
            String format = String.format("绑定chatId[%s]的钱包失败, %s", chatId, e.getMessage());
            log.error(format, e);
            return Result.fail(format);
        }
    }

    @Override
    @Transactional
    public void updateDefaultWalletAddress(String botUsername, String chatId, String pubKey, boolean isCover) {
        ChatDefaultWallet byId = chatDefaultWalletService.getById(chatId);
        if (byId == null || isCover) {
            ChatDefaultWallet chatDefaultWallet = new ChatDefaultWallet(chatId, pubKey);
            chatDefaultWalletService.save(chatDefaultWallet);
        }
    }


    @Override
    public Result updateChatListenAddress(String botUsername, String chatId, SolanaAddress solanaAddress) {
        try {
            String key = TelegramRedisUtil.chatIdSolanaWalletTraceHashKey(chatId, botUsername);

            RMap<String, String> map = redissonClient.getMap(key);

            map.put(solanaAddress.getAccountAddress(), JSONObject.toJSONString(solanaAddress));

            return Result.ok();
        } catch (Exception e) {
            String format = String.format("更新chatId[%s]跟踪的地址信息失败, %s", chatId, e.getMessage());
            log.error(format, e);
            return Result.fail(format);
        }
    }

    @Override
    public Result deleteChatListenAddress(String botUsername, String chatId, String solanaAddress) {

        try {
            String key = TelegramRedisUtil.chatIdSolanaWalletTraceHashKey(chatId, botUsername);
            RMap<String, String> map = redissonClient.getMap(key);
            map.remove(solanaAddress);
            return Result.ok();
        } catch (Exception e) {
            String format = String.format("删除chatId[%s]跟踪的地址信息失败, %s", chatId, e.getMessage());
            log.error(format, e);
            return Result.fail(format);
        }
    }

    @Override
    public String queryChatIdDefaultWalletAddress(String botUsername, String chatId) {
        ChatDefaultWallet byId = chatDefaultWalletService.getById(chatId);

        if (byId == null) return null;

        return byId.getPublicKey();
    }

    @Override
    public List<ChatWallet> queryChatIdAllWallet(String botUsername, String chatId) {
        ChatWallet query = new ChatWallet();
        query.setChatId(chatId);

        return chatWalletService.getBaseMapper().selectList(new QueryWrapper<>(query));
    }

    @Override
    public ChatWallet queryChatIdWallet(ChatWallet query) {

        return chatWalletService.getBaseMapper().selectOne(new QueryWrapper<>(query));
    }

    @Override
    public boolean saveChatWallet(ChatWallet chatWallet) {

        return chatWalletService.save(chatWallet);
    }

    @Override
    @Transactional
    public boolean deleteChatBindWallet(String chatId, String publicKey) {


        //Step 1 删除绑定钱包
        ChatWallet deleteCW = ChatWallet.builder().chatId(chatId).publicKey(publicKey).build();
        if (!chatWalletService.remove(new QueryWrapper<>(deleteCW))) {
            return false;
        }

        //Step 2 看删除的是否是默认钱包，如果是需重新选一个

        ChatDefaultWallet deleteCDW = new ChatDefaultWallet(chatId, publicKey);

        ChatDefaultWallet defaultWallet = chatDefaultWalletService.getBaseMapper().selectOne(new QueryWrapper<>(deleteCDW));

        //是默认钱包，取一个换
        if (defaultWallet != null && defaultWallet.getPublicKey().equals(publicKey)) {
            List<ChatWallet> list = chatWalletService.query().select("public_key").eq("chat_id", chatId).orderByAsc("create_datetime").list();

            //还有其他绑定的钱包，取一个最新的
            if (!list.isEmpty()) {
                ChatWallet first = list.getFirst();

                // 更改
                defaultWallet.setPublicKey(first.getPublicKey());
                chatDefaultWalletService.updateById(defaultWallet);
            }
        }

        return true;
    }
}



package com.helei.telegramebot.service;

import com.helei.dto.base.Result;
import com.helei.solanarpc.dto.SolanaAddress;
import com.helei.telegramebot.entity.ChatWallet;

import java.util.List;

public interface ISolanaATBotWalletPersistenceService {


    /**
     * 绑定钱包地址
     *
     * @param chatId     chatId
     * @param privateKey privateKey
     * @return Result
     */
    Result bindWalletByPrivateKey(String botUsername, String chatId, String privateKey);


    /**
     * 更新默认钱包地址
     *
     * @param botUsername botUsername
     * @param chatId      chatId
     * @param pubKey      pubKey
     */
    void updateDefaultWalletAddress(String botUsername, String chatId, String pubKey, boolean isCover);

    /**
     * 保存chatId跟踪的钱包地址
     *
     * @param chatId        chatId
     * @param solanaAddress 钱包地址
     * @return Result
     */
    Result updateChatListenAddress(String botUsername, String chatId, SolanaAddress solanaAddress);


    /**
     * 删除chatId跟踪的钱包地址
     *
     * @param chatId  chatId
     * @param address 钱包地址
     * @return Result
     */
    Result deleteChatListenAddress(String botUsername, String chatId, String address);


    /**
     * 查默认钱包地址
     *
     * @param botUsername botUsername
     * @param chatId      chatId
     * @return publicKey （address）
     */
    String queryChatIdDefaultWalletAddress(String botUsername, String chatId);


    /**
     * 查询chatId绑定的所有钱包
     *
     * @param botUsername botUsername
     * @param chatId      chatId
     * @return List<ChatWallet>
     */
    List<ChatWallet> queryChatIdAllWallet(String botUsername, String chatId);


    /**
     * 查询钱包信息
     *
     * @param query query
     * @return ChatWallet
     */
    ChatWallet queryChatIdWallet(ChatWallet query);


    /**
     * 保存chat 钱包
     *
     * @param chatWallet chatWallet
     * @return 是否成功
     */
    boolean saveChatWallet(ChatWallet chatWallet);


    /**
     * 删除绑定钱包
     *
     * @param chatId    chatId
     * @param publicKey publicKey
     * @return 是否成功
     */
    boolean deleteChatBindWallet(String chatId, String publicKey);
}


package com.helei;

import com.helei.telegramebot.bot.AbstractTelegramBot;
import com.helei.telegramebot.bot.impl.SolanaAutoTradeTelegramBot;
import com.helei.telegramebot.config.TelegramBotConfig;
import com.helei.telegramebot.service.impl.KafkaConsumerService;
import com.helei.telegramebot.service.impl.SolanaATBotPersistenceService;
import com.helei.telegramebot.service.impl.SolanaATBotWalletPersistenceServiceImpl;
import com.helei.telegramebot.service.impl.TelegramPersistenceServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;
import org.telegram.telegrambots.meta.TelegramBotsApi;
import org.telegram.telegrambots.meta.exceptions.TelegramApiException;

import java.util.List;
import java.util.concurrent.Executors;

@Slf4j
@SpringBootApplication
@MapperScan("com.helei.telegramebot.mapper")
public class TelegramBotApp {
    public static void main(String[] args) throws TelegramApiException {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(TelegramBotApp.class, args);


//        startAllEnvTradeSignalConsumer(applicationContext);
//
//        startAllTGBot(applicationContext);
        startSolanaBot(applicationContext);
    }


    private static void startSolanaBot(ConfigurableApplicationContext applicationContext) throws TelegramApiException {
        TelegramBotConfig telegramBotConfig = TelegramBotConfig.INSTANCE;

        SolanaATBotPersistenceService bean = applicationContext.getBean(SolanaATBotPersistenceService.class);
        TelegramPersistenceServiceImpl telegramPersistenceService = applicationContext.getBean(TelegramPersistenceServiceImpl.class);
        TelegramBotConfig.TelegramBotBaseConfig first = telegramBotConfig.getBots().getFirst();

        SolanaAutoTradeTelegramBot bot = new SolanaAutoTradeTelegramBot(
                first.getBotUsername(),
                first.getToken(),
                bean,
                telegramPersistenceService,
                Executors.newVirtualThreadPerTaskExecutor()
        );


        TelegramBotsApi telegramBotsApi = applicationContext.getBean(TelegramBotsApi.class);

        telegramBotsApi.registerBot(bot);
    }


    /**
     * 开启所有信号消费
     *
     * @param applicationContext app
     */
    private static void startAllEnvTradeSignalConsumer(ApplicationContext applicationContext) {
        log.info("开始消费交易信号.....");
        KafkaConsumerService kafkaConsumerService = applicationContext.getBean(KafkaConsumerService.class);
        kafkaConsumerService.startAllTradeSignalConsumer();
        log.info("交易信号消费启动完成.....");
    }

    /**
     * 开启所有的tg机器人
     *
     * @param applicationContext app
     */
    private static void startAllTGBot(ApplicationContext applicationContext) {
        try {
            log.info("开始启动tg机器人.....");
            TelegramBotsApi telegramBotsApi = applicationContext.getBean(TelegramBotsApi.class);

            List<AbstractTelegramBot> tgBots = (List<AbstractTelegramBot>) applicationContext.getBean("tgBots");

            for (AbstractTelegramBot tgBot : tgBots) {
                log.info("启动[{}}机器人", tgBot.getBotUsername());
                telegramBotsApi.registerBot(tgBot);
            }

            log.info("tg机器人启动完成");
        } catch (Exception e) {
            log.error("开启Telegram Bot发生异常", e);
        }
    }
}
