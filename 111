package com.helei.dto.order;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.helei.constants.*;
import com.helei.constants.order.OrderStatus;
import com.helei.constants.order.OrderType;
import com.helei.constants.order.PositionSide;
import com.helei.constants.trade.TradeSide;
import com.helei.constants.trade.TradeType;
import lombok.*;

import java.time.LocalDateTime;

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class BaseOrder {


    /**
     * 用户自定义订单ID
     */
    @TableField("client_order_id")
    protected String clientOrderId;

    /**
     * 用户id
     */
    @TableField("user_id")
    protected Long userId;

    /**
     * 用户的账户id
     */
    @TableField("account_id")
    protected Long accountId;

    /**
     * 交易对，例如 BTCUSDT
     */
    @TableField("symbol")
    protected String symbol;

    /**
     * 交易方向
     */
    @TableField("side")
    protected TradeSide side;

    /**
     * 持仓方向，默认BOTH
     */
    @TableField("position_side")
    protected PositionSide positionSide;


    /**
     * 运行环境
     */
    @TableField("run_env")
    protected RunEnv runEnv;

    /**
     * 交易类型
     */
    @TableField("run_env")
    protected TradeType tradeType;

    /**
     * 交易所类型
     */
    @TableField("cex_type")
    protected CEXType cexType = CEXType.BINANCE;


//    ===================================  下面是基础订单不用立刻写的数据 ======================================


    /**
     * 订单类型
     */
    @TableField("type")
    protected OrderType type;

    /**
     * 订单状态
     */
    @TableField("status")
    protected OrderStatus status;

    /**
     * 是否是主订单
     */
    @TableField("main_order")
    protected Boolean mainOrder;

    /**
     * 子订单的id列表，用’,‘号隔开
     */
    @TableField("sub_order_Id_list")
    protected String subOrderIdList;

    /**
     * 如果是辅助单，则必填的关联的主单id
     */
    @TableField("connect_main_order_id")
    protected Long connectMainOrderId;

    /**
     * 订单创建时间
     */
    @TableField(value = "created_datetime", fill = FieldFill.INSERT)
    protected LocalDateTime createdDatetime;

    /**
     * 订单更新时间
     */
    @TableField(value = "updated_datetime", fill = FieldFill.INSERT_UPDATE)
    protected LocalDateTime updatedDatetime;


    /**
     * apikey
     */
    protected String apiKey;

    /**
     * 签名
     */
    protected String signature;

    /**
     * 交易所接口参数
     */
    protected Long recvWindow;

    /**
     * 交易所接口参数
     */
    protected Long timestamp;


    public RunEnv getOriRunEnv() {
        return runEnv;
    }

    public TradeType getOriTradeType() {
        return tradeType;
    }

    public CEXType getOriCEXType() {
        return cexType;
    }

    public String getRunEnv() {
        return "%env(" + runEnv.name() + ")%";
    }

    public String getTradeType() {
        return "%tradeType(" + tradeType.name() + ")%";
    }

    public String getCexType() {
        return "%cexType(" + cexType + ")%";
    }
}

package com.helei.dto.order;

import com.baomidou.mybatisplus.annotation.*;

        import java.io.Serial;
import java.io.Serializable;
import java.math.BigDecimal;


import com.helei.constants.order.*;
        import lombok.*;

/**
 * <p>
 * 币安合约交易订单表
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
@Data
@EqualsAndHashCode(callSuper = true)
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_binance_contract_order")
public class CEXTradeOrder extends BaseOrder implements Serializable {

    @Serial
    private static final long serialVersionUID = 1231231419839753841L;

    /**
     * 是否仅减少持仓，仅适用于双向持仓模式
     */
    @TableField("reduce_only")
    protected Boolean reduceOnly;

    /**
     * 交易数量
     */
    @TableField("quantity")
    protected BigDecimal quantity;

    /**
     * 订单价格，仅限限价单
     */
    @TableField("price")
    protected BigDecimal price;

    /**
     *
     */
    @TableField("quote_order_qty")
    protected BigDecimal quoteOrderQty;

    /**
     * 移动止损
     */
    protected Integer trailingDelta;


    /**
     * 触发价，仅限触发单
     */
    @TableField("stop_price")
    protected BigDecimal stopPrice;

    /**
     * 是否为全平仓单，仅适用于触发单
     */
    @TableField("close_position")
    protected Boolean closePosition;

    /**
     * 追踪止损激活价格，仅TRAILING_STOP_MARKET 需要此参数, 默认为下单当前市场价格(支持不同workingType)
     */
    @TableField("activation_price")
    protected BigDecimal activationPrice;

    /**
     * 追踪止损回调比例，可取值范围[0.1, 10],其中 1代表1% ,仅TRAILING_STOP_MARKET 需要此参数
     */
    @TableField("callback_rate")
    protected BigDecimal callbackRate;

    /**
     * 订单有效期类型
     */
    @TableField("time_in_force")
    protected TimeInForce timeInForce;

    /**
     * 触发价格类型
     */
    @TableField("working_type")
    protected WorkingType workingType;

    /**
     * 价格保护开关
     */
    @TableField("price_protect")
    protected Boolean priceProtect;

    /**
     * 响应类型
     */
    @TableField("order_resp_type")
    protected OrderRespType orderRespType;

    /**
     * 不能与price同时传
     */
    @TableField("price_match")
    protected PriceMatch priceMatch;

    /**
     * 防自成交模式， 默认NONE
     */
    @TableField("self_trade_prevention_mode")
    protected SelfTradePreventionMode selfTradePreventionMode;

    /**
     * TIF为GTD时订单的自动取消时间， 当timeInforce为GTD时必传；传入的时间戳仅保留秒级精度，毫秒级部分会被自动忽略，时间戳需大于当前时间+600s且小于253402300799000
     */
    @TableField("good_till_date")
    protected Long goodTillDate;

    /**
     * 请求时间戳
     */
    @TableField("timestamp")
    protected Long timestamp;


    /**
     * 订单编号,交易所给的
     */
    @TableId(value = "order_id", type = IdType.INPUT)
    protected String orderId;


    public CEXTradeOrder(BaseOrder baseOrder) {
        super.setRunEnv(baseOrder.getOriRunEnv());
        super.setTradeType(baseOrder.getOriTradeType());
        super.setCexType(baseOrder.getOriCEXType());

        super.setApiKey(baseOrder.getApiKey());
        super.setSignature(baseOrder.getSignature());
        super.setRecvWindow(baseOrder.getRecvWindow());
        super.setTimestamp(baseOrder.getTimestamp());
        super.setClientOrderId(baseOrder.getClientOrderId());
        super.setUserId(baseOrder.getUserId());
        super.setAccountId(baseOrder.getAccountId());
        super.setSymbol(baseOrder.getSymbol());
        super.setSide(baseOrder.getSide());
        super.setPositionSide(baseOrder.getPositionSide());
        super.setType(baseOrder.getType());
        super.setStatus(baseOrder.getStatus());
        super.setMainOrder(baseOrder.getMainOrder());
        super.setSubOrderIdList(baseOrder.getSubOrderIdList());
        super.setConnectMainOrderId(baseOrder.getConnectMainOrderId());
        super.setCreatedDatetime(baseOrder.getCreatedDatetime());
        super.setUpdatedDatetime(baseOrder.getUpdatedDatetime());
    }
}



package com.helei.binanceapi.api.ws;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.CancelRestrictions;
import com.helei.binanceapi.constants.command.TradeCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import com.helei.dto.order.CEXTradeOrder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 交易相关api
 */
@Slf4j
public class BinanceWSTradeApi extends AbstractBinanceWSApi {

    public BinanceWSTradeApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 提交订单，
     *
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitOrder(CEXTradeOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_PLACE)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 提交测试订单，
     *
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitTestOrder(CEXTradeOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_TEST)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit test order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 查询订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * 对于某些历史订单，cummulativeQuoteQty 响应字段可能为负数，意味着此时数据不可用。
     *
     * @param symbol            symbol
     * @param orderId           orderId
     * @param origClientOrderId origClientOrderId
     * @param asKey             签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> queryOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .setCommandType(TradeCommandType.ORDER_STATUS)
                .build();

        log.info("query order [{}]", command);
        return binanceWSApiClient.sendRequest(4, command, asKey);
    }


    /**
     * 撤销订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * newClientOrderId 将替换已取消订单的 clientOrderId，为新订单腾出空间。
     * 如果您取消属于订单列表的订单，则整个订单列表将被取消。
     *
     * @param symbol             symbol
     * @param orderId            按 orderId 取消订单
     * @param origClientOrderId  按 clientOrderId 取消订单
     * @param newClientOrderId   已取消订单的新 ID。如果未发送，则自动生成
     * @param cancelRestrictions 支持的值:
     *                           ONLY_NEW - 如果订单状态为 NEW，撤销将成功。
     *                           ONLY_PARTIALLY_FILLED - 如果订单状态为 PARTIALLY_FILLED，撤销将成功。
     * @param asKey              签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> cancelOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .addParam("newClientOrderId", newClientOrderId)
                .addParam("cancelRestrictions", cancelRestrictions)
                .setCommandType(TradeCommandType.ORDER_CANCEL)
                .build();

        log.info("cancel order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 撤销单一交易对的所有挂单
     *
     * @param symbol symbol
     * @param asKey  签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersCancelAll(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_CANCEL_ALL)
                .build();

        log.info("cancel all order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }


    /**
     * 查询用户当前挂单情况
     *
     * @param symbol symbol
     * @param asKey  签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersStatus(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_STATUS)
                .build();
        int weight = 6;
        if (StrUtil.isBlank(symbol)) {
            weight = 80;
        }

        log.info("open order status [{}]", command);
        return binanceWSApiClient.sendRequest(weight, command, asKey);
    }
}



CREATE TABLE `t_binance_contract_order` (
                                            `client_order_id` varchar(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL COMMENT '用户自定义订单ID',
                                            `order_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL COMMENT '订单编号',
                                            `user_id` bigint NOT NULL COMMENT '用户id',
                                            `account_id` bigint NOT NULL COMMENT '用户的账户id',
                                            `symbol` varchar(20) NOT NULL COMMENT '交易对，例如 BTCUSDT',
                                            `side` enum('BUY','SELL') NOT NULL COMMENT '交易方向',
                                            `position_side` enum('BOTH','LONG','SHORT') DEFAULT 'BOTH' COMMENT '持仓方向，默认BOTH',
                                            `type` enum('LIMIT','MARKET','STOP','STOP_MARKET','TAKE_PROFIT','TAKE_PROFIT_MARKET','TRAILING_STOP_MARKET') NOT NULL COMMENT '订单类型',
                                            `reduce_only` tinyint(1) DEFAULT '0' COMMENT '是否仅减少持仓，仅适用于双向持仓模式',
                                            `quantity` decimal(18,8) NOT NULL COMMENT '交易数量',
                                            `price` decimal(18,8) DEFAULT NULL COMMENT '订单价格，仅限限价单',
                                            `stop_price` decimal(18,8) DEFAULT NULL COMMENT '触发价，仅限触发单',
                                            `close_position` tinyint(1) DEFAULT '0' COMMENT '是否为全平仓单，仅适用于触发单',
                                            `activation_price` decimal(18,8) DEFAULT NULL COMMENT '追踪止损激活价格，仅TRAILING_STOP_MARKET 需要此参数, 默认为下单当前市场价格(支持不同workingType)',
                                            `callback_rate` decimal(18,8) DEFAULT NULL COMMENT '追踪止损回调比例，可取值范围[0.1, 10],其中 1代表1% ,仅TRAILING_STOP_MARKET 需要此参数',
                                            `time_in_force` enum('GTC','IOC','FOK') DEFAULT 'GTC' COMMENT '订单有效期类型',
                                            `working_type` enum('MARK_PRICE','CONTRACT_PRICE') DEFAULT 'CONTRACT_PRICE' COMMENT '触发价格类型',
                                            `price_protect` tinyint(1) DEFAULT '0' COMMENT '价格保护开关',
                                            `order_resp_type` enum('ACK','RESULT') DEFAULT 'ACK' COMMENT '响应类型',
                                            `price_match` enum('OPPONENT','OPPONENT_5','OPPONENT_10','OPPONENT_20','QUEUE','QUEUE_5','QUEUE_10','QUEUE_20','NONE') DEFAULT 'NONE' COMMENT '不能与price同时传',
                                            `self_trade_prevention_mode` enum('NONE','EXPIRE_TAKER','EXPIRE_MAKER','EXPIRE_BOTH') DEFAULT 'NONE' COMMENT '防自成交模式， 默认NONE',
                                            `good_till_date` bigint DEFAULT NULL COMMENT 'TIF为GTD时订单的自动取消时间， 当timeInforce为GTD时必传；传入的时间戳仅保留秒级精度，毫秒级部分会被自动忽略，时间戳需大于当前时间+600s且小于253402300799000',
                                            `timestamp` bigint NOT NULL COMMENT '请求时间戳',
                                            `status` enum('NEW','PARTIALLY_FILLED','FILLED','CANCELED','REJECTED','EXPIRED') DEFAULT 'NEW' COMMENT '订单状态',
                                            `main_order` tinyint(1) NOT NULL COMMENT '是否是主订单',
                                            `sub_order_Id_list` varchar(255) DEFAULT NULL COMMENT '子订单的id列表，用’,‘号隔开',
                                            `connect_main_order_id` bigint DEFAULT NULL COMMENT '如果是辅助单，则必填的关联的主单id',
                                            `created_datetime` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '订单创建时间',
                                            `updated_datetime` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '订单更新时间',
                                            `run_env` enum('TEST_NET','NORMAL') DEFAULT NULL COMMENT '运行环境，TEST_NET、NORMAL',
                                            `trade_type` enum('SPOT','CONTRACT') DEFAULT NULL COMMENT '交易类型, SPOT、CONTRACT',
                                            `cex_type` enum('BINANCE') DEFAULT NULL COMMENT '交易所',
                                            PRIMARY KEY (`client_order_id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='币安合约交易订单表';





package com.helei.tradeapplication.config;

import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.DynamicTableNameInnerInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import com.helei.constants.CEXType;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.stereotype.Component;

import java.awt.*;
import java.time.LocalDateTime;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Component
@Configuration
public class MybatisPlusConfig implements MetaObjectHandler {

    private static final Pattern runEnvPattern = Pattern.compile("%env\\((.*?)\\)%");
    private static final Pattern tradeTypePattern = Pattern.compile("%env\\((.*?)\\)%");
    private static final Pattern cexTypePattern = Pattern.compile("%env\\((.*?)\\)%");


    /**
     * 使用mp做添加操作时候，这个方法执行
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        //设置属性值
        this.setFieldValByName("createdDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("updatedDatetime", LocalDateTime.now(), metaObject);
    }

    /**
     * 使用mp做修改操作时候，这个方法执行
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updatedDatetime", LocalDateTime.now(), metaObject);
    }

    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        // 配置查询动态表名的拦截器，使用时先在TableNameHelper设置要查询的动态表名，然后直接执行mybatisplus的查询方法。注意赋予的动态表名只在一次查询中有效
        DynamicTableNameInnerInterceptor dynamicTableNameInnerInterceptor = new DynamicTableNameInnerInterceptor();
        dynamicTableNameInnerInterceptor.setTableNameHandler(this::fixTableName);
        mybatisPlusInterceptor.addInnerInterceptor(dynamicTableNameInnerInterceptor);

//        分页配置
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

        return mybatisPlusInterceptor;
    }


    /**
     * 动态修改t_trade_order 订单目标表的后缀，指向不同环境的订单表
     * @param sql   sql
     * @param oldTableName 原始table name
     * @return  new table name
     */
    private String fixTableName(String sql, String oldTableName) {
        if (!oldTableName.startsWith("t_trade_order")) {
            return oldTableName;
        }
        Matcher envMatch = runEnvPattern.matcher(sql);
        String env = null;
        if (envMatch.find()) {
            env = envMatch.group(1);
        } else {
            return oldTableName;
        }

        Matcher tradeTypeMatch = tradeTypePattern.matcher(sql);
        String tradeType = null;
        if (tradeTypeMatch.find()) {
            tradeType = tradeTypeMatch.group(1);
        } else {
            return oldTableName;
        }

        Matcher cexTypeMatch = cexTypePattern.matcher(sql);
        String cexType = null;
        if (cexTypeMatch.find()) {
            env = cexTypeMatch.group(1);
        } else {
            return oldTableName;
        }


        return oldTableName + "_" + cexType + "_" + env + "_" +tradeType;
    }
}




package com.helei.tradeapplication.config;


import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.manager.BinanceBaseClientManager;
import com.helei.dto.config.SnowFlowConfig;
import com.helei.snowflack.SnowFlakeFactory;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.redisson.Redisson;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.annotation.EnableKafka;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;

import java.util.HashMap;
import java.util.Map;

@EnableKafka
@Configuration
public class SpringConfig {


    private final TradeAppConfig tradeAppConfig = TradeAppConfig.INSTANCE;

    @Autowired
    private ExecutorServiceManager executorServiceManager;

    @Bean
    public BinanceBaseClientManager binanceBaseWSClientManager() {
        return CEXApiFactory.binanceBaseWSClientManager(tradeAppConfig.getRun_type(), executorServiceManager.getConnectExecutor());
    }

    @Bean
    public Map<String, Object> kafkaConfigs() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, tradeAppConfig.getKafka().getBootstrap_servers());
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, tradeAppConfig.getKafka().getGroup_id());  // 消费者组ID
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest");
        return configProps;
    }

    @Bean
    public ConsumerFactory<String, String> consumerFactory() {

        return new DefaultKafkaConsumerFactory<>(kafkaConfigs());
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, String> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        return factory;
    }


    @Bean(name = "kafkaAdminClient")
    public AdminClient kafkaAdminClient() {
        return AdminClient.create(kafkaConfigs());
    }

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer().setAddress(tradeAppConfig.getRedis().getUrl());
        return Redisson.create(config);
    }


    @Bean
    public SnowFlakeFactory snowFlakeFactory() {
        SnowFlowConfig snowFlow = tradeAppConfig.getRun_type().getSnow_flow();
        return new SnowFlakeFactory(snowFlow.getDatacenter_id(), snowFlow.getMachine_id());
    }
}







package com.helei.tradeapplication.config;

import com.alibaba.fastjson.JSON;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.config.RunTypeConfig;
import com.helei.dto.kafka.KafkaConfig;
import com.helei.dto.kafka.RedisConfig;
import com.helei.util.KafkaUtil;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.yaml.snakeyaml.Yaml;

import java.io.InputStream;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class TradeAppConfig {
    private static final String CONFIG_FILE = "trade-app-config.yaml";

    public static final TradeAppConfig INSTANCE;

    private RunTypeConfig run_type;

    private RedisConfig redis;

    private KafkaConfig kafka;

    private TradeAppSignalConfig signal;


    static {
        Yaml yaml = new Yaml();
        try (InputStream inputStream = BinanceApiConfig.class.getClassLoader().getResourceAsStream(CONFIG_FILE)) {
            if (inputStream == null) {
                throw new IllegalArgumentException("File not found: " + CONFIG_FILE);
            }
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> shinano = (Map<String, Object>) yamlData.get("shinano");
            Map<String, Object> quantity = (Map<String, Object>) shinano.get("quantity");
            Map<String, Object> trade_app = (Map<String, Object>) quantity.get("trade_app");

            INSTANCE = yaml.loadAs(yaml.dump(trade_app), TradeAppConfig.class);
        } catch (Exception e) {
            throw new RuntimeException("Failed to load YAML file: " + CONFIG_FILE, e);
        }
    }


    /**
     * 获取信号topics，通过回调的方式，不直接返回topic列表
     *
     * @param env          运行环境
     * @param tradeType    交易类型
     * @param topicResolve 回调函数， 第一个参数为前缀， 第二个参数为信号名列表
     */
    public void getSignalTopics(RunEnv env, TradeType tradeType, BiConsumer<String, List<String>> topicResolve) {
        StringBuilder prefix = new StringBuilder(env.name());
        prefix.append(".").append(tradeType.name()).append(".");

        List<TradeSignalSymbolConfig> scList = switch (env) {
            case TEST_NET -> signal.test_net.getTradeSignalSymbolConfigs(tradeType);
            case NORMAL -> signal.normal.getTradeSignalSymbolConfigs(tradeType);
        };

        if (scList == null) {
            topicResolve.accept(prefix.toString(), Collections.emptyList());
            return;
        }

        for (TradeSignalSymbolConfig signalSymbolConfig : scList) {
            String symbol = signalSymbolConfig.getSymbol();
            topicResolve.accept(prefix + symbol + ".", signalSymbolConfig.signal_names);
        }
    }


    /**
     * 获取交易订单的topic
     *
     * @param env          运行环境
     * @param tradeType    交易信号
     * @param topicResolve 回调
     */
    public void getTradeOrderTopics(RunEnv env, TradeType tradeType, Consumer<List<String>> topicResolve) {

        List<TradeSignalSymbolConfig> scList = switch (env) {
            case TEST_NET -> signal.test_net.getTradeSignalSymbolConfigs(tradeType);
            case NORMAL -> signal.normal.getTradeSignalSymbolConfigs(tradeType);
        };

        if (scList == null) {
            topicResolve.accept(Collections.emptyList());
            return;
        }

        topicResolve.accept(scList.stream().map(e -> KafkaUtil.getOrderSymbolTopic(env, tradeType, e.getSymbol())).toList());
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class TradeAppSignalConfig {
        /**
         * 主网环境信号配置
         */
        private TradeSignalEnvConfig normal;

        /**
         * 测试环境信号配置
         */
        private TradeSignalEnvConfig test_net;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class TradeSignalEnvConfig {

        /**
         * 现货类型信号配置
         */
        private List<TradeSignalSymbolConfig> spot;

        /**
         * u本位合约类型信号设置
         */
        private List<TradeSignalSymbolConfig> contract;

        public List<TradeSignalSymbolConfig> getTradeSignalSymbolConfigs(TradeType tradeType) {
            return switch (tradeType) {
                case SPOT -> spot;
                case CONTRACT -> contract;
            };
        }
    }


    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class TradeSignalSymbolConfig {

        /**
         * 交易对名称
         */
        private String symbol;

        /**
         * 信号名list
         */
        private List<String> signal_names;
    }


    public static void main(String[] args) {
        System.out.println(JSON.toJSONString(INSTANCE));
    }
}




package com.helei.tradeapplication.dto;


import com.helei.constants.order.GroupOrderStatus;
import com.helei.dto.ASKey;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.List;


/**
 * 一组订单，包括开的主单，以及跟随的止损单和止盈单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class GroupOrder {

    /**
     * 用于鉴权
     */
    private ASKey asKey;

    /**
     * 主订单
     */
    private BaseOrder mainOrder;

    /**
     * 主订单的止损单列表
     */
    private List<CEXTradeOrderWrap> stopOrders;

    /**
     * 主订单的止盈单列表
     */
    private List<CEXTradeOrderWrap> profitOrders;

    /**
     * 订单组的状态
     */
    private GroupOrderStatus groupOrderStatus;


    /**
     * 为最终存到数据库以及发送到kafka的订单列表，保护mainOrder和所有的stopOrder、profitOrder
     */
    private List<CEXTradeOrder> cexTradeOrders;

    @Override
    public String toString() {
        return "GroupOrder{" +
                "  \nmainOrder=" + mainOrder +
                ", \nstopOrders=" + stopOrders +
                ", \nprofitOrders=" + profitOrders +
                ", \ngroupOrderStatus=" + groupOrderStatus +
                ", \ncexTradeOrders=" + cexTradeOrders +
                '}';
    }
}






package com.helei.tradeapplication.dto;


import com.helei.dto.ASKey;
import com.helei.dto.order.CEXTradeOrder;
import lombok.*;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@EqualsAndHashCode
public class TradeOrderGroup {

    /**
     * 请求鉴权信息
     */
    private ASKey asKey;

    /**
     * 主单
     */
    private CEXTradeOrder mainOrder;


    /**
     * 止损单
     */
    private List<CEXTradeOrder> stopOrders;


    /**
     * 止盈单
     */
    private List<CEXTradeOrder> profitOrders;
}



package com.helei.tradeapplication.listener;

import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.jetbrains.annotations.NotNull;
import org.springframework.kafka.listener.MessageListener;
import org.springframework.kafka.support.Acknowledgment;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;


@Slf4j
public abstract class KafkaTopicListener<R> implements MessageListener<String, String> {

    private final ExecutorService executor;

    protected KafkaTopicListener(ExecutorService executor) {
        this.executor = executor;
    }

    @Override
    public void onMessage(@NotNull ConsumerRecord<String, String> record) {
        executor.execute(()->{
            String topic = record.topic();
            String value = record.value();
            log.info("topic[{}]收到消息[{}]", topic, value);

            if (StrUtil.isBlank(value)) {
                log.warn("receive null kafka trade signal, topic[{}] key [{}]", topic, record.key());
                return;
            }

            try {
                invoke(topic, convertJsonToTarget(value));
            } catch (Exception e) {
                log.error("处理kafka topic[{}] 消息[{}]时出错", topic, value, e);
            }
        });
    }

    @Override
    public void onMessage(@NotNull ConsumerRecord<String, String> record, Acknowledgment acknowledgment) {
        executor.execute(()->{
            String topic = record.topic();
            String value = record.value();
            log.info("topic[{}]收到消息[{}]", topic, value);
            if (StrUtil.isBlank(value)) {
                log.warn("receive null kafka trade signal, topic[{}] key [{}]", topic, record.key());
                return;
            }

            try {
                R r = convertJsonToTarget(value);

                CompletableFuture<Boolean> invoke = invoke(topic, r);
                if (invoke != null) {
                    invoke.thenAcceptAsync(success->{
                        if (success) acknowledgment.acknowledge();
                    }, executor);
                }
            } catch (Exception e) {
                log.error("处理kafka topic[{}] 消息[{}]时出错", topic, value, e);
            }
        });
    }


    public abstract R convertJsonToTarget(String json);


    public abstract CompletableFuture<Boolean> invoke(String topic, R message);
}





package com.helei.tradeapplication.listener;

import com.alibaba.fastjson.JSONObject;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.tradeapplication.dto.TradeOrderGroup;
import com.helei.tradeapplication.service.TradeOrderCommitService;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

@Slf4j
public class KafkaTradeOrderListener extends KafkaTopicListener<TradeOrderGroup>{

    /**
     * 运行环境
     */
    private final RunEnv runEnv;

    /**
     * 交易类型
     */
    private final TradeType tradeType;


    /**
     * 提交订单服务
     */
    private final TradeOrderCommitService tradeOrderCommitService;


    public KafkaTradeOrderListener(RunEnv runEnv, TradeType tradeType, TradeOrderCommitService tradeOrderCommitService, ExecutorService executor) {
        super(executor);
        this.runEnv = runEnv;
        this.tradeType = tradeType;
        this.tradeOrderCommitService = tradeOrderCommitService;
    }

    @Override
    public TradeOrderGroup convertJsonToTarget(String json) {
        return JSONObject.parseObject(json, TradeOrderGroup.class);
    }

    @Override
    public CompletableFuture<Boolean> invoke(String topic, TradeOrderGroup orderGroup) {
        log.info("topic[{}]收到交易订单,runEnv[{}]-tradeType[{}]-orderGroup[{}]", topic, runEnv, tradeType, orderGroup);

        try {
            return tradeOrderCommitService.traderOrderHandler(runEnv, tradeType, orderGroup);
        } catch (Exception e) {
            log.error("处理topic[{}}信号发生错误", topic, e);
            return null;
        }
    }

}



package com.helei.tradeapplication.listener;

import com.alibaba.fastjson.JSONObject;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.trade.TradeSignal;
import com.helei.tradeapplication.service.TradeSignalService;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;


/**
 * kafka交易信号监听器
 */
@Slf4j
public class KafkaTradeSignalListener extends KafkaTopicListener<TradeSignal> {

    /**
     * 运行环境
     */
    private final RunEnv runEnv;

    /**
     * 交易类型
     */
    private final TradeType tradeType;


    private final TradeSignalService tradeSignalService;

    public KafkaTradeSignalListener(
            RunEnv env,
            TradeType tradeType,
            TradeSignalService tradeSignalService,
            ExecutorService executor
    ) {
        super(executor);

        this.runEnv = env;
        this.tradeType = tradeType;
        this.tradeSignalService = tradeSignalService;
    }

    @Override
    public TradeSignal convertJsonToTarget(String json) {
        return JSONObject.parseObject(json, TradeSignal.class);
    }

    @Override
    public CompletableFuture<Boolean> invoke(String topic, TradeSignal signal) {
        log.info("topic[{}]收到信号,runEnv[{}]-tradeType[{}]-signal[{}]", topic, runEnv, tradeType, signal);

        try {
            return tradeSignalService.resolveTradeSignal(runEnv, tradeType, signal);
        } catch (Exception e) {
            log.error("处理topic[{}}信号发生错误", topic, e);
            return null;
        }
    }

}




package com.helei.tradeapplication.manager;


import com.helei.util.NamedThreadFactory;
import lombok.Data;
import org.springframework.stereotype.Component;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Data
@Component
public class ExecutorServiceManager {

    private final ExecutorService tradeSignalResolveExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("kafka交易信号处理线程池"));


    private final ExecutorService connectExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("连接用线程池"));

    private final ExecutorService tradeOrderResolveExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("kafka订单处理线程池"));


    private final ExecutorService queryExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("查询用线程池"));


    private final ExecutorService tradeExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("交易用线程池"));


    private final ExecutorService orderExecutor = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("订单用线程池"));
}




<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mp.mpdemo.mapper.BinanceContractOrderMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.helei.dto.order.CEXTradeOrder">
        <id column="client_order_id" property="client_order_id" />
        <result column="order_id" property="orderId" />
        <result column="user_id" property="userId" />
        <result column="account_id" property="accountId" />
        <result column="symbol" property="symbol" />
        <result column="side" property="side" />
        <result column="position_side" property="positionSide" />
        <result column="type" property="type" />
        <result column="reduce_only" property="reduceOnly" />
        <result column="quantity" property="quantity" />
        <result column="price" property="price" />
        <result column="client_order_id" property="clientOrderId" />
        <result column="stop_price" property="stopPrice" />
        <result column="close_position" property="closePosition" />
        <result column="activation_price" property="activationPrice" />
        <result column="callback_rate" property="callbackRate" />
        <result column="time_in_force" property="timeInForce" />
        <result column="working_type" property="workingType" />
        <result column="price_protect" property="priceProtect" />
        <result column="order_resp_type" property="orderRespType" />
        <result column="price_match" property="priceMatch" />
        <result column="self_trade_prevention_mode" property="selfTradePreventionMode" />
        <result column="good_till_date" property="goodTillDate" />
        <result column="timestamp" property="timestamp" />
        <result column="status" property="status" />
        <result column="main_order" property="mainOrder" />
        <result column="sub_order_Id_list" property="subOrderIdList" />
        <result column="connect_main_order_id" property="connectMainOrderId" />
        <result column="created_datetime" property="createdDatetime" />
        <result column="updated_datetime" property="updatedDatetime" />
        <result column="run_env" property="runEnv"/>
        <result column="trade_type" property="tradeType"/>
        <result column="cex_type" property="cexType"/>
    </resultMap>
</mapper>

package com.helei.tradeapplication.mapper;


import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.helei.dto.order.CEXTradeOrder;

/**
 * <p>
 * 币安合约交易订单表 Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
public interface TradeOrderMapper extends BaseMapper<CEXTradeOrder> {

}



package com.helei.tradeapplication.service.impl.jdbc;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.tradeapplication.mapper.TradeOrderMapper;
import com.helei.tradeapplication.service.ITradeOrderJDBCService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.List;

/**
 * <p>
 * 币安合约交易订单表 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
@Slf4j
@Service
public class TradeOrderJDBCServiceImpl extends ServiceImpl<TradeOrderMapper, CEXTradeOrder> implements ITradeOrderJDBCService {


    @Transactional
    @Override
    public List<CEXTradeOrder> saveGroupOrder(GroupOrder groupOrder) {

        List<CEXTradeOrder> orderList = new ArrayList<>();

        // 主单
        orderList.add((CEXTradeOrder) groupOrder.getMainOrder());

        // 止损单
        List<CEXTradeOrderWrap> stopOrders = groupOrder.getStopOrders();
        if (stopOrders != null) {
            for (CEXTradeOrderWrap stopOrder : stopOrders) {
                orderList.add(stopOrder.getFullFieldOrder());
            }
        }

        //止盈单
        List<CEXTradeOrderWrap> profitOrders = groupOrder.getProfitOrders();
        if (profitOrders != null) {
            for (CEXTradeOrderWrap profitOrder : profitOrders) {
                orderList.add(profitOrder.getFullFieldOrder());
            }
        }

        //保存到数据库
        saveBatch(orderList);

        return orderList;
    }
}



package com.helei.tradeapplication.service.impl;

import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.tradeapplication.config.TradeAppConfig;
import com.helei.tradeapplication.listener.KafkaTradeOrderListener;
import com.helei.tradeapplication.listener.KafkaTradeSignalListener;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import com.helei.tradeapplication.service.TradeOrderCommitService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.listener.ConcurrentMessageListenerContainer;
import org.springframework.kafka.listener.MessageListener;
import org.springframework.stereotype.Service;

import java.util.List;


@Slf4j
@Service
public class KafkaConsumerService {

    private final TradeAppConfig tradeAppConfig = TradeAppConfig.INSTANCE;

    @Autowired
    private ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory;

    @Autowired
    private ExecutorServiceManager executorServiceManager;

    @Autowired
    private KafkaTradeSignalService tradeSignalService;

    @Autowired
    private TradeOrderCommitService tradeOrderCommitService;

    /**
     * 开始交易信号消费
     *
     * @param env       运行环境
     * @param tradeType 交易类型
     */
    public void startTradeSignalConsumer(RunEnv env, TradeType tradeType) {

        tradeAppConfig.getSignalTopics(env, tradeType, (prefix, signalNames) -> {
            if (signalNames.isEmpty()) {
                log.warn("没有配置env[{}]-tradeType[{}]类型的交易信号topic", env, tradeType);
                return;
            }
            log.info("注册监听topic [{}*] signalNames[{}]交易信号 ", prefix, signalNames);
            List<String> topics = signalNames.stream().map(name -> (prefix + name).toLowerCase()).toList();
            startConsumer(topics, new KafkaTradeSignalListener(env, tradeType, tradeSignalService, executorServiceManager.getTradeSignalResolveExecutor()));
        });
    }


    /**
     * 开始消费交易订单
     *
     * @param env       运行环境
     * @param tradeType 交易类型
     */
    public void startTradeOrderConsumer(RunEnv env, TradeType tradeType) {
        tradeAppConfig.getTradeOrderTopics(env, tradeType, topics->{
            startConsumer(topics, new KafkaTradeOrderListener(env, tradeType, tradeOrderCommitService, executorServiceManager.getTradeOrderResolveExecutor()));
        });
    }


    /**
     * 开始kafka消费
     *
     * @param topics          topics
     * @param messageListener messageListener
     */
    public void startConsumer(List<String> topics, MessageListener<String, String> messageListener) {
        ConcurrentMessageListenerContainer<String, String> container = kafkaListenerContainerFactory.createContainer(topics.toArray(new String[0]));

        container.setupMessageListener(messageListener);
        container.start();
    }
}





package com.helei.tradeapplication.service.impl;


import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.account.UserAccountInfo;
import com.helei.dto.account.UserAccountStaticInfo;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.dto.trade.TradeSignal;
import com.helei.interfaces.CompleteInvocation;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import com.helei.tradeapplication.service.OrderBuildService;
import com.helei.tradeapplication.service.TradeSignalService;
import com.helei.tradeapplication.service.UserAccountInfoService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;


/**
 * 处理交易信号
 */
@Slf4j
@Service
public class KafkaTradeSignalService implements TradeSignalService {

    private final ExecutorService executor;

    @Autowired
    private UserAccountInfoService userAccountInfoService;

    @Autowired
    private OrderBuildService orderBuildService;


    public KafkaTradeSignalService(ExecutorServiceManager executorServiceManager) {
        this.executor = executorServiceManager.getTradeExecutor();
    }


    /**
     * 处理交易信号
     *
     * @param runEnv    运行环境
     * @param tradeType 交易类型
     * @param signal    信号
     * @return true 无论处理结果如何都忽略到改信号
     */
    public CompletableFuture<Boolean> resolveTradeSignal(RunEnv runEnv, TradeType tradeType, TradeSignal signal) {

        try {
            return userAccountInfoService
                    // 1 查询环境下的账户
                    .queryEnvAccountInfo(runEnv, tradeType)
                    // 2 生成订单并交易
                    .thenApplyAsync(accounts -> makeOrdersAndSend2Trade(runEnv, tradeType, signal, accounts), executor);
        } catch (Exception e) {
            log.error("处理信号[{}]时发生错误", signal, e);
        }

        return null;
    }


    /**
     * 构建订单，符合条件的提交到交易.
     * <p>并不会真正把订单提交到交易所，而是写入数据库后，再写入kafka的topic里</p>
     *
     * @param runEnv       runEnv
     * @param tradeType    tradeType
     * @param signal       signal
     * @param accountInfos accountInfos
     * @return List<BaseOrder>
     */
    private boolean makeOrdersAndSend2Trade(RunEnv runEnv, TradeType tradeType, TradeSignal signal, List<UserAccountInfo> accountInfos) {

        List<CompletableFuture<GroupOrder>> futures = new ArrayList<>();

        for (UserAccountInfo accountInfo : accountInfos) {
            long userId = accountInfo.getUserId();
            long accountId = accountInfo.getId();

            //Step 1 过滤掉账户设置不接受此信号的
            if (filterAccount(runEnv, tradeType, signal, accountInfo.getUserAccountStaticInfo())) {
                log.warn("accountId[{}]不能执行信号 [{}]", accountId, signal);
                continue;
            }

            CompletableFuture<GroupOrder> future = userAccountInfoService
                    //Step 2 查询实时的账户数据
                    .queryAccountNewInfo(runEnv, tradeType, userId, accountId)
                    //Step 3 生产订单
                    .thenApplyAsync(newAccountInfo -> {
                        final GroupOrder[] groupOrder = {null};

                        try {
                            CountDownLatch latch = new CountDownLatch(1);

                            orderBuildService.makeOrder(newAccountInfo, signal, new CompleteInvocation<>() {
                                @Override
                                public void success(GroupOrder order) {
                                    groupOrder[0] = order;
                                    log.info("创建订单[{}]成功", order);
                                }

                                @Override
                                public void fail(GroupOrder order, String errorMsg) {
                                    groupOrder[0] = order;
                                    log.info("创建订单失败[{}],错误原因[{}]", order, errorMsg);
                                }

                                @Override
                                public void finish() {
                                    latch.countDown();
                                }
                            });

                            //等待订单创建完成
                            latch.await();

                        } catch (Exception e) {
                            log.error("为accountId[{}]创建订单时出错, signal[{}]", accountId, signal, e);
                        }
                        return groupOrder[0];
                    })
                    .exceptionallyAsync(throwable -> {
                        if (throwable != null) {
                            log.error("创建订单时发生错误", throwable);
                        }
                        return null;
                    });

            futures.add(future);
        }


        //等待执行完成
        for (CompletableFuture<GroupOrder> future : futures) {
            try {
                GroupOrder order = future.get();
                log.info("订单组创建并写入db、kafka成功, {}", order);
            } catch (ExecutionException | InterruptedException e) {
                log.error("获取订单结果处理订单结果出错", e);
            }
        }

        // 都返回true，不依赖kafka完成ack
        return true;
    }


    /**
     * 根据账户设置过滤
     *
     * @param signal     信号
     * @param staticInfo 账户静态信息
     * @return List<UserAccountInfo>
     */
    private boolean filterAccount(RunEnv runEnv, TradeType tradeType, TradeSignal signal, UserAccountStaticInfo staticInfo) {
        return !staticInfo.isUsable() ||
                !staticInfo.getSubscribeSymbol().contains(signal.getSymbol().toLowerCase()) ||
                !runEnv.equals(staticInfo.getRunEnv()) ||
                !tradeType.equals(staticInfo.getTradeType());
    }
}




package com.helei.tradeapplication.service.impl;

import com.alibaba.fastjson.JSONObject;
import com.helei.constants.CEXType;
import com.helei.constants.order.GroupOrderStatus;
import com.helei.constants.order.OrderEvent;
import com.helei.constants.order.OrderStatus;
import com.helei.constants.order.OrderType;
import com.helei.constants.trade.TradeType;
import com.helei.dto.account.AccountPositionConfig;
import com.helei.dto.account.UserAccountInfo;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.CEXTradeOrderWrap;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.dto.trade.TradeSignal;
import com.helei.interfaces.CompleteInvocation;
import com.helei.tradeapplication.dto.TradeOrderGroup;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import com.helei.tradeapplication.service.ITradeOrderJDBCService;
import com.helei.tradeapplication.service.OrderEventProcessService;
import com.helei.tradeapplication.supporter.TradeOrderBuildSupporter;
import com.helei.util.KafkaUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.ExecutionException;


@Slf4j
@Service
public class OrderBuildServiceImpl extends OrderEventProcessService {


    @Autowired
    private KafkaProducerService kafkaProducerService;


    @Autowired
    private ITradeOrderJDBCService binanceContractOrderService;


    @Autowired
    private TradeOrderBuildSupporter tradeOrderBuildSupporter;


    @Autowired
    public OrderBuildServiceImpl(ExecutorServiceManager executorServiceManager) {
        super(executorServiceManager.getOrderExecutor());
        super.startProcessEvents();
    }


    /**
     * 生成订单
     *
     * @param accountInfo   账户信息
     * @param signal        信号
     */
    @Override
    public void makeOrder(UserAccountInfo accountInfo, TradeSignal signal, CompleteInvocation<GroupOrder> invocation) {

        AccountPositionConfig accountPositionConfig = accountInfo.getUserAccountStaticInfo().getAccountPositionConfig();
        OrderType orderType = accountPositionConfig.getOrderType();

        GroupOrder groupOrder = new GroupOrder();
        groupOrder.setAsKey(accountInfo.getUserAccountStaticInfo().getAsKey());

        //Step 1 创建主单
        CEXTradeOrderWrap orderWrapper = switch (orderType) {
            case LIMIT -> tradeOrderBuildSupporter.buildLimitOrder(accountInfo, signal);
            case MARKET -> tradeOrderBuildSupporter.buildMarketOrder(accountInfo, signal);
            default -> null;
        };


        long userId = accountInfo.getId();
        long accountId = accountInfo.getId();

        if (orderWrapper == null) {
            log.warn("userId[{}]-accountId[{}]创建主订单结果为null, signalId[{}]", userId, accountId, signal.getId());
            return;
        }

        // 获取订单
        CEXTradeOrder order = orderWrapper.getFullFieldOrder();

        // 资金不足
        if (order.getQuantity().doubleValue() <= 0) {
            order.setStatus(OrderStatus.BALANCE_INSUFFICIENT);
        }
        groupOrder.setMainOrder(order);


        // 满足资金不足的标记，给group order也打上，不继续创建止盈止损单了
        if (OrderStatus.BALANCE_INSUFFICIENT.equals(order.getStatus())) {
            log.warn("userId[{}]-account[{}] 资金不足，将不会提交订单[{}]到交易所, signalId[{}]", userId, accountId, order.getOrderId(), signal.getId());
            groupOrder.setGroupOrderStatus(GroupOrderStatus.BALANCE_INSUFFICIENT);

            super.submitOrderEvent(groupOrder, OrderEvent.BALANCE_INSUFFICIENT, invocation);
            return;
        }

        //Step 2 根据策略创建止损、止盈单


        log.info("订单[{}]创建成功", order);
        //Step 3 提交订单创建事件
        super.submitOrderEvent(groupOrder, OrderEvent.CREATED_ORDER, invocation);
    }


    @Override
    public GroupOrder writeOrder2Kafka(GroupOrder order) throws ExecutionException, InterruptedException {
        //Step 1 从主单中取出环境信息，生成topic
        BaseOrder mainOrder = order.getMainOrder();

        String topic = KafkaUtil.getOrderSymbolTopic(mainOrder.getOriRunEnv(), mainOrder.getOriTradeType(), mainOrder.getSymbol());

        //Step 2 封装订单对象
        TradeOrderGroup tradeOrderGroup = TradeOrderGroup
                .builder()
                .stopOrders(order.getStopOrders().stream().map(CEXTradeOrderWrap::getFullFieldOrder).toList())
                .profitOrders(order.getProfitOrders().stream().map(CEXTradeOrderWrap::getFullFieldOrder).toList())
                .mainOrder((CEXTradeOrder) order.getMainOrder())
                .build();

        //Step 3 发送kafka
        kafkaProducerService.sendMessage(topic, JSONObject.toJSONString(tradeOrderGroup)).get();

        log.debug("订单order[{}]写入kafka成功", order);

        return order;
    }


    @Override
    public GroupOrder writeOrder2DB(GroupOrder order) {

        BaseOrder mainOrder = order.getMainOrder();
        CEXType cexType = mainOrder.getOriCEXType();
        TradeType tradeType = mainOrder.getOriTradeType();


        if (CEXType.BINANCE.equals(cexType) && TradeType.CONTRACT.equals(tradeType)) {
            List<CEXTradeOrder> cexTradeOrders = binanceContractOrderService.saveGroupOrder(order);
            order.setCexTradeOrders(cexTradeOrders);
            return order;
        }

        return null;
    }

}





package com.helei.tradeapplication.service.impl;


import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.BinanceWSReqRespApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.cexapi.manager.BinanceBaseClientManager;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.ASKey;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.tradeapplication.dto.TradeOrderGroup;
import com.helei.tradeapplication.manager.ExecutorServiceManager;
import com.helei.tradeapplication.service.ITradeOrderJDBCService;
import com.helei.tradeapplication.service.TradeOrderCommitService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
@Service
public class TradeOrderCommitServiceImpl implements TradeOrderCommitService {

    private final ExecutorService executor;


    @Autowired
    private BinanceBaseClientManager binanceBaseClientManager;


    @Autowired
    private ITradeOrderJDBCService tradeOrderJdbcService;


    @Autowired
    public TradeOrderCommitServiceImpl(ExecutorServiceManager executorServiceManager) {
        this.executor = executorServiceManager.getTradeOrderResolveExecutor();
    }

    @Override
    public CompletableFuture<Boolean> traderOrderHandler(RunEnv runEnv, TradeType tradeType, TradeOrderGroup orderGroup) {

        return binanceBaseClientManager
                //Step 1 获取客户端
                .getEnvTypedApiClient(runEnv, tradeType, BinanceWSClientType.REQUEST_RESPONSE)
                //Step 2 请求发送订单
                .thenApplyAsync(abstractBinanceWSApiClient -> {
                    BinanceWSReqRespApiClient reqRespApiClient = (BinanceWSReqRespApiClient) abstractBinanceWSApiClient;
                    CEXTradeOrder mainOrder = orderGroup.getMainOrder();
                    String clientOrderId = mainOrder.getClientOrderId();

                    //Step 2.1 校验参数
                    ASKey asKey = orderGroup.getAsKey();
                    if (asKey == null || StrUtil.isBlank(asKey.getApiKey()) || StrUtil.isBlank(asKey.getSecretKey())) {
                        throw new IllegalArgumentException(String.format("订单clientId[%s]提交时出错，asKey为空", clientOrderId));
                    }


                    //Step 2 提交主单
                    CompletableFuture<Boolean> mainFuture = reqRespApiClient
                            .getTradeApi()
                            .commitOrder(mainOrder, asKey)
                            .thenApplyAsync(this::updateDBTradeOrderStatus)
                            .exceptionallyAsync(throwable -> {
                                log.error("提交交易订单cex[{}]-runEnv[{}]-tradeType[{}]-clientId[{}]发生错误",
                                        mainOrder.getOriCEXType(), mainOrder.getRunEnv(), mainOrder.getTradeType(), mainOrder.getClientOrderId(), throwable);
                                return false;
                            }, executor);

                    try {
                        if (mainFuture.get()) {
                            log.info("提交交易订单cex[{}]-runEnv[{}]-tradeType[{}]-clientId[{}]成功",
                                    mainOrder.getOriCEXType(), mainOrder.getRunEnv(), mainOrder.getTradeType(), mainOrder.getClientOrderId());
                        } else {
                            throw new RuntimeException("提交主单失败");
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        log.error("提交交易订单cex[{}]-runEnv[{}]-tradeType[{}]-clientId[{}]发生错误",
                                mainOrder.getOriCEXType(), mainOrder.getRunEnv(), mainOrder.getTradeType(), mainOrder.getClientOrderId(), e);
                        return false;
                    }


                    List<CompletableFuture<Boolean>> futures = new ArrayList<>();

                    //Step 3 提交止损单
                    for (CEXTradeOrder stopOrder : orderGroup.getStopOrders()) {
                        CompletableFuture<Boolean> future = reqRespApiClient
                                .getTradeApi()
                                //Step 3.1 提交
                                .commitOrder(stopOrder, asKey)
                                //Step 3.2 修改数据库状态
                                .thenApplyAsync(this::updateDBTradeOrderStatus, executor)
                                .exceptionallyAsync(throwable -> {
                                    log.error("提交止损订单cex[{}]-runEnv[{}]-tradeType[{}]-clientId[{}]发生错误",
                                            stopOrder.getOriCEXType(), stopOrder.getRunEnv(), stopOrder.getTradeType(), stopOrder.getClientOrderId(), throwable);
                                    return false;
                                }, executor);

                        futures.add(future);
                    }

                    //Step 4 提交止盈单
                    for (CEXTradeOrder profitOrder : orderGroup.getProfitOrders()) {
                        CompletableFuture<Boolean> future = reqRespApiClient
                                .getTradeApi()
                                .commitOrder(profitOrder, asKey)
                                .thenApplyAsync(this::updateDBTradeOrderStatus, executor)
                                .exceptionallyAsync(throwable -> {
                                    log.error("提交止盈订单cex[{}]-runEnv[{}]-tradeType[{}]-clientId[{}]发生错误",
                                            profitOrder.getOriCEXType(), profitOrder.getRunEnv(), profitOrder.getTradeType(), profitOrder.getClientOrderId(), throwable);
                                    return false;
                                }, executor);

                        futures.add(future);
                    }

                    //Step 5 等待提交完成
                    AtomicBoolean res = new AtomicBoolean(true);
                    try {
                        CompletableFuture
                                .allOf(futures.toArray(new CompletableFuture[0]))
                                .whenCompleteAsync((unused, throwable) -> {
                                    if (throwable != null) {
                                        log.error("提交订单组发生错误,[{}]", orderGroup, throwable);
                                    } else {
                                        for (CompletableFuture<Boolean> future : futures) {
                                            try {
                                                Boolean success = future.get();
                                                res.compareAndExchange(BooleanUtil.isFalse(success), false);
                                            } catch (InterruptedException | ExecutionException e) {
                                                throw new RuntimeException(e);
                                            }
                                        }
                                    }
                                }, executor).get();
                    } catch (InterruptedException | ExecutionException e) {
                        log.error("提交订单组发生错误,[{}]", orderGroup, e);
                        return false;
                    }

                    return res.get();
                }, executor);
    }


    /**
     * 更新数据库订单状态
     *
     * @param result 提交订单的结果
     * @return 提交结果
     */
    private boolean updateDBTradeOrderStatus(JSONObject result) {
        CEXTradeOrder mainOrderResult = result.toJavaObject(CEXTradeOrder.class);
        return tradeOrderJdbcService.updateById(mainOrderResult);
    }
}




package com.helei.tradeapplication.service;


import com.baomidou.mybatisplus.extension.service.IService;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.dto.order.CEXTradeOrder;

import java.util.List;

/**
 * <p>
 * 币安合约交易订单表 服务类
 * </p>
 *
 * @author com.helei
 * @since 2024-11-05
 */
public interface ITradeOrderJDBCService extends IService<CEXTradeOrder> {


    /**
     * 保存订单
     * @param order 订单
     */
    List<CEXTradeOrder> saveGroupOrder(GroupOrder order);

}






package com.helei.tradeapplication.service;

import com.helei.dto.account.UserAccountInfo;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.dto.trade.TradeSignal;
import com.helei.interfaces.CompleteInvocation;

import java.util.concurrent.ExecutionException;

public interface OrderBuildService {


    /**
     * 生成订单
     *
     * @param accountInfo   账户信息
     * @param signal        信号
     * @param invocation    生成订单结果的回调
     */
    void makeOrder(UserAccountInfo accountInfo, TradeSignal signal, CompleteInvocation<GroupOrder> invocation);


    /**
     * 将订单写到kafka
     *
     * @param order 订单数据
     * @return 订单数据
     */
    GroupOrder writeOrder2Kafka(GroupOrder order) throws ExecutionException, InterruptedException;


    /**
     * 将订单写入数据库
     *
     * @param order order
     * @return 订单数据
     */
    GroupOrder writeOrder2DB(GroupOrder order);
}



package com.helei.tradeapplication.service;

import com.helei.constants.order.OrderEvent;
import com.helei.constants.order.GroupOrderStatus;
import com.helei.tradeapplication.dto.GroupOrder;
import com.helei.interfaces.CompleteInvocation;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.*;


@Slf4j
public abstract class OrderEventProcessService implements OrderBuildService {


    /**
     * 写入db的重试次数
     */
    private static final int WRITE_DB_RETRY_TIMES = 3;

    /**
     * 写入kafka的重试次数
     */
    private static final int WRITE_KAFKA_RETRY_TIMES = 3;


    /**
     * 阻塞队列， 用于存放订单和当前订单的事件
     */
    private final BlockingQueue<OrderProcessTask> eventQueue = new LinkedBlockingQueue<>();


    /**
     * 存放订单回调的map
     */
    private final ConcurrentMap<GroupOrder, CompleteInvocation<GroupOrder>> invocationMap = new ConcurrentHashMap<>();


    /**
     * 记录重试次数的map
     */
    private final ConcurrentMap<GroupOrder, Integer> retryMap = new ConcurrentHashMap<>();


    /**
     * 执行的线程池
     */
    private final ExecutorService executor;


    public OrderEventProcessService(ExecutorService executor) {
        this.executor = executor;
    }


    /**
     * 提交订单事件
     *
     * @param order              订单
     * @param event              订单事件
     * @param completeInvocation 完成的回调函数
     */
    public void submitOrderEvent(GroupOrder order, OrderEvent event, CompleteInvocation<GroupOrder> completeInvocation) {
        invocationMap.compute(order, (k, v) -> {
            submitOrderEvent(order, event);
            return completeInvocation;
        });
    }

    /**
     * 提交订单事件
     *
     * @param order 订单
     * @param event 订单事件
     */
    public void submitOrderEvent(GroupOrder order, OrderEvent event) {
        try {
            eventQueue.put(new OrderProcessTask(order, event));
        } catch (InterruptedException e) {
            log.error("提交订单[{}]事件[{}]失败", order, event, e);
            throw new RuntimeException("提交订单事件失败", e);
        }
    }

    /**
     * 事件处理
     *
     * @param order 订单
     * @param event 事件
     */
    public void processOrderEvent(GroupOrder order, OrderEvent event) {
        log.debug("开始处理订单[{}]的事件[{}]", order, event);

        OrderEvent next = switch (event) {
            case CREATED_ORDER -> createdOrderProcess(order);

            case SEND_TO_DB -> sendToDBProcess(order);
            case SEND_TO_KAFKA -> sendToKafkaProcess(order);

            case SEND_TO_DB_RETRY -> sendToDBRetryProcess(order);
            case SEND_TO_KAFKA_RETRY -> sendToKafkaRetryProcess(order);

            case SEND_TO_DB_FINAL_ERROR -> errorProcess(order, OrderEvent.SEND_TO_DB_FINAL_ERROR);
            case SEND_TO_KAFKA_FINAL_ERROR -> errorProcess(order, OrderEvent.SEND_TO_KAFKA_FINAL_ERROR);
            case UN_SUPPORT_EVENT_ERROR -> errorProcess(order, OrderEvent.UN_SUPPORT_EVENT_ERROR);

            case BALANCE_INSUFFICIENT -> balanceInsufficientProcess(order);

            case COMPLETE -> successProcess(order);
            case ERROR -> errorProcess(order, OrderEvent.ERROR);
            case CANCEL -> cancelProcess(order);
        };

        if (next != null) {
            submitOrderEvent(order, next);
        }

        log.debug("订单[{}]的事件[{}]处理完毕", order, event);
    }


    /**
     * 资金不足的订单处理
     *
     * @param order groupOrder
     * @return 下一个事件
     */
    private OrderEvent balanceInsufficientProcess(GroupOrder order) {
        if (GroupOrderStatus.BALANCE_INSUFFICIENT.equals(order.getGroupOrderStatus())) {
            try {
                //写入数据库
                writeOrder2DB(order);
            } catch (Exception e) {
                //重试
                return OrderEvent.SEND_TO_DB_RETRY;
            }
            //错误事件
            errorProcess(order, OrderEvent.BALANCE_INSUFFICIENT);
        }
        return OrderEvent.UN_SUPPORT_EVENT_ERROR;
    }


    /**
     * 取消订单
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent cancelProcess(GroupOrder order) {
        //TODO 取消订单逻辑，未写入kafka的标记就好，写入kafka的还需要向另外的kafka里写上取消的消息，订单提交服务收到后进行取消

        log.warn("取消订单 [{}]", order);
        return null;
    }


    /**
     * 执行成功的事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent successProcess(GroupOrder order) {

        CompleteInvocation<GroupOrder> invocation = invocationMap.remove(order);

        if (invocation != null) {
            invocation.success(order);
            invocation.finish();
        }

        return null;
    }


    /**
     * 错误事件处理
     *
     * @param order order
     * @param event 时间
     * @return 下一个事件
     */
    private OrderEvent errorProcess(GroupOrder order, OrderEvent event) {

        CompleteInvocation<GroupOrder> invocation = invocationMap.remove(order);

        if (invocation != null) {
            invocation.fail(order, event.name());
            invocation.finish();
        }

        return null;
    }


    /**
     * 发送到kafka错误重试事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent sendToKafkaRetryProcess(GroupOrder order) {
        if (GroupOrderStatus.WRITE_IN_KAFKA.equals(order.getGroupOrderStatus())) {
            Integer times = retryMap.remove(order);
            times = times == null ? 0 : times;

            //超过重试次数
            if (times > WRITE_KAFKA_RETRY_TIMES) {
                return OrderEvent.SEND_TO_KAFKA_FINAL_ERROR;
            }


            try {
                GroupOrder result = writeOrder2Kafka(order);

                if (result == null) return OrderEvent.CANCEL;

                return OrderEvent.COMPLETE;
            } catch (Exception e) {
                log.error("写入Order[{}]到kafka发生错误,重试次数[{}]", order, times, e);
                retryMap.put(order, times + 1);
                return OrderEvent.SEND_TO_KAFKA_RETRY;
            }
        }

        return OrderEvent.UN_SUPPORT_EVENT_ERROR;
    }


    /**
     * 发送到kafka事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent sendToKafkaProcess(GroupOrder order) {
        if (GroupOrderStatus.WRITE_IN_DB.equals(order.getGroupOrderStatus())) {
            // 发送kafka
            try {
                order.setGroupOrderStatus(GroupOrderStatus.WRITE_IN_KAFKA);

                GroupOrder result = writeOrder2Kafka(order);

                if (result == null) return OrderEvent.CANCEL;
            } catch (Exception e) {
                log.error("写入Order[{}]到kafka发生错误", order, e);
                return OrderEvent.SEND_TO_KAFKA_RETRY;
            }
            return OrderEvent.COMPLETE;
        }
        return OrderEvent.UN_SUPPORT_EVENT_ERROR;
    }


    /**
     * 发送到DB错误重试事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent sendToDBRetryProcess(GroupOrder order) {
        GroupOrderStatus groupOrderStatus = order.getGroupOrderStatus();
        if (GroupOrderStatus.WRITE_IN_DB.equals(groupOrderStatus) || GroupOrderStatus.BALANCE_INSUFFICIENT.equals(groupOrderStatus)) {
            Integer times = retryMap.remove(order);
            times = times == null ? 0 : times;

            //超过重试次数
            if (times > WRITE_DB_RETRY_TIMES) {
                return OrderEvent.SEND_TO_DB_FINAL_ERROR;
            }

            try {
                GroupOrder result = writeOrder2DB(order);

                if (result == null) return OrderEvent.CANCEL;

                //资金不足，只写入数据库记录
                if (GroupOrderStatus.BALANCE_INSUFFICIENT.equals(groupOrderStatus)) return OrderEvent.ERROR;

                return OrderEvent.SEND_TO_KAFKA;
            } catch (Exception e) {
                log.error("写入Order[{}]到数据库发生错误, 重试次数[{}]", order, times, e);
                retryMap.put(order, times + 1);
                return OrderEvent.SEND_TO_DB_RETRY;
            }
        }

        return OrderEvent.UN_SUPPORT_EVENT_ERROR;
    }


    /**
     * 发送到DB事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent sendToDBProcess(GroupOrder order) {
        if (GroupOrderStatus.CREATED.equals(order.getGroupOrderStatus())) {
            // 写数据库
            try {
                order.setGroupOrderStatus(GroupOrderStatus.WRITE_IN_DB);

                GroupOrder result = writeOrder2DB(order);

                if (result == null) return OrderEvent.CANCEL;
            } catch (Exception e) {
                log.error("写入Order[{}]到数据库发生错误", order, e);
                return OrderEvent.SEND_TO_DB_RETRY;
            }
            return OrderEvent.SEND_TO_KAFKA;
        }
        return OrderEvent.UN_SUPPORT_EVENT_ERROR;
    }

    /**
     * 创建订单事件处理
     *
     * @param order order
     * @return 下一个事件
     */
    private OrderEvent createdOrderProcess(GroupOrder order) {
        //订单创建事件
        order.setGroupOrderStatus(GroupOrderStatus.CREATED);
        return OrderEvent.SEND_TO_DB;
    }


    /**
     * 开始处理事件
     */
    public void startProcessEvents() {
        while (!eventQueue.isEmpty()) {
            try {
                OrderProcessTask task = eventQueue.take();

                executor.execute(() -> processOrderEvent(task.getOrder(), task.getOrderEvent()));
            } catch (InterruptedException e) {
                log.error("处理事件时发生错误", e);
            }
        }
    }


    /**
     * 订单处理任务，包含订单信息和订单事件
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class OrderProcessTask {

        /**
         * 订单信息
         */
        private GroupOrder order;

        /**
         * 订单事件
         */
        private OrderEvent orderEvent;
    }


}

package com.helei.tradeapplication.service;


import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.tradeapplication.dto.TradeOrderGroup;

import java.util.concurrent.CompletableFuture;

/**
 * 负责提交订单
 */
public interface TradeOrderCommitService {


    /**
     * 处理交易信号
     *
     * @param runEnv     运行环境
     * @param tradeType  交易类型
     * @param orderGroup 订单
     * @return 是否全部提交
     */
    CompletableFuture<Boolean> traderOrderHandler(RunEnv runEnv, TradeType tradeType, TradeOrderGroup orderGroup);
}

package com.helei.tradeapplication.service;

import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.trade.TradeSignal;

import java.util.concurrent.CompletableFuture;

public interface TradeSignalService {


    /**
     * 处理交易信号
     *
     * @param runEnv    运行环境
     * @param tradeType 交易类型
     * @param signal    信号
     * @return 是否执行成功
     */
    CompletableFuture<Boolean> resolveTradeSignal(RunEnv runEnv, TradeType tradeType, TradeSignal signal);
}

package com.helei.tradeapplication.supporter;

import com.helei.constants.order.OrderType;
import com.helei.constants.order.TimeInForce;
import com.helei.dto.account.*;
import com.helei.dto.order.BaseOrder;
import com.helei.dto.order.CEXTradeOrder;
import com.helei.dto.order.type.*;
import com.helei.dto.trade.TradeSignal;
import com.helei.snowflack.BRStyle;
import com.helei.snowflack.SnowFlakeFactory;
import com.helei.util.OrderQuantityCalUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;


/**
 * 构建用于交易的订单，自带id
 */
@Component
public class TradeOrderBuildSupporter {

    @Autowired
    private SnowFlakeFactory snowFlakeFactory;

    /**
     * 构建限价单
     *
     * @param accountInfo 账户信息
     * @param signal      信号
     * @return 限价单
     */
    public LimitOrder buildLimitOrder(UserAccountInfo accountInfo, TradeSignal signal) {
        // Step 1 参数检验
        UserAccountStaticInfo staticInfo = accountInfo.getUserAccountStaticInfo();
        UserAccountRealTimeInfo realTimeInfo = accountInfo.getUserAccountRealTimeInfo();

        String quote = staticInfo.getQuote();


        BigDecimal enterPrice = signal.getEnterPrice();
        if (enterPrice == null) return null;

        AccountPositionConfig positionConfig = staticInfo.getAccountPositionConfig();

        // Step 2 创建订单
        String symbol = signal.getSymbol();


        // Step 2.1 基础订单信息
        BaseOrder baseOrder = BaseOrder.builder()
                .clientOrderId(nextId(OrderType.LIMIT))
                .runEnv(staticInfo.getRunEnv())
                .tradeType(staticInfo.getTradeType())
                .cexType(staticInfo.getCexType())
                .symbol(symbol)
                .side(signal.getTradeSide())
                .positionSide(positionConfig.getPositionSide())
                .userId(accountInfo.getUserId())
                .accountId(staticInfo.getId())
                .build();
        LimitOrder limitOrder = new LimitOrder(baseOrder);

        // Step 2.2 订单价格、数量等 LimitOrder 信息
        BalanceInfo balanceInfo = realTimeInfo.getAccountBalanceInfo().getBalances().get(quote);
        PositionInfo positionInfo = realTimeInfo.getAccountPositionInfo().getPositions().get(symbol.toUpperCase());


        BigDecimal quantity = OrderQuantityCalUtil.riskPercentBasedQuantityCalculate(
                balanceInfo.getAvailableBalance(),
                BigDecimal.valueOf(positionConfig.getRiskPercent()),
                enterPrice,
                positionInfo.getEntryPrice(),
                positionInfo.getPositionAmt(),
                signal.getStopPrice()
        );

        limitOrder.setTimeInForce(TimeInForce.GTC);
        limitOrder.setPrice(enterPrice);
        limitOrder.setQuantity(quantity);

        return limitOrder;
    }


    /**
     * 构建市价单
     *
     * @param accountInfo 账户信息
     * @param signal      信号
     * @return 限价单
     */
    public MarketOrder buildMarketOrder(UserAccountInfo accountInfo, TradeSignal signal) {
        return null;
    }

    /**
     * 构建市价止损单
     *
     * @param accountInfo 账户信息
     * @param symbol      交易对
     * @return 限价单
     */
    public StopLossMarketOrder buildStopMarketOrder(UserAccountInfo accountInfo, String symbol) {
        return null;
    }


    /**
     * 构建限价止损单
     *
     * @param accountInfo 账户信息
     * @param symbol      交易对
     * @return 限价单
     */
    public StopLossLimitOrder buildStopLimitOrder(UserAccountRealTimeInfo accountInfo, String symbol) {
        return null;
    }

    /**
     * 构建市价止盈单
     *
     * @param accountInfo 账户信息
     * @param symbol      交易对
     * @return 限价单
     */
    public TakeProfitMarketOrder buildTakeProfitMarketOrder(UserAccountRealTimeInfo accountInfo, String symbol) {
        return null;
    }

    /**
     * 构建限价止盈单
     *
     * @param accountInfo 账户信息
     * @param symbol      交易对
     * @return 限价单
     */
    public TakeProfitLimitOrder buildTakeProfitLimitOrder(UserAccountRealTimeInfo accountInfo, String symbol) {
        return null;
    }

    /**
     * buildTrailingSTIDMarketOrder
     *
     * @param accountInfo 账户信息
     * @param symbol      交易对
     * @return 限价单
     */
    public CEXTradeOrder buildTrailingSTIDMarketOrder(UserAccountRealTimeInfo accountInfo, String symbol) {
        return null;
    }


    /**
     * 获取下一id
     *
     * @param orderType 订单类型
     * @return 订单id
     */
    private String nextId(OrderType orderType) {
        return snowFlakeFactory.nextId(BRStyle.TRADE_SIGNAL, orderType.name());
    }
}




