package cn.com.vortexa.browser_control.dto;

import cn.com.vortexa.common.constants.ProxyProtocol;
import cn.com.vortexa.common.entity.ProxyInfo;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SeleniumProxy {

    private ProxyProtocol proxyProtocol;

    private String host;

    private int port;

    private String username;

    private String password;

    public SeleniumProxy(ProxyInfo proxy) {
        this.proxyProtocol = proxy.getProxyProtocol();
        this.host = proxy.getHost();
        this.port = proxy.getPort();
        this.username = proxy.getUsername();
        this.password = proxy.getPassword();
    }
}
package cn.com.vortexa.browser_control.util;

import cn.com.vortexa.browser_control.dto.SeleniumProxy;
import cn.com.vortexa.common.util.FileUtil;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class SeleniumProxyAuth {

    private static final String BASE_DIR = FileUtil.RESOURCE_ROOT_DIR + File.separator + "extensions";

    public static String createProxyAuthExtension(SeleniumProxy seleniumProxy) throws IOException {
        String pluginPath = BASE_DIR + File.separator + "proxy_auth_plugin_%s_%s.zip".formatted(
            seleniumProxy.getHost(), seleniumProxy.getPort()
        );

        if (new File(pluginPath).exists()) {
            return pluginPath;
        }

        String manifestJson = """
            {
                "version": "1.0.0",
                "manifest_version": 2,
                "name": "Chrome Proxy",
                "permissions": [
                    "proxy",
                    "tabs",
                    "unlimitedStorage",
                    "storage",
                    "<all_urls>",
                    "webRequest",
                    "webRequestBlocking"
                ],
                "background": {
                    "scripts": ["background.js"]
                },
                "minimum_chrome_version":"22.0.0"
            }
            """;

        String backgroundJs =
            """
                var config = {
                        mode: "fixed_servers",
                        rules: {
                          singleProxy: {
                            scheme: "%s",
                            host: "%s",
                            port: parseInt(%s)
                          },
                          bypassList: ["foobar.com"]
                        }
                      };
                chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});
                function callbackFn(details) {
                    return {
                        authCredentials: {
                            username: "%s",
                            password: "%s"
                        }
                    };
                }
                chrome.webRequest.onAuthRequired.addListener(
                            callbackFn,
                            {urls: ["<all_urls>"]},
                            ['blocking']
                );
                """.formatted(
                    seleniumProxy.getProxyProtocol().name().toLowerCase(),
                    seleniumProxy.getHost(),
                    seleniumProxy.getPort(),
                    seleniumProxy.getUsername(),
                    seleniumProxy.getPassword()
                );

        Path dirPath = Paths.get(BASE_DIR + File.separator + "proxy_auth_extension_%s_%s".formatted(
            seleniumProxy.getHost(),
            seleniumProxy.getPort()
        ));

        if (!Files.exists(dirPath)) {
            Files.createDirectories(dirPath);
        }

        File dir = dirPath.toFile();
        writeToFile(new File(dir, "manifest.json"), manifestJson);
        writeToFile(new File(dir, "background.js"), backgroundJs);

        // 创建 ZIP 扩展
        File zipFile = new File(pluginPath);
        try (FileOutputStream fos = new FileOutputStream(zipFile);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            java.util.zip.ZipOutputStream zos = new java.util.zip.ZipOutputStream(bos)) {

            addToZipFile(new File(dir, "manifest.json"), zos);
            addToZipFile(new File(dir, "background.js"), zos);
        }

        return pluginPath;
    }

    private static void writeToFile(File file, String content) throws IOException {
        try (FileWriter fw = new FileWriter(file);
            BufferedWriter bw = new BufferedWriter(fw)) {
            bw.write(content);
        }
    }

    private static void addToZipFile(File file, java.util.zip.ZipOutputStream zos) throws IOException {
        try (FileInputStream fis = new FileInputStream(file);
            BufferedInputStream bis = new BufferedInputStream(fis)) {

            java.util.zip.ZipEntry zipEntry = new java.util.zip.ZipEntry(file.getName());
            zos.putNextEntry(zipEntry);

            byte[] bytes = new byte[1024];
            int length;
            while ((length = bis.read(bytes)) >= 0) {
                zos.write(bytes, 0, length);
            }
        }
    }
}
package cn.com.vortexa.browser_control;

import cn.com.vortexa.browser_control.dto.SeleniumParams;
import cn.com.vortexa.browser_control.dto.SeleniumProxy;
import cn.com.vortexa.browser_control.execute.ExecuteGroup;
import cn.com.vortexa.browser_control.execute.ExecuteLogic;
import cn.com.vortexa.browser_control.util.SeleniumProxyAuth;
import cn.com.vortexa.browser_control.util.SeleniumUtil;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebDriverException;
import org.openqa.selenium.WindowType;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;

import java.io.File;
import java.io.IOException;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;


@Slf4j
@Getter
public abstract class SeleniumInstance implements SeleniumOperate {

    private final SeleniumParams params;

    private final ChromeOptions chromeOptions;

    private final SeleniumProxy proxy;

    private final List<ExecuteGroup> seleniumExecuteChain = new ArrayList<>();

    private final Random random = new Random();

    private final String instanceId;

    private WebDriver webDriver;

    private String targetHandle;

    @Setter
    private boolean autoClose = true;

    @Setter
    private Consumer<Long> finishHandler;

    public SeleniumInstance(
            String instanceId,
            SeleniumParams params
    ) throws IOException {
        this(instanceId, null, params);
    }

    public SeleniumInstance(
            String instanceId,
            SeleniumProxy proxy,
            SeleniumParams params
    ) throws IOException {
        this.instanceId = instanceId;
        if (instanceId == null || instanceId.isEmpty()) throw new IllegalArgumentException("instanceId is empty");
        this.params = params;
        this.proxy = proxy;
        this.chromeOptions = initChromeOption(proxy, params);
    }

    public abstract void init();

    public abstract void webDriverLaunched();

    /**
     * 添加执行方法
     *
     * @param executeGroup executeGroup
     * @return SeleniumInstance
     */
    public SeleniumInstance addExecuteFun(ExecuteGroup executeGroup) {
        this.seleniumExecuteChain.add(executeGroup);
        return this;
    }

    /**
     * 同步启动selenium
     */
    public void syncStart() throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(1);

        if (finishHandler == null) {
            setFinishHandler(cost -> {
                latch.countDown();
            });
        } else {
            Consumer<Long> fh = getFinishHandler();
            setFinishHandler(cost -> {
                fh.accept(cost);
                latch.countDown();
            });
        }

        asyncStart();
        latch.await();
    }


    /**
     * 异步启动selenium
     */
    public void asyncStart() {
        init();

        long start = System.currentTimeMillis();
        try {
            // Step 1 设置driver
            String driverPath = params.getDriverPath();
            if (driverPath != null && !driverPath.isEmpty()) {
                System.setProperty("webdriver.chrome.driver", driverPath);
            }

            // Step 2 启动浏览器
            launchBrowser();

            webDriverLaunched();

            // Step 3 遍历execute chain 执行
            executeChainInvoke();
        } catch (Exception e) {
            log.error("selenium instance invoke error", e);
        } finally {
            if (finishHandler != null) {
                finishHandler.accept(System.currentTimeMillis() - start);
            }
        }
    }

    /**
     * 调用执行链
     *
     * @throws InterruptedException InterruptedException
     */
    protected void executeChainInvoke() throws InterruptedException {
        for (ExecuteGroup executeGroup : seleniumExecuteChain) {
            String groupName = executeGroup.getName();

            log.info("[{}]-[{}] group start execute", instanceId, groupName);

            // Step 3.1 判断该组操作是否能够进入
            Boolean isEnter = executeGroup.getEnterCondition().apply(webDriver, this);
            if (isEnter != null && isEnter) {
                // Step 3.1.1 能够进入，开始执行group的逻辑
                log.info("[{}]-[{}] group can execute", instanceId, groupName);
                executeGroup.getExecuteItems().forEach(item -> {
                    // Step 3.1.1.1 带重试
                    Integer retryTimes = item.getRetryTimes() == null ? 1 : item.getRetryTimes();
                    for (int j = 0; j < retryTimes; j++) {
                        try {
                            log.info("[{}]-[{}]-[{}] start invoke logic [{}/{}]",
                                    instanceId, groupName, item.getName(), j, retryTimes);
                            ExecuteLogic executeLogic = item.getExecuteLogic();

                            if (executeLogic != null) {
                                executeLogic.execute(webDriver, this);
                            }
                            // Step 3。1.1.2 运行成功，return下一个item执行
                            return;
                        } catch (Exception e) {
                            // Step 3.1.1.3 运行失败，调用重试Rest方法后，继续执行
                            log.error("[{}]-[{}]-[{}] invoke logic error, retry {}", instanceId, groupName, item.getName(), j, e);

                            ExecuteLogic resetLogic = item.getResetLogic();
                            if (resetLogic != null) {
                                resetLogic.execute(webDriver, this);
                            }
                        }
                    }
                    // Step 3.1.1.4 超过次数抛出异常
                    throw new RuntimeException("[%S]-[%s]-[%s] invoke logic error, out of limit %s"
                            .formatted(instanceId, groupName, item.getName(), retryTimes));
                });
            } else {
                // Step 3.1.2 不能进入执行
                log.warn("[{}]-[{}] group can not execute", instanceId, groupName);
            }

            // Step 3.2 group 操作执行完，sleep一段时间
            int timeout = random.nextInt(500, 5000);
            log.info("[{}]-[{}] execute finish, sleep [{}]ms", instanceId, groupName, timeout);
            TimeUnit.MILLISECONDS.sleep(timeout);
        }
    }

    /**
     * 创建web driver
     *
     * @param chromeOptions chromeOptions
     * @return WebDriver
     */
    protected WebDriver createWebDriver(ChromeOptions chromeOptions) {
        ChromeDriver chromeDriver = new ChromeDriver(chromeOptions);
        log.info("chrome browser started, start execute chain");
        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        return chromeDriver;
    }

    /**
     * 启动浏览器
     *
     * @throws IOException IOException
     */
    private void launchBrowser() throws IOException {
        log.info("starting chrome browser [{}}", instanceId);
        this.webDriver = createWebDriver(chromeOptions);
        this.webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(1));

        // Step 2.2 设置代理
        setProxyAuth();

        // Step 2.3 进入目标页面
        // 打开初始页面
        Set<String> windowHandles = webDriver.getWindowHandles();
        for (String windowHandle : windowHandles) {
            webDriver.switchTo().window(windowHandle);
            String title = null;
            try {
                // 打开新的标签页并自动切换到这个 tab
                webDriver.switchTo().newWindow(WindowType.TAB);
                title = webDriver.getTitle();
                // 跳转到目标网址
                webDriver.get(params.getTargetWebSite());
                targetHandle = webDriver.getWindowHandle();
                TimeUnit.SECONDS.sleep(5);
                break;
            } catch (WebDriverException e) {
                webDriver.close();
            } catch (Exception e) {
                log.warn("{} cannot open tab, try next", title);
            }
        }
    }

    private void setProxyAuth() {

    }

    /**
     * 初始化参数
     *
     * @param proxy  proxy
     * @param params params
     * @return ChromeOptions
     * @throws IOException IOException
     */
    private ChromeOptions initChromeOption(SeleniumProxy proxy, SeleniumParams params) throws IOException {
        final ChromeOptions chromeOptions = new ChromeOptions();
        addDefaultChromeOptions(chromeOptions);

        if (params.getChromeOptions() != null) {
            params.getChromeOptions().forEach(chromeOptions::addArguments);
        }
        if (params.getExperimentalOptions() != null) {
            for (Pair<String, String> pair : params.getExperimentalOptions()) {
                chromeOptions.setExperimentalOption(pair.getKey(), pair.getValue());
            }
        }
        if (params.getExtensionPaths() != null) {
            chromeOptions.addExtensions(params.getExtensionPaths().stream().map(File::new).toList());
        }
        if (proxy != null) {
            chromeOptions.addExtensions(new File(SeleniumProxyAuth.createProxyAuthExtension(proxy)));
        }
        return chromeOptions;
    }

    protected void addDefaultChromeOptions(ChromeOptions chromeOptions) {
        // 设置用户数据目录
        chromeOptions.addArguments("user-data-dir=" + SeleniumUtil.getUserDataDir(instanceId));
        // 设置代理
        chromeOptions.addArguments("--disable-gpu");
        chromeOptions.addArguments("--remote-allow-origins=*");
        chromeOptions.addArguments("--no-default-browser-check");
        chromeOptions.addArguments("--disable-popup-blocking");
        chromeOptions.addArguments("--disable-infobars");
        chromeOptions.addArguments("---no-sandbox");

        chromeOptions.addArguments("--disable-blink-features=AutomationControlled");  // 禁用自动化检测
        chromeOptions.addArguments("--start-maximized");
        chromeOptions.setExperimentalOption("useAutomationExtension", false);
        chromeOptions.setExperimentalOption("excludeSwitches", new String[]{"enable-automation"});
    }

    public void close() {
        if (StrUtil.isNotBlank(targetHandle)) {
            try {
                webDriver.switchTo().window(targetHandle);
                webDriver.close();
            } catch (Exception e) {
                log.error("{} close exception", instanceId, e);
            }
        }
    }
}
package cn.com.vortexa.script_bot.daily.haha_wallet;

import cn.com.vortexa.browser_control.*;
import cn.com.vortexa.browser_control.dto.SeleniumParams;
import cn.com.vortexa.browser_control.dto.SeleniumProxy;
import cn.com.vortexa.browser_control.execute.ExecuteGroup;
import cn.com.vortexa.browser_control.execute.ExecuteItem;
import cn.com.vortexa.browser_control.util.SeleniumProxyAuth;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.BrowserEnv;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.hutool.core.date.DateTime;
import cn.hutool.core.util.StrUtil;
import org.jetbrains.annotations.NotNull;
import org.openqa.selenium.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


import java.awt.*;
import java.awt.event.KeyEvent;
import java.io.IOException;
import java.util.*;
import java.util.List;

import static cn.com.vortexa.script_bot.daily.haha_wallet.HaHaWalletBot.*;

public class HahaWalletSelenium extends OptSeleniumInstance {

    public static String HAHA_WALLET_EXTENSION_CRX_PATH = "";
    public static String CHROME_DRIVER_PATH = "";

    private static final Logger log = LoggerFactory.getLogger(HahaWalletSelenium.class);

    private final AccountContext accountContext;

    private int todayCount;

    public HahaWalletSelenium(HaHaWalletBot bot, AccountContext accountContext) throws IOException {
        super(
                accountContext.getParam(HaHaWalletBot.USERNAME_KEY),
                new SeleniumProxy(
                    accountContext.getProxy().getProxyProtocol(),
                        accountContext.getProxy().getHost(),
                        accountContext.getProxy().getPort(),
                        accountContext.getProxy().getUsername(),
                        accountContext.getProxy().getPassword()
                ),
                getParams(accountContext)
        );

        String email = accountContext.getParam(HaHaWalletBot.USERNAME_KEY);
        String password = accountContext.getParam(HaHaWalletBot.PASSWORD_KEY);
        String todayCountStr = accountContext.getParam(TODAY_COUNT_KEY);

        String lastRunDay = accountContext.getParam(TODAY_KEY);
        String today = DateTime.now().toString();

        if (StrUtil.isBlank(todayCountStr) || StrUtil.isBlank(lastRunDay) || !today.equals(todayCountStr)) {
            todayCount = getRandom().nextInt(10, 13);
        } else {
            todayCount = Integer.parseInt(todayCountStr);
        }

        accountContext.setParam(TODAY_KEY, today);
        accountContext.setParam(TODAY_COUNT_KEY, todayCount);


        bot.logger.info("[%s] remained [%s] today".formatted(accountContext.getAccountBaseInfoId(), todayCount));

        String wallet = accountContext.getParam(WALLET_KEY);

        if (todayCount == 0) {
            throw new RuntimeException("today total finish");
        }

        if (StrUtil.isBlank(wallet) || StrUtil.isBlank(email) || StrUtil.isBlank(password)) {
            bot.logger.warn("%s no email or password or wallet".formatted(accountContext.getSimpleInfo()));
            throw new IllegalArgumentException("email or password or wallet is empty");
        }

        this.accountContext = accountContext;
    }


    @Override
    public void init() {
        super.addExecuteFun(ExecuteGroup.builder()
                        .name("初始化")
                        .enterCondition((webDriver, params) -> {
                            return true;
                        })
                        .executeItems(List.of(
                                ExecuteItem.builder().name("代理验证").executeLogic(this::proxyVerify).build()
                        ))
                        .build()
                )
                .addExecuteFun(ExecuteGroup.builder()
                        .name("登录HaHa")
                        .enterCondition((webDriver, params) -> {
                            return !xPathExist("//*[@id=\"app-content\"]/div/div[2]/div[2]/div/button[2]");
                        })
                        .executeItems(List.of(
                                ExecuteItem.builder().name("切换到目标页面").executeLogic(this::changeToTargetPage).build(),
                                ExecuteItem.builder().name("登录账号").executeLogic(this::loginAccount).build(),
                                ExecuteItem.builder().name("导入钱包").executeLogic(this::importWallet).build()
                        ))
                        .build()
                )
                .addExecuteFun(ExecuteGroup.builder()
                        .name("解锁钱包")
                        .enterCondition((webDriver, params) -> {
                            return xPathExist("//*[@id=\"app-content\"]/div/div[2]/div[2]/div/button[2]");
                        })
                        .executeItems(List.of(
                                ExecuteItem.builder().name("输入Pin Code").executeLogic(((webDriver, seleniumInstance) -> {
                                    xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div/div/input").sendKeys("123456789");

                                    xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div/button[1]");
                                })).build()
                        ))
                        .build()
                )
                .addExecuteFun(ExecuteGroup.builder()
                        .name("每日任务")
                        .enterCondition((webDriver, params) -> {
                            return true;
                        })
                        .executeItems(List.of(
                                ExecuteItem.builder().name("进入monad Swap页面").executeLogic(this::enterMonadSwapPage).build(),
                                ExecuteItem.builder().name("交换Monad").executeLogic(this::monadSwap).build()
//                                ExecuteItem.builder().name("trans sepolia Eth").executeLogic(this::sepoliaSwapPage).build()
                        ))
                        .build()
                );

    }


    private void sepoliaSwapPage(WebDriver webDriver, SeleniumInstance seleniumInstance) {

        // 点击进入legacyPage
        xPathClick("//p[text()='Legacy Wallet']");

        // 点击网络选择按钮
        xPathClick("//div[text()='Sepolia' or text()='Monad Testnet']");

        // 点击选择测试网
        xPathClick("//li[text()='Testnet']");

        // 点击选择Sepolia
        xPathClick("//p[text()='Sepolia (ETH)']");

        randomWait();

        int count = seleniumInstance.getRandom().nextInt(5, 10);

        for (int i = 0; i < count; i++) {
            try {
                sepoliaSwap(webDriver, seleniumInstance);

            } catch (Exception e) {
                log.error("{} sepolia swap error", getInstanceId(), e);
            }
        }
    }

    private void sepoliaSwap(WebDriver webDriver, SeleniumInstance seleniumInstance) {

        // 点击send页面
        xPathClick("//p[text()='Send']");

        randomWait();

        // 选择代币
        List<WebElement> selectionBtnList = xPathFindElements("//*[@id=\"app-content\"]/div[1]/div[2]/div[2]/div[2]/div[1]/div[1]/div[1]//button");
        int select = seleniumInstance.getRandom().nextInt(selectionBtnList.size());
        selectionBtnList.get(select).click();

        // 选择自己的地址
        xPathClick("//div[contains(text(), 'Account 1')]", 60);
        randomWait();

        WebElement countP = xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[1]/div[2]/div[2]/div[3]/p");
        if (countP.getText().isEmpty()) {
            countP = xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[1]/div[2]/div[2]/div[3]/p");
        }
        double total = Double.parseDouble(countP.getText());
        double count = seleniumInstance.getRandom().nextDouble(0.01, 0.07) * total;

        // 输入数量
        WebElement countInput = xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[1]/div[2]/div[5]/div/div[2]/input");
        countInput.sendKeys("%.6f".formatted(count));

        // 点击下一步
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[2]/div[2]/button", 120);

        // 点击确认
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[2]/div[2]/button", 120);
    }


    private void monadSwap(WebDriver webDriver, SeleniumInstance seleniumInstance) {
        WebElement swapCountInput = xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[1]/div[2]/div/div[3]/input");

        Random random = new Random();
        int monCount = random.nextInt(10, 13);
        int successTimes = 0;
        int errorTimes = 0;
        while (successTimes < monCount) {
            try {
                // 点击进入交换代币选择界面
                xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[3]/div[1]/button");

                // 随机选择代币
                List<WebElement> token2List = xPathFindElements("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[3]/div[2]/div[3]/div//button");
                token2List.removeFirst();

                randomWait();
                token2List.get(random.nextInt(token2List.size())).click();

                double count = random.nextDouble(0.0001, 0.001);
                swapCountInput.clear();
                swapCountInput.sendKeys("%.4f".formatted(count));

                randomWait();
                // 点击确认
                xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[6]/button");

                randomWait();
                xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[3]/div[2]/div/button", 120);
                successTimes++;

                todayCount--;
                accountContext.setParam(TODAY_COUNT_KEY, todayCount);
            } catch (Exception e) {
                log.error("{} monad swap error", getInstanceId(), e);
                if (errorTimes++ > 3) {
                    break;
                }
            }
        }

        // 点击返回按钮
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[1]/button");
    }

    private void enterMonadSwapPage(WebDriver webDriver, SeleniumInstance seleniumInstance) {

        // 点击进入legacyPage
        xPathClick("//p[text()='Legacy Wallet']");

        // 点击网络选择按钮
        xPathClick("//div[text()='Sepolia' or text()='Monad Testnet']");

        // 点击选择测试网
        xPathClick("//li[text()='Testnet']");

        // 点击选择Monad
        xPathClick("//p[text()='Monad Testnet']");

        randomWait();

        // 点击swap页面
        xPathClick("//p[text()='Swap']");

        randomWait();
    }

    private void importWallet(WebDriver webDriver, SeleniumInstance seleniumInstance) {
        // 点击导入按钮
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[5]/div[2]/button");

        // 等待输入框出现， 输入钱包
        List<WebElement> inputs = xPathFindElements("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[3]/div//input");
        String[] split = accountContext.getParam(WALLET_KEY).split(" ");
        for (int i = 0; i < inputs.size(); i++) {
            inputs.get(i).sendKeys(split[i]);
        }

        // 点击导入按钮
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[4]/button");

        // 点击导入成功的确认按钮
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/button");

        // 点击跳过按钮
//            xPathClick("//*[@id=\"app-content\"]/div[2]/div[2]/div[3]/button[2]");


        randomWait();
    }


    private void loginAccount(WebDriver webDriver, SeleniumInstance seleniumInstance) {
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[3]/button[2]");

        // 找到 email 输入框并输入邮箱
        webDriver.findElement(By.cssSelector("input[type='email']")).sendKeys(accountContext.getParam(USERNAME_KEY));
        // 找到 password 输入框并输入密码
        webDriver.findElement(By.cssSelector("input[type='password']")).sendKeys(accountContext.getParam(PASSWORD_KEY));
        // 点击登录按钮
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[3]/div[3]/button[1]");


        // 输入解锁密码
        xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[3]/div[1]/input").sendKeys("123456789");
        // 输入解锁密码
        xPathFindElement("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[3]/div[2]/input").sendKeys("123456789");
        // 确认
        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/div[2]/div[4]/button");


        xPathClick("//*[@id=\"app-content\"]/div/div[2]/div[2]/label/input");
    }


    private void changeToTargetPage(WebDriver webDriver, SeleniumInstance seleniumInstance) {
        // 获取所有窗口句柄
        Set<String> handles = webDriver.getWindowHandles();
        for (String handle : handles) {
            webDriver.switchTo().window(handle);
            if (Objects.equals(webDriver.getCurrentUrl(), "data:,")) {
                webDriver.close(); // 关闭 data:, 页面
                break;
            }
        }

        // 切换到第二个标签页（索引 1）
        List<String> windowList = new ArrayList<>(webDriver.getWindowHandles());
        webDriver.switchTo().window(windowList.getFirst());
    }

    private void proxyVerify(WebDriver webDriver, SeleniumInstance instance) {
        // 使用 Robot 模拟输入用户名和密码
        Robot robot = null;
        try {
            robot = new Robot();
        } catch (AWTException e) {
            throw new RuntimeException(e);
        }
        robot.delay(10000); // 等待弹框出现

        // 输入用户名
        for (char c : instance.getProxy().getUsername().toCharArray()) {
            robot.keyPress(KeyEvent.getExtendedKeyCodeForChar(c));
            robot.keyRelease(KeyEvent.getExtendedKeyCodeForChar(c));
        }

        robot.keyPress(KeyEvent.VK_TAB);
        robot.keyRelease(KeyEvent.VK_TAB);

        // 输入密码
        for (char c : instance.getProxy().getPassword().toCharArray()) {
            robot.keyPress(KeyEvent.getExtendedKeyCodeForChar(c));
            robot.keyRelease(KeyEvent.getExtendedKeyCodeForChar(c));
        }
        robot.keyPress(KeyEvent.VK_ENTER);
        robot.keyRelease(KeyEvent.VK_ENTER);
    }

    @NotNull
    private static SeleniumParams getParams(AccountContext accountContext) {
        return SeleniumParams
                .builder()
                .driverPath(CHROME_DRIVER_PATH)
                .targetWebSite("chrome-extension://andhndehpcjpmneneealacgnmealilal/popup.html")
                .extensionPaths(List.of(HAHA_WALLET_EXTENSION_CRX_PATH))
                .chromeOptions(List.of("user-agent=" + accountContext.getBrowserEnv().getUserAgent()))
                .build();
    }
}
package cn.com.vortexa.script_bot.daily.taker;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.script_node.constants.MapConfigKey;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.hutool.core.util.StrUtil;

import java.util.Map;
import java.util.concurrent.ExecutionException;


/**
 * @author helei
 * @since 2025/4/18 9:26
 */
public class TakerApi {
    private static final String BASE_URL = "https://sowing-api.taker.xyz";
    private static final String LOGIN_MESSAGE = "Taker quest needs to verify your identity to prevent unauthorized access. Please confirm your sign-in details below:\\n\\naddress: %s\\n\\nNonce: %s";
    private final TakerBot takerBot;

    public TakerApi(TakerBot takerBot) {
        this.takerBot = takerBot;
    }

    /**
     * 自动领
     *
     * @param accountContext    accountContext
     * @throws Exception    Exception
     */
    public void autoClaim(AccountContext accountContext) throws Exception {
        Map<String, String> headers = buildHaader(accountContext);

        String simpleInfo = accountContext.getSimpleInfo();
        String token = accountContext.getParam(MapConfigKey.TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            token = login(accountContext);
        }
        if (StrUtil.isBlank(token)) {
            throw new Exception("token is empty");
        }

        headers.put("authorization", "Bearer " + token);
        try {
            String response = takerBot.syncRequest(
                accountContext.getProxy(),
                BASE_URL + "/task/signIn?status=true",
                HttpMethod.GET,
                headers,
                null,
                null,
                () -> simpleInfo + " send auto claim request.."
            ).get();
            takerBot.logger.info(simpleInfo + " claim success.." + response);
        } catch (InterruptedException | ExecutionException e) {
            throw new Exception("auto claim error", e);
        }
    }

    /**
     * 登录获取token
     *
     * @param accountContext    accountContext
     * @return  token
     * @throws Exception    Exception
     */
    public String login(AccountContext accountContext) throws Exception {
        String primaryKey = accountContext.getParam(MapConfigKey.WALLET_PRIMARY_KEY_Key);
        if (StrUtil.isBlank(primaryKey)) {
            throw new Exception(accountContext.getId() + " primary key is empty");
        }
        String address = accountContext.getParam(MapConfigKey.WALLET_ADDRESS_KEY, () -> EthWalletUtil.getETHAddress(primaryKey));
        String nonce = generateNonce(accountContext, address);

        String signature = EthWalletUtil.signatureMessage2String(
            primaryKey,
            LOGIN_MESSAGE.formatted(address, nonce)
        );

        JSONObject body = new JSONObject();
        body.put("address", address);
        body.put("signature", signature);

        JSONObject response = takerBot.syncJSONRequest(
            accountContext.getProxy(),
            BASE_URL + "/wallet/login",
            HttpMethod.POST,
            buildHaader(accountContext),
            null,
            body,
            () -> accountContext.getSimpleInfo() + ": " + address + " send login request.."
        ).get();

        String token = response.getJSONObject("result").getString("token");
        accountContext.setParam(MapConfigKey.TOKEN_KEY, token);

        return token;
    }

    private String generateNonce(AccountContext accountContext, String address) throws Exception {
        JSONObject body = new JSONObject();
        body.put("walletAddress", address);
        try {
            JSONObject response = takerBot.syncJSONRequest(
                accountContext.getProxy(),
                BASE_URL + "/wallet/generateNonce",
                HttpMethod.POST,
                buildHaader(accountContext),
                null,
                body,
                () -> accountContext.getSimpleInfo() + ": " + address + " send get nonce request.."
            ).get();

            if (response.getInteger("code") == 200) {
                takerBot.logger.info("request nonce success");
                return response.getJSONObject("result").getString("nonce");
            } else {
                throw new Exception("request nonce result exception");
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new Exception("request nonce unknown error", e);
        }
    }

    private Map<String, String> buildHaader(AccountContext ac) {
        Map<String, String> headers = ac.getBrowserEnv().generateHeaders();
        headers.put("accept", "application/json, text/plain, */*");
        headers.put("accept-language", "en-US,en;q=0.9");
        headers.put("Referer", "https://sowing.taker.xyz/");
        headers.put("Referrer-Policy", "strict-origin-when-cross-origin");
        return headers;
    }
}
package cn.com.vortexa.script_bot.daily.taker;

import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.script_node.anno.BotApplication;
import cn.com.vortexa.script_node.anno.BotMethod;
import cn.com.vortexa.script_node.bot.AutoLaunchBot;
import cn.com.vortexa.script_node.constants.MapConfigKey;
import cn.com.vortexa.script_node.service.BotApi;

/**
 * @author helei
 * @since 2025/4/18 9:02
 */
@BotApplication(name = "taker_auto_bot", accountParams = MapConfigKey.WALLET_PRIMARY_KEY_Key)
public class TakerBot extends AutoLaunchBot<TakerBot> {

    private TakerApi takerApi;

    @Override
    protected void botInitialized(AutoBotConfig botConfig, BotApi botApi) {
        this.takerApi = new TakerApi(this);
    }

    @Override
    protected TakerBot getInstance() {
        return this;
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 60 * 60 * 3 + 120)
    public void autoClaim(AccountContext accountContext) {
        try {
            takerApi.autoClaim(accountContext);
        } catch (Exception e) {
            logger.error(accountContext.getSimpleInfo() + " auto claim fail.."
                + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
        }
    }
}
package cn.com.vortexa.script_node.bot;

import static cn.com.vortexa.script_node.service.impl.BotAccountContextServiceImpl.BOT_ACCOUNT_CONTEXT_TABLE_PREFIX;
import static cn.com.vortexa.common.entity.BotInfo.BASIC_JOB_LIST_KEY;

import cn.com.vortexa.script_node.config.ScriptNodeConfiguration;
import cn.com.vortexa.script_node.service.BotApi;
import cn.com.vortexa.script_node.constants.BotStatus;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.script_node.util.log.AppendLogger;
import cn.com.vortexa.common.dto.AutoBotRuntimeInfo;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStatusException;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

import lombok.Getter;
import lombok.Setter;

import java.io.File;
import java.io.IOException;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;
import java.util.function.Supplier;

public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    public AppendLogger logger;

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot api
     */
    @Getter
    private BotApi botApi;

    /**
     * bot运行时信息
     */
    @Getter
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * 请求并发数量
     */
    @Getter
    @Setter
    private int requestConcurrentCount = 5;

    /**
     * bot信息
     */
    @Getter
    private BotInfo botInfo;

    @Getter
    private BotInstance botInstance;

    /**
     * script node配置
     */
    @Getter
    private ScriptNodeConfiguration scriptNodeConfiguration;

    /**
     * 配置
     */
    @Getter
    private AutoBotConfig autoBotConfig;

    /**
     * 执行异步任务的线程池
     */
    @Getter
    private ExecutorService executorService;

    /**
     * 状态
     */
    @Getter
    private BotStatus status = BotStatus.NEW;

    public AbstractAutoBot() {
        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();
    }

    /**
     * 初始化方法
     *
     * @param autoBotConfig autoBotConfig
     * @throws BotInitException BotInitException
     */
    public final void init(
            ScriptNodeConfiguration scriptNodeConfiguration, BotApi botApi, AutoBotConfig autoBotConfig
    ) throws BotInitException {
        try {
            this.logger = new AppendLogger(
                    scriptNodeConfiguration.getScriptNodeName(),
                    autoBotConfig.getBotName(),
                    autoBotConfig.getBotKey()
            );
        } catch (IOException e) {
            throw new BotInitException("bot logger create error", e);
        }

        this.scriptNodeConfiguration = scriptNodeConfiguration;
        this.botApi = botApi;

        // Step 1 参数校验
        if (StrUtil.isBlank(autoBotConfig.getBotKey())) {
            throw new IllegalArgumentException("bot key is empty!");
        }

        // Step 2 进入INIT状态，获取参数
        updateState(BotStatus.INIT);
        this.autoBotConfig = autoBotConfig;
        try {
            // Step 2.1 获取BotInfo,解析Bot Job
            botInfo = buildBotInfo();
            resolveBotJobMethod();
        } catch (Exception e) {
            throw new BotInitException("resolve bot job error", e);
        }

        // Step 2.2 保存bot info
        try {
            if (botApi.getBotInfoRPC().insertOrUpdateRPC(botInfo) == 1) {
                Map<String, Object> query = new HashMap<>();
                query.put("name", botInfo.getName());
                // 保存成还需查询botId
                Integer id = botApi.getBotInfoRPC().conditionQueryRPC(query).getFirst().getId();
                botInfo.setId(id);
                logger.info("save bot info success, id:" + botInfo.getId());
            }
        } catch (SQLException e) {
            throw new BotInitException("save bot info error", e);
        }

        this.botInstance = BotInstance.builder()
                .botId(botInfo.getId())
                .botName(botInfo.getName())
                .botKey(autoBotConfig.getBotKey())
                .build();

        // Step 2.3 设置logger前缀与线程池
        this.executorService = Executors.newThreadPerTaskExecutor(
                new NamedThreadFactory(botInfo.getName() + "-executor"));

        try {
            // Step 2.4 初始化存储的Table
            logger.info("start init database table");
            // 检查对应分表是否存在
            if (!botApi.getBotAccountService()
                    .checkAndCreateShardedTable(botInfo.getId(), getAutoBotConfig().getBotKey(), true)) {
                throw new RuntimeException("bot account table create error");
            }
            logger.info("database table init finish");

            // Step 2.5 初始化BotInstance实例
            logger.info("start init bot instance");

            BotInstance dbInstance = getBotApi().getBotInstanceRPC().selectOneRPC(botInstance);

            // 数据库存在bot instance实例信息并且job信息没变化，用数据库的。 否则用BotInfo信息生成BotInstance信息写入库
            if (dbInstance != null && !compareBotJobParamsChanged(botInfo, dbInstance)) {
                this.botInstance = dbInstance;
                logger.info("exist botInstance, use exist instance config");
            } else {
                logger.info("no instance or instance job update, create it...");

                String tableName = getBotApi().getTableShardStrategy().generateTableName(
                        BOT_ACCOUNT_CONTEXT_TABLE_PREFIX,
                        new Object[]{botInstance.getBotId(), botInstance.getBotKey()}
                );
                botInstance.setBotName(botInfo.getName());
                botInstance.setAccountTableName(tableName);
                botInstance.setJobParams(botInfo.getJobParams());
                botInstance.setParams(botInfo.getParams());

                if (botApi.getBotInstanceRPC().insertOrUpdateRPC(botInstance) > 0) {
                    logger.info("new bot instance create success");
                } else {
                    throw new BotInitException("new bot instance create error");
                }
            }

            // Step 2.5 子类初始化
            doInit();

            // Step 2。6 更新状态
            updateState(BotStatus.INIT_FINISH);
        } catch (Exception e) {
            logger.error("init error", e);
            updateState(BotStatus.INIT_ERROR);
        }
    }

    /**
     * 初始化方法
     */
    protected abstract void doInit() throws BotInitException;

    /**
     * 停止Bot
     */
    public void stop() {
        updateState(BotStatus.STOPPING);
        try {
            networkSyncControllerMap.clear();
            doStop();
            updateState(BotStatus.STOPPED);
        } catch (Exception e) {
            logger.error("stop bot error, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
            updateState(BotStatus.SHUTDOWN);
        }
    }

    protected abstract void doStop();

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, 1);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            int retryTimes
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null, retryTimes);
    }
    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<JSONObject> syncJSONRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart
    ) {
        return syncRequest(
            proxy,
            url,
            method,
            headers,
            params,
            body,
            requestStart,
            1
        ).thenApply(responseStr->{
            if(responseStr == null) return null;
            return JSONObject.parseObject(responseStr);
        });
    }
    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncRequest(
                proxy,
                url,
                method,
                headers,
                params,
                body,
                requestStart,
                1
        );
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart,
            int retryTimes
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body,
                        retryTimes
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<List<String>> syncStreamRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).streamRequest(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    public <R> CompletableFuture<R> syncCCHandler(
            ProxyInfo proxy,
            Supplier<String> requestStart,
            Supplier<R> request
    ) {

        Semaphore networkController = networkSyncControllerMap
                .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                    if (v == null) {
                        v = new Semaphore(requestConcurrentCount);
                    }
                    return v;
                });

        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "start network request";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                logger.debug("同步器允许发送请求 - " + str);

                return request.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getAppResourceAppConfigPath() + File.separator + getBotInstance().getBotKey();
    }

    /**
     * 更新BotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(BotStatus newStatus) throws BotStatusException {

        boolean b = switch (status) {
            //当前为NEW，新状态才能为NEW,SHUTDOWN
            case NOT_LOADED -> BotStatus.NEW.equals(newStatus);
            case NEW -> BotStatus.INIT.equals(newStatus);
            //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
            case INIT -> newStatus.equals(BotStatus.INIT_FINISH)
                    || newStatus.equals(BotStatus.INIT_ERROR);
            //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
            case INIT_ERROR -> newStatus.equals(BotStatus.INIT);
            //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
            case INIT_FINISH -> newStatus.equals(BotStatus.STARTING);
            //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
            case STARTING -> newStatus.equals(BotStatus.RUNNING);
            //RUNNING，新状态只能为 SHUTDOWN
            case RUNNING -> newStatus.equals(BotStatus.STOPPING);
            case STOPPING -> newStatus.equals(BotStatus.STOPPED) || newStatus.equals(BotStatus.SHUTDOWN);
            case STOPPED -> newStatus.equals(BotStatus.INIT);
            case SHUTDOWN -> throw new BotStatusException("bot already shutdown");
        };

        if (b) {
            logger.debug("Status change [%s] => [%s]".formatted(status, newStatus));
            this.status = newStatus;
        } else {
            throw new BotStatusException(
                    String.format("%s status can't from[%s] -> to[%s]", runtimeBotName(), status, newStatus));
        }
    }

    public String runtimeBotName() {
        return "Bot[%s]-[%s]".formatted(botInstance.getBotName(), autoBotConfig.getBotKey());
    }

    public String getScriptNodeName() {
        return scriptNodeConfiguration.getScriptNodeName();
    }

    protected synchronized Map<String, AutoBotJobParam> getJobParams() {
        return this.botInstance == null ? new HashMap<>() : this.botInstance.getJobParams();
    }

    protected synchronized AutoBotJobParam getJobParam(String jobName) {
        return this.botInfo.getJobParams() == null ? null : this.botInfo.getJobParams().get(jobName);
    }

    protected synchronized void setJobParam(String jobKey, AutoBotJobParam jobParam) {
        this.botInfo.getJobParams().put(jobKey, jobParam);
    }

    protected synchronized void addBasicJob(BotJobType jobType) {
        if (this.botInfo.getParams() == null) {
            this.botInfo.setParams(new HashMap<>());
        }

        this.botInfo.getParams().compute(BASIC_JOB_LIST_KEY, (k, v) -> {
            if (v == null) {
                v = new HashSet<String>();
            }
            if (v instanceof JSONArray t) {
                v = new HashSet<String>();
                for (int i = 0; i < t.size(); i++) {
                    ((HashSet<String>) v).add(t.getString(i));
                }
            }
            Set<String> set = (HashSet<String>) v;
            set.add(jobType.name());
            return v;
        });
    }

    protected abstract BotInfo buildBotInfo() throws BotInitException;

    protected abstract void resolveBotJobMethod();

    /**
     * 比较botInfo 和 BotInstance是否发生变化
     *
     * @param botInfo    botInfo
     * @param dbInstance dbInstance
     * @return boolean
     */
    private boolean compareBotJobParamsChanged(BotInfo botInfo, BotInstance dbInstance) {
        Map<String, AutoBotJobParam> botJobParam = botInfo.getJobParams();
        Map<String, AutoBotJobParam> botInstanceParam = dbInstance.getJobParams();

        // rpc map序列化范型丢失处理
        Map<String, AutoBotJobParam> jobParams = dbInstance.getJobParams();
        if (jobParams != null) {
            for (String key : jobParams.keySet()) {
                Object param = jobParams.get(key);
                if (param instanceof JSONObject jb) {
                    jobParams.put(key, JSONObject.parseObject(JSONObject.toJSONString(jb), AutoBotJobParam.class));
                }
            }
        }

        if (botJobParam.size() != botInstanceParam.size()) return true;

        if (!botJobParam.keySet().containsAll(botInstanceParam.keySet())) {
            return true;
        }

        for (Map.Entry<String, AutoBotJobParam> entry : botJobParam.entrySet()) {
            String jobName = entry.getKey();
            AutoBotJobParam param = entry.getValue();
            AutoBotJobParam instanceParam = botInstanceParam.get(jobName);

            if (!param.equals(instanceParam)) {
                return true;
            }
        }
        return false;
    }
}

package cn.com.vortexa.script_node.constants;

public class MapConfigKey {

    public static final String INVITE_CODE_KEY = "invite_code";

    public static final String REGISTER_TYPE_KEY = "register_type";

    public static final String EMAIL_VERIFIED_KEY = "email_verified";

    public static final String EMAIL_VERIFIER_TYPE = "email_verifier_type";

    public static final String TOKEN_KEY = "token";

    public static final String CONNECT_URL_KEY = "connect_url";

    public static final String USER_AGENT_KEY = "user_agent";

    public static final String TWO_CAPTCHA_API_KEY = "two_captcha_api_key";

    public static final String PASSWORD_KEY = "password";

    public static final String WALLET_PRIMARY_KEY_Key = "wallet_primary_key";
    public static final String WALLET_ADDRESS_KEY = "wallet_address";

    public static final String ACCESS_TOKEN_KEY_V1 = "access_token";
    public static final String ACCESS_TOKEN_KEY_V2 ="accessToken";
    public static final String REFRESH_TOKEN_KEY_V1 = "refresh_token";
    public static final String REFRESH_TOKEN_KEY_V2 = "refreshToken";
}
