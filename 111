package cn.com.helei.DepinBot.app.keitokun;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.WSDepinBotConfig;
import cn.com.helei.DepinBot.core.config.SystemConfig;
import cn.com.helei.DepinBot.core.util.YamlConfigLoadUtil;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;

import java.util.List;

@EqualsAndHashCode(callSuper = true)
@Data
@ToString(callSuper = true)
public class KeitokunConfig extends WSDepinBotConfig {

    private List<String> uids;


    public static KeitokunConfig loadYamlConfig(String classpath) {
        return YamlConfigLoadUtil.load(SystemConfig.CONFIG_DIR_APP_PATH, classpath, List.of("depin", "app", "keitokun"), KeitokunConfig.class);
    }


    public static void main(String[] args) {
        System.out.println(loadYamlConfig("keitokun.yaml"));
    }
}


package cn.com.helei.DepinBot.app.keitokun;

import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.SimpleDepinWSClient;
import cn.com.helei.DepinBot.core.bot.WSMenuCMDLineDepinBot;
import cn.com.helei.DepinBot.core.commandMenu.CommandMenuNode;
import cn.com.helei.DepinBot.core.commandMenu.DefaultMenuType;
import cn.com.helei.DepinBot.core.dto.RewordInfo;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.dto.account.ConnectStatusInfo;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import cn.com.helei.DepinBot.core.util.ClosableTimerTask;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

@Slf4j
public class KeitokunWSDepinBot extends WSMenuCMDLineDepinBot<KeitokunConfig, JSONObject, JSONObject> {

    private final static Map<BaseDepinWSClient<JSONObject,JSONObject>, Integer> requestIdMap = new ConcurrentHashMap<>();

    private final Random random = new Random();

    public KeitokunWSDepinBot(KeitokunConfig config) {
        super(config);
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        super.doInit();

        // 将tokens加载到对应的accountContext
        List<AccountContext> accounts = getAccounts();

        List<String> uids = getBotConfig().getUids();
        if (uids == null) return;

        for (int i = 0; i < uids.size(); i++) {
            if (i < accounts.size()) {
                accounts.get(i).setParam("uid", uids.get(i));
            }
        }
    }

    @Override
    public BaseDepinWSClient<JSONObject, JSONObject> buildAccountWSClient(AccountContext accountContext) {
        accountContext.setConnectUrl(getBotConfig().getWsBaseUrl() + "?uid=" + accountContext.getParam("uid"));
        SimpleDepinWSClient simpleDepinWSClient = new SimpleDepinWSClient(this, accountContext);

        requestIdMap.put(simpleDepinWSClient, 0);
        simpleDepinWSClient.setAllIdleTimeSecond(getBotConfig().getAutoClaimIntervalSeconds() * 2);
        return simpleDepinWSClient;
    }

    @Override
    public void whenAccountClientStatusChange(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, WebsocketClientStatus clientStatus) {
        AccountContext accountContext = depinWSClient.getAccountContext();
        switch (clientStatus) {
            case RUNNING -> {
                log.info("账户[{}]-uid[{}] 连接ws服务器[{}]成功", accountContext.getName(), accountContext.getParam("uid"), accountContext.getConnectUrl());
                // 随机时间发送心跳
                addTimer(new ClosableTimerTask() {
                    @Override
                    public boolean run() {
                        try {
                            TimeUnit.SECONDS.sleep(random.nextInt(10));

                            // 发送心跳
                            accountContext.getConnectStatusInfo().getHeartBeat().getAndIncrement();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }

                        // 继续运行
                        return true;
                    }
                }, getBotConfig().getAutoClaimIntervalSeconds() + random.nextInt(60), TimeUnit.SECONDS);
            }
            case STOP -> {
                log.info("账户[{}]-uid[{}] 连接到ws服务器[{}]失败", accountContext.getName(), accountContext.getParam("uid"),
                        accountContext.getConnectUrl());

                accountContext.getConnectStatusInfo().getRestart().incrementAndGet();
            }
            case SHUTDOWN -> {
                log.info("账户[{}]-uid[{}] ws连接已断开", accountContext.getName(), accountContext.getParam("uid"));
                requestIdMap.remove(depinWSClient);
            }
        }
    }

    @Override
    public void whenAccountReceiveResponse(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, Object id, JSONObject response) {
        Integer cmd = response.getInteger("cmd");
        JSONObject data = response.getJSONObject("data");

        AccountContext accountContext = depinWSClient.getAccountContext();
        ConnectStatusInfo connectStatusInfo = accountContext.getConnectStatusInfo();

        switch (cmd) {
            case 1001:
                Integer totalNum = data.getInteger("totalNum");
                Integer collectNum = data.getInteger("collectNum");
                log.info("[{}]收到响应,[{}/{}]", accountContext.getParam("uid"),
                        collectNum, totalNum);

                RewordInfo rewordInfo = accountContext.getRewordInfo();
                rewordInfo.setTotalPoints(data.getDouble("keitoAmount"));
                rewordInfo.setTodayPoints(Double.valueOf(collectNum));

                connectStatusInfo.getHeartBeat().incrementAndGet();

                // 今日的领完了, 关闭
                if (totalNum != null && totalNum.equals(collectNum)) {
                    log.info("账户[{}]今日keitokun点击已完成，断开ws连接", accountContext.getParam("uid"));
                    depinWSClient.shutdown();
                }
                break;
            default:
                connectStatusInfo.getErrorHeartBeat().incrementAndGet();
        }

        connectStatusInfo.setUpdateDateTime(LocalDateTime.now());
    }

    @Override
    public void whenAccountReceiveMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, JSONObject message) {

    }

    @Override
    public JSONObject getHeartbeatMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient) {
        JSONObject frame = new JSONObject();
        frame.put("cmd", 1001);
        frame.put("id", requestIdMap.compute(depinWSClient, (k, v) -> v == null ? 1 : v + 1));
        frame.put("uid", depinWSClient.getAccountContext().getParam("uid"));

        JSONObject data = new JSONObject();
        int randomClickTimes = getRandomClickTimes();
        data.put("amount", randomClickTimes);
        data.put("collectNum", randomClickTimes);
        data.put("timestamp", System.currentTimeMillis());
        frame.put("data", data);

        return frame;
    }


    @Override
    protected void addCustomMenuNode(List<DefaultMenuType> defaultMenuTypes, CommandMenuNode mainMenu) {
        defaultMenuTypes.add(DefaultMenuType.START_ACCOUNT_CLAIM);
    }

    @Override
    protected CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode) {
        return null;
    }

    @Override
    protected CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext) {
        return null;
    }

    private int getRandomClickTimes() {
        return random.nextInt(5) + 1;
    }
}

package cn.com.helei.DepinBot.app.layeredge;

import cn.com.helei.DepinBot.core.bot.DefaultMenuCMDLineDepinBot;
import cn.com.helei.DepinBot.core.commandMenu.CommandMenuNode;
import cn.com.helei.DepinBot.core.commandMenu.DefaultMenuType;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class LayeredgeDepinBot extends DefaultMenuCMDLineDepinBot<LayeredgeConfig> {

    public LayeredgeDepinBot(LayeredgeConfig botConfig) {
        super(botConfig);
    }

    @Override
    protected void addCustomMenuNode(List<DefaultMenuType> defaultMenuTypes, CommandMenuNode mainMenu) {

        defaultMenuTypes.add(DefaultMenuType.START_ACCOUNT_CLAIM);
        mainMenu.addSubMenu(
                new CommandMenuNode("每日签到", "正在开始每日签到", this::dailySignIn)
        );
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        super.doInit();

        // 将tokens加载到对应的accountContext
        List<AccountContext> accounts = getAccounts();

        List<String> publicKeys = getBotConfig().getPublicKeys();
        if (publicKeys == null) return;

        for (int i = 0; i < publicKeys.size(); i++) {
            if (i < accounts.size()) {
                accounts.get(i).setParam("publicKey", publicKeys.get(i));
            }
        }
    }

    @Override
    protected CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode) {
        return null;
    }

    @Override
    protected CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext) {
        return null;
    }

    @Override
    protected boolean doAccountClaim(AccountContext accountContext) {
        String url = "https://referral.layeredge.io/api/light-node/node-status/";
        NetworkProxy proxy = accountContext.getProxy();
        Map<String, String> headers = getHeaders(accountContext);

        String address = accountContext.getParam("publicKey");

        String pintStr = String.format("id[%s]-账户[%s]-address[%s]-proxy[%s/%d]",
                accountContext.getClientAccount().getId(), accountContext.getName(), address, proxy.getAddress(), proxy.getPort()
        );

        syncRequest(
                proxy,
                url + address,
                "get",
                headers,
                null,
                null,
                () -> {
                    accountContext.getConnectStatusInfo().getHeartBeat().incrementAndGet();
                    return pintStr + " ping服务器";
                })
                .thenAcceptAsync(responseStr -> {
                    log.info("{} ping服务器成功, {}", pintStr, responseStr);

                    accountContext.getConnectStatusInfo().setUpdateDateTime(LocalDateTime.now());

                }, getExecutorService())
                .exceptionally(throwable -> {
                    log.error("{} ping服务器成失败, {}", pintStr, throwable.getMessage());
                    accountContext.getConnectStatusInfo().getErrorHeartBeat().incrementAndGet();
                    return null;
                });

        return true;
    }

    @Override
    protected CompletableFuture<Boolean> updateAccountRewordInfo(AccountContext accountContext) {
        String url = "https://referral.layeredge.io/api/referral/wallet-details/";
        NetworkProxy proxy = accountContext.getProxy();
        Map<String, String> headers = getHeaders(accountContext);

        String address = accountContext.getParam("publicKey");

        String pintStr = String.format("id[%s]-账户[%s]-address[%s]-proxy[%s/%d]",
                accountContext.getClientAccount().getId(), accountContext.getName(), address, proxy.getAddress(), proxy.getPort()
        );

        return syncRequest(
                proxy,
                url + address,
                "get",
                headers,
                null,
                null,
                () -> pintStr + " 查询奖励"
        )
                .thenApplyAsync(responseStr -> {
                    log.info("{} 查询奖励成功, {}", pintStr, responseStr);
                    return true;
                }, getExecutorService())
                .exceptionally(throwable -> {
                    log.error("{} 查询奖励失败,", pintStr, throwable);
                    return false;
                });
    }

    private String dailySignIn() {
        getAccounts().forEach(accountContext -> {
            if (accountContext.getClientAccount().getId() != 0) return;
            String url = "https://dashboard.layeredge.io/api/claim-points";

            NetworkProxy proxy = accountContext.getProxy();
            Map<String, String> headers = getHeaders(accountContext);

            JSONObject body = new JSONObject();
            String address = accountContext.getParam("publicKey");
            body.put("walletAddress", address);

            String pintStr = String.format("id[%s]-账户[%s]-address[%s]-proxy[%s/%d]",
                    accountContext.getClientAccount().getId(), accountContext.getName(), address, proxy.getAddress(), proxy.getPort()
            );

            syncRequest(
                    proxy,
                    url,
                    "post",
                    headers,
                    null,
                    body,
                    () -> pintStr
            )
                    .thenAcceptAsync(responseStr -> {
                        log.info("{} 每日奖励领取成功, {}", pintStr, responseStr);
                    }, getExecutorService())
                    .exceptionally(throwable -> {
                        log.error("{} 每日奖励领取失败,", pintStr, throwable);
                        return null;
                    });
        });

        return "已开始领取每日奖励";
    }

    private static Map<String, String> getHeaders(AccountContext accountContext) {
        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
        headers.put("origin", "https://dashboard.layeredge.io");
        headers.put("referer", "https://dashboard.layeredge.io/");
        return headers;
    }
}
package cn.com.helei.DepinBot.app.oasis;

import cn.com.helei.DepinBot.core.WSDepinBotConfig;
import cn.com.helei.DepinBot.core.config.SystemConfig;
import cn.com.helei.DepinBot.core.util.YamlConfigLoadUtil;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;

import java.util.List;

@EqualsAndHashCode(callSuper = true)
@Slf4j
@Data
public class OasisBotConfig extends WSDepinBotConfig {

    private String inviteCode;

    public static void main(String[] args) {
        System.out.println(loadYamlConfig("app/oasis.yaml"));
    }

    public static OasisBotConfig loadYamlConfig(String classpath) {
        return YamlConfigLoadUtil.load(SystemConfig.CONFIG_DIR_APP_PATH, classpath, List.of("depin", "app", "oasis"), OasisBotConfig.class);
    }
}
package cn.com.helei.DepinBot.app.oasis;

import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.SimpleDepinWSClient;
import cn.com.helei.DepinBot.core.bot.WSMenuCMDLineDepinBot;
import cn.com.helei.DepinBot.core.commandMenu.CommandMenuNode;
import cn.com.helei.DepinBot.core.commandMenu.DefaultMenuType;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import cn.com.helei.DepinBot.core.util.SystemInfo;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
public class OasisDepinBot extends WSMenuCMDLineDepinBot<OasisBotConfig, JSONObject, JSONObject> {


    private final OasisApi oasisApi;

    public OasisDepinBot(String oasisBotConfigPath) {
        super(OasisBotConfig.loadYamlConfig(oasisBotConfigPath));
        this.oasisApi = new OasisApi(this);
    }

    @Override
    protected void addCustomMenuNode(List<DefaultMenuType> defaultMenuTypes, CommandMenuNode mainMenu) {
        defaultMenuTypes.add(DefaultMenuType.START_ACCOUNT_CLAIM);

        CommandMenuNode resendCode = new CommandMenuNode(true, "重发验证邮件",
                "开始重发验证邮件", this::resendCode);
        mainMenu.addSubMenu(resendCode);
    }

    @Override
    protected CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode) {
        return oasisApi.registerUser(accountContext, inviteCode);
    }

    @Override
    protected CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext) {
        return oasisApi
                .loginUser(accountContext);
    }


    @Override
    public BaseDepinWSClient<JSONObject, JSONObject> buildAccountWSClient(AccountContext accountContext) {
        String token = accountContext.getParam("token");
        if (token == null) {
            throw new IllegalArgumentException("token不能为空");
        }

        accountContext.setConnectUrl(getBotConfig().getWsBaseUrl() + " ?token=" + token);

        SimpleDepinWSClient simpleDepinWSClient = new SimpleDepinWSClient(this, accountContext);
        simpleDepinWSClient.setAllIdleTimeSecond((int) getBotConfig().getAutoClaimIntervalSeconds());

        return simpleDepinWSClient;
    }


    @Override
    public void whenAccountClientStatusChange(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, WebsocketClientStatus clientStatus) {

        switch (clientStatus) {
            case RUNNING -> {
                //Step 1 发送机器信息
                depinWSClient.sendMessage(generateRandomSystemData());

                //Step 2 主动发一次心跳
                depinWSClient.sendMessage(getHeartbeatMessage(depinWSClient));
            }
        }
    }

    @Override
    public void whenAccountReceiveResponse(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, Object id, JSONObject response) {

    }


    @Override
    public void whenAccountReceiveMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, JSONObject message) {
        String accountName = depinWSClient.getAccountContext().getClientAccount().getName();
        log.debug("账户[{}]收到消息[{}]", accountName, message);

        switch (message.getString("type")) {
            case "serverMetrics" -> {
                log.info("账户[{}]心跳已发送, token[{}]-总运行时间[{}]秒-总积分[{}]",
                        accountName,
                        message.getString("token"),
                        message.getString("totalUptime"),
                        message.getString("creditsEarned")
                );
            }
            case "acknowledged" -> {
                log.warn("系统更新:[{}]", message);
            }
            case "error" -> {
                if (message.getJSONObject("data").getString("code").equals("invalid_token")) {
                    log.warn("账户[{}]需要发送机器信息", accountName);
                    depinWSClient.sendMessage(generateRandomSystemData());
                }
            }
            default -> {
                log.warn("账户[{}]收到未知消息[{}]", accountName, message);
            }
        }
    }

    @Override
    public JSONObject getHeartbeatMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient) {
        log.info("账户[{}]发送心跳", depinWSClient.getAccountContext().getClientAccount().getName());

        // 定时发送心跳
        JSONObject pingFrame = new JSONObject();
        pingFrame.put("id", SystemInfo.INSTANCE.getRandomId(26));
        pingFrame.put("type", "heartbeat");

        JSONObject data = new JSONObject();
        data.put("version", "0.1.7");
        data.put("mostRecentModel", "unknown");
        data.put("status", "active");

        pingFrame.put("data", data);

        return pingFrame;
    }

    /**
     * 重发验证邮件
     *
     * @return 打印的字符串
     */
    private String resendCode() {
        List<CompletableFuture<Void>> futures = getAccounts().stream().map(accountContext -> {
            String email = accountContext.getClientAccount().getEmail();

            return oasisApi
                    .resendCode(accountContext)
                    .thenAccept(success -> {
                        if (success) {
                            log.info("重发邮件[{}]成功", email);
                        }
                    }).exceptionally(throwable -> {
                        log.error("邮箱[{}]重发验证邮件失败, {}", email, throwable.getMessage());
                        return null;
                    });
        }).toList();

        try {
            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();
        } catch (InterruptedException | ExecutionException e) {
            return "等待token获取完成发生错误，" + e.getMessage();
        }

        return "token获取完成，共:" + getAccounts().size() + "个账户";
    }

    /**
     * 创建随机的系统数据
     *
     * @return JSONObject
     */
    private static @NotNull JSONObject generateRandomSystemData() {
        JSONObject systemData = new JSONObject();

        systemData.put("id", SystemInfo.INSTANCE.getRandomId(26));
        systemData.put("type", "system");

        JSONObject data = new JSONObject();
        data.put("gpuInfo", SystemInfo.INSTANCE.generateRandomGpuInfo());
        data.put("cpuInfo", SystemInfo.INSTANCE.generateRandomCpuInfo());
        data.put("memoryInfo", SystemInfo.INSTANCE.generateRandomMemoryInfo());
        data.put("machineId", SystemInfo.INSTANCE.getRandomId(32).toLowerCase());
        data.put("operatingSystem", SystemInfo.INSTANCE.generateRandomOperatingSystem());

        systemData.put("data", data);
        return systemData;
    }
}
package cn.com.helei.DepinBot.app.openLedger;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j
@ToString
public class OpenLedgerConfig extends BaseDepinBotConfig {


    /**
     * 浏览器标识
     */
    private String origin;

    /**
     * 账户列表
     */
    private List<OpenLedgerAccount> openLedgerAccounts;


    public static void main(String[] args) {
        OpenLedgerConfig openLedgerConfig = loadYamlConfig("app/openledger.yaml");
        System.out.println(openLedgerConfig);
    }

    public static OpenLedgerConfig loadYamlConfig(String classpath) {
        Yaml yaml = new Yaml();
        log.info("开始加载OpenLedger配置信息-file classpath:[{}}", classpath);
        try (InputStream inputStream = OpenLedgerConfig.class.getClassLoader().getResourceAsStream(classpath)) {
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
            Map<String, Object> openledger = (Map<String, Object>) depin.get("openledger");

            //Step 1 基础配置文件
            OpenLedgerConfig openLedgerConfig = yaml.loadAs(yaml.dump(openledger), OpenLedgerConfig.class);

            //Step 4 账户列表完善
            openLedgerConfig.getOpenLedgerAccounts().forEach(openLedgerAccount -> {
                openLedgerAccount.setOpenLedgerConfig(openLedgerConfig);
            });

            log.info("OpenLedger配置信息加载完毕: 共{}个账号", openLedgerConfig.getOpenLedgerAccounts().size());

            return openLedgerConfig;
        } catch (IOException e) {
            throw new RuntimeException(String.format("价值配置网络代理池文件[%s]发生错误", classpath));
        }
    }



    @EqualsAndHashCode(callSuper = true)
    @Data
    public static class OpenLedgerAccount extends DepinClientAccount {

        private final static String printTemplate = "%-25s\t%-25s\t%-5s";

        private transient OpenLedgerConfig openLedgerConfig;

        private String token;

        private String identity;

        private String ownerAddress;


        public static String printTittle() {
            return String.format(printTemplate, "账户名", "代理", "环境ID");
        }

        @Override
        public HashMap<String, String> getWSHeaders() {
            HashMap<String, String> headers = new HashMap<>();

            headers.put("Upgrade", "websocket");
            headers.put("Origin", openLedgerConfig.origin);
            headers.put("Host", "apitn.openledger.xyz");
            headers.put("Connection", "Upgrade");

            return headers;
        }

        @Override
        public  HashMap<String, String>  getRestHeaders() {
            HashMap<String, String> headers = new HashMap<>();

            headers.put("authorization", "Bearer " + token);

            return headers;
        }

        @Override
        public String toString() {
            return "OpenLedgerAccount{" +
                    "token='" + token + '\'' +
                    ", identity='" + identity + '\'' +
                    ", ownerAddress='" + ownerAddress + '\'' +
                    "} " + super.toString();
        }
    }
}
package cn.com.helei.DepinBot.app.teneo;

import cn.com.helei.DepinBot.core.WSDepinBotConfig;

public class TeneoDepinConfig extends WSDepinBotConfig {
}
package cn.com.helei.DepinBot.app.teneo;

import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.SimpleDepinWSClient;
import cn.com.helei.DepinBot.core.bot.WSMenuCMDLineDepinBot;
import cn.com.helei.DepinBot.core.commandMenu.CommandMenuNode;
import cn.com.helei.DepinBot.core.commandMenu.DefaultMenuType;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.dto.account.ConnectStatusInfo;
import cn.com.helei.DepinBot.core.exception.LoginException;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class TeneoWSDepinBot extends WSMenuCMDLineDepinBot<TeneoDepinConfig, JSONObject, JSONObject> {


    public TeneoWSDepinBot(TeneoDepinConfig config) {
        super(config);
    }

    @Override
    public BaseDepinWSClient<JSONObject, JSONObject> buildAccountWSClient(AccountContext accountContext) {
        accountContext.setConnectUrl("wss://secure.ws.teneo.pro/websocket?accessToken="
                + accountContext.getParam("token") + "&version=v0.2");

        SimpleDepinWSClient simpleDepinWSClient = new SimpleDepinWSClient(this, accountContext);

        DefaultHttpHeaders headers = new DefaultHttpHeaders();
        Map<String, String> originHeaders = accountContext.getBrowserEnv().getHeaders();
        originHeaders.forEach(headers::add);

        headers.add("Host", "secure.ws.teneo.pro");
        headers.add("Origin", "chrome-extension://emcclcoaglgcpoognfiggmhnhgabppkm");
        headers.add("Upgrade", "websocket");

        simpleDepinWSClient.setHeaders(headers);

        return simpleDepinWSClient;
    }

    @Override
    public void whenAccountClientStatusChange(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, WebsocketClientStatus clientStatus) {

        final AccountContext accountContext = depinWSClient.getAccountContext();

        switch (clientStatus) {
            case STARTING -> {
                log.info("账户[{}]-proxy[{}] 开始到ws服务器[{}]",
                        accountContext.getName(), accountContext.getProxy().getAddressStr(), accountContext.getConnectUrl());
            }
            case RUNNING -> {
                log.info("账户[{}]-proxy[{}]已连接到ws服务器",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());
            }
            case STOP -> {
                log.warn("账户[{}]-proxy[{}]已断开连接",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());
                accountContext.getConnectStatusInfo().getRestart().incrementAndGet();
            }
            case SHUTDOWN ->{
                log.warn("账户[{}]-proxy[{}] 工作已停止",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());
            }
        }
    }

    @Override
    public void whenAccountReceiveResponse(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, Object id, JSONObject response) {

    }

    @Override
    public void whenAccountReceiveMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient, JSONObject message) {
        String type = message.getString("message");
        AccountContext accountContext = depinWSClient.getAccountContext();

        if ("Connected successfully".equals(type)) {
            Double pointsToday = message.getDouble("pointsToday");
            Double pointsTotal = message.getDouble("pointsTotal");

            accountContext.getRewordInfo().setTodayPoints(pointsToday);
            accountContext.getRewordInfo().setTotalPoints(pointsTotal);

            log.info("账户[{}]-proxy[{}] 连接成功. 今日积分: {}, 总积分: {}",
                    accountContext.getName(), accountContext.getProxy().getAddressStr(),
                    pointsToday, pointsTotal);

        } else if ("Pulse from server".equals(type)) {
            Double pointsToday = message.getDouble("pointsToday");
            Double pointsTotal = message.getDouble("pointsTotal");

            accountContext.getRewordInfo().setTodayPoints(pointsToday);
            accountContext.getRewordInfo().setTotalPoints(pointsTotal);

            int heartbeatToday = message.getInteger("heartbeats");

            //减去提前加上的错误心跳数
            accountContext.getConnectStatusInfo().getErrorHeartBeat().decrementAndGet();
            log.debug("账户[{}]-proxy[{}] 心跳发送成功. 今日心跳: {}",
                    accountContext.getName(), accountContext.getProxy().getAddressStr(),
                    heartbeatToday);
        }
    }

    @Override
    public JSONObject getHeartbeatMessage(BaseDepinWSClient<JSONObject, JSONObject> depinWSClient) {
        ConnectStatusInfo connectStatusInfo = depinWSClient.getAccountContext().getConnectStatusInfo();
        connectStatusInfo.getHeartBeat().incrementAndGet();

        // 错误心跳数提前加上
        connectStatusInfo.getErrorHeartBeat().incrementAndGet();

        JSONObject ping = new JSONObject();
        ping.put("type", "ping");
        return ping;
    }

    @Override
    protected void addCustomMenuNode(List<DefaultMenuType> defaultMenuTypes, CommandMenuNode mainMenu) {
        defaultMenuTypes.add(DefaultMenuType.LOGIN);
        defaultMenuTypes.add(DefaultMenuType.START_ACCOUNT_CLAIM);
    }

    @Override
    protected CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode) {
        return null;
    }

    @Override
    protected CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext) {
        String url = "https://auth.teneo.pro/api/login";

        NetworkProxy proxy = accountContext.getProxy();

        JSONObject body = new JSONObject();
        body.put("email", accountContext.getClientAccount().getEmail());
        body.put("password", accountContext.getClientAccount().getPassword());

        String printStr = String.format("账户[%s]-proxy[%s:{%d]",
                accountContext.getClientAccount().getEmail(), proxy.getHost(), proxy.getPort());

        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();

        return syncRequest(
                proxy,
                url,
                "post",
                headers,
                null,
                body,
                () -> printStr
        ).thenApplyAsync(responseStr -> {
            JSONObject response = JSONObject.parseObject(responseStr);
            if (response != null && responseStr.contains("access_token")) {
                return response.getString("access_token");
            } else {
                throw new LoginException(printStr + " 登录获取token失败, response: " + responseStr);
            }
        });
    }
}
package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.constants.DepinBotStatus;
import cn.com.helei.DepinBot.core.pool.account.AccountPool;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnvPool;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.exception.DepinBotStartException;
import cn.com.helei.DepinBot.core.exception.DepinBotStatusException;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxyPool;
import cn.com.helei.DepinBot.core.util.ClosableTimerTask;
import cn.com.helei.DepinBot.core.util.NamedThreadFactory;
import cn.com.helei.DepinBot.core.util.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

@Slf4j
@Getter
public abstract class AbstractDepinBot {
    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 代理池
     */
    private final NetworkProxyPool proxyPool;

    /**
     * 浏览器环境池
     */
    private final BrowserEnvPool browserEnvPool;

    /**
     * 账户池
     */
    private final AccountPool accountPool;

    /**
     * 配置
     */
    private final BaseDepinBotConfig baseDepinBotConfig;

    /**
     * 状态
     */
    private DepinBotStatus status = DepinBotStatus.NEW;

    /**
     * 代理并发控制
     */
    private final Map<NetworkProxy, Semaphore> networkSyncControllerMap;

    /**
     * task 任务并发控制
     */
    private final Semaphore taskSyncController;

    public AbstractDepinBot(BaseDepinBotConfig baseDepinBotConfig) {
        if (StrUtil.isBlank(baseDepinBotConfig.getName())) throw new IllegalArgumentException("bot 名字不能为空");

        this.baseDepinBotConfig = baseDepinBotConfig;
        this.executorService = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(baseDepinBotConfig.getName() + "-executor"));

        this.proxyPool = NetworkProxyPool.loadYamlPool(
                baseDepinBotConfig.getNetworkPoolConfig(),
                "bot.network.proxy",
                NetworkProxyPool.class
        );
        this.browserEnvPool = BrowserEnvPool.loadYamlPool(
                baseDepinBotConfig.getBrowserEnvPoolConfig(),
                "bot.browser",
                BrowserEnvPool.class
        );
        this.accountPool = AccountPool.loadYamlPool(
                baseDepinBotConfig.getAccountPoolConfig(),
                "bot.account",
                AccountPool.class
        );

        networkSyncControllerMap = new ConcurrentHashMap<>();
        taskSyncController = new Semaphore(baseDepinBotConfig.getConcurrentCount());
    }

    public void init() {
        updateState(DepinBotStatus.INIT);
        try {
            doInit();

            //更新状态
            updateState(DepinBotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化DepinBot[{}}发生错误", getBaseDepinBotConfig().getName(), e);
            updateState(DepinBotStatus.INIT_ERROR);
        }
    }

    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;

    /**
     * 机器人运行方法
     *
     * @throws IOException IOException
     */
    protected abstract void doExecute() throws IOException;

    /**
     * 启动bot
     *
     * @throws DepinBotStartException DepinBotStartException
     */
    public void start() throws DepinBotStartException {
        updateState(DepinBotStatus.STARTING);
        log.info("正在启动Depin Bot");
        try {
            CountDownLatch startLatch = new CountDownLatch(1);
            //启动命令行交互的线程
            asyncExecute(startLatch);

            log.info("Depin Bot启动完毕");

            updateState(DepinBotStatus.RUNNING);
            startLatch.await();

        } catch (Exception e) {
            updateState(DepinBotStatus.SHUTDOWN);
            throw new DepinBotStartException("启动CommandLineDepinBot发生错误", e);
        }
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            NetworkProxy proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            NetworkProxy proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {

        Semaphore networkController = networkSyncControllerMap.compute(proxy, (k, v) -> {
            if (v == null) {
                v = new Semaphore(baseDepinBotConfig.getConcurrentCount());
            }
            return v;
        });


        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "开始";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                log.info("同步器允许发送请求-{}", str);

                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 添加定时任务,closableTimerTask执行run方法放回true会继续执行， 返回false则会跳出循环
     *
     * @param closableTimerTask closableTimerTask
     * @param delay    delay
     * @param timeUnit timeUnit
     */
    public void addTimer(ClosableTimerTask closableTimerTask, long delay, TimeUnit timeUnit) {

        executorService.execute(() -> {
            while (true) {
                try {
                    taskSyncController.acquire();

                    if (closableTimerTask.isRunning()) {
                        closableTimerTask.setRunning(closableTimerTask.run());
                    }

                    if (!closableTimerTask.isRunning()) {
                        break;
                    }

                    timeUnit.sleep(delay);
                } catch (Exception e) {
                    log.error("定时任务执行失败", e);
                    break;
                } finally {
                    taskSyncController.release();
                }
            }
        });
    }

    /**
     * 异步启动
     */
    private void asyncExecute(CountDownLatch startLatch) {
        Thread commandInputThread = new Thread(() -> {
            try {
                doExecute();
            } catch (IOException e) {
                log.error("启动bot发生错误", e);
            } finally {
                startLatch.countDown();
            }
        }, "depin-bot-main");
        commandInputThread.setDaemon(true);
        commandInputThread.start();
    }


    /**
     * 更新DepinBotStatus
     *
     * @param newStatus 新状态
     */
    private synchronized void updateState(DepinBotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(DepinBotStatus.SHUTDOWN)) {
            status = DepinBotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> DepinBotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(DepinBotStatus.INIT_FINISH)
                        || newStatus.equals(DepinBotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(DepinBotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(DepinBotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(DepinBotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }
}
package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.dto.account.AccountPrintDto;
import cn.com.helei.DepinBot.core.dto.RewordInfo;
import cn.com.helei.DepinBot.core.dto.account.ConnectStatusInfo;
import cn.com.helei.DepinBot.core.exception.DepinBotStartException;
import cn.com.helei.DepinBot.core.exception.RewardQueryException;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnv;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.supporter.persistence.AccountPersistenceManager;
import cn.com.helei.DepinBot.core.util.table.CommandLineTablePrintHelper;
import cn.hutool.core.util.BooleanUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;

@Slf4j
public abstract class AccountAutoManageDepinBot extends AbstractDepinBot {

    /**
     * 持久化管理器
     */
    private final AccountPersistenceManager persistenceManager;

    /**
     * 账号列表
     */
    @Getter
    private final List<AccountContext> accounts = new ArrayList<>();

    /**
     * 是否允许账户收益查询
     */
    private final AtomicBoolean isRunningAccountRewardQuery = new AtomicBoolean(true);


    public AccountAutoManageDepinBot(BaseDepinBotConfig baseDepinBotConfig) {
        super(baseDepinBotConfig);

        this.persistenceManager = new AccountPersistenceManager(baseDepinBotConfig.getName());
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        // Step 1 初始化保存的线程
        persistenceManager.init();

        // Step 2 初始化账户
        initAccounts();
    }


    @Override
    public void start() throws DepinBotStartException {
        super.start();

        // 启动奖励查询任务
        if (BooleanUtil.isTrue(getBaseDepinBotConfig().getIsAccountRewardAutoRefresh())) {
            startAccountRewardQueryTask();
        }
    }

    /**
     * 开启账户奖励查询任务
     */
    private void startAccountRewardQueryTask() {
        getExecutorService().execute(() -> {
            while (isRunningAccountRewardQuery.get()) {
                List<AccountContext> accounts = getAccounts();

                List<CompletableFuture<Boolean>> futures = accounts.stream().map(accountContext -> {
                    try {
                        return updateAccountRewordInfo(accountContext);
                    } catch (Exception e) {
                        throw new RewardQueryException(e);
                    }
                }).toList();

                for (int i = 0; i < futures.size(); i++) {
                    try {
                        futures.get(i).get();
                    } catch (InterruptedException | ExecutionException e) {
                        log.error("查询账户[" + accounts.get(i).getName() + "]奖励失败", e.getMessage());
                    }
                }
                try {
                    TimeUnit.SECONDS.sleep(getBaseDepinBotConfig().getAccountRewardRefreshIntervalSeconds());
                } catch (InterruptedException e) {
                    log.error("等待执行账户查询时发生异常", e);
                }
            }
        });
    }


    /**
     * 更新账户奖励信息
     *
     * @param accountContext accountContext
     * @return CompletableFuture<Boolean>
     */
    protected abstract CompletableFuture<Boolean> updateAccountRewordInfo(AccountContext accountContext);


    /**
     * 初始化账号方法
     */
    private void initAccounts() throws DepinBotInitException {
        try {
            // Step 1 获取持久化的
            Map<Integer, AccountContext> accountContextMap = persistenceManager.loadAccountContexts();

            // Step 2 没有保存的数据，加载新的
            List<AccountContext> accountContexts;
            if (accountContextMap == null || accountContextMap.isEmpty()) {
                log.info("bot[{}]加载新账户数据", getBaseDepinBotConfig().getName());
                // Step 2.1 加载新的
                accountContexts = loadNewAccountContexts();

                // Step 2.2 持久化
                persistenceManager.persistenceAccountContexts(accountContexts);
            } else {
                log.info("bot[{}]使用历史账户数据", getBaseDepinBotConfig().getName());
                accountContexts = new ArrayList<>(accountContextMap.values());
            }

            // Step 3 加载到bot
            registerAccountsInBot(accountContexts,
                    accountContext ->  AccountPersistenceManager.getAccountContextPersistencePath(getBaseDepinBotConfig().getName(), accountContext));

            accounts.addAll(accountContexts);
        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }

    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts, Function<AccountContext, String> getSavePath) {
        persistenceManager.registerPersistenceListener(accountContexts, getSavePath);
    }


    /**
     * 加载新的账户上下文列表，从配置文件中
     *
     * @return List<AccountContext>
     */
    private List<AccountContext> loadNewAccountContexts() {
        // Step 1 初始化账号

        List<AccountContext> newAccountContexts = new ArrayList<>();

        List<AccountContext> noProxyIds = new ArrayList<>();
        List<AccountContext> noBrowserEnvIds = new ArrayList<>();

        getAccountPool()
                .getAllItem()
                .forEach(depinClientAccount -> {
                    AccountContext accountContext = AccountContext.builder()
                            .clientAccount(depinClientAccount).build();

                    Integer id = depinClientAccount.getId();

                    // 账号没有配置代
                    if (depinClientAccount.getProxyId() == null) {
                        noProxyIds.add(accountContext);
                    } else {
                        accountContext.setProxy(getProxyPool().getItem(depinClientAccount.getProxyId()));
                    }

                    // 账号没有配置浏览器环境
                    if (depinClientAccount.getBrowserEnvId() == null) {
                        noBrowserEnvIds.add(accountContext);
                    } else {
                        accountContext.setBrowserEnv(getBrowserEnvPool().getItem(depinClientAccount.getBrowserEnvId()));
                    }

                    newAccountContexts.add(accountContext);
                });

        // Step 2 账号没代理的尝试给他设置代理
        if (!noProxyIds.isEmpty()) {
            log.warn("以下账号没有配置代理，将随机选择一个代理进行使用");
            List<NetworkProxy> lessUsedProxy = getProxyPool().getLessUsedItem(noProxyIds.size());
            for (int i = 0; i < noProxyIds.size(); i++) {
                AccountContext accountContext = noProxyIds.get(i);

                NetworkProxy proxy = lessUsedProxy.get(i);
                accountContext.setProxy(proxy);

                log.warn("账号:{},将使用代理:{}", accountContext.getName(), proxy);
            }
        }

        // Step 3 账号没浏览器环境的尝试给他设置浏览器环境
        if (!noBrowserEnvIds.isEmpty()) {
            log.warn("以下账号没有配置浏览器环境，将随机选择一个浏览器环境使用");
            List<BrowserEnv> lessUsedBrowserEnv = getBrowserEnvPool().getLessUsedItem(noBrowserEnvIds.size());
            for (int i = 0; i < noBrowserEnvIds.size(); i++) {
                AccountContext accountContext = noBrowserEnvIds.get(i);

                BrowserEnv browserEnv = lessUsedBrowserEnv.get(i);
                accountContext.setBrowserEnv(browserEnv);

                log.warn("账号:{},将使用浏览器环境:{}", accountContext.getName(), browserEnv);
            }
        }

        return newAccountContexts;
    }


//    {
//        return CompletableFuture.runAsync(() -> {
//            //Step 1 遍历账户
//            List<CompletableFuture<Void>> connectFutures = accounts.stream()
//                    .map(accountContext -> {
//                        // Step 2 根据账户获取ws client
//                        BaseDepinWSClient<Req, Resp> depinWSClient = accountWSClientMap.compute(accountContext, (k, v) -> {
//                            // 没有创建过，或被关闭，创建新的
//                            if (v == null || v.getClientStatus().equals(WebsocketClientStatus.SHUTDOWN)) {
//                                v = buildAccountWSClient(accountContext);
//                            }
//
//                            return v;
//                        });
//
//                        String accountName = accountContext.getClientAccount().getName();
//
//                        //Step 3 建立连接
//                        WebsocketClientStatus clientStatus = depinWSClient.getClientStatus();
//                        return switch (clientStatus) {
//                            case NEW, STOP:  // 新创建，停止状态，需要建立连接
//                                yield depinWSClient
//                                        .connect()
//                                        .thenAcceptAsync(success -> {
//                                            try {
//                                                whenAccountConnected(depinWSClient, success);
//                                            } catch (Exception e) {
//                                                log.error("账户[{}]-连接完成后执行回调发生错误", accountName, e);
//                                            }
//                                        }, executorService)
//                                        .exceptionallyAsync(throwable -> {
//                                            log.error("账户[{}]连接失败, ", accountName,
//                                                    throwable);
//                                            return null;
//                                        }, executorService);
//                            case STARTING, RUNNING: // 正在建立连接，直接返回
//                                CompletableFuture.completedFuture(null);
//                            case SHUTDOWN: // 被禁止使用，抛出异常
//                                throw new DepinBotStatusException("cannot start ws client when it shutdown, " + accountName);
//                        };
//                    })
//                    .toList();
//
//            //Step 4 等所有账户连接建立完成
//            try {
//                CompletableFuture
//                        .allOf(connectFutures.toArray(new CompletableFuture[0]))
//                        .get();
//            } catch (InterruptedException | ExecutionException e) {
//                log.error("账户建立连接发生异常", e);
//            }
//        }, executorService);
//    }


    /**
     * 打印账号列表
     *
     * @return String
     */
    public String printAccountList() {
        List<AccountPrintDto> list = accounts.stream().map(accountContext -> {
            NetworkProxy proxy = accountContext.getProxy();
            BrowserEnv browserEnv = accountContext.getBrowserEnv();

            return AccountPrintDto
                    .builder()
                    .id(accountContext.getClientAccount().getId())
                    .name(accountContext.getName())
                    .proxyInfo(proxy.getId() + "-" + proxy.getAddress())
                    .browserEnvInfo(String.valueOf(browserEnv == null ? "NO_ENV" : browserEnv.getId()))
                    .signUp(accountContext.getClientAccount().getSignUp())
                    .build();
        }).toList();

        return "账号列表:\n" +
                CommandLineTablePrintHelper.generateTableString(list, AccountPrintDto.class) +
                "\n";
    }

    /**
     * 打印账户连接情况
     *
     * @return String
     */
    public String printAccountConnectStatusList() {
        List<ConnectStatusInfo> list = accounts.stream().map(AccountContext::getConnectStatusInfo).toList();

        return "账号链接状态列表:\n" +
                CommandLineTablePrintHelper.generateTableString(list, ConnectStatusInfo.class) +
                "\n";
    }

    /**
     * 打印账号收益
     *
     * @return String
     */
    public String printAccountReward() {
        StringBuilder sb = new StringBuilder();

        List<RewordInfo> list = accounts.stream().map(AccountContext::getRewordInfo).toList();

        sb.append("收益列表:\n")
                .append(CommandLineTablePrintHelper.generateTableString(list, RewordInfo.class))
                .append("\n");

        return sb.toString();
    }

}
package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.commandMenu.CommandMenuNode;
import cn.com.helei.DepinBot.core.commandMenu.DefaultMenuType;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.util.ClosableTimerTask;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;


@Slf4j
public abstract class DefaultMenuCMDLineDepinBot<C extends BaseDepinBotConfig> extends CommandLineDepinBot {


    private static final String INVITE_CODE_KEY = "inviteCode";

    /**
     * 刷新节点
     */
    public static final CommandMenuNode REFRESH_NODE = new CommandMenuNode(true, "刷新", "当前数据已刷新", null);

    /**
     * 是否开始过链接所有账号
     */
    private final AtomicBoolean isStartAccountConnected = new AtomicBoolean(false);


    private final List<DefaultMenuType> defaultMenuTypes = new ArrayList<>(List.of(
            DefaultMenuType.ACCOUNT_LIST,
            DefaultMenuType.PROXY_LIST,
            DefaultMenuType.BROWSER_ENV_LIST
    ));

    @Getter
    private final C botConfig;

    public DefaultMenuCMDLineDepinBot(C botConfig) {
        super(botConfig);

        this.botConfig = botConfig;
    }


    @Override
    protected CompletableFuture<Boolean> updateAccountRewordInfo(AccountContext accountContext) {
        return CompletableFuture.completedFuture(false);
    }

    @Override
    protected void buildMenuNode(CommandMenuNode mainManu) {
        addCustomMenuNode(defaultMenuTypes, mainManu);

        for (DefaultMenuType menuType : defaultMenuTypes) {
            mainManu.addSubMenu(switch (menuType) {
                case REGISTER -> buildRegisterMenuNode();
                case LOGIN -> buildQueryTokenMenuNode();
                case ACCOUNT_LIST -> buildAccountListMenuNode();
                case PROXY_LIST -> buildProxyListMenuNode();
                case BROWSER_ENV_LIST -> buildBrowserListMenuNode();
                case START_ACCOUNT_CLAIM -> buildStartAccountConnectMenuNode();
            });
        }
    }


    /**
     * 构建注册菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildRegisterMenuNode() {
        CommandMenuNode registerMenu = new CommandMenuNode("注册",
                "请确认邀请码后运行", this::printCurrentInvite);

        CommandMenuNode interInvite = new CommandMenuNode(
                "填入邀请码",
                "请输入邀请码：",
                this::printCurrentInvite
        );
        interInvite.setResolveInput(input -> {
            log.info("邀请码修改[{}]->[{}]", botConfig.getConfig(INVITE_CODE_KEY), input);
            botConfig.setConfig(INVITE_CODE_KEY, input);
        });


        return registerMenu.addSubMenu(interInvite)
                .addSubMenu(new CommandMenuNode(
                        "开始注册",
                        "开始注册所有账号...",
                        this::registerAllAccount
                ));
    }

    /**
     * 获取token
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildQueryTokenMenuNode() {
        return new CommandMenuNode("获取token", "开始获取所有账号token...", this::loadAllAccountToken);
    }

    /**
     * 构建查看代理列表的菜单节点
     *
     * @return 查看代理列表菜单节点
     */
    private CommandMenuNode buildProxyListMenuNode() {
        return new CommandMenuNode(
                "查看代理列表",
                "当前代理列表文件:" + getProxyPool().getConfigClassPath(),
                getProxyPool()::printPool
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 构建查看浏览器环境列表的菜单节点
     *
     * @return 查看浏览器环境列表菜单节点
     */
    private CommandMenuNode buildBrowserListMenuNode() {
        return new CommandMenuNode(
                "查看浏览器环境列表",
                "当前代理列表文件:" + getBrowserEnvPool().getConfigClassPath(),
                getBrowserEnvPool()::printPool
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 账户列表菜单节点
     *
     * @return 账户列表节点
     */
    private CommandMenuNode buildAccountListMenuNode() {
        CommandMenuNode accountListMenuNode = new CommandMenuNode(
                "查看账号",
                "当前账户详情列表:",
                this::printAccountList
        );

        return accountListMenuNode
                .addSubMenu(buildAccountRewardMenuNode())
                .addSubMenu(buildAccountConnectStatusMenuNode())
                .addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户收益菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountRewardMenuNode() {
        return new CommandMenuNode(
                "查看账号收益",
                "账号收益详情列表:",
                this::printAccountReward
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户连接情况菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountConnectStatusMenuNode() {
        return new CommandMenuNode(
                "查看账号连接情况",
                "账号连接情况列表:",
                this::printAccountConnectStatusList
        ).addSubMenu(REFRESH_NODE);
    }


    /**
     * 开始账户连接菜单节点
     *
     * @return 连接账户菜单节点
     */
    private CommandMenuNode buildStartAccountConnectMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode(
                "启动账号",
                "启动账号界面，",
                this::startAccountsClaim
        );

        CommandMenuNode refresh = new CommandMenuNode(true, "刷新", "当前账户列表",
                this::printAccountList);

        menuNode.addSubMenu(refresh);
        return menuNode;
    }

    /**
     * 注册所有账号
     *
     * @return String
     */
    private String registerAllAccount() {
        CompletableFuture.supplyAsync(() -> {
            List<CompletableFuture<Boolean>> futures = getAccounts().stream()
                    .map(account -> {
                        // 账户注册过，
                        if (BooleanUtil.isTrue(account.getClientAccount().getSignUp())) {
                            log.warn("账户[{}]-email[{}]注册过", account.getName(), account.getClientAccount().getEmail());
                            return CompletableFuture.completedFuture(false);
                        } else {
                            return registerAccount(account, botConfig.getConfig(INVITE_CODE_KEY));
                        }
                    }).toList();

            int successCount = 0;
            for (int i = 0; i < futures.size(); i++) {
                CompletableFuture<Boolean> future = futures.get(i);
                AccountContext accountContext = getAccounts().get(i);
                try {
                    if (future.get()) {
                        //注册成功
                        successCount++;
                        accountContext.getClientAccount().setSignUp(true);
                    }
                } catch (InterruptedException | ExecutionException e) {
                    log.error("注册账号[{}]发生错误, {}", accountContext.getName(), e.getMessage());
                }
            }

            return String.format("所有账号注册完毕，[%d/%d]", successCount, getAccounts().size());
        }, getExecutorService());

        return "已开始账户注册";
    }

    /**
     * 获取账号的token
     *
     * @return String
     */
    public String loadAllAccountToken() {
        List<CompletableFuture<String>> futures = getAccounts().stream()
                .map(this::requestTokenOfAccount).toList();

        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            CompletableFuture<String> future = futures.get(i);
            AccountContext accountContext = getAccounts().get(i);
            try {
                String token = future.get();
                if (StrUtil.isNotBlank(token)) {
                    successCount++;
                    accountContext.getParams().put("token", token);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("账号[{}]获取token发生错误, {}", accountContext.getName(), e.getMessage());
            }
        }

        return String.format("所有账号获取token完毕，[%d/%d]", successCount, getAccounts().size());
    }


    /**
     * 开始所有账户
     *
     * @return String 打印的消息
     */
    private String startAccountsClaim() {
        if (isStartAccountConnected.compareAndSet(false, true)) {

            getAccounts().forEach(account -> {
                if (account.getClientAccount().getId() != 0) { return;}
                account.getConnectStatusInfo().setStartDateTime(LocalDateTime.now());

                addTimer(
                        new ClosableTimerTask() {
                            @Override
                            public boolean run() {
                                return doAccountClaim(account);
                            }
                        },
                        getBotConfig().getAutoClaimIntervalSeconds(),
                        TimeUnit.SECONDS
                );
            });

            return "已开始账号自动收获";
        }

        return "账号自动收获中";
    }

    /**
     * 打印当前的邀请码
     *
     * @return 邀请码
     */
    private String printCurrentInvite() {
        String inviteCode = botConfig.getConfigMap().get("inviteCode");
        return "(当前邀请码为:" + inviteCode + ")";
    }

    /**
     * 添加自定义菜单节点, defaultMenuTypes中可额外添加菜单类型
     *
     * @param defaultMenuTypes defaultMenuTypes
     * @param mainMenu         mainMenu
     */
    protected abstract void addCustomMenuNode(List<DefaultMenuType> defaultMenuTypes, CommandMenuNode mainMenu);

    /**
     * 注册账户
     *
     * @param accountContext accountContext
     * @param inviteCode     inviteCode
     * @return CompletableFuture<Boolean> 是否注册成功
     */
    protected abstract CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode);

    /**
     * 请求获取账户token
     *
     * @param accountContext accountContext
     * @return CompletableFuture<String> token
     */
    protected abstract CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext);


    /**
     * 开始账户自动收获,会自动循环。返回false则跳出自动循环
     *
     * @return CompletableFuture<Void>
     */
    protected abstract boolean doAccountClaim(AccountContext accountContext);

}
package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.WSDepinBotConfig;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.exception.DepinBotStatusException;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;

@Slf4j
public abstract class WSMenuCMDLineDepinBot<C extends WSDepinBotConfig, Req, Resp> extends DefaultMenuCMDLineDepinBot<C> {

    private final Map<AccountContext, BaseDepinWSClient<Req, Resp>> accountWSClientMap;

    public WSMenuCMDLineDepinBot(C config) {
        super(config);
        accountWSClientMap = new ConcurrentHashMap<>();
    }

    @Override
    protected final boolean doAccountClaim(AccountContext accountContext) {
        BaseDepinWSClient<Req, Resp> depinWSClient = accountWSClientMap.compute(accountContext, (k, v) -> {
            // 没有创建过，或被关闭，创建新的
            if (v == null || v.getClientStatus().equals(WebsocketClientStatus.SHUTDOWN)) {
                v = buildAccountWSClient(accountContext);

                v.setReconnectCountDownSecond(getBotConfig().getReconnectCountDownSecond());
                v.setAllIdleTimeSecond(getBotConfig().getAutoClaimIntervalSeconds());
            }

            return v;
        });

        String accountName = accountContext.getClientAccount().getName();

        //Step 3 建立连接
        WebsocketClientStatus currentStatus = depinWSClient.getClientStatus();

        depinWSClient.setClientStatusChangeHandler(newStatus -> {
            depinWSClient.whenClientStatusChange(newStatus);
            // 调用bot类的回调方法
            whenAccountClientStatusChange(depinWSClient, newStatus);
        });

        return switch (currentStatus) {
            case NEW, STOP:  // 新创建，停止状态，需要建立连接
                try {
                    yield !depinWSClient.connect().get() && getBotConfig().isWsUnlimitedRetry() ;
                } catch (InterruptedException | ExecutionException e) {
                    log.error("账户[{}]ws链接发生错误", accountName, e);
                    yield true;
                }
            case STARTING, RUNNING:
                yield false;
            case SHUTDOWN: // 被禁止使用，抛出异常
                throw new DepinBotStatusException("cannot start ws client when it shutdown, " + accountName);
        };
    }

    /**
     * 使用accountContext构建AbstractDepinWSClient
     *
     * @param accountContext accountContext
     * @return AbstractDepinWSClient
     */
    public abstract BaseDepinWSClient<Req, Resp> buildAccountWSClient(AccountContext accountContext);


    /**
     * 当账户链接时调用
     *
     * @param depinWSClient depinWSClient
     * @param clientStatus  clientStatus
     */
    public abstract void whenAccountClientStatusChange(BaseDepinWSClient<Req, Resp> depinWSClient, WebsocketClientStatus clientStatus);

    /**
     * 当ws连接收到响应
     *
     * @param depinWSClient depinWSClient
     * @param id            id
     * @param response      response
     */
    public abstract void whenAccountReceiveResponse(BaseDepinWSClient<Req, Resp> depinWSClient, Object id, Resp response);

    /**
     * 当ws连接收到消息
     *
     * @param depinWSClient depinWSClient
     * @param message       message
     */
    public abstract void whenAccountReceiveMessage(BaseDepinWSClient<Req, Resp> depinWSClient, Resp message);


    /**
     * 获取心跳消息
     *
     * @param depinWSClient depinWSClient
     * @return 消息体
     */
    public abstract Req getHeartbeatMessage(BaseDepinWSClient<Req, Resp> depinWSClient);


}
package cn.com.helei.DepinBot.core.dto.account;

import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenField;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnv;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.dto.RewordInfo;
import lombok.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@PropertyChangeListenClass(isDeep = true)
public class AccountContext {

    /**
     * 账户是否可用
     */
    @PropertyChangeListenField
    private boolean usable = true;

    /**
     * client 账户
     */
    @PropertyChangeListenField
    private DepinClientAccount clientAccount;

    /**
     * 代理
     */
    private NetworkProxy proxy;

    /**
     * 浏览器环境
     */
    private BrowserEnv browserEnv;

    /**
     * 连接的url
     */
    private String connectUrl;

    /**
     * 连接状态
     */
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    /**
     * 分数信息
     */
    @PropertyChangeListenField
    private final RewordInfo rewordInfo = new RewordInfo();

    @PropertyChangeListenField
    private final Map<String, String> params = new HashMap<>();


    private LocalDateTime saveDatetime;


    public String getParam(String key) {
        return params.get(key);
    }

    public void setParam(String key, String value) {
        params.put(key, value);
    }

    public Map<String, String> getWSHeaders() {
        return clientAccount.getWSHeaders();
    }

    public Map<String, String> getRestHeaders() {
        return clientAccount.getRestHeaders();
    }

    public String getName() {
        return clientAccount.getName() == null ? clientAccount.getEmail() : clientAccount.getName();
    }
}
package cn.com.helei.DepinBot.core.dto.account;

import cn.com.helei.DepinBot.core.constants.ConnectStatus;
import lombok.Data;

import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Account的连接状态
 */
@Data
public class ConnectStatusInfo {

    /**
     * 开始时间
     */
    private volatile LocalDateTime startDateTime;

    /**
     * 更新时间
     */
    private volatile LocalDateTime updateDateTime;

    /**
     * 心跳数
     */
    private final AtomicInteger heartBeat = new AtomicInteger(0);

    /**
     * 错误的心跳数
     */
    private final AtomicInteger errorHeartBeat = new AtomicInteger(0);

    /**
     * 重启次数
     */
    private final AtomicInteger restart = new AtomicInteger(0);

    /**
     * 连接状态
     */
    private volatile ConnectStatus connectStatus = ConnectStatus.NEW;
}
package cn.com.helei.DepinBot.core.netty.base;


import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.netty.constants.NettyConstants;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import com.alibaba.fastjson.JSON;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.*;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.HttpProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    protected String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    @Getter
    protected final ExecutorService callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected NetworkProxy proxy = null;

    @Setter
    protected HttpHeaders headers;

    /**
     * 空闲时间
     */
    @Setter
    protected int allIdleTimeSecond = 10;


    /**
     * 重连次数减少的间隔
     */
    @Setter
    private int reconnectCountDownSecond = 180;

    /**
     * 重链接次数
     */
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);

    /**
     * 重连锁
     */
    private final ReentrantLock reconnectLock = new ReentrantLock();

    /**
     * 启动中阻塞的condition
     */
    private final Condition startingWaitCondition = reconnectLock.newCondition();

    /**
     * 客户端当前状态
     */
    @Getter
    private volatile WebsocketClientStatus clientStatus = WebsocketClientStatus.NEW;

    /**
     * clientStatus更新的回调
     */
    @Setter
    private Consumer<WebsocketClientStatus> clientStatusChangeHandler = socketCloseStatus -> {
    };

    @Setter
    @Getter
    private String name;

    private Bootstrap bootstrap;

    private final EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        this.callbackInvoker = Executors.newVirtualThreadPerTaskExecutor();

        this.eventLoopGroup = new NioEventLoopGroup();
    }

    private void init() throws SSLException, URISyntaxException {

        resolveParamFromUrl();


        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, headers, MAX_FRAME_SIZE
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5) // 设置连接超时为10秒
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            // 添加 HttpProxyHandler 作为代理
                            p.addLast(new HttpProxyHandler(proxy.getAddress(), proxy.getUsername(), proxy.getPassword()));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new IdleStateHandler(0, 0, allIdleTimeSecond, TimeUnit.SECONDS));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }


    /**
     * 链接服务端
     */
    public CompletableFuture<Boolean> connect() {
        return switch (clientStatus) {
            case NEW, STOP -> reconnect();
            case STARTING -> waitForStarting();
            case RUNNING -> {
                log.warn("WS客户端[{}}正在运行, clientStatus[{}]", url, clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> throw new RuntimeException("");
        };
    }


    /**
     * 重链接
     *
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Boolean> reconnect() {
        return switch (clientStatus) {
            case NEW, STOP -> doReconnect();
            case STARTING -> waitForStarting().thenApplyAsync(success -> {
                if (success) return true;
                try {
                    return doReconnect().get();
                } catch (InterruptedException | ExecutionException e) {
                    throw new RuntimeException(e);
                }
            });
            case RUNNING -> {
                log.warn("WS客户端[{}}正在启动或运行, 不能reconnect. clientStatus[{}]", url, clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> CompletableFuture.supplyAsync(() -> {
                log.error("client[{}] already shutdown", name);
                return false;
            });
        };
    }

    /**
     * 执行重连接，带重试逻辑
     *
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Boolean> doReconnect() {
        updateClientStatus(WebsocketClientStatus.STARTING);

        return CompletableFuture.supplyAsync(() -> {
            //Step 1 重连次数超过限制，关闭
            if (reconnectTimes.get() >= NettyConstants.RECONNECT_LIMIT) {
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
                return false;
            }

            AtomicBoolean isSuccess = new AtomicBoolean(false);

            //Step 2 重连逻辑
            //Step 2.1 加锁保证只要一个线程进行重连
            reconnectLock.lock();
            try {

                //Step 2.2 已经再running状态，直接返回true。变为shutdown、stop状态，直接返回false
                if (clientStatus.equals(WebsocketClientStatus.RUNNING)) {
                    log.info("client started by other thread");
                    return true;
                } else if (clientStatus.equals(WebsocketClientStatus.SHUTDOWN) || clientStatus.equals(WebsocketClientStatus.STOP)) {
                    log.error("clint stop/shutdown when client starting");
                    return false;
                }

                //Step 3 初始化
                log.info("开始初始化WS客户端");
                try {
                    init();
                } catch (SSLException | URISyntaxException e) {
                    throw new RuntimeException("初始化WS客户端发生错误", e);
                }
                log.info("初始化WS客户端完成，开始链接服务器 [{}]", url);


                //Step 4 链接服务器
                if (reconnectTimes.incrementAndGet() <= NettyConstants.RECONNECT_LIMIT) {

                    //Step 4.1 每进行重连都会先将次数加1并设置定时任务将重连次数减1
                    eventLoopGroup.schedule(() -> {
                        reconnectTimes.decrementAndGet();
                    }, reconnectCountDownSecond, TimeUnit.SECONDS);

                    log.info("start connect client [{}], url[{}], current times [{}]", name, url, reconnectTimes.get());

                    //Step 4.2 latch用于同步等等链接完成
                    CountDownLatch latch = new CountDownLatch(1);

                    //Step 4.3 延迟再进行连接
                    eventLoopGroup.schedule(() -> {
                        try {
                            channel = bootstrap.connect().sync().channel();

                            handler.handshakeFuture().sync();

                            channel.attr(NettyConstants.CLIENT_NAME).set(name);

                            //Step 4.4 连接成功设置标识
                            isSuccess.set(true);
                        } catch (Exception e) {
                            log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                            isSuccess.set(false);
                        } finally {
                            latch.countDown();
                        }
                    }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                    //Step 4.5 等待链接完成
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        log.error("connect client [{}], url[{}] interrupted, times [{}]", name, url, reconnectTimes.get(), e);
                    }


                    //Step 6 未成功启动，关闭
                    if (!isSuccess.get()) {
                        log.info("connect client [{}], url[{}] fail, current times [{}]", name, url, reconnectTimes.get());

                        close();
                    } else {
                        log.info("connect client [{}], url[{}] success, current times [{}]", name, url, reconnectTimes.get());

                        updateClientStatus(WebsocketClientStatus.RUNNING);
                        reconnectTimes.set(0);
                    }
                }
            } catch (Exception e) {
                //exception 遇到未处理异常，直接关闭
                close();
                throw new RuntimeException(String.format("connect client [%s] appear unknown error", name), e);
            } finally {
                //Step 5 释放等待启动的线程
                startingWaitCondition.signalAll();
                reconnectLock.unlock();
            }

            return isSuccess.get();
        }, callbackInvoker);
    }


    /**
     * 停止WebSocketClient
     */
    public void close() {
        if (clientStatus.equals(WebsocketClientStatus.STOP)) return;

        updateClientStatus(WebsocketClientStatus.STOP);

        log.info("closing websocket client [{}], [{}]", name, channel == null ? "null" : channel.hashCode());
        if (channel != null) {
            channel.close();
            channel = null;
        }

        log.warn("web socket client [{}] closed", name);
    }

    /**
     * 彻底关闭客户端
     */
    public void shutdown() {
        close();

        updateClientStatus(WebsocketClientStatus.SHUTDOWN);

        if (eventLoopGroup != null) {
            eventLoopGroup.shutdownGracefully();
        }

        log.warn("web socket client [{}] already shutdown !", name);
    }

    /**
     * 等待启动完成
     *
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Boolean> waitForStarting() {
        return CompletableFuture.supplyAsync(() -> {
            log.warn("client [{}] is starting, waiting for complete", name);
            reconnectLock.lock();
            try {
                while (clientStatus.equals(WebsocketClientStatus.STARTING)) {
                    startingWaitCondition.await();
                }

                if (clientStatus.equals(WebsocketClientStatus.STOP) || clientStatus.equals(WebsocketClientStatus.SHUTDOWN)) {
                    log.error("启动WS客户端[{}]失败, ClientStatus [{}}", name, clientStatus);
                    return false;
                }
                return true;
            } catch (InterruptedException e) {
                log.error("waiting for start client [{}] error", name);
                throw new RuntimeException(e);
            } finally {
                reconnectLock.unlock();
            }
        }, callbackInvoker);
    }


    /**
     * 发送消息，没有回调
     *
     * @param message message
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> sendMessage(P message) {
        return CompletableFuture.runAsync(() -> {
            if (message == null) {
                throw new IllegalArgumentException("message is null");
            }

            try {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(message)));
            } catch (Exception e) {
                throw new RuntimeException("send message [" + message + "] error");
            }
        }, callbackInvoker);
    }

    ;

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = handler.registryRequest(request, response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                log.info("send request [{}]", request);
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        log.debug("client [{}] send ping {}", name, url);
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        log.debug("client [{}] send pong {}", name, url);
        channel.writeAndFlush(new PongWebSocketFrame());
    }


    /**
     * 更新status
     *
     * @param newStatus newStatus
     */
    public void updateClientStatus(WebsocketClientStatus newStatus) {
        synchronized ("CLIENT_STATUS_LOCK") {
            try {
                if (newStatus != clientStatus && clientStatusChangeHandler != null) {
                    clientStatusChangeHandler.accept(newStatus);
                }
            } finally {
                log.info("client status [{}] -> [{}]", clientStatus, newStatus);
                clientStatus = newStatus;
            }
        }
    }

    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }
}

