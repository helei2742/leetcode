bot:
  app:
    projectName: sahara
    runtime:
      concurrentCount: 6
      autoClaimIntervalSeconds: 60
      isAccountRewardAutoRefresh: false
      accountRewardRefreshIntervalSeconds: 600

    websocket:
      wsBaseUrl: wss://example.com
      wsUnlimitedRetry: false
      heartBeatIntervalSecond: 30
      wsConnectCount: 5
      reconnectCountDownSecond: 180

    filePathConfig:
      proxyFileBotConfigPath: proxy.xlsx
      browserEnvFileBotConfigPath: browser_env.xlsx
      twitterFileBotConfigPath: twitter_account.xlsx
      discordFileBotConfigPath: discord_account.xlsx
      telegramFileBotConfigPath: telegram_account.xlsx
      baseAccountFileBotConfigPath: base_account.xlsx

    accountConfig:
      configFilePath: app/test_project_account.xlsx


    customConfig:
      key1: value1
      key2: 123
      key3:
        - 1
        - 2
        - 3
      key4:
        - name: hah
          age: 2
        - name: ooo
          age: 3


package cn.com.helei.bot.core.bot.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotApplication {

    /**
     * bot 名字
     *
     * @return name
     */
    String name();

    /**
     * 描述
     *
     * @return 描述
     */
    String describe() default "";

    /**
     * 适用项目的id
     *
     * @return id
     */
    int[] limitProjectIds() default {};
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.config.AutoBotConfig;
import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.constants.DepinBotStatus;
import cn.com.helei.bot.core.dto.AutoBotRuntimeInfo;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.util.exception.DepinBotStatusException;
import cn.com.helei.bot.core.util.FileUtil;
import cn.com.helei.bot.core.util.NamedThreadFactory;
import cn.com.helei.bot.core.util.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

@Slf4j
@Getter
public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 配置
     */
    private final AutoBotConfig autoBotConfig;

    /**
     * 状态
     */
    private DepinBotStatus status = DepinBotStatus.NEW;

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot运行时信息
     */
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    @Getter
    private final BotApi botApi;

    /**
     * bot信息
     */
    @Getter
    @Setter
    private BotInfo botInfo;

    public AbstractAutoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        this.autoBotConfig = autoBotConfig;
        this.botApi = botApi;

        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();

        // 解析注解，添加botInfo
        resolveAnnoAndFillBotInfo();

        this.executorService = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(botInfo.getName() + "-executor"));
    }


    public void init() {
        updateState(DepinBotStatus.INIT);
        try {
            // 查询project是否存在
//            if (isProjectExist()) return;

            doInit();

            //更新状态
            updateState(DepinBotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化Bot[{}]发生错误", botInfo.getName(), e);
            updateState(DepinBotStatus.INIT_ERROR);
        }
    }


    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;


    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {

        Semaphore networkController = networkSyncControllerMap
                .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                    if (v == null) {
                        v = new Semaphore(autoBotConfig.getRuntime().getConcurrentCount());
                    }
                    return v;
                });


        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "开始";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                log.info("同步器允许发送请求-{}", str);

                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH,
                getAutoBotConfig().getProjectName() + File.separator + botInfo.getName());
    }


    /**
     * 更新DepinBotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(DepinBotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(DepinBotStatus.SHUTDOWN)) {
            status = DepinBotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> DepinBotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(DepinBotStatus.INIT_FINISH)
                        || newStatus.equals(DepinBotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(DepinBotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(DepinBotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(DepinBotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }


    /**
     * 解析注解，添加botInfo
     */
    private void resolveAnnoAndFillBotInfo() {
        BotApplication annotation = this.getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            BotInfo dbBotInfo = botApi.getBotInfoService().query().eq("name", botName).one();

            // 查询bot是否存在，不存在则创建
            if (dbBotInfo == null) {
                log.warn("不存在[{}]bot info, 自动创建...", botName);
                botInfo = new BotInfo();
                botInfo.setDescribe(annotation.describe());
                botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
                botInfo.setName(botName);
                if (botApi.getBotInfoService().save(botInfo)) {
                    log.info("自动创建[{}]bot info成功", botName);
                } else {
                    throw new RuntimeException("自动创建[" + botName + "]失败");
                }
            } else {
                this.botInfo = dbBotInfo;
            }
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }

}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.config.AccountMailConfig;
import cn.com.helei.bot.core.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.persistence.impl.DBAccountPersistenceManager;
import cn.com.helei.bot.core.util.exception.RewardQueryException;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.supporter.mail.constants.MailProtocolType;
import cn.com.helei.bot.core.supporter.mail.factory.MailReaderFactory;
import cn.com.helei.bot.core.supporter.mail.reader.MailReader;
import cn.com.helei.bot.core.supporter.persistence.AccountPersistenceManager;
import cn.com.helei.bot.core.util.ClosableTimerTask;
import cn.hutool.core.collection.ConcurrentHashSet;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

import static cn.com.helei.bot.core.constants.MapConfigKey.EMAIL_VERIFIED_KEY;
import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AccountManageAutoBot extends AbstractAutoBot implements AccountAutoBot {

    /**
     * 账号列表
     */
    @Getter
    private final Map<String, List<AccountContext>> typedAccountMap = new HashMap<>();

    /**
     * 是否允许账户收益查询
     */
    private final AtomicBoolean isRunningAccountRewardQuery = new AtomicBoolean(true);

    /**
     * 存放账户对应的addTimer添加的任务
     */
    private final Map<AccountContext, Set<ClosableTimerTask>> accountTimerTaskMap;

    /**
     * task 任务并发控制
     */
    private final Semaphore taskSyncController;

    /**
     * 是否开始过链接所有账号
     */
    private final Set<String> startedAccountType = new ConcurrentHashSet<>();

    /**
     * 持久化管理器
     */
    private final AccountPersistenceManager persistenceManager;

    public AccountManageAutoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        this.accountTimerTaskMap = new ConcurrentHashMap<>();
        this.taskSyncController = new Semaphore(autoBotConfig.getRuntime().getConcurrentCount());

        this.persistenceManager = new DBAccountPersistenceManager(botApi);
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        // Step 1 初始化保存的线程
        persistenceManager.init();

        // Step 2 初始化账户
        initAccounts();
    }

    /**
     * 添加定时任务,closableTimerTask执行run方法放回true会继续执行， 返回false则会跳出循环
     *
     * @param taskLogic taskLogic
     * @param delay     delay
     * @param timeUnit  timeUnit
     */
    public ClosableTimerTask addTimer(
            Supplier<Boolean> taskLogic,
            long delay,
            TimeUnit timeUnit,
            AccountContext timerOwner
    ) {
        ClosableTimerTask closableTimerTask = new ClosableTimerTask(taskLogic);

        accountTimerTaskMap.compute(timerOwner, (k, v) -> {
            if (v == null) {
                v = new HashSet<>();
            }
            v.add(closableTimerTask);
            return v;
        });

        getExecutorService().execute(() -> {
            while (true) {
                try {
                    taskSyncController.acquire();

                    if (closableTimerTask.isRunning()) {
                        closableTimerTask.setRunning(closableTimerTask.getTask().get());
                    }

                    if (!closableTimerTask.isRunning()) {
                        // 运行完毕后移除
                        accountTimerTaskMap.get(timerOwner).remove(closableTimerTask);
                        break;
                    }

                    timeUnit.sleep(delay);
                } catch (Exception e) {
                    log.error("定时任务执行失败", e);
                    // 异常退出后移除
                    accountTimerTaskMap.get(timerOwner).remove(closableTimerTask);
                    break;
                } finally {
                    taskSyncController.release();
                }
            }
        });

        return closableTimerTask;
    }

    /**
     * 去除账户的所有计时任务
     *
     * @param accountContext accountContext
     */
    public void removeAccountTimer(AccountContext accountContext) {
        accountTimerTaskMap.compute(accountContext, (k, v) -> {
            if (v != null) {
                v.forEach(task -> task.setRunning(false));
                v.removeIf(task -> true);
            }
            return v;
        });
    }


    /**
     * 注册type账号
     *
     * @return String
     */
    public String registerTypeAccount(String type) {
        if (!getTypedAccountMap().containsKey(type)) {
            return type + " 类型账户不存在";
        }

        StringBuilder sb = new StringBuilder("已开始账户注册, type: [");

        // Step 1 遍历不同类型的账户
        List<AccountContext> accountContexts = getTypedAccountMap().get(type);

        sb.append(type).append(", ");

        // Step 2 遍历不同类型下的所有账户
        List<CompletableFuture<Boolean>> futures = accountContexts.stream()
                .map(account -> {
                    // 账户注册过，
                    if (BooleanUtil.isTrue(account.getSignUp())) {
                        log.warn("[{}]账户[{}]-email[{}]注册过", type, account.getName(),
                                account.getAccountBaseInfo().getEmail());

                        return CompletableFuture.completedFuture(false);
                    } else {
                        return registerAccount(account, getAutoBotConfig().getConfig(INVITE_CODE_KEY));
                    }
                }).toList();

        // Step 3 等待注册完成
        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            CompletableFuture<Boolean> future = futures.get(i);
            AccountContext accountContext = accountContexts.get(i);

            try {
                if (future.get()) {
                    //注册成功
                    successCount++;
                    accountContext.setSignUp(true);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("注册[{}]账号[{}]发生错误", type, accountContext.getName(), e);
            }
        }

        log.info("[{}] 所有账号注册完毕，[{}/{}}]", type, successCount, accountContexts.size());

        return sb.append("]").toString();
    }


    public String verifierEmail(String type) {
        List<AccountContext> accounts = getTypedAccountMap().get(type);

        // Step 1  获取type类型的邮件设置
        AutoBotConfig botConfig = getAutoBotConfig();

        //TODO
        Optional<AccountMailConfig> first = null;

        if (first.isEmpty()) {
            return "没有找到 " + type + "类型的账户邮件设置";
        }

        AtomicInteger successCount = new AtomicInteger();

        first.ifPresent(accountMailConfig -> {
            System.out.println("已开始 " + type + " 类型邮箱验证");

            // Step 2 根据设置获取mailReader
            MailReader mailReader = MailReaderFactory.getMailReader(
                    MailProtocolType.valueOf(accountMailConfig.getProtocol().toLowerCase()),
                    accountMailConfig.getHost(),
                    String.valueOf(accountMailConfig.getPort()),
                    accountMailConfig.isSslEnable());

            List<CompletableFuture<Boolean>> accountVerifiedFuture = accounts.stream()
                    .filter(accountContext -> {
                        String emailVerified = accountContext.getParam(EMAIL_VERIFIED_KEY);

                        // 注册的、验证状态为false的才需要验证邮件
                        return BooleanUtil.isTrue(accountContext.getSignUp())
                                && emailVerified != null && BooleanUtil.isFalse(Boolean.valueOf(emailVerified));
                    })
                    .map(accountContext -> CompletableFuture.supplyAsync(() -> {
                        AccountBaseInfo accountBaseInfo = accountContext.getAccountBaseInfo();

                        List<CompletableFuture<Boolean>> futureList = mailReader.readMessage(
                                accountBaseInfo.getEmail(),
                                accountBaseInfo.getPassword(),
                                1,
                                m -> {
                                    return verifierAccountEmail(accountContext, m);
                                }
                        );

                        for (CompletableFuture<Boolean> future : futureList) {
                            try {
                                if (future.get()) {
                                    log.info("{} 邮件验证成功", accountContext.getSimpleInfo());
                                    return true;
                                }
                            } catch (ExecutionException | InterruptedException e) {
                                log.error("{} 验证邮件发生异常, {}", accountContext.getSimpleInfo(), e.getMessage());
                            }
                        }
                        return false;
                    }, getExecutorService()))
                    .toList();

            for (CompletableFuture<Boolean> future : accountVerifiedFuture) {
                try {
                    if (future.get()) {
                        successCount.getAndIncrement();
                    }
                } catch (Exception e) {
                    log.error("验证[{}]邮件出错, {}", type, e.getMessage());
                }
            }


        });


        return type + " 类型邮箱验证完毕，成功：" + successCount + "错误：" + (accounts.size() - successCount.get());
    }


    /**
     * 获取账号的token
     *
     * @return String
     */
    public String loadTypedAccountToken(String type) {
        List<AccountContext> accountContexts = typedAccountMap.get(type);

        log.info("开始获取[{}]类型账号token", type);
        Semaphore semaphore = new Semaphore(getAutoBotConfig().getRuntime().getConcurrentCount());

        List<CompletableFuture<String>> futures = accountContexts.stream()
                .map(accountContext -> {
                    try {
                        semaphore.acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }


                    return requestTokenOfAccount(accountContext)
                            .whenComplete((token, throwable) -> semaphore.release());
                }).toList();

        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            CompletableFuture<String> future = futures.get(i);
            AccountContext accountContext = accountContexts.get(i);
            try {
                String token = future.get();
                if (StrUtil.isNotBlank(token)) {
                    successCount++;
                    accountContext.getParams().put(MapConfigKey.TOKEN_KEY, token);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("[{}] {} 获取token发生错误", type, accountContext.getSimpleInfo(), e);
            }
        }

        log.info("[{}]类型账号token获取完毕, [{}/{}]", type, successCount, accountContexts.size());

        return "已开始获取账户token";
    }


    public List<AccountContext> getAccounts() {
        List<AccountContext> accountContexts = new ArrayList<>();
        for (List<AccountContext> value : getTypedAccountMap().values()) {
            accountContexts.addAll(value);
        }
        return accountContexts;
    }

    /**
     * 账号被加载后调用
     *
     * @param typedAccountMap typedAccountMap
     */
    protected void typedAccountsLoadedHandler(Map<String, List<AccountContext>> typedAccountMap) {

    }

    /**
     * 开始所有账户Claim
     *
     * @return String 打印的消息
     */
    public String startAccountsClaim(String type, List<AccountContext> accountContexts) {
        if (startedAccountType.add(type)) {
            doAccountsClaim(type, accountContexts);
            return "已开始[" + type + "]类型账号自动收获";
        }

        return type + " 类型账户自动收获任务已开启";
    }

    /**
     * 开始账户claim
     */
    protected void doAccountsClaim(String type, List<AccountContext> accountContexts) {
        log.info("开始[{}]账户claim", type);

        accountContexts.forEach(account -> {
            account.getConnectStatusInfo().setStartDateTime(LocalDateTime.now());

            // 添加定时任务
            addTimer(
                    () -> doAccountClaim(account),
                    getAutoBotConfig().getRuntime().getAutoClaimIntervalSeconds(),
                    TimeUnit.SECONDS,
                    account
            );
        });
    }


    /**
     * 开启账户奖励查询任务
     */
    private void startAccountRewardQueryTask() {
        getExecutorService().execute(() -> {
            while (isRunningAccountRewardQuery.get()) {
                for (Map.Entry<String, List<AccountContext>> entry : getTypedAccountMap().entrySet()) {
                    List<AccountContext> accounts = entry.getValue();

                    List<CompletableFuture<Boolean>> futures = accounts.stream().map(accountContext -> {
                        try {
                            return updateAccountRewordInfo(accountContext);
                        } catch (Exception e) {
                            throw new RewardQueryException(e);
                        }
                    }).toList();

                    for (int i = 0; i < futures.size(); i++) {
                        try {
                            futures.get(i).get();
                        } catch (InterruptedException | ExecutionException e) {
                            log.error("查询账户[" + accounts.get(i).getName() + "]奖励失败", e.getMessage());
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(getAutoBotConfig().getRuntime().getAccountRewardRefreshIntervalSeconds());
                    } catch (InterruptedException e) {
                        log.error("等待执行账户查询时发生异常", e);
                    }
                }
            }
        });
    }


    /**
     * 初始化账号方法
     */
    private void initAccounts() throws DepinBotInitException {
        Integer botId = getBotInfo().getId();

        String name = getBotInfo().getName();

        try {
            // Step 1 获取持久化的
            Map<String, List<AccountContext>> typedAccountMap = persistenceManager.loadAccountContexts(botId);

            // Step 2 没有保存的数据，加载新的
            if (typedAccountMap == null || typedAccountMap.isEmpty()) {
                log.warn("bot[{}]没有账户数据", name);
            } else {
                log.info("bot[{}]使用历史账户数据", name);

                // Step 3 加载到bot
                registerAccountsInBot(typedAccountMap);

                typedAccountsLoadedHandler(typedAccountMap);

                this.typedAccountMap.putAll(typedAccountMap);
            }

        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }


    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param typedAccountMap typedAccountMap
     */
    private void registerAccountsInBot(Map<String, List<AccountContext>> typedAccountMap) {
        typedAccountMap.forEach(persistenceManager::registerPersistenceListener);
    }
}
package cn.com.helei.bot.core.bot.view;

import cn.com.helei.bot.core.bot.base.AccountManageAutoBot;
import cn.com.helei.bot.core.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.DepinBotStatus;
import cn.com.helei.bot.core.util.exception.DepinBotStartException;
import cn.com.helei.bot.core.supporter.commandMenu.CommandMenuNode;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jline.reader.LineReader;
import org.jline.reader.LineReaderBuilder;
import org.jline.reader.impl.DefaultParser;
import org.jline.terminal.Terminal;
import org.jline.terminal.TerminalBuilder;

import java.io.IOException;
import java.util.List;
import java.util.Stack;
import java.util.concurrent.CountDownLatch;


/**
 * 命令行交互的depin机器人
 */
@Slf4j
@Getter
public abstract class CommandLineAutoBot {

    private final AutoBotConfig botConfig;

    private final AccountManageAutoBot bot;

    private final CommandMenuNode mainManu;

    public CommandLineAutoBot(AccountManageAutoBot bot) {
        this.bot = bot;
        this.botConfig = bot.getAutoBotConfig();

        this.mainManu = new CommandMenuNode(
                "主菜单",
                String.format("欢迎使用[%s]-bot", getBot().getBotInfo().getName()),
                this::printBanner
        );
    }

    /**
     * 构建command菜单
     */
    protected abstract void buildMenuNode(CommandMenuNode mainManu);


    /**
     * 异步启动
     */
    private void asyncExecute(CountDownLatch startLatch) {
        Thread commandInputThread = new Thread(() -> {
            try {
                doExecute();
            } catch (Exception e) {
                log.error("启动bot发生错误", e);
            } finally {
                startLatch.countDown();
            }
        }, "depin-bot-main");
        commandInputThread.setDaemon(true);
        commandInputThread.start();
    }

    /**
     * 启动bot
     *
     * @throws DepinBotStartException DepinBotStartException
     */
    public void start() throws DepinBotStartException {
        bot.init();

        bot.updateState(DepinBotStatus.STARTING);
        log.info("正在启动Depin Bot");
        try {
            CountDownLatch startLatch = new CountDownLatch(1);
            //启动命令行交互的线程
            asyncExecute(startLatch);

            log.info("Depin Bot启动完毕");

            bot.updateState(DepinBotStatus.RUNNING);
            startLatch.await();

        } catch (Exception e) {
            bot.updateState(DepinBotStatus.SHUTDOWN);
            throw new DepinBotStartException("启动CommandLineDepinBot发生错误", e);
        }
    }


    /**
     * 运行机器人
     *
     * @throws IOException IOException
     */
    public void doExecute() throws IOException {
        //Step 1 获取输入
        CommandMenuNode mainMenuNode = getMenuNode();
        Terminal terminal = TerminalBuilder.builder().system(true).build();
        LineReader reader = LineReaderBuilder.builder().terminal(terminal).parser(new DefaultParser()).build();

        Stack<CommandMenuNode> menuNodeStack = new Stack<>();
        CommandMenuNode currentMenuNode = mainMenuNode;

        //Step 2 不断监听控制台输入
        while (true) {
            boolean inputAccept = true;
            //Step 2.1 获取输入
            String choice;
            try {
                choice = reader.readLine("\n<\n" + getInvokeActionAndMenuNodePrintStr(currentMenuNode) + "请选择>").trim();
            } catch (Exception e) {
                log.error("进入菜单节点[{}]发生异常", currentMenuNode.getTittle(), e);
                currentMenuNode = menuNodeStack.pop();
                continue;
            }

            try {
                //Step 2.2 退出
                if ("exit".equals(choice)) {
                    exitHandler();
                    break;
                }

                //Step 2.3 选择操作
                int option = Integer.parseInt(choice.trim());
                if (option == 0) {
                    //返回上一级菜单
                    if (!menuNodeStack.isEmpty()) {
                        currentMenuNode = menuNodeStack.pop();
                    }
                } else if (option > 0 && option <= currentMenuNode.getSubNodeList().size()) {
                    //进入选择的菜单
                    menuNodeStack.push(currentMenuNode);
                    currentMenuNode = currentMenuNode.getSubNodeList().get(option - 1);
                } else {
                    inputAccept = false;
                }

                //终点节点，不进入，直接返回
                if (currentMenuNode.isEnd()) {
                    System.out.println(getInvokeActionAndMenuNodePrintStr(currentMenuNode));
                    currentMenuNode = menuNodeStack.pop();
                }
            } catch (Exception e) {
                inputAccept = false;
            }

            try {
                if (!inputAccept && currentMenuNode.getResolveInput() != null) {
                    currentMenuNode.getResolveInput().accept(choice);
                }
            } catch (Exception e) {
                System.out.println("系统异常");
            }
        }
    }


    /**
     * 获取菜单， 会放入额外的固定菜单
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode getMenuNode() {

        buildMenuNode(mainManu);

        return mainManu;
    }

    private String printBanner() {

        return "" + bot.printBotRuntimeInfo();
    }

    /**
     * 退出回调
     */
    protected void exitHandler() {
    }

    /**
     * 执行Action回调，获取当前菜单打印的字符串
     *
     * @param currentMenuNode currentMenuNode
     * @return String
     */
    public String getInvokeActionAndMenuNodePrintStr(CommandMenuNode currentMenuNode) {
        StringBuilder sb = new StringBuilder();
        sb.append(currentMenuNode.getDescribe()).append("\n");

        if (currentMenuNode.getAction() != null) {
            sb.append(currentMenuNode.getAction().get()).append("\n");
        }

        if (currentMenuNode.isEnd()) return sb.toString();

        sb.append("选项:\n");
        List<CommandMenuNode> menuNodeList = currentMenuNode.getSubNodeList();
        for (int i = 0; i < menuNodeList.size(); i++) {
            sb.append(i + 1).append(". ").append(menuNodeList.get(i).getTittle()).append("\n");
        }

        sb.append("0. 返回上一级菜单\n");

        return sb.toString();
    }

}
package cn.com.helei.bot.core.bot.view;


import cn.com.helei.bot.core.bot.base.AccountManageAutoBot;
import cn.com.helei.bot.core.config.AutoBotConfig;
import cn.com.helei.bot.core.supporter.AccountInfoPrinter;
import cn.com.helei.bot.core.supporter.commandMenu.CommandMenuNode;
import cn.com.helei.bot.core.supporter.commandMenu.DefaultMenuType;
import cn.com.helei.bot.core.supporter.commandMenu.MenuNodeMethod;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.function.Consumer;

import static cn.com.helei.bot.core.constants.MapConfigKey.*;


@Slf4j
public class MenuCMDLineAutoBot<C extends AutoBotConfig> extends CommandLineAutoBot {
    /**
     * 刷新节点
     */
    public static final CommandMenuNode REFRESH_NODE = new CommandMenuNode(true, "刷新", "当前数据已刷新", null);


    private final List<DefaultMenuType> defaultMenuTypes;

    @Setter
    private Consumer<CommandMenuNode> addCustomMenuNode;

    public MenuCMDLineAutoBot(AccountManageAutoBot bot, List<DefaultMenuType> defaultMenuTypes) {
        super(bot);
        this.defaultMenuTypes = new ArrayList<>(defaultMenuTypes);

        this.defaultMenuTypes.add(DefaultMenuType.ACCOUNT_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.PROXY_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.BROWSER_ENV_LIST);

        // 解析MenuNodeMethod注解添加菜单节点
        for (Method method : bot.getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            if (method.isAnnotationPresent(MenuNodeMethod.class)) {
                if (method.getParameterCount() > 0) {
                    throw new IllegalArgumentException("菜单方法参数数量必须为0");
                }

                MenuNodeMethod anno = method.getAnnotation(MenuNodeMethod.class);
                String title = anno.title();
                String description = anno.description();

                CommandMenuNode menuNode = new CommandMenuNode(title, description, () -> {
                    try {
                        return method.invoke(bot).toString();
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new RuntimeException(e);
                    }
                });

                getMainManu().addSubMenu(menuNode);
            }
        }
    }


    @Override
    public final void buildMenuNode(CommandMenuNode mainManu) {
        if (addCustomMenuNode != null) {
            addCustomMenuNode.accept(mainManu);
        }

        for (DefaultMenuType menuType : defaultMenuTypes) {
            mainManu.addSubMenu(switch (menuType) {
                case REGISTER -> buildRegisterMenuNode();
                case VERIFIER -> buildVerifierMenuNode();
                case LOGIN -> buildQueryTokenMenuNode();
                case ACCOUNT_LIST -> buildAccountListMenuNode();
                case PROXY_LIST -> buildProxyListMenuNode();
                case BROWSER_ENV_LIST -> buildBrowserListMenuNode();
                case START_ACCOUNT_CLAIM -> buildStartAccountConnectMenuNode();
                case IMPORT -> buildImportMenuNode();
            });
        }
    }


    /**
     * 构建注册菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildRegisterMenuNode() {
        CommandMenuNode registerMenu = new CommandMenuNode("注册",
                "请确认设置后运行", this::printCurrentRegisterConfig);

        CommandMenuNode interInvite = new CommandMenuNode(
                "填入邀请码",
                "请输入邀请码：",
                this::printCurrentRegisterConfig
        );
        interInvite.setResolveInput(input -> {
            log.info("邀请码修改[{}]->[{}]", getBotConfig().getConfig(INVITE_CODE_KEY), input);
            getBotConfig().setConfig(INVITE_CODE_KEY, input);
        });

        CommandMenuNode typeSelect = new CommandMenuNode(
                "选择账户类型",
                "请选择账户类型",
                this::printCurrentRegisterConfig
        );

        List<String> typeList = new ArrayList<>(getBot().getTypedAccountMap().keySet());
        for (String type : typeList) {
            CommandMenuNode typeInput = new CommandMenuNode(
                    true,
                    type + " 账户",
                    "type",
                    () -> {
                        getBotConfig().setConfig(REGISTER_TYPE_KEY, type);
                        return "注册[" + type + "]类型账户，共：" + getBot().getTypedAccountMap().get(type).size();
                    }
            );

            typeSelect.addSubMenu(typeInput);
        }


        return registerMenu
                .addSubMenu(interInvite)
                .addSubMenu(typeSelect)
                .addSubMenu(new CommandMenuNode(
                        true,
                        "开始注册",
                        "开始注册所有账号...",
                        () -> getBot()
                                .registerTypeAccount(getBot().getAutoBotConfig()
                                        .getConfig(REGISTER_TYPE_KEY))
                ));
    }

    private CommandMenuNode buildVerifierMenuNode() {
        CommandMenuNode verifier = new CommandMenuNode("验证邮箱", "请选择验证的账户类型",
                () -> "当前的邮箱类型：" + getBotConfig().getConfig(EMAIL_VERIFIER_TYPE));

        for (String type : getBot().getTypedAccountMap().keySet()) {
            verifier.addSubMenu(new CommandMenuNode(true, type + " 类型", "",
                    () -> getBot().verifierEmail(type)));
        }
        return verifier;
    }


    /**
     * 获取token
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildQueryTokenMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode("获取token", "请选择邮箱类型", null);

        for (String type : getBot().getTypedAccountMap().keySet()) {
            CommandMenuNode typeInput = new CommandMenuNode(
                    true,
                    type + " 账户",
                    "type",
                    () -> getBot().loadTypedAccountToken(type)
            );
            menuNode.addSubMenu(typeInput);
        }
        return menuNode;
    }

    /**
     * 构建查看代理列表的菜单节点
     *
     * @return 查看代理列表菜单节点
     */
    private CommandMenuNode buildProxyListMenuNode() {
        return new CommandMenuNode(
                "查看代理列表",
                "当前代理列表:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 构建查看浏览器环境列表的菜单节点
     *
     * @return 查看浏览器环境列表菜单节点
     */
    private CommandMenuNode buildBrowserListMenuNode() {
        return new CommandMenuNode(
                "查看浏览器环境列表",
                "当前浏览器环境:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 账户列表菜单节点
     *
     * @return 账户列表节点
     */
    private CommandMenuNode buildAccountListMenuNode() {
        CommandMenuNode accountListMenuNode = new CommandMenuNode(
                "查看账号",
                "当前账户详情列表:",
                () -> AccountInfoPrinter.printAccountList(getBot().getTypedAccountMap())
        );

        return accountListMenuNode
                .addSubMenu(buildAccountRewardMenuNode())
                .addSubMenu(buildAccountConnectStatusMenuNode())
                .addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户收益菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountRewardMenuNode() {
        return new CommandMenuNode(
                "查看账号收益",
                "账号收益详情列表:",
                () -> AccountInfoPrinter.printAccountReward(getBot().getTypedAccountMap())
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户连接情况菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountConnectStatusMenuNode() {
        return new CommandMenuNode(
                "查看账号连接情况",
                "账号连接情况列表:",
                () -> AccountInfoPrinter.printAccountConnectStatusList(getBot().getTypedAccountMap())
        ).addSubMenu(REFRESH_NODE);
    }


    /**
     * 开始账户连接菜单节点
     *
     * @return 连接账户菜单节点
     */
    private CommandMenuNode buildStartAccountConnectMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode(
                "启动账号",
                "选择启动账号类型",
                null
        );

        Set<String> typeSet = getBot().getTypedAccountMap().keySet();
        for (String type : typeSet) {
            CommandMenuNode typeInput = new CommandMenuNode(true, type + " 账户", "type",
                    () -> getBot().startAccountsClaim(type, getBot().getTypedAccountMap().get(type))
            );

            menuNode.addSubMenu(typeInput);
        }
        menuNode.addSubMenu(new CommandMenuNode(true, "全部类型账户", "", () -> {
            getBot().getTypedAccountMap().forEach(getBot()::startAccountsClaim);

            return "开始全部类型" + typeSet + "账户";
        }));

        CommandMenuNode refresh = new CommandMenuNode(true, "刷新", "当前账户列表",
                () -> AccountInfoPrinter.printAccountList(getBot().getTypedAccountMap()));

        menuNode.addSubMenu(refresh);
        return menuNode;
    }

    /**
     * 导入菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportMenuNode() {

        return new CommandMenuNode("导入", "请选择要导入的数据", null)
                .addSubMenu(buildImportBotAccountContextMenuNode()
                .addSubMenu(buildImportBaseAccountMenuNode())
                .addSubMenu(buildImportProxyMenuNode())
                .addSubMenu(buildImportBrowserEnvMenuNode())
                .addSubMenu(buildImportTwitterMenuNode())
                .addSubMenu(buildImportDiscordMenuNode())
                .addSubMenu(buildImportTelegramMenuNode()))
                ;
    }

    /**
     * 导入浏览器环境菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBrowserEnvMenuNode() {

        return new CommandMenuNode(true, "导入浏览器环境", null, () -> {
            String filePath = getBotConfig().getFilePathConfig().getBrowserEnvFileBotConfigPath();

            getBot().getBotApi().getImportService().importBrowserEnvFromExcel(filePath);

            return "浏览器环境导入完成";
        });
    }

    /**
     * 导入代理信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportProxyMenuNode() {
        return new CommandMenuNode(true, "导入代理", null, () -> {

            getBot().getBotApi().getImportService()
                    .importProxyFromExcel(getBotConfig().getFilePathConfig().getProxyFileBotConfigPath());

            return "代理导入完成";
        });
    }

    /**
     * 导入账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBaseAccountMenuNode() {
        return new CommandMenuNode(true, "导入账号基本信息", null, () -> {

            Map<String, Integer> result = getBot().getBotApi().getImportService()
                    .importAccountBaseInfoFromExcel(getBotConfig().getFilePathConfig().getBaseAccountFileBotConfigPath());

            return "账号基本信息导入完成，" + result;
        });
    }


    /**
     * 导入twitter账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportTwitterMenuNode() {
        return new CommandMenuNode(true, "导入twitter账号", null, () -> {
            getBot().getBotApi().getImportService()
                    .importTwitterFromExcel(getBotConfig().getFilePathConfig().getTwitterFileBotConfigPath());
            return "twitter导入完成";
        });
    }


    /**
     * 导入discord账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportDiscordMenuNode() {
        return new CommandMenuNode(true, "导入discord账号", null, () -> {

            getBot().getBotApi().getImportService().importDiscordFromExcel(getBotConfig().getFilePathConfig().getDiscordFileBotConfigPath());

            return "discord导入完成";
        });
    }

    /**
     * 导入Telegram账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportTelegramMenuNode() {
        return new CommandMenuNode(true, "导入Telegram账号", null, () -> {

            getBot().getBotApi().getImportService().importTelegramFormExcel(getBotConfig().getFilePathConfig().getTelegramFileBotConfigPath());

            return "Telegram导入完成";
        });
    }


    private CommandMenuNode buildImportBotAccountContextMenuNode() {
        return new CommandMenuNode(true, "导入bot运行账号", null, () -> {

            getBot().getBotApi().getImportService().importBotAccountContextFromExcel(
                    getBot().getBotInfo().getId(),
                    getBotConfig().getAccountConfig().getConfigFilePath()
            );

            return "bot运行账号导入完成";
        });
    }


    /**
     * 打印当前的邀请码
     *
     * @return 邀请码
     */
    private String printCurrentRegisterConfig() {
        String inviteCode = (String) getBotConfig().getCustomConfig().get(INVITE_CODE_KEY);
        String registerType = (String) getBotConfig().getCustomConfig().get(REGISTER_TYPE_KEY);

        return "(当前邀请码为:" + inviteCode + ")\n"
                + "(当前注册类型为:" + registerType + ")\n";
    }
}
package cn.com.helei.bot.core.config;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class AutoBotAccountConfig {

    private String configFilePath;
}
package cn.com.helei.bot.core.config;


import lombok.Data;
import lombok.ToString;

import java.util.HashMap;
import java.util.Map;

@Data
@ToString
public class AutoBotConfig {

    /**
     * 项目信息
     */
    private String projectName;

    /**
     * 运行时设置
     */
    private AutoBotRuntimeConfig runtime = new AutoBotRuntimeConfig();

    /**
     * websocket 设置
     */
    private AutoBotWSConfig websocket = new AutoBotWSConfig();

    /**
     * 配置文件配置
     */
    private AutoBotConfigFilePathConfig filePathConfig = new AutoBotConfigFilePathConfig();

    /**
     * 账户配置
     */
    private AutoBotAccountConfig accountConfig = new AutoBotAccountConfig();

    /**
     * 自定义配置
     */
    private Map<String, Object> customConfig = new HashMap<>();


    public String getConfig(String key) {
        return String.valueOf(customConfig.get(key));
    }

    public void setConfig(String key, String value) {
        this.customConfig.put(key, value);
    }

}
package cn.com.helei.bot.core.config;

import cn.com.helei.bot.core.util.typehandler.JsonTypeHandler;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

@Configuration
public class MybatisConfig implements MetaObjectHandler {
    /**
     * 使用mp做添加操作时候，这个方法执行
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        //设置属性值
        this.setFieldValByName("insertDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("isValid", 0, metaObject);
    }

    /**
     * 使用mp做修改操作时候，这个方法执行
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
    }


    @Bean
    public JsonTypeHandler jsonTypeHandler() {
        return new JsonTypeHandler();
    }

    @Bean
    public MapTextTypeHandler mapTextTypeHandler() {
        return new MapTextTypeHandler();
    }

    @Bean
    public LocalDateTimeTypeHandler localDateTimeTypeHandler() {
        return new LocalDateTimeTypeHandler();
    }
}
package cn.com.helei.bot.core.dto;

import lombok.Data;

@Data
public class TableColumnInfo {
    private Integer cid;

    private String name;

    private String type;

    private Integer notnull;

    private Object dflt_value;

    private Integer pk;
}


package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenField;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

        import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
public class AccountContext {


    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("account_base_info_id")
    @ExcelProperty("account_base_info_id")
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty("twitter_id")
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty("discord_id")
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty("proxy_id")
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty("browser_env_id")
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty("telegram_id")
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty("wallet_id")
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    @TableField("status")
    @PropertyChangeListenField
    private Integer status;

    @TableField("usable")
    @PropertyChangeListenField
    private boolean usable = true;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    private ProxyInfo proxy;

    @TableField(exist = false)
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return String.valueOf(params.get(key));
    }

    public void setParam(String key, String value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getAccountBaseInfo().getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().getAddressStr());
    }

    public Boolean getSignUp() {
        return status == 1;
    }

    public void setSignUp(boolean b) {
        status = 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;

import lombok.*;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@TableName("t_bot_info")
public class BotInfo {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;
}
package cn.com.helei.bot.core.mvc.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@RestController
@RequestMapping("/core/botInfo")
public class BotInfoController {

}
package cn.com.helei.bot.core.mvc.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@RestController
@RequestMapping("/core/project")
public class ProjectController {

}
package cn.com.helei.bot.core.mvc.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import java.io.Serializable;
import lombok.Getter;
import lombok.Setter;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@TableName("t_bot_info")
public class BotInfo implements Serializable {

    private static final long serialVersionUID = 1L;

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField("update_datetime")
    private String updateDatetime;

    @TableField("is_valid")
    private Integer isValid;
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mapper.BotInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.BotInfo">
        <id column="id" property="id" />
        <result column="name" property="name" />
        <result column="describe" property="describe" />
        <result column="limit_project_ids" property="limitProjectIds" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="is_valid" property="isValid" />
    </resultMap>

</mapper>
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.AccountContext;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface BotAccountContextMapper extends BaseMapper<AccountContext> {

    Integer insertOrUpdate(AccountContext accountBaseInfo);
}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.BotInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface BotInfoMapper extends BaseMapper<BotInfo> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.ProjectInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface ProjectInfoMapper extends BaseMapper<ProjectInfo> {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.mvc.mapper.BotAccountContextMapper;
import cn.com.helei.bot.core.mvc.service.IBotAccountContextService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class BotAccountContextServiceImpl extends ServiceImpl<BotAccountContextMapper, AccountContext> implements IBotAccountContextService {

    @Override
    public Integer insertOrUpdate(AccountContext accountBaseInfo) {
        accountBaseInfo.setInsertDatetime(LocalDateTime.now());
        accountBaseInfo.setUpdateDatetime(LocalDateTime.now());
        accountBaseInfo.setIsValid(1);

        return baseMapper.insertOrUpdate(accountBaseInfo);
    }

    @Override
    public Integer insertOrUpdateBatch(List<AccountContext> accountContext) {
        int successCount = 0;
        for (AccountContext accountBaseInfo : accountContext) {
            try {
                Integer count = insertOrUpdate(accountBaseInfo);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", accountBaseInfo, e);
            }
        }

        return successCount;
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.mvc.mapper.BotInfoMapper;
import cn.com.helei.bot.core.mvc.service.IBotInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Service
public class BotInfoServiceImpl extends ServiceImpl<BotInfoMapper, BotInfo> implements IBotInfoService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.ProjectInfo;
import cn.com.helei.bot.core.mvc.mapper.ProjectInfoMapper;
import cn.com.helei.bot.core.mvc.service.IProjectInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Service
public class ProjectInfoServiceImpl extends ServiceImpl<ProjectInfoMapper, ProjectInfo> implements IProjectInfoService {

}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.entity.AccountContext;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IBotAccountContextService extends IService<AccountContext> {
    public Integer insertOrUpdate(AccountContext accountBaseInfo);

    Integer insertOrUpdateBatch(List<AccountContext> twitterAccounts);

}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.entity.BotInfo;
import com.baomidou.mybatisplus.extension.service.IService;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface IBotInfoService extends IService<BotInfo> {

}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.entity.ProjectInfo;
import com.baomidou.mybatisplus.extension.service.IService;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface IProjectInfoService extends IService<ProjectInfo> {

}
package cn.com.helei.bot.core.supporter.botapi.impl;

import cn.com.helei.bot.core.mvc.service.*;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Getter
@Component
public class DBBotApi implements BotApi {

    @Autowired
    private IProjectInfoService projectInfoService;

    @Autowired
    private IBotInfoService botInfoService;

    @Autowired
    private IAccountBaseInfoService accountBaseInfoService;

    @Autowired
    private ITwitterAccountService twitterAccountService;

    @Autowired
    private IProxyInfoService proxyInfoService;

    @Autowired
    private IBrowserEnvService browserEnvService;

    @Autowired
    private IDiscordAccountService discordAccountService;

    @Autowired
    private IBotAccountContextService projectAccountContextService;

    @Autowired
    private IRewordInfoService rewordInfoService;

    @Autowired
    private DBImportService importService;
}
package cn.com.helei.bot.core.supporter.botapi.impl;

import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.constants.ProxyProtocol;
import cn.com.helei.bot.core.constants.ProxyType;
import cn.com.helei.bot.core.entity.*;
import cn.com.helei.bot.core.mvc.service.*;
import cn.com.helei.bot.core.mvc.service.ITelegramAccountService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import cn.com.helei.bot.core.util.excel.ExcelReadUtil;
import cn.com.helei.bot.core.util.FileUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;

import static cn.com.helei.bot.core.constants.MapConfigKey.USER_AGENT_KEY;

@Slf4j
@Component
public class DBImportService implements ImportService {

    @Autowired
    private IBotAccountContextService botAccountContextService;

    @Autowired
    private IAccountBaseInfoService accountBaseInfoService;

    @Autowired
    private IProxyInfoService proxyInfoService;

    @Autowired
    private IBrowserEnvService browserEnvService;

    @Autowired
    private ITwitterAccountService twitterAccountService;

    @Autowired
    private IDiscordAccountService discordAccountService;

    @Autowired
    private ITelegramAccountService telegramAccountService;


    @Override
    public Integer importBotAccountContextFromExcel(Integer botId, String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            List<AccountContext> twitterAccounts = rawLines.stream().map(map -> AccountContext.builder()
                    .botId(botId)
                    .accountBaseInfoId(autoCast(map.remove("account_base_info_id")))
                    .twitterId(autoCast(map.remove("twitter_id")))
                    .discordId(autoCast(map.remove("discord_id")))
                    .proxyId(autoCast(map.remove("proxy_id")))
                    .browserEnvId(autoCast(map.remove("browser_env_id")))
                    .telegramId(autoCast(map.remove("telegram_id")))
                    .walletId(autoCast(map.remove("wallet_id")))
                    .params(map)
                    .build()).toList();


            return botAccountContextService.insertOrUpdateBatch(twitterAccounts);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importBrowserEnvFromExcel(String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        List<Map<String, Object>> headerList = ExcelReadUtil.readExcelToMap(proxyFilePath);

        List<BrowserEnv> list = headerList.stream().map(map -> {

            Object userAgent = map.remove(USER_AGENT_KEY);
            if (userAgent == null) return null;

            BrowserEnv browserEnv = new BrowserEnv();
            browserEnv.setUserAgent((String) userAgent);
            browserEnv.setOtherHeader(map);
            return browserEnv;
        }).filter(Objects::nonNull).toList();

        log.info("文件解析成功, 共[{}]个，过滤掉没有User-Agent头后共[{}}个", headerList.size(), list.size());

        return browserEnvService.insertOrUpdateBatch(list);
    }

    @Override
    public Integer importProxyFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);

        List<ProxyInfo> proxyInfos = new ArrayList<>();

        try {
            List<Map<String, Object>> staticProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "static");

            staticProxies.forEach(map -> {
                String proxyProtocol = autoCast(map.remove("proxy_protocol"));

                ProxyInfo proxyInfo = ProxyInfo.builder()
                        .proxyType(ProxyType.STATIC)
                        .host(autoCast(map.remove("host")))
                        .port(Integer.valueOf(autoCast(map.remove("port"))))
                        .proxyProtocol(ProxyProtocol.valueOf(proxyProtocol.toUpperCase()))
                        .username(autoCast(map.remove("username")))
                        .password(autoCast(map.remove("password")))
                        .params(map)
                        .build();

                proxyInfos.add(proxyInfo);
            });

            List<Map<String, Object>> dynamicProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "dynamic");

            dynamicProxies.forEach(map -> {
                ProxyInfo proxyInfo = ProxyInfo.builder()
                        .proxyType(ProxyType.DYNAMIC)
                        .host(autoCast(map.remove("host")))
                        .port(autoCast(map.remove("port")))
                        .proxyProtocol(autoCast(map.remove("proxy_protocol")))
                        .username(autoCast(map.remove("username")))
                        .password(autoCast(map.remove("password")))
                        .params(map)
                        .build();

                proxyInfos.add(proxyInfo);
            });

            log.info("代理配置文件解析成功，static-proxy:[{}], dynamic-proxy:[{}]", staticProxies.size(), dynamicProxies.size());

            return proxyInfoService.insertOrUpdateBatch(proxyInfos);
        } catch (Exception e) {
            log.error("解析代理配置文件[{}]错误", proxyFilePath, e);

            return 0;
        }
    }

    @Override
    public Map<String, Integer> importAccountBaseInfoFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);
        Map<String, Integer> result = new HashMap<>();

        try {
            ExcelReadUtil.readExcelAsMap(
                    proxyFilePath,
                    (type, map) -> AccountBaseInfo.builder()
                            .type(type)
                            .name(autoCast(map.remove("name")))
                            .email(autoCast(map.remove("email")))
                            .password(autoCast(map.remove("password")))
                            .params(map)
                            .build(),
                    (type, accountBaseInfos) -> CompletableFuture.runAsync(() -> {
                        log.info("[{}] 账号基本信息读取完毕, 共[{}]", type, accountBaseInfos.size());
                        Integer insertCount = accountBaseInfoService.insertOrUpdateBatch(accountBaseInfos);

                        log.info("[{}] 账号基本信息保存成功, 新增[{}], 共[{}]", type, insertCount, accountBaseInfos.size());

                        result.put(type, accountBaseInfos.size());
                    })
            );

        } catch (IOException e) {
            log.error("从文件导入账号基本信息出错", e);
        }

        return result;
    }

    @Override
    public Integer importTwitterFromExcel(String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            List<TwitterAccount> twitterAccounts = rawLines.stream().map(map -> TwitterAccount.builder()
                    .username(autoCast(map.remove("username")))
                    .password(autoCast(map.remove("password")))
                    .email(autoCast(map.remove("email")))
                    .emailPassword(autoCast(map.remove("email_password")))
                    .token(autoCast(map.remove("token")))
                    .f2aKey(autoCast(map.remove("f2a_key")))
                    .params(map)
                    .build()).toList();


            return twitterAccountService.insertOrUpdateBatch(twitterAccounts);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importDiscordFromExcel(String fileBotConfigPath) {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);
            List<DiscordAccount> discordAccounts = rawLines.stream().map(map -> DiscordAccount.builder()
                    .username(autoCast(map.remove("username")))
                    .password(autoCast(map.remove("password")))
                    .bindEmail(autoCast(map.remove("bind_email")))
                    .bindEmailPassword(autoCast(map.remove("bind_email_password")))
                    .token(autoCast(map.remove("token")))
                    .params(map)
                    .build()
            ).toList();

            return discordAccountService.insertOrUpdateBatch(discordAccounts);
        } catch (Exception e) {
            log.error("读取discord account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }

    @Override
    public Integer importTelegramFormExcel(String fileBotConfigPath) {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);

            List<TelegramAccount> telegramAccounts = rawLines.stream().map(map -> TelegramAccount.builder()
                    .username(autoCast(map.remove("username")))
                    .password(autoCast(map.remove("password")))
                    .phonePrefix(autoCast(map.remove("phone_prefix")))
                    .phone(autoCast(map.remove("phone")))
                    .token(autoCast(map.remove("token")))
                    .params(map)
                    .build()
            ).toList();


            return telegramAccountService.insertOrUpdateBatch(telegramAccounts);
        } catch (Exception e) {
            log.error("读取telegram account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }


    private static <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }
}
package cn.com.helei.bot.core.supporter.botapi;


import cn.com.helei.bot.core.mvc.service.*;

public interface BotApi {

    IProjectInfoService getProjectInfoService();

    IBotInfoService getBotInfoService();

    IAccountBaseInfoService getAccountBaseInfoService();

    IBrowserEnvService getBrowserEnvService();

    IDiscordAccountService getDiscordAccountService();

    IBotAccountContextService getProjectAccountContextService();

    IProxyInfoService getProxyInfoService();

    IRewordInfoService getRewordInfoService();

    ITwitterAccountService getTwitterAccountService();

    ImportService getImportService();
}
