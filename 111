package cn.com.helei.common.util;

import cn.com.helei.common.config.SystemConfig;

import java.io.*;
import java.nio.file.Path;
import java.util.List;

public class FileUtil {


    public static final String RESOURCE_ROOT_DIR = System.getProperty("user.dir") + File.separator + "botData";

    public static String getConfigDirResourcePath(List<String> path, String fileName) {
        StringBuilder sb = new StringBuilder(RESOURCE_ROOT_DIR);

        for (String p : path) {
            sb.append(File.separator).append(p);
        }
        return sb.append(File.separator).append(fileName).toString();
    }

    public static String getBotAppConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, SystemConfig.CONFIG_DIR_APP_PATH);
    }

    public static String getSystemConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, SystemConfig.CONFIG_DIR_BOT_PATH);
    }

    /**
     * 保存账户
     */
    public static void saveJSONStringContext(Path filePath, String jsonContext) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath.toFile()))) {
            writer.write(jsonContext);
            writer.flush();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        System.out.println(getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, "account.yaml"));
    }
}
package cn.com.helei.bot_father.bot;

import cn.com.helei.bot_father.util.persistence.AccountPersistenceManager;
import cn.com.helei.bot_father.util.persistence.impl.DBAccountPersistenceManager;
import cn.com.helei.common.dto.ACListOptResult;
import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.common.entity.AccountContext;
import cn.com.helei.common.exception.BotInitException;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.BooleanUtil;
import com.alibaba.fastjson.JSONArray;
import lombok.Getter;
import org.jetbrains.annotations.NotNull;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static cn.com.helei.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;


public abstract class AccountManageAutoBot extends AbstractAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();


    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    /**
     * 持久化管理器
     */
    private  AccountPersistenceManager persistenceManager;

    @Override
    protected void doInit() throws BotInitException {
        // Step 1 初始化保存的线程
        this.persistenceManager = new DBAccountPersistenceManager(getBotApi());

        this.persistenceManager.init();

        // Step 2 初始化账户
        this.initAccounts();
    }

    /**
     * 注册账户
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> registerAccount();

    /**
     * 登录并获取token
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> loginAndTakeTokenAccount();


    /**
     * 更新账户奖励信息
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> updateAccountRewordInfo();


    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> botJobNameList();

    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }


    public CompletableFuture<ACListOptResult> uniqueAsyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> buildResultFuture.apply(accountContext, accountContextMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }


    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .filter(this::checkAccountContainsParams)
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult;
                    CompletableFuture<Result> future;

                    try {
                        botACJobResult = new BotACJobResult(
                                getBotInfo().getId(),
                                getBotInfo().getName(),
                                jobName,
                                accountContext.getId()
                        );

                        future = buildResultFuture.apply(accountContext);

                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        throw new RuntimeException(e);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) success++;

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            logger.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInfo().getId(),
                                            getBotInfo().getName(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInfo().getId())
                            .botName(getBotInfo().getName())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 检查账户是否含有指定参数
     *
     * @param accountContext accountContext
     * @return boolean
     */
    private boolean checkAccountContainsParams(AccountContext accountContext) {
        // 过滤掉没有账户需要参数的
        Object o = getBotInfo().getParams().get(ACCOUNT_PARAMS_KEY);
        // 使用的json序列化进db，反序列化得到的是JsonArray
        if (o instanceof JSONArray jsonArray) {
            for (Object obj : jsonArray) {
                String key = (String) obj;
                if (accountContext.getParam(key) == null) {
                    return false;
                }
            }
        }
        return true;
    }


    /**
     * 初始化账号方法
     */
    private void initAccounts() throws BotInitException {
        Integer botId = getBotInfo().getId();

        try {
            logger.info("开始加载账户数据");
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                    .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                logger.warn("没有账户数据");
            } else {
                logger.info("使用历史账户数据, 共:" + accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new BotInitException("初始化账户发生错误", e);
        }
    }


    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }


    @NotNull
    public Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> getUniAccountContexts() {
        Map<Integer, List<AccountContext>> groupByABIId = getAccountContexts()
                .stream()
                .collect(Collectors.groupingBy(ac ->
                        ac.getAccountBaseInfoId() == null ? -1 : ac.getAccountBaseInfoId())
                );


        List<AccountContext> accountContexts = groupByABIId.values().stream().map(List::getFirst).toList();

        return new Pair<>(accountContexts, groupByABIId);
    }

    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }

}
package cn.com.helei.bot_father.bot;

import cn.com.helei.bot_father.anno.BotApplication;
import cn.com.helei.bot_father.anno.BotMethod;
import cn.com.helei.bot_father.anno.BotWSMethodConfig;
import cn.com.helei.bot_father.service.BotApi;
import cn.com.helei.bot_father.websocket.AccountWSClientBuilder;
import cn.com.helei.bot_father.websocket.WebSocketClientLauncher;
import cn.com.helei.common.constants.BotJobType;
import cn.com.helei.bot_father.constants.MapConfigKey;
import cn.com.helei.common.dto.ACListOptResult;
import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.common.dto.Result;
import cn.com.helei.bot_father.config.AutoBotConfig;
import cn.com.helei.common.entity.AccountContext;
import cn.com.helei.common.entity.BotInfo;
import cn.com.helei.common.exception.BotMethodFormatException;
import cn.com.helei.common.exception.BotMethodInvokeException;
import cn.com.helei.common.exception.BotInitException;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.dto.AutoBotJobRuntimeParam;
import cn.com.helei.common.dto.job.AutoBotJobWSParam;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONArray;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.*;

import static cn.com.helei.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;
import static cn.com.helei.common.entity.BotInfo.CONFIG_PARAMS_KEY;


@Slf4j
public abstract class AnnoDriveAutoBot<T extends AbstractAutoBot> extends JobInvokeAutoBot {


    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher = new WebSocketClientLauncher(this);

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;


    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() throws BotInitException {
        // 解析bot 基本信息
        try {
            return resolveAnnoBotInfo(getBotApi());
        } catch (Exception e) {
            throw new BotInitException(e);
        }
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.REGISTER.name(),
                    "未找到注册方法"
            ));
        }
        return uniqueAsyncForACList(
                (accountContext, accountContexts) -> {
                    if (BooleanUtil.isTrue(accountContext.isSignUp())) {
                        // 账户注册过，
                        String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(), accountContext.getName(),
                                accountContext.getAccountBaseInfo().getEmail());

                        log.warn(errorMsg);

                        return CompletableFuture.completedFuture(Result.fail(errorMsg));
                    } else if (registerMethod != null) {
                        // 调用注册方法注册
                        return invokeBotMethod(
                                registerMethod,
                                accountContext,
                                accountContexts,
                                getAutoBotConfig().getConfig(MapConfigKey.INVITE_CODE_KEY)
                        ).thenApplyAsync(result -> {
                            if (result.getSuccess()) {
                                for (AccountContext ac : accountContexts) {
                                    AccountContext.signUpSuccess(ac);
                                }
                            }
                            return result;
                        });
                    } else {
                        return CompletableFuture.completedFuture(Result.fail("未知错误"));
                    }
                },
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        //注册成功
                        AccountContext.signUpSuccess(accountContext);
                    }
                    return result;
                },
                BotJobType.REGISTER.name()
        );
    }

    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (loginMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.LOGIN.name(),
                    "未找到登录方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(
                        loginMethod,
                        accountContext
                ),
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        String token = result.getData() == null ? null :
                                (result.getData() instanceof String ? (String) result.getData() : null);

                        // token不为空，设置到accountContext里
                        if (StrUtil.isNotBlank(token)) {
                            accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                        } else {
                            log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                        }
                    }
                    return result;
                },
                BotJobType.LOGIN.name()
        );
    }


    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (updateRewordMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.QUERY_REWARD.name(),
                    "未找到奖励查询方法"
            ));
        }

        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> invokeBotMethod(
                        updateRewordMethod,
                        accountContext,
                        accountContextMap.get(accountContext.getAccountBaseInfoId())
                ),
                (accountContext, result) -> result,
                BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> botJobNameList() {
        return getJobParams().keySet();
    }


    protected abstract T getInstance();

    /**
     * 解析注解，添加botInfo
     */
    private BotInfo resolveAnnoBotInfo(BotApi botApi) throws SQLException {

        BotApplication annotation = getInstance().getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            //  解析bot 自定义配置, 看是否有满足的
            AutoBotConfig botConfig = getAutoBotConfig();
            Map<String, Object> customConfig = botConfig.getCustomConfig();
            for (String key : annotation.configParams()) {
                if (!customConfig.containsKey(key)) {
                    throw new IllegalArgumentException("缺乏Bot必要参数[%s]".formatted(key));
                }
            }

            BotInfo botInfo = null;

            // 解析bot job 参数
            Map<String, AutoBotJobParam> jobParamMap = resolveAnnoBotJobParams();

            // 查询是否存在botKey的bot
            Map<String, Object> query = new HashMap<>();
            query.put("name", botName);
            List<BotInfo> dbBotInfoList = botApi.getBotInfoRPC().conditionQuery(query);

            // 查询bot是否存在，不存在则创建
            if (dbBotInfoList == null || dbBotInfoList.isEmpty()) {
                logger.warn("不存在bot info, 自动创建...");
                botInfo = generateFromAnno(annotation);
            } else {
                botInfo = dbBotInfoList.getFirst();
            }

            botInfo.setJobParams(jobParamMap);
            if (botApi.getBotInfoRPC().insertOrUpdate(botInfo) == 1) {
                // 保存成还需查询botId
                Integer id = botApi.getBotInfoRPC().conditionQuery(query).getFirst().getId();
                botInfo.setId(id);
                logger.info("保存bot信息成功, id:" + botInfo.getId());
            }

            return botInfo;
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }


    /**
     * 解析注解中的方法
     */
    private Map<String, AutoBotJobParam> resolveAnnoBotJobParams() {
        Map<String, AutoBotJobParam> params = new HashMap<>();

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod, params);
                    case ONCE_TASK, TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod, params);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod, params);
                }
            }
        }

        return params;
    }

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 3
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
                && method.getParameters()[2].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                    "应为 Result methodName(AccountContext accountContext, List<AccountContext> sameAccountBaseInfoIdLists, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                    "应为 Result methodName(AccountContext ac");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
        ) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            AutoBotJobParam queryRewardJob = buildAutoBotJobParam(method, botJobMethod);

            params.put(queryRewardJob.getJobName(), queryRewardJob);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 Result methodName(AccountContext ac, List<AccountContext> sameAccountBaseInfoIdLists)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getParameterCount() > 2
                || method.getParameterCount() < 1
                || method.getParameters()[0].getType() != AccountContext.class
                || (method.getParameterCount() == 2 && method.getParameters()[1].getType() != List.class)
        ) {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 void methodName(AccountContext ac) 或 " +
                    "void methodName(AccountContext exampleAC, List<AccountContext> sameABIIdList) ");
        }

        AutoBotJobParam jobParam = buildAutoBotJobParam(method, botJobMethod);
        String jobName = jobParam.getJobName();

        params.put(jobName, jobParam);
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     * @param params           params
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno, Map<String, AutoBotJobParam> params) {
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (cn.com.helei.bot_father.websocket.BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                AutoBotJobParam jobParam = buildAutoBotJobParam(WebSocketClientLauncher.lanuchMethod, botJobMethodAnno);

                String jobName = jobParam.getJobName();
                AutoBotJobRuntimeParam runtimeParam = getJobRuntimeParamMap().get(jobName);

                if (runtimeParam != null) {
                    // 更改执行target，添加额外参数
                    runtimeParam.setTarget(webSocketClientLauncher);
                    runtimeParam.setExtraParams(new Object[]{jobParam, new AccountWSClientBuilder() {
                        @Override
                        public cn.com.helei.bot_father.websocket.BaseBotWSClient<?, ?> build(AccountContext accountContext) throws InvocationTargetException, IllegalAccessException {
                            Object invoke = method.invoke(getInstance(), accountContext);

                            return (cn.com.helei.bot_father.websocket.BaseBotWSClient<?, ?>) invoke;
                        }
                    }});
                }

                // 添加到jobMap
                params.put(jobName, jobParam);
            } catch (Exception e) {
                throw new BotMethodFormatException(e);
            }
        } else {
            throw new BotMethodFormatException("websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 根据方法注解创建 AutoBotJob
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     * @return AutoBotJobParam
     */
    private @NotNull AutoBotJobParam buildAutoBotJobParam(Method method, BotMethod botJobMethodAnno) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            String jobName = StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName();

            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
                logger.info("%s cronExpression:[%s]".formatted(jobName, cronExpression.getCronExpression()));
            } else if (botJobMethodAnno.jobType() != BotJobType.ONCE_TASK) {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            // 设置job运行时参数
            getJobRuntimeParamMap().put(
                    jobName,
                    AutoBotJobRuntimeParam.builder().bot(this).method(method).build()
            );

            // 构建job task参数
            autoBotJobParam = new AutoBotJobParam(
                    botJobMethodAnno.jobType(),
                    jobName,
                    botJobMethodAnno.description(),
                    botJobMethodAnno.cronExpression(),
                    intervalInSecond,
                    botJobMethodAnno.concurrentCount(),
                    generateFromAnno(botJobMethodAnno.bowWsConfig()),
                    botJobMethodAnno.uniqueAccount()
            );
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format("[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInfo().getName(), method.getName(), botJobMethodAnno.cronExpression()),
                    e
            );
        }

        return autoBotJobParam;
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInfo().getName(),
                        registerMethod.getName()
                ), e);
            }
        }, getExecutorService());
    }



    protected BotInfo generateFromAnno(BotApplication annotation) {
        BotInfo botInfo = new BotInfo();
        botInfo.setName(annotation.name());
        botInfo.setDescribe(annotation.describe());
        botInfo.setImage(annotation.image());
        botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
        botInfo.getParams().put(CONFIG_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.configParams())));
        botInfo.getParams().put(ACCOUNT_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.accountParams())));

        return botInfo;
    }

    protected AutoBotJobWSParam generateFromAnno(BotWSMethodConfig methodConfig) {
        return new AutoBotJobWSParam(
                methodConfig.isRefreshWSConnection(),
                methodConfig.wsUnlimitedRetry(),
                methodConfig.wsConnectCount(),
                methodConfig.reconnectLimit(),
                methodConfig.heartBeatIntervalSecond(),
                methodConfig.reconnectCountDownSecond()
        );
    }
}
package cn.com.helei.bot_father.bot;

import cn.com.helei.common.dto.ACListOptResult;
import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.job.dto.AutoBotJobRuntimeParam;
import cn.hutool.core.util.BooleanUtil;
import lombok.Getter;

import java.lang.reflect.Method;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

@Getter
public abstract class JobInvokeAutoBot extends AccountManageAutoBot implements AutoBotJobInvoker {

    private final Map<String, AutoBotJobRuntimeParam> jobRuntimeParamMap = new ConcurrentHashMap<>();

    private final Map<String, Method> jobMethodMap = new ConcurrentHashMap<>();

    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().registerJob(getJobRuntimeParamMap().get(jobName), getJobParam(jobName), this);
    }

    @Override
    public void invokeJob(AutoBotJobRuntimeParam runtimeParam, AutoBotJobParam param) {
        Object[] extraParams = runtimeParam.getExtraParams();

        String jobName = runtimeParam.getJobName();

        logger.info("开始执行[%s]定时任务".formatted(jobName));
        CompletableFuture<ACListOptResult> future = null;
        if (BooleanUtil.isTrue(param.getUniqueAccount())) {
            future = uniqueForEachAccount(extraParams, jobMethod, jobName);
        } else {
            future = normalForEachAccount(extraParams, jobMethod, jobName);
        }

        acListOptResultHandler(future);

        logger.info("[%s]定时任务执行完毕".formatted(jobName));
    }

    private CompletableFuture<ACListOptResult> normalForEachAccount(Object[] extraParams, Method jobMethod, String jobName) {
        return asyncForACList(
                accountContext -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // 封装参数
                        Object[] params;
                        if (extraParams == null) {
                            params = new Object[]{accountContext};
                        } else {
                            params = new Object[1 + extraParams.length];
                            params[0] = accountContext;
                            System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                        }

                        // 调用执行的job method
                        jobMethod.setAccessible(true);
                        Object invoke = jobMethod.invoke(this, params);
                        return Result.ok(invoke);
                    } catch (Exception e) {
                        logger.error("执行定时任务发生异常", e);
                        return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
                    }
                }, getExecutorService()),
                (accountContext, result) -> result,
                jobName
        );
    }


    private CompletableFuture<ACListOptResult> uniqueForEachAccount(Object[] extraParams, Method jobMethod, Object invokeObj, String jobName) {
        return uniqueAsyncForACList(
                (accountContext, accountContexts) -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // 封装参数
                        Object[] params;
                        if (extraParams == null) {
                            params = new Object[]{accountContext, accountContexts};
                        } else {
                            params = new Object[2 + extraParams.length];
                            params[0] = accountContext;
                            params[1] = accountContexts;
                            System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                        }

                        // 调用执行的job method
                        jobMethod.setAccessible(true);
                        Object invoke = jobMethod.invoke(invokeObj, params);
                        return Result.ok(invoke);
                    } catch (Exception e) {
                        logger.error("执行定时任务发生异常", e);
                        return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
                    }
                }, getExecutorService()),
                (accountContext, result) -> result,
                jobName
        );
    }

    public void acListOptResultHandler(CompletableFuture<ACListOptResult> future) {
        future.thenAcceptAsync(acListOptResult -> {
            if (!acListOptResult.getSuccess()) {
                log.info("botId[{}]-botName[{}]-jobName[{}] 定时任务执行失败, {}",
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                );
            } else {
                log.info("botId[{}]-botName[{}]-jobName[{}] 定时任务执行成功, {}/{}",
                        acListOptResult.getBotId(), acListOptResult.getBotName(),
                        acListOptResult.getJobName(), acListOptResult.getSuccessCount(), acListOptResult.getResults().size()
                );
            }
        });
    }
}
package cn.com.helei.bot_father.service;


import cn.com.helei.job.service.BotJobService;
import cn.com.helei.rpc.*;
import cn.com.helei.rpc.bot.IBotAccountRPC;
import cn.com.helei.rpc.bot.IRewordInfoRPC;

public interface BotApi {

    IProjectInfoRPC getProjectInfoRPC();

    IBotInfoRPC getBotInfoRPC();

    IAccountBaseInfoRPC getAccountBaseInfoRPC();

    IBrowserEnvRPC getBrowserEnvRPC();

    IDiscordAccountRPC getDiscordAccountRPC();

    IProxyInfoRPC getProxyInfoRPC();

    IRewordInfoRPC getRewordInfoRPC();

    ITwitterAccountRPC getTwitterAccountRPC();

    ITelegramAccountRPC getTelegramAccountRPC();


    IBotAccountRPC getBotAccountRPC();

    BotJobService getBotJobService();
}
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>cn.com.helei</groupId>
        <artifactId>BotFramework</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>bot-father</artifactId>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>db-layer</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>job</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>rpc-api</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>websocket</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>mail</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>



        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-quartz</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
        </dependency>

        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
</project>
package cn.com.helei.common.util;

import cn.com.helei.common.config.SystemConfig;

import java.io.*;
import java.nio.file.Path;
import java.util.List;

public class FileUtil {


    public static final String RESOURCE_ROOT_DIR = System.getProperty("user.dir") + File.separator + "botData";

    public static String getConfigDirResourcePath(List<String> path, String fileName) {
        StringBuilder sb = new StringBuilder(RESOURCE_ROOT_DIR);

        for (String p : path) {
            sb.append(File.separator).append(p);
        }
        return sb.append(File.separator).append(fileName).toString();
    }

    public static String getBotAppConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, SystemConfig.CONFIG_DIR_APP_PATH);
    }

    public static String getSystemConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, SystemConfig.CONFIG_DIR_BOT_PATH);
    }

    /**
     * 保存账户
     */
    public static void saveJSONStringContext(Path filePath, String jsonContext) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath.toFile()))) {
            writer.write(jsonContext);
            writer.flush();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String[] args) {
        System.out.println(getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, "account.yaml"));
    }
}
package cn.com.helei.job.core;

import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.dto.AutoBotJobRuntimeParam;

public interface AutoBotJobInvoker {


    void invokeJob(AutoBotJobRuntimeParam runtimeParam, AutoBotJobParam param);

}
package cn.com.helei.job.dto;

import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.job.service.BotJobService;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
@DisallowConcurrentExecution
public class AutoBotJob implements Job {

    public static final String BOT_JOB_PARAM_KEY = "bot_job_param";

    public static final String BOT_JOB_RUNTIME_PARAM_KEY = "bot_job_runtime_param";

    @Autowired
    private BotJobService botJobService;

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

        // 提取JobDataMap里的参数
        AutoBotJobParam autoBotJobParam = (AutoBotJobParam) jobDataMap.get(BOT_JOB_PARAM_KEY);
        AutoBotJobRuntimeParam autoBotJobRuntimeParam = (AutoBotJobRuntimeParam) jobDataMap.get(BOT_JOB_RUNTIME_PARAM_KEY);

        // 获取job调用者
        AutoBotJobInvoker invoker = botJobService.getJobInvoker(context.getJobDetail().getKey());

        // 调用invoke方法
        invoker.invokeJob(autoBotJobRuntimeParam, autoBotJobParam);
    }

}
package cn.com.helei.job.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AutoBotJobRuntimeParam {

    private Integer botId;

    private String botKey;

    private String jobName;

    private Object[] extraParams;
}
package cn.com.helei.job.service.impl;

import cn.com.helei.common.constants.BotJobType;
import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.dto.AutoBotJob;
import cn.com.helei.job.dto.AutoBotJobRuntimeParam;
import cn.com.helei.job.service.BotJobService;
import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import static cn.com.helei.job.dto.AutoBotJob.BOT_JOB_PARAM_KEY;
import static cn.com.helei.job.dto.AutoBotJob.BOT_JOB_RUNTIME_PARAM_KEY;


@Slf4j
@Service
public class QuartzBotJobService implements BotJobService {

    private final ConcurrentMap<JobKey, AutoBotJobInvoker> invokerMap;

    private final Scheduler scheduler;

    public QuartzBotJobService(Scheduler scheduler) {
        this.scheduler = scheduler;
        this.invokerMap = new ConcurrentHashMap<>();
    }

    @Override
    public List<BotACJobResult> registerJobList(AutoBotJobRuntimeParam runtimeParam, Collection<AutoBotJobParam> autoBotJobParams, AutoBotJobInvoker invoker) {

        List<BotACJobResult> resultList = new ArrayList<>(autoBotJobParams.size());

        for (AutoBotJobParam autoBotJob : autoBotJobParams) {
            resultList.add(registerJob(runtimeParam, autoBotJob, invoker));
        }

        return resultList;
    }


    @Override
    public BotACJobResult registerJob(AutoBotJobRuntimeParam runtimeParam, AutoBotJobParam jobParam, AutoBotJobInvoker invoker) {

        String group = runtimeParam.getBotKey();

        BotACJobResult result = BotACJobResult.builder()
                .botId(runtimeParam.getBotId())
                .group(group)
                .jobName(jobParam.getJobName())
                .success(true)
                .build();

        JobKey jobKey = new JobKey(jobParam.getJobName(), group);

        try {
            // 存在这个job
            if (scheduler.checkExists(jobKey)) {
                result.setSuccess(false);
                result.setErrorMsg("job exist");
            } else {
                JobDataMap jobDataMap = new JobDataMap();
                jobDataMap.put(BOT_JOB_PARAM_KEY, jobParam);
                jobDataMap.put(BOT_JOB_RUNTIME_PARAM_KEY, runtimeParam);

                // 不存在，创建并运行
                JobDetail jobDetail = JobBuilder.newJob(AutoBotJob.class)
                        .withIdentity(jobKey)
                        .withDescription(jobParam.getDescription())
                        .setJobData(jobDataMap)
                        .storeDurably()
                        .build();

                TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger()
                        .withIdentity(jobParam.getJobName(), group)
                        .startNow();

                if (BotJobType.ONCE_TASK.equals(jobParam.getJobType())) {
                    triggerBuilder
                            .startNow();  // 立即开始
                } else if (jobParam.getIntervalInSecond() != null) {
                    triggerBuilder
                            .withSchedule(SimpleScheduleBuilder
                                    .simpleSchedule()
                                    .withIntervalInSeconds(jobParam.getIntervalInSecond())
                                    .repeatForever()
                            );
                } else if (jobParam.getCronExpression() != null) {
                    triggerBuilder
                            .withSchedule(CronScheduleBuilder.cronSchedule(jobParam.getCronExpression()));
                }

                scheduler.scheduleJob(jobDetail, triggerBuilder.build());
            }

            invokerMap.put(jobKey, invoker);
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMsg(e.getMessage());

            log.error("注册[{}]job发生异常", jobKey, e);
        }

        return result;
    }

    @Override
    public AutoBotJobInvoker getJobInvoker(JobKey jobKey) {
        return invokerMap.get(jobKey);
    }
}
package cn.com.helei.job.service;


import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.dto.AutoBotJobRuntimeParam;
import org.quartz.JobKey;

import java.util.Collection;
import java.util.List;

public interface BotJobService {

    /**
     * 批量注册job
     *
     * @param autoBotJobParams autoBotJobParams
     * @return Result
     */
    List<BotACJobResult> registerJobList(AutoBotJobRuntimeParam runtimeParam, Collection<AutoBotJobParam> autoBotJobParams, AutoBotJobInvoker invoker);

    /**
     * 注册job，开始定时执行
     *
     * @param runtimeParam    runtimeParam
     * @param autoBotJobParam autoBotJobParam
     * @return BotACJobResult
     */
    BotACJobResult registerJob(AutoBotJobRuntimeParam runtimeParam, AutoBotJobParam autoBotJobParam, AutoBotJobInvoker invoker);

    /**
     * 获取job的调用者
     *
     * @param jobKey jobKey
     * @return invoker
     */
    AutoBotJobInvoker getJobInvoker(JobKey jobKey);
}
package cn.com.helei.job;

import org.quartz.spi.JobFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.quartz.SchedulerFactoryBean;
import org.springframework.scheduling.quartz.SpringBeanJobFactory;

import javax.sql.DataSource;

@Configuration
public class JobAutoConfig {

    @Autowired
    @Qualifier("quartzDataSource")
    private DataSource quartzDataSource;

    @Bean
    public SchedulerFactoryBean schedulerFactoryBean() {
        SchedulerFactoryBean factoryBean = new SchedulerFactoryBean();

        factoryBean.setDataSource(quartzDataSource);
        factoryBean.setJobFactory(springBeanJobFactory());
        return factoryBean;
    }

    @Bean
    public JobFactory springBeanJobFactory() {
        return new SpringBeanJobFactory();
    }
}
spring:
  datasource:
    quartz:
      url: ""
      username: ""
      password: ""
      driver-class-name: com.mysql.cj.jdbc.Driver
      hikari:
        maximum-pool-size: 10
  quartz:
    jdbc:
      initialize-schema: never
    job-store-type: jdbc
#
# Quartz seems to work best with the driver mm.mysql-2.0.7-bin.jar
#
# PLEASE consider using mysql with innodb tables to avoid locking issues
#
# In your Quartz properties file, you'll need to set
# org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate
#

DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;
DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;
DROP TABLE IF EXISTS QRTZ_LOCKS;
DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;
DROP TABLE IF EXISTS QRTZ_CALENDARS;


CREATE TABLE QRTZ_JOB_DETAILS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    JOB_NAME  VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    JOB_CLASS_NAME   VARCHAR(250) NOT NULL,
    IS_DURABLE VARCHAR(1) NOT NULL,
    IS_NONCONCURRENT VARCHAR(1) NOT NULL,
    IS_UPDATE_DATA VARCHAR(1) NOT NULL,
    REQUESTS_RECOVERY VARCHAR(1) NOT NULL,
    JOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
);

CREATE TABLE QRTZ_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    JOB_NAME  VARCHAR(200) NOT NULL,
    JOB_GROUP VARCHAR(200) NOT NULL,
    DESCRIPTION VARCHAR(250) NULL,
    NEXT_FIRE_TIME BIGINT(13) NULL,
    PREV_FIRE_TIME BIGINT(13) NULL,
    PRIORITY INTEGER NULL,
    TRIGGER_STATE VARCHAR(16) NOT NULL,
    TRIGGER_TYPE VARCHAR(8) NOT NULL,
    START_TIME BIGINT(13) NOT NULL,
    END_TIME BIGINT(13) NULL,
    CALENDAR_NAME VARCHAR(200) NULL,
    MISFIRE_INSTR SMALLINT(2) NULL,
    JOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP)
        REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP)
);

CREATE TABLE QRTZ_SIMPLE_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    REPEAT_COUNT BIGINT(7) NOT NULL,
    REPEAT_INTERVAL BIGINT(12) NOT NULL,
    TIMES_TRIGGERED BIGINT(10) NOT NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CRON_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    CRON_EXPRESSION VARCHAR(200) NOT NULL,
    TIME_ZONE_ID VARCHAR(80),
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_SIMPROP_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    STR_PROP_1 VARCHAR(512) NULL,
    STR_PROP_2 VARCHAR(512) NULL,
    STR_PROP_3 VARCHAR(512) NULL,
    INT_PROP_1 INT NULL,
    INT_PROP_2 INT NULL,
    LONG_PROP_1 BIGINT NULL,
    LONG_PROP_2 BIGINT NULL,
    DEC_PROP_1 NUMERIC(13,4) NULL,
    DEC_PROP_2 NUMERIC(13,4) NULL,
    BOOL_PROP_1 VARCHAR(1) NULL,
    BOOL_PROP_2 VARCHAR(1) NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
    REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_BLOB_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    BLOB_DATA BLOB NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),
    FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
        REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CALENDARS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    CALENDAR_NAME  VARCHAR(200) NOT NULL,
    CALENDAR BLOB NOT NULL,
    PRIMARY KEY (SCHED_NAME,CALENDAR_NAME)
);

CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    TRIGGER_GROUP  VARCHAR(200) NOT NULL,
    PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP)
);

CREATE TABLE QRTZ_FIRED_TRIGGERS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    ENTRY_ID VARCHAR(95) NOT NULL,
    TRIGGER_NAME VARCHAR(200) NOT NULL,
    TRIGGER_GROUP VARCHAR(200) NOT NULL,
    INSTANCE_NAME VARCHAR(200) NOT NULL,
    FIRED_TIME BIGINT(13) NOT NULL,
    SCHED_TIME BIGINT(13) NOT NULL,
    PRIORITY INTEGER NOT NULL,
    STATE VARCHAR(16) NOT NULL,
    JOB_NAME VARCHAR(200) NULL,
    JOB_GROUP VARCHAR(200) NULL,
    IS_NONCONCURRENT VARCHAR(1) NULL,
    REQUESTS_RECOVERY VARCHAR(1) NULL,
    PRIMARY KEY (SCHED_NAME,ENTRY_ID)
);

CREATE TABLE QRTZ_SCHEDULER_STATE
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    INSTANCE_NAME VARCHAR(200) NOT NULL,
    LAST_CHECKIN_TIME BIGINT(13) NOT NULL,
    CHECKIN_INTERVAL BIGINT(13) NOT NULL,
    PRIMARY KEY (SCHED_NAME,INSTANCE_NAME)
);

CREATE TABLE QRTZ_LOCKS
  (
    SCHED_NAME VARCHAR(120) NOT NULL,
    LOCK_NAME  VARCHAR(40) NOT NULL,
    PRIMARY KEY (SCHED_NAME,LOCK_NAME)
);


commit;
