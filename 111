package cn.com.helei.bot.app.depin_3_dos;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.RewordInfo;
import cn.com.helei.bot.core.supporter.mail.constants.MailProtocolType;
import cn.com.helei.bot.core.supporter.mail.factory.MailReaderFactory;
import cn.com.helei.bot.core.supporter.mail.reader.MailReader;
import cn.com.helei.bot.core.util.exception.LoginException;
import cn.com.helei.bot.core.util.exception.RegisterException;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.select.Elements;

import javax.mail.Message;
import javax.mail.internet.MimeMultipart;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
public class ThreeDosApi {

    private static final String REGISTER_API = "https://api.dashboard.3dos.io/api/auth/register";

    private static final String LOGIN_API = "https://api.dashboard.3dos.io/api/auth/login";

    private static final String KEEP_ALIVE_API = "https://m8k9mykqqj.us-east-1.awsapprunner.com/api/harvest-data";

    private static final String REWORD_QUERY_API = "https://api.dashboard.3dos.io/api/profile/me";

    private static final String RESEND_EMAIL_API = "https://api.dashboard.3dos.io/api/email/resend";

    private static final String GENERATE_KEY_API = "https://api.dashboard.3dos.io/api/profile/generate-api-key";

    private static final String HARVESTED_DATA = "Download Tokopedia App\nTentang Tokopedia\nMitra Tokopedia\nMulai Berjualan\nPromo\nTokopedia Care\nKategori\nMasuk\nDaftar\nSamsung Note 10\nCharger Mobil\nSamsung A73\nPull Up Bar\nHdd 1tb\nXbox Series X\nKe slide 1\nKe slide 2\nKe slide 3\nKe slide 4\nKe slide 5\nLihat Promo Lainnya\nprev\nnext";

    private static final String HARVESTED_URL = "https://github.com/airdropinsiders?tab=repositories";

    private static final String PASSWORD_KEY = "password";

    private static final String SECRET_KEY = "api_secret";

    private static final String TOKEN_KEY = "token";

    private static final String TOKEN_EXPIRE = "token_expire";

    private static final String MAIL_FROM = "3DOS <noreply@3dos.io>";

    private static final String MAIL_CSS_SELECTOR = "body > div > div.content > div > a";

    private static final MailReader mailReader = MailReaderFactory.getMailReader(MailProtocolType.imap,
            "imap.gmail.com", "993", true);

    private final ThreeDosBot bot;

    public ThreeDosApi(ThreeDosBot bot) {
        this.bot = bot;
    }

    public Result register(AccountContext exampleAC, List<AccountContext> sameABIIdList, String inviteCode) {

        JSONObject body = new JSONObject();
        body.put("country_id", "233");
        body.put("acceptTerms", true);
        body.put("referred_by", inviteCode);

        AccountBaseInfo accountBaseInfo = exampleAC.getAccountBaseInfo();
        body.put("email", accountBaseInfo.getEmail());
        body.put("password", exampleAC.getParam(PASSWORD_KEY));

        Map<String, String> headers = exampleAC.getBrowserEnv().generateHeaders();
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");


        try {
            CompletableFuture<Boolean> future = bot.syncRequest(
                    exampleAC.getProxy(),
                    REGISTER_API,
                    HttpMethod.POST,
                    headers,
                    null,
                    body,
                    () -> exampleAC.getSimpleInfo() + " 开始注册"
            ).thenApplyAsync(responseStr -> {
                JSONObject result = JSONObject.parseObject(responseStr);

                if (BooleanUtil.isTrue(result.getBoolean("flag"))) {
                    bot.logger.info(exampleAC.getSimpleInfo() + "注册成功");
                    return true;
                } else {
                    JSONArray data = result.getJSONArray("data");
                    for (int i = 0; i < data.size(); i++) {
                        if ("The email has already been taken.".equals(data.getString(i))) {
                            bot.logger.warn(exampleAC.getSimpleInfo() + "邮箱已被注册");
                            return true;
                        }
                    }
                    throw new RegisterException(exampleAC.getSimpleInfo() + "注册失败, " + responseStr);
                }
            }, bot.getExecutorService());

            future.get();
            return Result.ok();
        } catch (Exception e) {
            bot.logger.error(exampleAC.getSimpleInfo() + "注册失败，", e.getCause());
            return Result.fail("注册失败, " + e.getMessage());
        }
    }

    public void resendEmail(AccountContext exampleAC, List<AccountContext> accountContexts) {
        String token = exampleAC.getParam(TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            return;
        }

        Map<String, String> headers = createAuthHeader(exampleAC, token);

        CompletableFuture<String> query = bot.syncRequest(
                exampleAC.getProxy(),
                RESEND_EMAIL_API,
                HttpMethod.GET,
                headers,
                null,
                null,
                () -> exampleAC.getSimpleInfo() + " 请求重发验证邮件"
        );

        try {
            String responseStr = query.get();

            bot.logger.info("%s 验证邮件重发成功,  %s".formatted(exampleAC.getSimpleInfo(), responseStr));
        } catch (InterruptedException | ExecutionException e) {
            String errorMsg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();
            bot.logger.error("%s 验证邮件重发失败, %s".formatted(exampleAC.getSimpleInfo(), errorMsg));
        }
    }

    public void checkEmail(AccountContext accountContext) {
        AccountBaseInfo accountBaseInfo = accountContext.getAccountBaseInfo();

        bot.logger.info("开始验证邮箱 " + accountBaseInfo.getEmail());
        String emailPassword = (String) accountBaseInfo.getParams().get("imap_password");
        emailPassword = emailPassword.replace(" ", "").replace(" ", "");

        AtomicReference<String> link = new AtomicReference<>("");
        mailReader.stoppableReadMessage(
                accountBaseInfo.getEmail(),
                emailPassword,
                3,
                message -> {
                    String newValue = resolveLinkFromMessage(message);
                    link.set(newValue);
                    return StrUtil.isNotBlank(newValue);
                }
        );

        if (StrUtil.isNotBlank(link.get())) {
            bot.logger.info("邮箱[%s]验证链接获取成功, %s".formatted(accountBaseInfo.getEmail(), link));
            try {
                bot.syncRequest(
                        accountContext.getProxy(),
                        link.get(),
                        HttpMethod.GET,
                        accountContext.getBrowserEnv().generateHeaders(),
                        null,
                        null,
                        () -> "点击邮箱[%s]验证链接[%s]".formatted(accountBaseInfo.getEmail(), link),
                        3
                ).get();

            } catch (InterruptedException | ExecutionException e) {
                bot.logger.error("[%s]邮箱验证失败".formatted(accountBaseInfo.getEmail()), e);
            }
        } else {
            bot.logger.error("[%s]验证链接提取失败".formatted(accountBaseInfo.getEmail()));
        }
    }


    private String resolveLinkFromMessage(Message message) {
        try {
            boolean b = Arrays.stream(message.getFrom())
                    .anyMatch(address -> MAIL_FROM.equals(address.toString()));
            if (!b) return null;

            MimeMultipart mimeMultipart = (MimeMultipart) message.getContent();

            String htmlStr = mimeMultipart.getBodyPart(1).getContent().toString();

            Document document = Jsoup.parse(htmlStr);
            // 使用 CSS 选择器提取 a 标签内容
            Elements linkElement = document.select(MAIL_CSS_SELECTOR);
            return linkElement.attr("href");
        } catch (Exception e) {
            throw new RuntimeException("从邮件提取链接出错", e);
        }
    }

    public Result login(AccountContext accountContext) {
        String existToken = accountContext.getParam(TOKEN_KEY);
        String expireStr = accountContext.getParam(TOKEN_EXPIRE);
        if (StrUtil.isNotBlank(existToken)
                && StrUtil.isNotBlank(expireStr)
                && System.currentTimeMillis() - Long.parseLong(expireStr) < 0
        ) {
            bot.logger.warn("%s 已有可用token".formatted(accountContext.getSimpleInfo()));
            return Result.ok();
        }

        JSONObject body = new JSONObject();
        body.put("email", accountContext.getAccountBaseInfo().getEmail());
        body.put("password", accountContext.getParam(PASSWORD_KEY));

        Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");

        CompletableFuture<String> tokenFuture = bot.syncRequest(
                accountContext.getProxy(),
                LOGIN_API,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> accountContext.getSimpleInfo() + " 开始登录"
        ).thenApplyAsync(responseStr -> {
            JSONObject result = JSONObject.parseObject(responseStr);

            if (BooleanUtil.isTrue(result.getBoolean("flag"))) {
                bot.logger.info(accountContext.getSimpleInfo() + "登录成功");
                JSONObject data = result.getJSONObject("data");

                accountContext.setParam(TOKEN_EXPIRE, System.currentTimeMillis() + data.getInteger("expires_in") * 1000);
                return data.getString("access_token");
            }
            throw new LoginException("登录获取token失败," + responseStr);
        });

        try {
            String token = tokenFuture.get();
            bot.logger.info("%s 登录成功, token: %s".formatted(accountContext.getSimpleInfo(), token));
            return Result.ok(token);
        } catch (InterruptedException | ExecutionException e) {
            bot.logger.error("%s 登录失败".formatted(accountContext.getSimpleInfo()), e);
            return Result.fail("登录失败, " + e.getMessage());
        }
    }

    public void keepLive(AccountContext accountContext) {
        String secretKey = accountContext.getParam(SECRET_KEY);
        if (StrUtil.isBlank(secretKey)) {
            bot.logger.warn(accountContext.getSimpleInfo() + " 没有secret key");
            return;
        }
        JSONObject body = new JSONObject();
        body.put("apiSecret", secretKey);
        body.put("harvestedData", HARVESTED_DATA);
        body.put("url", HARVESTED_URL);

        Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();

        CompletableFuture<String> request = bot.syncRequest(
                accountContext.getProxy(),
                KEEP_ALIVE_API,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> accountContext.getSimpleInfo() + "发生心跳..."
        );

        try {
            String responseStr = request.get();
            bot.logger.info("%s 发送心跳成功, %s".formatted(accountContext.getSimpleInfo(), responseStr));
        } catch (InterruptedException | ExecutionException e) {
            bot.logger.error("%s 发送心跳失败, %s".formatted(accountContext.getSimpleInfo(),
                    e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
        }
    }


    public Result updateAccount(AccountContext exampleAC, List<AccountContext> sameABIIdList) {
        String token = exampleAC.getParam(TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            bot.logger.warn("%s token为空".formatted(exampleAC.getSimpleInfo()));
            return Result.fail("token为空");
        }

        Map<String, String> headers = createAuthHeader(exampleAC, token);

        CompletableFuture<String> query = bot.syncRequest(
                exampleAC.getProxy(),
                REWORD_QUERY_API,
                HttpMethod.POST,
                headers,
                null,
                new JSONObject(),
                () -> exampleAC.getSimpleInfo() + " 开始更新账户信息"
        );

        try {
            String responseStr = query.get();

            JSONObject result = JSONObject.parseObject(responseStr);
            JSONObject data = result.getJSONObject("data");

            String apiSecret = data.getString("api_secret");
            for (AccountContext ac : sameABIIdList) {
                RewordInfo rewordInfo = ac.getRewordInfo();
                rewordInfo.setDailyPoints(data.getDouble("todays_earning"));
                rewordInfo.setTotalPoints(data.getDouble("loyalty_points"));
                ac.setParam(SECRET_KEY, apiSecret);
            }

            bot.logger.info("%s 更新账户信息成功, api_secret -> %s".formatted(exampleAC.getSimpleInfo(), apiSecret));
            return Result.ok();
        } catch (InterruptedException | ExecutionException e) {
            String errorMsg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();
            bot.logger.info("%s 更新账户信息失败, %s".formatted(exampleAC.getSimpleInfo(), errorMsg));
            return Result.fail("更新账户信息失败, " + errorMsg);
        }
    }

    public void generateSecretKey(AccountContext accountContext) {
        String token = accountContext.getParam(TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            bot.logger.warn("%s token为空".formatted(accountContext.getSimpleInfo()));
            return;
        }

        Map<String, String> headers = createAuthHeader(accountContext, token);

        CompletableFuture<String> query = bot.syncRequest(
                accountContext.getProxy(),
                GENERATE_KEY_API,
                HttpMethod.POST,
                headers,
                null,
                new JSONObject(),
                () -> accountContext.getSimpleInfo() + " 开始获取secret key"
        );

        try {
            String responseStr = query.get();

            JSONObject result = JSONObject.parseObject(responseStr);
            JSONObject data = result.getJSONObject("data");
            if (data == null) {
                bot.logger.warn("%s secret key获取失败, %s".formatted(accountContext.getSimpleInfo(), responseStr));
            } else {
                String key = data.getString(SECRET_KEY);
                accountContext.setParam(SECRET_KEY, key);
                bot.logger.info("%s secret key获取成功, api_secret -> %s".formatted(accountContext.getSimpleInfo(), key));
            }
        } catch (InterruptedException | ExecutionException e) {
            String errorMsg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();
            bot.logger.info("%s secret key获取失败, %s".formatted(accountContext.getSimpleInfo(), errorMsg));
        }
    }

    @NotNull
    private static Map<String, String> createAuthHeader(AccountContext accountContext, String token) {
        Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();
        headers.put("Authorization", "Bearer " + token);
        headers.put("Origin", "https://dashboard.3dos.io");
        headers.put("Referer", "https://dashboard.3dos.io/");
        return headers;
    }
}
package cn.com.helei.bot.app.depin_3_dos;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;

import java.util.List;

@BotApplication(
        name = "three_dos_bot",
        configParams = {"inviteCode"},
        accountParams = {"password", "token"}
)
public class ThreeDosBot extends AnnoDriveAutoBot<ThreeDosBot> {

    private final ThreeDosApi threeDosApi;

    public ThreeDosBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);
        this.threeDosApi = new ThreeDosApi(this);
    }

    @BotMethod(jobType = BotJobType.REGISTER, jobName = "自动注册")
    public Result autoRegister(AccountContext exampleAC, List<AccountContext> sameABIIdList, String inviteCode) {
        return threeDosApi.register(exampleAC, sameABIIdList, inviteCode);
    }

    @BotMethod(jobType = BotJobType.LOGIN, jobName = "自动获取token")
    public Result login(AccountContext accountContext) {
        return threeDosApi.login(accountContext);
    }

    @BotMethod(jobType = BotJobType.QUERY_REWARD, jobName = "奖励查询", intervalInSecond = 300, uniqueAccount = true)
    public Result queryReward(AccountContext exampleAC, List<AccountContext> sameABIIdList) {
        return threeDosApi.updateAccount(exampleAC, sameABIIdList);
    }

    @BotMethod(jobType = BotJobType.ONCE_TASK, jobName = "重发验证邮件", uniqueAccount = true)
    public void resendEmail(AccountContext exampleAC, List<AccountContext> sameABIIdList) {
        threeDosApi.resendEmail(exampleAC, sameABIIdList);
    }

    @BotMethod(jobType = BotJobType.ONCE_TASK)
    public void checkEmail(AccountContext accountContext) {
        threeDosApi.checkEmail(accountContext);
    }

    @BotMethod(jobType = BotJobType.ONCE_TASK, jobName = "生成秘钥")
    public void generateSecretKey(AccountContext accountContext) {
        threeDosApi.generateSecretKey(accountContext);
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 30)
    public void keepAlivePing(AccountContext accountContext) {
        threeDosApi.keepLive(accountContext);
    }

    @Override
    protected ThreeDosBot getInstance() {
        return this;
    }
}
package cn.com.helei.bot.core.bot.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotApplication {

    /**
     * bot 名字
     *
     * @return name
     */
    String name();

    /**
     * 描述
     *
     * @return 描述
     */
    String describe() default "";

    /**
     * 图片url
     *
     * @return url
     */
    String image() default "";

    /**
     * 适用项目的id
     *
     * @return id
     */
    int[] limitProjectIds() default {};

    /**
     * 设置参数
     *
     * @return String
     */
    String[] configParams() default {};

    /**
     * 账户需要的参数 AccountContext.params
     *
     * @return String
     */
    String[] accountParams() default {};
}
package cn.com.helei.bot.core.bot.anno;

import cn.com.helei.bot.core.bot.constants.BotJobType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotMethod {

    /**
     * job类型
     *
     * @return BotJobType
     */
    BotJobType jobType();

    /**
     * jobName
     *
     * @return string
     */
    String jobName() default "";

    /**
     * 描述
     *
     * @return String
     */
    String description() default "";

    /**
     * 时间表达式
     *
     * @return String
     */
    String cronExpression() default "";

    /**
     * 运行间隔
     *
     * @return int
     */
    int intervalInSecond() default 0;

    /**
     * 并发数
     *
     * @return int
     */
    int concurrentCount() default 20;

    /**
     * 是否区分账户
     * @return
     */
    boolean uniqueAccount() default false;

    BotWSMethodConfig bowWsConfig() default @BotWSMethodConfig();
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.bot.AccountWSClientBuilder;
import cn.com.helei.bot.core.bot.WebSocketClientLauncher;
import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.bot.job.AutoBotJobRuntimeParam;
import cn.com.helei.bot.core.bot.job.AutoBotJobWSParam;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.util.exception.BotMethodFormatException;
import cn.com.helei.bot.core.util.exception.BotMethodInvokeException;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONArray;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;

import java.lang.reflect.Array;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;


import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T> extends AccountManageAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher = new WebSocketClientLauncher(this);

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;


    public AnnoDriveAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        super(autoBotConfig, botApi);
    }

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() {
        // 解析bot 基本信息
        return resolveAnnoBotInfo(getBotApi());
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.REGISTER.name(),
                    "未找到注册方法"
            ));
        }
        return uniqueAsyncForACList(
                (accountContext, accountContexts) -> {
                    if (BooleanUtil.isTrue(accountContext.isSignUp())) {
                        // 账户注册过，
                        String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(), accountContext.getName(),
                                accountContext.getAccountBaseInfo().getEmail());

                        log.warn(errorMsg);

                        return CompletableFuture.completedFuture(Result.fail(errorMsg));
                    } else if (registerMethod != null) {
                        // 调用注册方法注册
                        return invokeBotMethod(
                                registerMethod,
                                accountContext,
                                accountContexts,
                                getAutoBotConfig().getConfig(INVITE_CODE_KEY)
                        ).thenApplyAsync(result -> {
                            if (result.getSuccess()) {
                                for (AccountContext ac : accountContexts) {
                                    AccountContext.signUpSuccess(ac);
                                }
                            }
                            return result;
                        });
                    } else {
                        return CompletableFuture.completedFuture(Result.fail("未知错误"));
                    }
                },
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        //注册成功
                        AccountContext.signUpSuccess(accountContext);
                    }
                    return result;
                },
                BotJobType.REGISTER.name()
        );
    }


    @Override
    protected void doInit() throws DepinBotInitException {
        super.doInit();
    }

    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (loginMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.LOGIN.name(),
                    "未找到登录方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(
                        loginMethod,
                        accountContext
                ),
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        String token = result.getData() == null ? null :
                                (result.getData() instanceof String ? (String) result.getData() : null);

                        // token不为空，设置到accountContext里
                        if (StrUtil.isNotBlank(token)) {
                            accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                        } else {
                            log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                        }
                    }
                    return result;
                },
                BotJobType.LOGIN.name()
        );
    }


    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (updateRewordMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.QUERY_REWARD.name(),
                    "未找到奖励查询方法"
            ));
        }

        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> invokeBotMethod(
                        updateRewordMethod,
                        accountContext,
                        accountContextMap.get(accountContext.getAccountBaseInfoId())
                ),
                (accountContext, result) -> result,
                BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> botJobNameList() {
        return getJobParams().keySet();
    }

    @Override
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().registerJob(getJobRuntimeParamMap().get(jobName), getJobParam(jobName));
    }

    protected abstract T getInstance();


    public CompletableFuture<ACListOptResult> uniqueAsyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        Pair<List<AccountContext>, Map<Integer, List<AccountContext>>> pair = getUniAccountContexts();
        List<AccountContext> uniAccountContexts = pair.getKey();
        Map<Integer, List<AccountContext>> accountContextMap = pair.getValue();

        return asyncForACList(
                uniAccountContexts,
                accountContext -> buildResultFuture.apply(accountContext, accountContextMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }


    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .filter(this::checkAccountContainsParams)
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult;
                    CompletableFuture<Result> future;

                    try {
                        botACJobResult = new BotACJobResult(
                                getBotInfo().getId(),
                                getBotInfo().getName(),
                                jobName,
                                accountContext.getId()
                        );

                        future = buildResultFuture.apply(accountContext);

                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        throw new RuntimeException(e);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) success++;

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            log.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInfo().getId(),
                                            getBotInfo().getName(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInfo().getId())
                            .botName(getBotInfo().getName())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 检查账户是否含有指定参数
     *
     * @param accountContext accountContext
     * @return boolean
     */
    private boolean checkAccountContainsParams(AccountContext accountContext) {
        // 过滤掉没有账户需要参数的
        Object o = getBotInfo().getParams().get(BotInfo.ACCOUNT_PARAMS_KEY);
        // 使用的json序列化进db，反序列化得到的是JsonArray
        if (o instanceof JSONArray jsonArray) {
            for (Object obj : jsonArray) {
                String key = (String) obj;
                if (accountContext.getParam(key) == null) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 解析注解，添加botInfo
     */
    private BotInfo resolveAnnoBotInfo(BotApi botApi) {

        BotApplication annotation = this.getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            //  解析bot 自定义配置, 看是否有满足的
            AutoBotConfig botConfig = getAutoBotConfig();
            Map<String, Object> customConfig = botConfig.getCustomConfig();
            for (String key : annotation.configParams()) {
                if (!customConfig.containsKey(key)) {
                    throw new IllegalArgumentException("缺乏Bot必要参数[%s]".formatted(key));
                }
            }

            BotInfo botInfo = null;

            BotInfo dbBotInfo = botApi.getBotInfoService().query().eq("name", botName).one();

            // 解析bot job 参数
            Map<String, AutoBotJobParam> jobParamMap = resolveAnnoBotJobParams();

            // 查询bot是否存在，不存在则创建
            if (dbBotInfo == null) {
                botInfo = BotInfo.generateFromAnno(annotation);

                botInfo.setJobParams(jobParamMap);

                logger.warn("不存在bot info, 自动创建...");

                try {
                    if (botApi.getBotInfoService().insertOrUpdate(botInfo) == 1) {
                        // 保存成还需查询botId
                        Integer id = botApi.getBotInfoService().query().select("id").eq("name", botName).one().getId();
                        botInfo.setId(id);
                        logger.info("保存bot信息成功, id:" + botInfo.getId());
                    }
                } catch (Exception e) {
                    throw new RuntimeException(botName + " 保存Bot信息失败", e);
                }
            } else {
                botInfo = dbBotInfo;

                botInfo.setJobParams(jobParamMap);
                getBotApi().getBotInfoService().insertOrUpdate(botInfo);
            }

            return botInfo;
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }


    /**
     * 解析注解中的方法
     */
    private Map<String, AutoBotJobParam> resolveAnnoBotJobParams() {
        Map<String, AutoBotJobParam> params = new HashMap<>();

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod, params);
                    case ONCE_TASK, TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod, params);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod, params);
                }
            }
        }

        return params;
    }

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 3
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
                && method.getParameters()[2].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                    "应为 Result methodName(AccountContext accountContext, List<AccountContext> sameAccountBaseInfoIdLists, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                    "应为 Result methodName(AccountContext ac");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
        ) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            AutoBotJobParam queryRewardJob = buildAutoBotJobParam(method, botJobMethod);

            params.put(queryRewardJob.getJobName(), queryRewardJob);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 Result methodName(AccountContext ac, List<AccountContext> sameAccountBaseInfoIdLists)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param params       params
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> params) {
        if (method.getParameterCount() > 2
                || method.getParameterCount() < 1
                || method.getParameters()[0].getType() != AccountContext.class
                || (method.getParameterCount() == 2 && method.getParameters()[1].getType() != List.class)
        ) {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 void methodName(AccountContext ac) 或 " +
                    "void methodName(AccountContext exampleAC, List<AccountContext> sameABIIdList) ");
        }

        AutoBotJobParam jobParam = buildAutoBotJobParam(method, botJobMethod);
        String jobName = jobParam.getJobName();

        params.put(jobName, jobParam);
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     * @param params           params
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno, Map<String, AutoBotJobParam> params) {
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                AutoBotJobParam jobParam = buildAutoBotJobParam(WebSocketClientLauncher.lanuchMethod, botJobMethodAnno);

                String jobName = jobParam.getJobName();
                AutoBotJobRuntimeParam runtimeParam = getJobRuntimeParamMap().get(jobName);

                if (runtimeParam != null) {
                    // 更改执行target，添加额外参数
                    runtimeParam.setTarget(webSocketClientLauncher);
                    runtimeParam.setExtraParams(new Object[]{jobParam, new AccountWSClientBuilder() {
                        @Override
                        public BaseBotWSClient<?, ?> build(AccountContext accountContext) throws InvocationTargetException, IllegalAccessException {
                            Object invoke = method.invoke(getInstance(), accountContext);

                            return (BaseBotWSClient<?, ?>) invoke;
                        }
                    }});
                }

                // 添加到jobMap
                params.put(jobName, jobParam);
            } catch (Exception e) {
                throw new BotMethodFormatException(e);
            }
        } else {
            throw new BotMethodFormatException("websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 根据方法注解创建 AutoBotJob
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     * @return AutoBotJobParam
     */
    private @NotNull AutoBotJobParam buildAutoBotJobParam(Method method, BotMethod botJobMethodAnno) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
            } else if (botJobMethodAnno.jobType() != BotJobType.ONCE_TASK) {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            String jobName = StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName();

            // 设置job运行时参数
            getJobRuntimeParamMap().put(
                    jobName,
                    AutoBotJobRuntimeParam.builder().bot(this).method(method).build()
            );

            // 构建job task参数
            autoBotJobParam = new AutoBotJobParam(
                    botJobMethodAnno.jobType(),
                    jobName,
                    botJobMethodAnno.description(),
                    cronExpression,
                    intervalInSecond,
                    botJobMethodAnno.concurrentCount(),
                    AutoBotJobWSParam.generateFromAnno(botJobMethodAnno.bowWsConfig()),
                    botJobMethodAnno.uniqueAccount()
            );
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format("[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInfo().getName(), method.getName(), botJobMethodAnno.cronExpression()),
                    e
            );
        }

        return autoBotJobParam;
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInfo().getName(),
                        registerMethod.getName()
                ), e);
            }
        }, getExecutorService());
    }


    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }
}
package cn.com.helei.bot.core.bot.job;

import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.Result;
import cn.hutool.core.util.BooleanUtil;
import lombok.extern.slf4j.Slf4j;
import org.quartz.JobDataMap;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;

import java.lang.reflect.Method;
import java.util.concurrent.CompletableFuture;

@Slf4j
public class AutoBotJob extends QuartzJobBean {

    public static final String BOT_JOB_PARAM_KEY = "bot_job_param";

    public static final String BOT_JOB_RUNTIME_PARAM_KEY = "bot_job_runtime_param";

    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

        // 提取JobDataMap里的参数
        AutoBotJobParam autoBotJobParam = (AutoBotJobParam) jobDataMap.get(BOT_JOB_PARAM_KEY);
        AutoBotJobRuntimeParam autoBotJobRuntimeParam = (AutoBotJobRuntimeParam) jobDataMap.get(BOT_JOB_RUNTIME_PARAM_KEY);

        AnnoDriveAutoBot<?> bot = autoBotJobRuntimeParam.getBot();
        Method jobMethod = autoBotJobRuntimeParam.getMethod();
        Object target = autoBotJobRuntimeParam.getTarget();
        Object[] extraParams = autoBotJobRuntimeParam.getExtraParams();

        String jobName = autoBotJobParam.getJobName();
        Object invokeObj = target == null ? bot : target;


        log.info("开始执行[{}]定时任务", jobName);
        CompletableFuture<ACListOptResult> future = null;
        if (BooleanUtil.isTrue(autoBotJobParam.getUniqueAccount())) {
            future = uniqueForEachAccount(bot, extraParams, jobMethod, invokeObj, jobName);
        } else {
            future = normalForEachAccount(bot, extraParams, jobMethod, invokeObj, jobName);
        }

        acListOptResultHandler(future);

        log.info("[{}]定时任务执行完毕", jobName);
    }

    private static CompletableFuture<ACListOptResult> normalForEachAccount(AnnoDriveAutoBot<?> bot, Object[] extraParams, Method jobMethod, Object invokeObj, String jobName) {
        return bot.asyncForACList(
                accountContext -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // 封装参数
                        Object[] params;
                        if (extraParams == null) {
                            params = new Object[]{accountContext};
                        } else {
                            params = new Object[1 + extraParams.length];
                            params[0] = accountContext;
                            System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                        }

                        // 调用执行的job method
                        jobMethod.setAccessible(true);
                        Object invoke = jobMethod.invoke(invokeObj, params);
                        return Result.ok(invoke);
                    } catch (Exception e) {
                        log.error("执行定时任务发生异常", e);
                        return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
                    }
                }, bot.getExecutorService()),
                (accountContext, result) -> result,
                jobName
        );
    }


    private static CompletableFuture<ACListOptResult> uniqueForEachAccount(AnnoDriveAutoBot<?> bot, Object[] extraParams, Method jobMethod, Object invokeObj, String jobName) {
        return bot.uniqueAsyncForACList(
                (accountContext, accountContexts) -> CompletableFuture.supplyAsync(() -> {
                    try {
                        // 封装参数
                        Object[] params;
                        if (extraParams == null) {
                            params = new Object[]{accountContext, accountContexts};
                        } else {
                            params = new Object[2 + extraParams.length];
                            params[0] = accountContext;
                            params[1] = accountContexts;
                            System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                        }

                        // 调用执行的job method
                        jobMethod.setAccessible(true);
                        Object invoke = jobMethod.invoke(invokeObj, params);
                        return Result.ok(invoke);
                    } catch (Exception e) {
                        log.error("执行定时任务发生异常", e);
                        return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
                    }
                }, bot.getExecutorService()),
                (accountContext, result) -> result,
                jobName
        );
    }

    public void acListOptResultHandler(CompletableFuture<ACListOptResult> future) {
        future.thenAcceptAsync(acListOptResult -> {
            if (!acListOptResult.getSuccess()) {
                log.info("botId[{}]-botName[{}]-jobName[{}] 定时任务执行失败, {}",
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                );
            } else {
                log.info("botId[{}]-botName[{}]-jobName[{}] 定时任务执行成功, {}/{}",
                        acListOptResult.getBotId(), acListOptResult.getBotName(),
                        acListOptResult.getJobName(), acListOptResult.getSuccessCount(), acListOptResult.getResults().size()
                );
            }
        });
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.fastjson.JSONArray;
import com.baomidou.mybatisplus.annotation.*;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@TableName("t_bot_info")
public class BotInfo {

    public static final String CONFIG_PARAMS_KEY = "config_params_key";

    public static final String ACCOUNT_PARAMS_KEY = "account_params_key";

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField("image")
    private String image;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField("job_params")
    private Map<String, AutoBotJobParam> jobParams = new HashMap<>();

    @TableField("params")
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public static BotInfo generateFromAnno(BotApplication annotation) {
        BotInfo botInfo = new BotInfo();
        botInfo.setName(annotation.name());
        botInfo.setDescribe(annotation.describe());
        botInfo.setImage(annotation.image());
        botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
        botInfo.getParams().put(CONFIG_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.configParams())));
        botInfo.getParams().put(ACCOUNT_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.accountParams())));

        return botInfo;
    }
}
