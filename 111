package cn.com.vortexa.common.util.http;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.exception.NetworkException;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import okio.BufferedSource;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.net.Proxy;
import java.net.SocketTimeoutException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;


@Slf4j
public class RestApiClient {

    private static final int RETRY_TIMES = 1;

    public static int connectTimeout = 25;
    public static int readTimeout = 120;
    public static int writeTimeout = 60;

    @Getter
    private final OkHttpClient okHttpClient;

    private final ExecutorService executorService;

    public RestApiClient(
            ProxyInfo proxy,
            ExecutorService executorService
    ) {
        this.executorService = executorService;
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder
                // 连接超时
                .connectTimeout(connectTimeout, TimeUnit.SECONDS)
                // 读取超时
                .readTimeout(readTimeout, TimeUnit.SECONDS)
                // 写入超时
                .writeTimeout(writeTimeout, TimeUnit.SECONDS);

        if (proxy != null) {
            builder.proxy(new Proxy(Proxy.Type.HTTP, proxy.generateAddress()));
            if (StrUtil.isNotBlank(proxy.getUsername())) {
                builder.proxyAuthenticator((route, response) -> {
                    String credential = Credentials.basic(proxy.getUsername(), proxy.getPassword());
                    return response.request().newBuilder()
                            .header("Proxy-Authorization", credential)
                            .build();
                });
            }
        }

        this.okHttpClient = builder.build();
    }

    /**
     * 发送请求，如果有asKey参数不为null，则会鉴权
     *
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<String> request(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return request(url, method, headers, params, body, 1);
    }

    /**
     * 发送请求，如果有asKey参数不为null，则会鉴权
     *
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<String> request(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            int retryTimes
    ) {
        return CompletableFuture.supplyAsync(() -> {

            Request request = null;
            try {
                request = buildRequest(url, method, headers, params, body);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            return normalRequest(url, method, request, retryTimes);
        }, executorService);
    }

    public CompletableFuture<List<String>> streamRequest(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return CompletableFuture.supplyAsync(() -> {
            Request request = null;
            try {
                request = buildRequest(url, method, headers, params, body);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }


            Exception exception = null;
            for (int i = 0; i < RETRY_TIMES; i++) {
                // 发送请求并获取响应
                try (Response response = okHttpClient.newCall(request).execute()) {
                    return streamRequest(url, response);
                } catch (SocketTimeoutException e) {
                    log.warn("请求[{}]超时，尝试重新请求 [{}}/{}],", url, i, RETRY_TIMES);
                    exception = e;
                } catch (IOException e) {
                    throw new RuntimeException("请求url [" + url + "] 失败", e);
                }
            }

            throw new RuntimeException("请求重试次数超过限制, " + RETRY_TIMES, exception);
        });
    }

    /**
     *rawRequest
     * @param url   url
     * @param method    method
     * @param headers   headers
     * @param params    params
     * @param body  body
     * @return  CompletableFuture<ResponseBody>
     */
    public CompletableFuture<Response> rawRequest(
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body
    ) {
        return CompletableFuture.supplyAsync(() -> {
            Request request = null;
            try {
                request = buildRequest(url, method, headers, params, body);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }

            Exception exception = null;
            for (int i = 0; i < RETRY_TIMES; i++) {
                // 发送请求并获取响应
                try (Response response = okHttpClient.newCall(request).execute()) {
                    return rawRequest(url, response);
                } catch (SocketTimeoutException e) {
                    log.warn("请求[{}]超时，尝试重新请求 [{}]/{}],", url, i, RETRY_TIMES);
                    exception = e;
                } catch (IOException e) {
                    throw new RuntimeException("请求url [" + url + "] 失败", e);
                }
            }

            throw new RuntimeException("请求重试次数超过限制, " + RETRY_TIMES, exception);
        });
    }

    @NotNull
    private static Request buildRequest(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) throws IOException {
        // 创建表单数据
        StringBuilder queryString = new StringBuilder();

        String requestUrl = url;
        if (params != null) {
            params.keySet().forEach(key -> {
                queryString.append(key).append("=").append(params.get(key)).append("&");
            });

            if (!queryString.isEmpty()) {
                queryString.deleteCharAt(queryString.length() - 1);
            }
            requestUrl = url + "?" + queryString;
        }


        Request.Builder builder = new Request.Builder();

        RequestBody requestBody = null;

        if (headers == null) {
            headers = new HashMap<>();
        }

        if (body != null) {
            String contentType = headers.getOrDefault("Content-Type",
                            headers.getOrDefault("content-type", "application/json; charset=utf-8"))
                    .toLowerCase();

            if (contentType.contains("x-www-form-urlencoded")) {
                StringBuilder formData = new StringBuilder();
                for (String key : body.keySet()) {
                    formData.append(key).append("=").append(body.get(key)).append("&");
                }

                if (!formData.isEmpty()) {
                    formData.deleteCharAt(formData.length() - 1);
                }

                requestBody = RequestBody.create(formData.toString(),
                        MediaType.parse("application/x-www-form-urlencoded"));
            } else if (contentType.startsWith("application/json")) {
                MediaType JSON = MediaType.get(contentType);

                requestBody = RequestBody.create(body.toJSONString().getBytes(StandardCharsets.UTF_8), JSON);
            } else {
                MediaType JSON = MediaType.parse(headers.getOrDefault("Content-Type",
                        headers.getOrDefault("content-type", "application/json; charset=utf-8")));

                requestBody = RequestBody.create(body.toJSONString(), JSON);
            }

            builder.addHeader("Content-Length", String.valueOf(requestBody.contentLength()));
        }


        // 创建 POST 请求
        builder.url(requestUrl);

        if (HttpMethod.GET.equals(method)) {
            builder.get();
        } else if(HttpMethod.POST.equals(method)) {
            builder.method(method.name(), requestBody);
        } else {
            builder.method(method.name(), requestBody);
        }

        for (Map.Entry<String, String> header : headers.entrySet()) {
            builder = builder.addHeader(header.getKey(), header.getValue());
        }

        return builder.build();
    }


    @NotNull
    private static List<String> streamRequest(String url, Response response) throws IOException {
        ResponseBody responseBody = response.body();
        if (response.isSuccessful() || responseBody == null) {
            throw new RuntimeException("请求 " + url + "失败, " + (responseBody == null ? null : responseBody.string()));
        }

        List<String> result = new ArrayList<>();

        BufferedSource source = responseBody.source();
        while (!source.exhausted()) {
            String chunk = source.readUtf8Line();
            if (chunk != null) {
                result.add(chunk);
            }
        }
        return result;
    }

    @NotNull
    private static Response rawRequest(String url, Response response) throws IOException {
        ResponseBody responseBody = response.body();
        if (response.isSuccessful() || responseBody == null) {
            throw new RuntimeException("请求 " + url + "失败, " + (responseBody == null ? null : responseBody.string()));
        }
        return response;
    }

    @Nullable
    private String normalRequest(String url, HttpMethod method, Request request, int retryTimes) {
        log.debug("创建请求 url[{}], method[{}]成功，开始请求服务器", url, method);

        Exception exception = null;
        for (int i = 0; i < retryTimes; i++) {
            // 发送请求并获取响应
            try (Response response = okHttpClient.newCall(request).execute()) {
                ResponseBody responseBody = response.body();
                if (response.isSuccessful()) {
                    try {
                        return responseBody == null ? null : responseBody.string();
                    } catch (IOException e) {
                        log.warn("请求[{}]失败, response body解析失败，尝试重新请求 [{}}/{}],",
                                url, i, retryTimes);
                        exception = e;
                    }
                } else {
                    String body = "";
                    if (responseBody != null) {
                        body = responseBody.string();
                        body = body.substring(0, Math.min(body.length(), 200));
                    }
                    log.warn("请求[{}]失败, code[{}]-body[{}]，尝试重新请求 [{}}/{}],",
                            url, response.code(), body, i, retryTimes);
                    exception = new NetworkException("请求[%s]失败, code[%s]-body[%s]".formatted(url, response.code(), body));
                }
            } catch (SocketTimeoutException e) {
                log.warn("请求[{}]超时，尝试重新请求 [{}}/{}],", url, i, retryTimes);
                exception = e;
            } catch (IOException e) {
                log.warn("请求[{}]失败, exception[{}]，尝试重新请求 [{}}/{}],",
                        url, e.getCause() != null ? e.getCause().getMessage() : e.getMessage(), i, retryTimes);
                exception = e;
            } catch (Exception e) {
                throw new NetworkException("未知异常", e);
            }
        }

        throw new NetworkException("请求重试次数超过限制[" + retryTimes + "], "
                + (exception != null ? exception.getMessage() : "known"), exception);
    }
}
package cn.com.vortexa.common.util;

import cn.hutool.core.lang.Pair;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

/**
 * @author h30069248
 * @since 2025/5/6 14:35
 */
@Slf4j
public class VersionUtil {

    /**
     * 获取目录下的botName 和版本信息map
     *
     * @param jarDir jarDir
     * @return Map<String, String>
     * @throws IOException IOException
     */
    public static Map<String, String> scanJarLibForBotVersionMap(String jarDir) throws IOException {
        Map<String, String> map = new HashMap<>();
        try (Stream<Path> list = Files.list(Paths.get(FileUtil.getLibraryDir()));) {
            list.filter(path -> path.toString().endsWith(".jar"))
                .forEach(path -> {
                    String fileName = path.getFileName().toString();
                    try {
                        Pair<String, String> nameAndVersion = VersionUtil.getBotNameAndVersionFromJarPath(
                            fileName);
                        map.put(nameAndVersion.getKey(), nameAndVersion.getValue());
                    } catch (Exception e) {
                        log.error("resolve bot version failed, jar name:{}", fileName, e);
                    }
                });
        }
        return map;
    }

    /**
     * 从jar的path中获取botName 和版本信息
     *
     * @param fileName fileName
     * @return Pair<String, String>
     */
    public static Pair<String, String> getBotNameAndVersionFromJarPath(String fileName) {
        String name = fileName.split("\\.jar")[0];
        String[] nameAndVersion = name.split("-v");
        if (nameAndVersion.length == 2) {
            return Pair.of(nameAndVersion[0], "v" + nameAndVersion[1]);
        } else {
            throw new IllegalArgumentException("jar name format error, should be botName-version.jar");
        }
    }

    /**
     * 获取bot jar的文件名
     *
     * @param botName   botName
     * @param version   version
     * @return  String
     */
    public static String getBotJarFileName(String botName, String version) {
        return botName + "-" + version + ".jar";
    }

    /**
     * 版本比较
     *
     * @param v1 v1
     * @param v2 v2
     * @return int
     */
    public static int compareVersion(String v1, String v2) {
        String[] parts1 = v1.split("\\.");
        String[] parts2 = v2.split("\\.");

        int length = Math.max(parts1.length, parts2.length);

        for (int i = 0; i < length; i++) {
            String p1 = i < parts1.length ? parts1[i] : "0";
            String p2 = i < parts2.length ? parts2[i] : "0";
            int cmp = comparePart(p1, p2);
            if (cmp != 0) {
                return cmp;
            }
        }
        return 0;
    }

    private static int comparePart(String p1, String p2) {
        try {
            int i1 = Integer.parseInt(p1);
            int i2 = Integer.parseInt(p2);
            return Integer.compare(i1, i2);
        } catch (Exception e) {
            return p1.compareTo(p2);
        }
    }
}
package cn.com.vortexa.bot_platform.controller;


import cn.com.vortexa.bot_platform.service.IVersionService;
import cn.com.vortexa.bot_platform.vo.BotVersionVO;
import cn.com.vortexa.common.dto.Result;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * @author helei
 * @since 2025-05-06
 */
@RestController
@RequestMapping("/version")
public class VersionController {

    @Autowired
    private IVersionService versionService;

    @PostMapping("/botVersions")
    public Result botVersions(@RequestBody BotVersionVO botVersionVO) {
        return Result.ok(versionService.queryBotNewestVersions(botVersionVO.getBotNames()));
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import cn.com.vortexa.bot_platform.service.IVersionService;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.VersionUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author h30069248
 * @since 2025/5/6 14:19
 */
@Slf4j
@Component
public class VersionServiceImpl implements IVersionService, InitializingBean {

    /**
     * platform中的bot版本（local version）  TODO 远程提供版本
     */
    private final Map<String, String> platformBotVersionMap = new ConcurrentHashMap<>();

    @Override
    public void afterPropertiesSet() throws Exception {
        log.info("start resolve platform exist bot version...");
        platformBotVersionMap.putAll(VersionUtil.scanJarLibForBotVersionMap(FileUtil.getLibraryDir()));
        log.info("resolve platform exist bot version done, platformBotVersionMap:{}", platformBotVersionMap);
    }

    @Override
    public Map<String, String> queryBotNewestVersions(List<String> botNames) {
        Map<String, String> result = new HashMap<>(botNames.size());
        botNames.forEach(botName -> {
            result.put(botName, platformBotVersionMap.getOrDefault(botName, null));
        });
        return result;
    }
}
package cn.com.vortexa.bot_platform.service;

import java.util.List;
import java.util.Map;

/**
 * @author h30069248
 * @since 2025/5/6 14:18
 */
public interface IVersionService {

    /**
     * 获取bot最新的版本
     *
     * @param botNames botNames
     * @return botName -> version
     */
    Map<String, String> queryBotNewestVersions(List<String> botNames);
}
package cn.com.vortexa.bot_platform.vo;

import lombok.Data;


import java.util.List;

/**
 * @author h30069248
 * @since 2025/5/6 17:37
 */
@Data
public class BotVersionVO {
    private List<String> botNames;
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.BotInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.BotInfo">
        <id column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="description" property="description"/>
        <result column="image" property="image"/>
        <result column="limit_project_ids" property="limitProjectIds"/>
        <result column="job_params" property="jobParams"/>
        <result column="params" property="params"/>
        <result column="version" property="version"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="valid" property="valid"/>
    </resultMap>


    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.BotInfo">
        INSERT INTO t_bot_info
        (name, description, limit_project_ids, image, job_params, params, version, update_datetime, valid)
        VALUES (
        #{name}, #{description}, #{limitProjectIds}, #{image}, #{jobParams}, #{params}, #{version}, current_timestamp, 1 )
        ON DUPLICATE KEY UPDATE
        <trim suffixOverrides=",">
            <if test="description != null">
                description = values (description),
            </if>
            <if test="limitProjectIds != null">
                limit_project_ids = values (limit_project_ids),
            </if>
            <if test="image != null">
                image = values (image),
            </if>
            <if test="jobParams != null">
                job_params =values (job_params),
            </if>
            <if test="params != null">
                params = values (params),
            </if>
            <if test="version != null">
                version =values (version),
            </if>
            <if test="updateDatetime != null">
                update_datetime =values (update_datetime),
            </if>
            <if test="valid != null">
                valid = values(valid),
            </if>
        </trim>
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_bot_info
        (name, description, limit_project_ids, image, job_params, params,version, update_datetime, valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{item.name}, #{item.description}, #{item.limitProjectIds}, #{item.image}, #{item.jobParams},
            #{item.params}, #{item.version} current_timestamp, 1)
        </foreach>
        ON DUPLICATE KEY UPDATE
        description = values(description),
        limit_project_ids = values(limit_project_ids),
        image = values(image),
        job_params = values(job_params),
        params = values(params),
        version = values(version),
        update_datetime = values(update_datetime),
        valid =values (valid)
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.BotInfo"
            resultType="cn.com.vortexa.common.entity.BotInfo">
        select
        t.id as id,
        t.name,
        t.description,
        t.image,
        t.job_params as jobParams,
        t.params,
        t.version,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.valid as valid
        from
        t_bot_info as t
        <where>
            valid = 1
            <if test="name != null">
                and t.name = #{name}
            </if>
            <if test="description != null">
                and t.description = #{description}
            </if>
            <if test="image != null">
                and t.image = #{image}
            </if>
            <if test="jobParams != null and !params.isEmpty()">
                and t.job_params = #{jobParams}
            </if>
            <if test="version != null">
                and t.version = #{version}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
package cn.com.vortexa.script_node.config;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.config.AutoBotAccountConfig;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.VersionUtil;
import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.com.vortexa.common.dto.BotMetaInfo;
import cn.com.vortexa.web3.constants.Web3ChainDict;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import okhttp3.Response;
import okhttp3.ResponseBody;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Stream;

/**
 * @author helei
 * @since 2025-04-04
 */
@Slf4j
@Data
@Component
@ConfigurationProperties(prefix = "vortexa.script-node")
public class ScriptNodeConfiguration implements InitializingBean {
    public static Map<String, Object> RAW_CONFIG = null;
    public static final String BOT_META_INF_FILE_NAME = "bot-meta-info.yaml";
    public static final List<String> BOT_META_INFO_PREFIX = List.of("vortexa", "botMetaInfo");
    public static final List<String> BOT_INSTANCE_CONFIG_PREFIX = List.of("vortexa", "botInstance");

    /**
     * bot group（Script Node中运行的bot的group)
     * ）
     */
    private String scriptNodeName;

    /**
     * 远程REST接口的url
     */
    private String remoteRestUrl;

    /**
     * 链信息字典
     */
    private Web3ChainDict chainDict;

    /**
     * 要使用的bot name列表
     */
    private List<String> loadBotNames;

    /**
     * Script node 基础路径
     */
    private String scriptNodeBasePath;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;


    /**
     * botNameMetaInfoMap, （解析配置文件自动填入）
     */
    private Map<String, BotMetaInfo> botNameMetaInfoMap;

    /**
     * botKeyConfigMap, （解析配置文件自动填入）
     */
    private Map<String, AutoBotConfig> botKeyConfigMap;

    /**
     * bot版本   （解析目录自动写入）
     */
    private Map<String, String> botVersionMap;

    /**
     * 自动时自动启动的botKey
     */
    private Set<String> autoLaunchBotKeys;

    /**
     * bot公共配置，会加载到每个bot的 customConfig下
     *
     * @see AutoBotConfig
     */
    private Map<String, Object> botCommonConfig;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 解析地址，
        scriptNodeBasePath = FileUtil.getAppResourceAppConfigDir() + File.separator + scriptNodeName;

        // 尝试从platform拉取最新jar包
        tryUpdateNewestBotJarFile();

        initBotMetaInfo();

        initBotInstance();
    }

    /**
     * 获取远程设置api
     *
     * @return String
     */
    public String buildRemoteConfigRestApi() {
        return remoteRestUrl + "/script-node/remote-config";
    }

    /**
     * 获取bot版本的api
     *
     * @return String
     */
    public String buildBotVersionRestApi() {
        return remoteRestUrl + "/version/botVersions";
    }

    /**
     * 尝试更新bot 的jar包
     */
    private void tryUpdateNewestBotJarFile() throws IOException {
        // Step 1 扫描script node jar包目录，获取botName -> version
        botVersionMap = VersionUtil.scanJarLibForBotVersionMap(FileUtil.getJarFileDir());

        // Step 2 从platform获取最新的版本信息
        Map<String, String> newestBotVersion = fetchRemoteNewestBotVersion(buildBotVersionRestApi(),
            new ArrayList<>(botVersionMap.keySet()));
        if (newestBotVersion != null) {
            // Step 3 对比版本，如果有新版本，则下载
            Iterator<Map.Entry<String, String>> iterator = botVersionMap.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry<String, String> entry = iterator.next();
                String botName = entry.getKey();
                String v1 = entry.getKey();
                String v2 = newestBotVersion.get(botName);
                if (StrUtil.isBlank(v2)) {
                    // 远程没这个版本的bot, 去除后续不使用
                    iterator.remove();
                } else {
                    int compare = VersionUtil.compareVersion(v1, v2);
                    if (compare < 0) {
                        try {
                            downloadNewestBotJarFile(botName, v2);
                            botVersionMap.put(botName, v2);
                        } catch (ExecutionException | InterruptedException e) {
                            log.error("download newest bot[{}] version[{}] jar file error",botName, v2, e);
                            botVersionMap.remove(botName);
                        }
                    }
                }
            }
        }
    }

    /**
     * 下载最新的jar文件
     *
     * @param botName botName
     * @param version version
     */
    private void downloadNewestBotJarFile(String botName, String version)
        throws ExecutionException, InterruptedException, IOException {
        // 本地版本小于远程版本，需要更新
        log.info("botName[{}] local version less than remote version[{}], try update ...", botName, version);
        String downloadUrl = remoteRestUrl + "/version/bot/download" + botName + "/" + version;
        String fileName = VersionUtil.getBotJarFileName(botName, version);

        Response response = RestApiClientFactory.getClient().rawRequest(
            downloadUrl,
            HttpMethod.GET,
            new HashMap<>(),
            null,
            null
        ).get();
        // 保存文件到本地
        File file = new File(FileUtil.getJarFilePath(fileName));
        ResponseBody responseBody = response.body();
        if (responseBody == null) {
            throw new IOException("response body is null");
        }
        try (InputStream in = responseBody.byteStream();
            OutputStream out = Files.newOutputStream(file.toPath())
        ) {
            byte[] buffer = new byte[8192];
            int len ;
            while ((len = in.read(buffer)) != -1) {
                out.write(buffer, 0, len);
            }
            log.info("update bot[{}]-[{}] jar file success, path: {}", botName, version, file.getAbsolutePath());
        }
    }

    /**
     * 获取原创最新的bot版本
     *
     * @param botVersionApi botVersionApi
     * @param botNames botNames
     * @return Map<String, String>
     */
    private Map<String, String> fetchRemoteNewestBotVersion(String botVersionApi, List<String> botNames) {
        if (StrUtil.isBlank(botVersionApi)) {
            return null;
        }
        try {
            JSONObject body = new JSONObject();
            body.put("botNames", botNames);
            String response = RestApiClientFactory.getClient().request(
                botVersionApi,
                HttpMethod.POST,
                new HashMap<>(),
                null,
                body
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                return JSONObject.parseObject(JSONObject.toJSONString(result.getData()), Map.class);
            } else {
                log.warn("remote newest bot version fetch fail, {}", result.getErrorMsg());
                return new HashMap<>();
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("remote newest bot version fetch error", e);
            return new HashMap<>();
        }
    }

    /**
     * 初始化BotInstance
     */
    private void initBotInstance() {
        botKeyConfigMap = new HashMap<>();
        Path botInstanceConfigPath = Paths.get(FileUtil.getBotInstanceConfigDir());
        if (!Files.exists(botInstanceConfigPath) || !Files.isDirectory(botInstanceConfigPath)) {
            log.warn("no bot instance config dir [{}]", botInstanceConfigPath);
            return;
        }

        try (Stream<Path> walk = Files.walk(botInstanceConfigPath, 5)) {
            walk.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(".yaml")).forEach(configFile -> {
                try {
                    AutoBotConfig botConfig = YamlConfigLoadUtil.load(configFile.toFile(), BOT_INSTANCE_CONFIG_PREFIX,
                        AutoBotConfig.class);
                    // 配置文件校验
                    if (botConfig == null) {
                        throw new IllegalArgumentException(
                            "bot instance config file [" + configFile.getFileName() + "] illegal");
                    }

                    if (botConfig.getCustomConfig() == null) {
                        botConfig.setCustomConfig(new HashMap<>());
                    }

                    BotMetaInfo botMetaInfo = botNameMetaInfoMap.get(botConfig.getBotName());

                    if (botMetaInfo == null) {
                        log.warn("botName[{}] didn't loaded in script node", botConfig.getBotName());
                        return;
                    }

                    botConfig.setMetaInfo(botMetaInfo);

                    // 相对路径转绝对路径
                    reactivePathConfigConvert(
                        botConfig,
                        botMetaInfo.getResourceDir()
                    );

                    // 合并bot公共配置
                    if (botCommonConfig != null) {
                        botConfig.getCustomConfig().putAll(botCommonConfig);
                    }

                    // 合并远程配置
                    AutoBotConfig remoteBotConfig = fetchRemoteBotConfig(
                        buildRemoteConfigRestApi(),
                        scriptNodeName,
                        botConfig.getBotKey()
                    );
                    if (remoteBotConfig != null) {
                        mergeRemoteAutoBotConfig(botConfig, remoteBotConfig);
                    }

                    botKeyConfigMap.put(botConfig.getBotKey(), botConfig);
                } catch (Exception e) {
                    log.error("bot instance config[{}] load error, {}",
                        configFile.getFileName(),
                        e.getCause() == null ? e.getMessage() : e.getCause().getMessage()
                    );
                }
            });
        } catch (IOException e) {
            log.error("load bot instance config error", e);
        }
    }

    /**
     * 初始化bot原信息
     *
     * @throws IOException IOException
     */
    private void initBotMetaInfo() throws IOException {
        botNameMetaInfoMap = new HashMap<>();
        if (CollUtil.isNotEmpty(loadBotNames)) {
            for (String loadBotName : loadBotNames) {
                String version = this.botVersionMap.get(loadBotName);
                if (StrUtil.isBlank(version)) {
                    log.warn("bot[{}] no version, skip load it", loadBotName);
                    continue;
                }
                String botJarFileName = VersionUtil.getBotJarFileName(loadBotName, version).replace(".jar", "");
                String jarLibraryPath = FileUtil.getLibraryPath(botJarFileName);
                String jarFilePath = FileUtil.getJarFilePath(botJarFileName);
                if (!Files.exists(Paths.get(jarFilePath))) {
                    FileUtil.extractJar(
                        jarLibraryPath,
                        jarFilePath
                    );
                } else {
                    log.info("jar[{}] extracted, skip extract it", botJarFileName);
                }


                // 解析文件夹
                log.info("start resolve bot meta info config from dir[{}]", jarFilePath);
                try (Stream<Path> walk = Files.walk(Paths.get(jarFilePath), 5)) {
                    walk.filter(Files::isDirectory).forEach(dir -> {
                        Path configFilePath = dir.resolve(BOT_META_INF_FILE_NAME);
                        if (Files.exists(configFilePath)) {
                            BotMetaInfo metaInfo = YamlConfigLoadUtil.load(configFilePath.toFile(),
                                BOT_META_INFO_PREFIX, BotMetaInfo.class);

                            // 配置文件校验
                            if (metaInfo == null) {
                                throw new IllegalArgumentException(
                                    "bot meta info file [" + BOT_META_INF_FILE_NAME + "] illegal");
                            }

                            // 设置bot资源目录
                            metaInfo.setResourceDir(dir.toString());
                            // 设置所在jar包路径
                            metaInfo.setClassJarPath(jarLibraryPath);

                            botNameMetaInfoMap.put(metaInfo.getBotName(), metaInfo);
                            log.info("botName[{}]-[{}] meta info loaded", metaInfo.getBotName(), version);
                        }
                    });
                }
            }
        }
    }

    /**
     * 获取远程配置
     *
     * @param configUrl configUrl
     * @param scriptNodeName scriptNodeName
     * @param botKey botKey
     * @return String
     */
    private AutoBotConfig fetchRemoteBotConfig(String configUrl, String scriptNodeName, String botKey) {
        if (StrUtil.isBlank(configUrl)) {
            return null;
        }

        try {
            JSONObject params = new JSONObject();
            params.put("scriptNodeName", scriptNodeName);
            params.put("botKey", botKey);
            String response = RestApiClientFactory.getClient().request(
                configUrl,
                HttpMethod.POST,
                new HashMap<>(),
                params,
                new JSONObject()
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                AutoBotConfig load = YamlConfigLoadUtil.load(String.valueOf(result.getData()),
                    BOT_INSTANCE_CONFIG_PREFIX, AutoBotConfig.class);
                log.info("remote config fetch success, merge into [{}] bot config...", botKey);
                return load;
            } else {
                log.warn("script node[{}] botKey[{}] config not found in remote", scriptNodeName, botKey);
                return null;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("script node[{}] botKey[{}] remote fetch error", scriptNodeName, botKey, e);
            return null;
        }
    }

    /**
     * 合并远程配置
     *
     * @param local local
     * @param remote remote
     */
    private void mergeRemoteAutoBotConfig(AutoBotConfig local, AutoBotConfig remote) {
        if (remote.getAccountConfig() != null) {
            local.setAccountConfig(remote.getAccountConfig());
        }
        if (remote.getCustomConfig() != null) {
            local.setCustomConfig(remote.getCustomConfig());
        }
    }

    /**
     * 相对路径转换
     *
     * @param config config
     * @param botResourcePath botResourcePath
     */
    private void reactivePathConfigConvert(AutoBotConfig config, String botResourcePath) {
        AutoBotAccountConfig accountConfig = config.getAccountConfig();
        accountConfig.setConfigFilePath(
            FileUtil.generateAbsPath(accountConfig.getConfigFilePath(), botResourcePath)
        );

        Map<String, Object> customConfig = config.getCustomConfig();
        if (customConfig != null && !customConfig.isEmpty()) {
            for (Map.Entry<String, Object> entry : customConfig.entrySet()) {
                Object value = entry.getValue();
                if (value instanceof String) {
                    entry.setValue(FileUtil.generateAbsPath((String) value, botResourcePath));
                }
            }
        }
    }
}
    load-bot-names:
