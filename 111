package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.bot.constants.BotStatus;
import cn.com.helei.bot.core.dto.AutoBotRuntimeInfo;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.util.exception.DepinBotStatusException;
import cn.com.helei.bot.core.util.FileUtil;
import cn.com.helei.bot.core.util.NamedThreadFactory;
import cn.com.helei.bot.core.util.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
        import java.util.function.Supplier;

@Slf4j
@Getter
public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 配置
     */
    private final AutoBotConfig autoBotConfig;

    /**
     * 状态
     */
    private BotStatus status = BotStatus.NEW;

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot运行时信息
     */
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * 请求并发数量
     */
    @Getter
    @Setter
    private int requestConcurrentCount = 5;

    /**
     * bot api
     */
    @Getter
    private final BotApi botApi;

    /**
     * bot信息
     */
    @Getter
    private final BotInfo botInfo;

    public AbstractAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        if (StrUtil.isBlank(autoBotConfig.getBotKey())) {
            throw new IllegalArgumentException("bot key不能为空");
        }

        this.autoBotConfig = autoBotConfig;
        this.botApi = botApi;
        this.botInfo = buildBotInfo();

        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();

        this.executorService = Executors.newThreadPerTaskExecutor(
                new NamedThreadFactory(botInfo.getName() + "-executor"));
    }


    public void init() {
        updateState(BotStatus.INIT);
        try {
            // 检查对应分表是否存在

            if (botApi.getBotAccountContextService().checkAndCreateShardedTable(botInfo.getId())) {
                throw new RuntimeException("[%d][%s]运行失败,创建账户表失败".formatted(botInfo.getId(), botInfo.getName()));
            }

            doInit();

            //更新状态
            updateState(BotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化Bot[{}]发生错误", botInfo.getName(), e);
            updateState(BotStatus.INIT_ERROR);
        }
    }


    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;


    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<List<String>> syncStreamRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).streamRequest(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    public <R> CompletableFuture<R> syncCCHandler(
            ProxyInfo proxy,
            Supplier<String> requestStart,
            Supplier<R> request
    ) {

        Semaphore networkController = networkSyncControllerMap
                .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                    if (v == null) {
                        v = new Semaphore(requestConcurrentCount);
                    }
                    return v;
                });


        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "开始";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                log.info("同步器允许发送请求-{}", str);

                return request.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, botInfo.getName());
    }


    /**
     * 更新BotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(BotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(BotStatus.SHUTDOWN)) {
            status = BotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> BotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(BotStatus.INIT_FINISH)
                        || newStatus.equals(BotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(BotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(BotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(BotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }


    protected abstract BotInfo buildBotInfo();
}
package cn.com.helei.bot.core.config;

import cn.com.helei.bot.core.util.table_shard.TableShardInterceptor;
import cn.com.helei.bot.core.util.typehandler.JsonTypeHandler;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

@Configuration
public class MybatisConfig implements MetaObjectHandler {

    @Autowired
    private ApplicationContext applicationContext;

    /**
     * 使用mp做添加操作时候，这个方法执行
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        //设置属性值
        this.setFieldValByName("insertDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("isValid", 1, metaObject);
    }

    /**
     * 使用mp做修改操作时候，这个方法执行
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
    }


    @Bean
    public JsonTypeHandler jsonTypeHandler() {
        return new JsonTypeHandler();
    }

    @Bean
    public MapTextTypeHandler mapTextTypeHandler() {
        return new MapTextTypeHandler();
    }

    @Bean
    public LocalDateTimeTypeHandler localDateTimeTypeHandler() {
        return new LocalDateTimeTypeHandler();
    }

    @Bean
    public Interceptor tableShardInterceptor() {
        return new TableShardInterceptor(applicationContext);
    }
}
package cn.com.helei.bot.core.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("http://localhost:9527")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.mvc.service.IAccountBaseInfoService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/accountBaseInfo")
public class AccountBaseInfoController {
    @Autowired
    private IAccountBaseInfoService accountBaseInfoService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return accountBaseInfoService.saveAccountBaseInfos(importVO.getRawLines());
    }
}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.util.table_shard.strategy.BotIdBasedTableShardStrategy;
import cn.com.helei.bot.core.util.table_shard.TableShard;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Param;

import static cn.com.helei.bot.core.mvc.service.impl.BotAccountContextServiceImpl.BOT_ACCOUNT_CONTEXT_TABLE_PREFIX;

/**
 * <p>
 * Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@TableShard(
        tableNamePrefix = BOT_ACCOUNT_CONTEXT_TABLE_PREFIX,
        value = "botId",
        fieldFlag = true,
        shardStrategy = BotIdBasedTableShardStrategy.class,
        targetClass = AccountContext.class
)
public interface BotAccountContextMapper extends BaseMapper<AccountContext> {

    Integer insertOrUpdate(AccountContext accountBaseInfo);

    Boolean createIfTableNotExist(@Param("botId") Integer botId);
}

package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.mvc.mapper.AccountBaseInfoMapper;
import cn.com.helei.bot.core.mvc.service.IAccountBaseInfoService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class AccountBaseInfoServiceImpl extends ServiceImpl<AccountBaseInfoMapper, AccountBaseInfo> implements IAccountBaseInfoService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(AccountBaseInfo accountBaseInfo) {
        accountBaseInfo.setInsertDatetime(LocalDateTime.now());
        accountBaseInfo.setUpdateDatetime(LocalDateTime.now());
        accountBaseInfo.setIsValid(1);

        return baseMapper.insertOrUpdate(accountBaseInfo);
    }

    @Override
    public Integer insertOrUpdateBatch(List<AccountBaseInfo> accountBaseInfos) {
        int successCount = 0;
        for (AccountBaseInfo accountBaseInfo : accountBaseInfos) {
            try {
                Integer count = insertOrUpdate(accountBaseInfo);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                throw new RuntimeException("insert or update [%s] error".formatted(accountBaseInfo), e.getCause());
            }
        }

        return successCount;
    }

    @Override
    public Result saveAccountBaseInfos(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importAccountBaseInfoFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            log.error("导入账户数据失败", e.getCause());
            return Result.fail("导入账户数据失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.mvc.mapper.BotAccountContextMapper;
import cn.com.helei.bot.core.mvc.service.IBotAccountContextService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import cn.com.helei.bot.core.util.table_shard.strategy.BotIdBasedTableShardStrategy;
import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class BotAccountContextServiceImpl extends ServiceImpl<BotAccountContextMapper, AccountContext> implements IBotAccountContextService {

    public static final String BOT_ACCOUNT_CONTEXT_TABLE_PREFIX = "t_bot_account_context";

    @Autowired
    private ImportService importService;

    @Autowired
    private BotIdBasedTableShardStrategy botIdBasedTableShardStrategy;

    @Override
    public Integer insertOrUpdate(AccountContext accountBaseInfo) {
        accountBaseInfo.setInsertDatetime(LocalDateTime.now());
        accountBaseInfo.setUpdateDatetime(LocalDateTime.now());
        accountBaseInfo.setIsValid(1);

        return baseMapper.insertOrUpdate(accountBaseInfo);
    }

    @Override
    public Integer insertOrUpdateBatch(List<AccountContext> accountContext) {
        int successCount = 0;
        for (AccountContext accountBaseInfo : accountContext) {
            try {
                Integer count = insertOrUpdate(accountBaseInfo);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", accountBaseInfo, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> rawLines) {
        if (botId == null || StrUtil.isBlank(botKey)) {
            return Result.fail("botId或botKey不能为空");
        }

        try {
            importService.importBotAccountContextFromRaw(botId, botKey, rawLines);

            return Result.ok();
        } catch (Exception e) {
            log.error("botId[{}]-botKey[{}] 报错账户信息失败", botId, botKey, e);
            return Result.fail("保存失败, " + e.getMessage());
        }
    }

    @Override
    public Boolean checkAndCreateShardedTable(Integer botId) {

        return getBaseMapper().createIfTableNotExist(botId);
    }
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IAccountBaseInfoService extends IService<AccountBaseInfo> {

    Integer insertOrUpdate(AccountBaseInfo accountBaseInfo);

    Integer insertOrUpdateBatch(List<AccountBaseInfo> accountBaseInfos);

    Result saveAccountBaseInfos(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IBotAccountContextService extends IService<AccountContext> {
    Integer insertOrUpdate(AccountContext accountBaseInfo);

    Integer insertOrUpdateBatch(List<AccountContext> twitterAccounts);

    Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> acKVMap);

    Boolean checkAndCreateShardedTable(Integer botId);
}
package cn.com.helei.bot.core.mvc;

import cn.com.helei.bot.core.dto.Result;
import com.alibaba.fastjson.JSON;
import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.stereotype.Component;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;


import java.io.IOException;
import java.io.OutputStreamWriter;

@Slf4j
@Component
public class GlobalExceptionHandler implements HandlerExceptionResolver {
    @Override
    public ModelAndView resolveException(@NotNull HttpServletRequest request,
                                         @NotNull HttpServletResponse response,
                                         Object handler,
                                         @NotNull Exception e) {

        //设置默认错误视图
        ModelAndView mv = new ModelAndView();
        mv.setViewName("error");
        mv.addObject("code", 400);
        mv.addObject("msg", "系统异常，请稍后重试");

        if (handler instanceof HandlerMethod handlerMethod) {

            //获取方法上的ResponseBody注解
            ResponseBody responseBody = handlerMethod.getMethod().getDeclaredAnnotation(ResponseBody.class);

            //没有该注解，说明返回视图
            if (null == responseBody) {
                return mv;
            } else {
                //有注解，返回JSON字符串，参数异常
                Result resultInfo = new Result();
                resultInfo.setSuccess(false);
                resultInfo.setErrorMsg("系统异常, " + e.getCause().getMessage());

                //设置格式
                response.setContentType("application/json;charset=utf-8");

                //由于controller层也会返回数据，调用response.getWriter,
                // 所以这里使用response.getOutputStream()避免报错
                ServletOutputStream out = null;
                OutputStreamWriter ow = null;
                try {
                    out = response.getOutputStream();
                    ow = new OutputStreamWriter(out);
                    ow.append(JSON.toJSONString(resultInfo));
                    ow.flush();
                } catch (IOException ioException) {
                    log.error("unknown error", ioException);
                } finally {
                    try {
                        if (out != null) {
                            out.close();
                        }
                        if (ow != null)
                            ow.close();
                    } catch (IOException ioException) {
                        log.error("unknown error", ioException);
                    }
                }
            }
        }

        return null;
    }
}

package cn.com.helei.bot.core.util.table_shard.strategy;

import cn.com.helei.bot.core.util.table_shard.ITableShardStrategy;
import org.apache.commons.lang3.ObjectUtils;
import org.springframework.stereotype.Component;

@Component
public class BotIdBasedTableShardStrategy implements ITableShardStrategy {
    @Override
    public String generateTableName(String tableNamePrefix, Object value) {
        verificationTableNamePrefix(tableNamePrefix);

        if (value == null || ObjectUtils.isEmpty(value.toString())) {
            throw new RuntimeException("value is null");
        }

        long bot_id = Long.parseLong(value.toString());

        //此处可以缓存优化
        return tableNamePrefix + "_" + bot_id;
    }
}
package cn.com.helei.bot.core.util.table_shard;

import org.apache.commons.lang3.ObjectUtils;

public interface ITableShardStrategy {

    /**
     * 生成分表名
     *
     * @param tableNamePrefix 表前缀名
     * @param value           值
     * @return String
     */
    String generateTableName(String tableNamePrefix, Object value);

    /**
     * 验证tableNamePrefix
     *
     * @param tableNamePrefix 表前缀名
     */
    default void verificationTableNamePrefix(String tableNamePrefix) {
        if (ObjectUtils.isEmpty(tableNamePrefix)) {
            throw new RuntimeException("tableNamePrefix is null");
        }
    }
}
package cn.com.helei.bot.core.util.table_shard;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(value = {ElementType.TYPE,ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface TableShard {

    // 表前缀名
    String tableNamePrefix();

    // 值
    String value() default "";

    // 是否是字段名，如果是需要解析请求参数改字段名的值（默认否）
    boolean fieldFlag() default false;


    Class<?> targetClass();

    // 对应的分表策略类
    Class<? extends ITableShardStrategy> shardStrategy();

}
package cn.com.helei.bot.core.util.table_shard;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import org.apache.ibatis.binding.MapperMethod;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.reflection.DefaultReflectorFactory;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.SystemMetaObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationContext;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.Connection;

@Intercepts({
        @Signature(
                type = StatementHandler.class,
                method = "prepare",
                args = {Connection.class, Integer.class}
        )
})
public class TableShardInterceptor implements Interceptor {

    private static final ReflectorFactory defaultReflectorFactory = new DefaultReflectorFactory();
    private static final Logger log = LoggerFactory.getLogger(TableShardInterceptor.class);

    private final ApplicationContext applicationContext;

    public TableShardInterceptor(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    @Override
    public Object intercept(Invocation invocation) throws Throwable {

        // MetaObject是mybatis里面提供的一个工具类，类似反射的效果
        MetaObject metaObject = getMetaObject(invocation);
        BoundSql boundSql = (BoundSql) metaObject.getValue("delegate.boundSql");
        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue("delegate.mappedStatement");

        // 获取Mapper执行方法
        Method method = invocation.getMethod();

        // 获取分表注解
        TableShard tableShard = getTableShard(method, mappedStatement);

        // 如果method与class都没有TableShard注解或执行方法不存在，执行下一个插件逻辑
        if (tableShard == null) {
            return invocation.proceed();
        }

        //获取值
        String value = tableShard.value();
        //value是否字段名，如果是，需要解析请求参数字段名的值
        boolean fieldFlag = tableShard.fieldFlag();

        if (fieldFlag) {
            //获取请求参数
            Object parameterObject = boundSql.getParameterObject();

            if (parameterObject instanceof MapperMethod.ParamMap paramMap) {
                // 根据字段名获取参数值
                Object valueObject = resolveValueObject(paramMap, boundSql, value, tableShard);

                if (valueObject == null) {
                    log.warn("入参字段[{}]无匹配, 使用默认表名[{}]", value, tableShard.tableNamePrefix());
                } else {
                    //替换sql
                    replaceSql(tableShard, valueObject, metaObject, boundSql);
                }
            }
        }
        //执行下一个插件逻辑
        return invocation.proceed();
    }

    private static Object resolveValueObject(MapperMethod.ParamMap paramMap, BoundSql boundSql, String value, TableShard tableShard) throws NoSuchFieldException, IllegalAccessException {
        if (boundSql.getParameterMappings().isEmpty()) {
            return paramMap.get(value);
        }

        for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {
            String property = parameterMapping.getProperty();
            if (property.endsWith("." + value)) {
                String[] split = property.split("\\.");
                Object o = paramMap.get(split[0]);

                if (o instanceof QueryWrapper<?> queryWrapper) {
                    Object entity = queryWrapper.getEntity();
                    Class<?> targetClass = tableShard.targetClass();
                    if (targetClass.isInstance(entity)) {
                        Field field = targetClass.getDeclaredField(value);
                        field.setAccessible(true);
                        return field.get(entity);
                    }
                }
                break;
            }
        }
        return null;
    }

    /**
     * @param target target
     * @return Object
     */
    @Override
    public Object plugin(Object target) {
        // 当目标类是StatementHandler类型时，才包装目标类，否者直接返回目标本身, 减少目标被代理的次数
        if (target instanceof StatementHandler) {
            return Plugin.wrap(target, this);
        } else {
            return target;
        }
    }

    /**
     * 基本数据类型验证，true是，false否
     *
     * @param object object
     * @return boolean
     */
    private static boolean isBaseType(Object object) {
        return object.getClass().isPrimitive()
                || object instanceof String
                || object instanceof Integer
                || object instanceof Double
                || object instanceof Float
                || object instanceof Long
                || object instanceof Boolean
                || object instanceof Byte
                || object instanceof Short;
    }

    /**
     * @param tableShard 分表注解
     * @param value      值
     * @param metaObject mybatis反射对象
     * @param boundSql   sql信息对象
     */
    private void replaceSql(TableShard tableShard, Object value, MetaObject metaObject, BoundSql boundSql) {
        String tableNamePrefix = tableShard.tableNamePrefix();
        // 获取策略class
        Class<? extends ITableShardStrategy> strategyClazz = tableShard.shardStrategy();
        // 从spring ioc容器获取策略类
        ITableShardStrategy tableShardStrategy = applicationContext.getBean(strategyClazz);
        // 生成分表名
        String shardTableName = tableShardStrategy.generateTableName(tableNamePrefix, value);
        // 获取sql
        String sql = boundSql.getSql();
        // 完成表名替换
        metaObject.setValue("delegate.boundSql.sql", sql.replaceAll(tableNamePrefix, shardTableName));
    }

    /**
     * 获取MetaObject对象-mybatis里面提供的一个工具类，类似反射的效果
     *
     * @param invocation invocation
     * @return MetaObject
     */
    private MetaObject getMetaObject(Invocation invocation) {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        // MetaObject是mybatis里面提供的一个工具类，类似反射的效果

        return MetaObject.forObject(statementHandler,
                SystemMetaObject.DEFAULT_OBJECT_FACTORY,
                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,
                defaultReflectorFactory
        );
    }

    /**
     * 获取分表注解
     *
     * @param method          method
     * @param mappedStatement mappedStatement
     * @return TableShard
     */
    private TableShard getTableShard(Method method, MappedStatement mappedStatement) throws ClassNotFoundException {
        String id = mappedStatement.getId();
        // 获取Class
        final String className = id.substring(0, id.lastIndexOf("."));
        // 分表注解
        TableShard tableShard = null;
        // 获取Mapper执行方法的TableShard注解
        tableShard = method.getAnnotation(TableShard.class);
        // 如果方法没有设置注解，从Mapper接口上面获取TableShard注解
        if (tableShard == null) {
            // 获取TableShard注解
            tableShard = Class.forName(className).getAnnotation(TableShard.class);
        }
        return tableShard;
    }

}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.BotAccountContextMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.AccountContext">
        <id column="id" property="id"/>
        <result column="bot_id" property="botId"/>
        <result column="bot_key" property="botKey"/>
        <result column="account_base_info_id" property="accountBaseInfoId"/>
        <result column="twitter_id" property="twitterId"/>
        <result column="discord_id" property="discordId"/>
        <result column="proxy_id" property="proxyId"/>
        <result column="browser_env_id" property="browserEnvId"/>
        <result column="telegram_id" property="telegramId"/>
        <result column="wallet_id" property="walletId"/>
        <result column="reward_id" property="rewardId"/>
        <result column="status" property="status"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="createIfTableNotExist" parameterType="java.lang.String">
        CREATE TABLE IF NOT EXISTS t_bot_account_context
        (
            "id"                   INTEGER PRIMARY KEY AUTOINCREMENT,
            "bot_id"               INTEGER NOT NULL,
            "bot_key"              TEXT,
            "account_base_info_id" INTEGER NOT NULL,
            "twitter_id"           INtEGER,
            "discord_id"           INTEGER,
            "proxy_id"             INTEGER,
            "browser_env_id"       INTEGER,
            "telegram_id"          INTEGER,
            "wallet_id"            INTEGER,
            "reward_id"            INTEGER,
            "status"               INTEGER,
            "usable"               INTEGER(1),
            "params"               TEXT,
            "insert_datetime"      TEXT,
            "update_datetime"      TEXT,
            "is_valid"             INTEGER(1)
        );
    </insert>

    <insert id="insertOrUpdate" parameterType="cn.com.helei.bot.core.entity.AccountBaseInfo">

        INSERT INTO t_bot_account_context
        (bot_id, bot_key, account_base_info_id, twitter_id, discord_id, proxy_id, browser_env_id, telegram_id,
         wallet_id,
         reward_id, status, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{botId}, #{botKey}, #{accountBaseInfoId}, #{twitterId}, #{discordId}, #{proxyId}, #{browserEnvId},
                #{telegramId},
                #{walletId}, #{rewardId}, #{status}, #{params}, #{insertDatetime}, #{updateDatetime},
                #{isValid}) ON CONFLICT(bot_key, account_base_info_id) DO
        UPDATE SET
            bot_id = excluded.bot_id,
            twitter_id = excluded.twitter_id,
            discord_id = excluded.discord_id,
            proxy_id = excluded.proxy_id,
            browser_env_id = excluded.browser_env_id,
            telegram_id = excluded.telegram_id,
            wallet_id = excluded.wallet_id,
            reward_id = excluded.reward_id,
            status = excluded.status,
            params = excluded.params,
            update_datetime = excluded.update_datetime;
    </insert>
</mapper>
import request from '@/utils/custom_request'

/**
 * 上传账户基本信息
 * @param accountBaseInfoList
 * @returns {*}
 */
export function uploadAccountBaseInfoList(accountBaseInfoList) {
  return request({
    url: '/accountBaseInfo/batchAdd',
    method: 'post',
    data: {
      rawLines: accountBaseInfoList
    }
  })
}

/**
 * 分页查询账户基本信息
 * @param {page, limit, filterMap}
 * @returns {*}
 */
export function pageQueryAccountBaseInfo({ page, limit, filterMap }) {
  return request({
    url: '/accountBaseInfo/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      filterMap
    }
  })
}

/**
 * 删除账户，根据id
 * @param ids
 * @returns {*}
 */
export function deleteAccountBaseInfo(ids) {
  return request({
    url: '/accountBaseInfo/delete',
    method: 'post',
    data: {
      ids: ids
    }
  })
}

import request from '@/utils/custom_request'

/**
 * 上传浏览器环境
 * @param browserEnvList browserEnvList
 * @returns {*}
 */
export function uploadBrowserEnvList(browserEnvList) {
  return request({
    url: '/browserEnv/upload',
    method: 'post',
    data: {
      rawLines: browserEnvList
    }
  })
}
/**
 * 分页查询浏览器环境
 * @param {page, limit}
 * @returns {*}
 */
export function pageQueryBrowserEnv({ page, limit, filterMap }) {
  return request({
    url: '/browserEnv/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      filterMap
    }
  })
}

/**
 * 删除BrowserEnv，根据id
 * @param ids
 * @returns {*}
 */
export function deleteBrowserEnv(ids) {
  return request({
    url: '/proxyInfo/delete',
    method: 'post',
    data: {
      ids: ids
    }
  })
}
import request from '@/utils/custom_request'

/**
 * 上传代理
 * @param proxyInfoList proxyInfoList
 * @returns {*}
 */
export function uploadProxyInfoList(proxyInfoList) {
  return request({
    url: '/proxyInfoList/upload',
    method: 'post',
    data: {
      rawLines: proxyInfoList
    }
  })
}

/**
 * 分页查询代理
 * @param {page, limit, filterMap}
 * @returns {*}
 */
export function pageQueryProxyInfo({ page, limit, filterMap }) {
  return request({
    url: '/proxyInfo/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      filterMap
    }
  })
}

/**
 * 删除账户，根据id
 * @param ids
 * @returns {*}
 */
export function deleteProxyInfo(ids) {
  return request({
    url: '/proxyInfo/delete',
    method: 'post',
    data: {
      ids: ids
    }
  })
}

import request from '@/utils/request'

/**
 * 分页查询discord
 * @param
 *   {
 *     page,
 *     limit,
 *     username,
 *     bindEmail,
 *     token
 *   } page,limit必须
 * @returns {*}
 */
export function pageQueryDiscord(
  {
    page,
    limit,
    username,
    bindEmail,
    token
  }
) {
  return request({
    url: '/discord/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      username,
      bindEmail,
      token
    }
  })
}

/**
 * 分页查telegramList
 * @param
 *   {
 *       page,
 *       limit,
 *       username,
 *       phone_prefix,
 *       phone
 *   } page,limit,必须
 * @returns {*}
 */
export function pageQueryTelegram(
  {
    page,
    limit,
    username,
    phone_prefix,
    phone
  }
) {
  return request({
    url: '/telegram/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      username,
      phone_prefix,
      phone
    }
  })
}

/**
 * 分页查bot
 * @param page
 * @param limit
 */
export function pageQueryBot({ page, limit }) {
  return request({
    url: '/bot/pageQuery',
    method: 'post',
    data: {
      page,
      limit
    }
  })
}

/**
 * 查询账户类型列表
 * @returns
 * [
 *   {
 *    type: 'google',
 *    count: 10
 *   }
 *]
 */
export function queryAccountTypeList() {
  return request({
    url: '/accountBaseInfo/typeList',
    method: 'get'
  })
}

import request from '@/utils/custom_request'

/**
 * 分页查询twitter
 * @param
 * {
 *     page,
 *     limit,
 *     fieldFilter
 *   }  page、limit 必选
 * @returns {*}
 */
export function pageQueryTwitter(
  {
    page,
    limit,
    fieldFilter
  }
) {
  return request({
    url: '/twitter/pageQuery',
    method: 'post',
    data: {
      page,
      limit,
      fieldFilter
    }
  })
}

/**
 * 上传twitter
 * @param uploadTwitterList uploadTwitterList
 * @returns {*}
 */
export function uploadTwitterList(uploadTwitterList) {
  return request({
    url: '/uploadTwitterList/upload',
    method: 'post',
    data: {
      rawLines: uploadTwitterList
    }
  })
}

/**
 * 删除Twitter，根据id
 * @param ids
 * @returns {*}
 */
export function deleteTwitter(ids) {
  return request({
    url: '/proxyInfo/delete',
    method: 'post',
    data: {
      ids: ids
    }
  })
}
import request from '@/utils/custom_request'

/**
 * 上传discord
 * @param discordList discordList
 * @returns {*}
 */
export function uploadDiscordList(discordList) {
  return request({
    url: '/discordList/upload',
    method: 'post',
    data: {
      discordList
    }
  })
}

/**
 * 上传telegramList
 * @param telegramList telegramList
 * @returns {*}
 */
export function uploadTelegramList(telegramList) {
  return request({
    url: '/telegramList/upload',
    method: 'post',
    data: {
      telegramList
    }
  })
}
import axios from 'axios'
import { MessageBox, Message } from 'element-ui'
import store from '@/store'
import { getToken } from '@/utils/auth'

// create an axios instance
const customService = axios.create({
  baseURL: 'http://localhost:10111', // url = base url + request url
  // withCredentials: true, // send cookies when cross-domain requests
  timeout: 5000 // request timeout
})

// request interceptor
customService.interceptors.request.use(
  config => {
    // do something before request is sent

    if (store.getters.token) {
      // let each request carry token
      // ['X-Token'] is a custom headers key
      // please modify it according to the actual situation
      config.headers['X-Token'] = getToken()
    }
    return config
  },
  error => {
    // do something with request error
    console.log(error) // for debug
    return Promise.reject(error)
  }
)

// response interceptor
customService.interceptors.response.use(
  /**
   * If you want to get http information such as headers or status
   * Please return  response => response
  */

  /**
   * Determine the request status by custom code
   * Here is just an example
   * You can also judge the status by HTTP Status Code
   */
  response => {
    const res = response.data

    console.log(res)
    // if the custom code is not 20000, it is judged as an error.
    if (res.success === undefined || res.success !== true) {
      Message({
        message: res.errorMsg || 'Error',
        type: 'error',
        duration: 5 * 1000
      })
      return Promise.reject(new Error(res.message || 'Error'))
    } else {
      return res
    }
  },
  error => {
    console.log('err' + error) // for debug
    Message({
      message: error.message,
      type: 'error',
      duration: 5 * 1000
    })
    return Promise.reject(error)
  }
)

export default customService
<template>
  <div>
    <!--    头部搜索、添加、上传 bar-->
    <div class="filter-container clearfix">
      <el-select
        v-for="headerName in fullHeaders"
        v-model="currentParams.headerFilterFieldValues[headerName]"
        :placeholder="headerName"
        clearable
        style="width: 90px"
        class="filter-item"
        @clear="currentParams.headerFilterFieldValues[headerName] = undefined"
      >
        <el-option v-for="item in getFieldOptions(headerName)" :key="item" :label="item" :value="item" />
      </el-select>

      <el-button
        v-waves
        class="filter-item"
        style="margin-left: 10px"
        type="primary"
        icon="el-icon-search"
        @click="handleFilter"
      >
        Search
      </el-button>
      <el-button
        v-if="useImportData"
        class="filter-item"
        style="margin-left: 10px;"
        type="primary"
        icon="el-icon-plus"
        @click="addBatchRowData"
      >
        Add
      </el-button>
      <el-button
        v-if="useImportData"
        v-waves
        class="filter-item"
        type="success"
        icon="el-icon-upload"
        @click="handleUpload"
      >
        Upload
      </el-button>

      <el-switch
        v-model="useImportData"
        class="filter-item"
        style="float: right; font-weight: bold"
        active-text="导入"
        inactive-text="查看"
      />
    </div>

    <!--    表格-->
    <el-table
      :data="filteredTableData()"
      border
      stripe
      fit
      highlight-current-row
      style="width: 100%;"
      @selection-change="handleSelectionChange"
    >
      <el-table-column type="selection" width="55" fixed="left" />

      <el-table-column type="index" class-name="status-col" min-width="75" />

      <el-table-column v-for="headName in fullHeaders" :label="headName" class-name="status-col" min-width="100">
        <template slot="header">
          {{ headName }}
          <el-badge
            v-if="headers.includes(headName)"
            class="header-badge"
            :value="''"
            :max="99"
            :is-dot="true"
          />
        </template>

        <template slot-scope="{row}">
          <el-input
            v-model="row[headName]"
            size="mini"
            placeholder="请输入内容"
          />
          <!--          <el-tag v-if="'email' === headName">{{ row[headName] }}</el-tag>-->
          <!--          <el-tag v-else-if="'type' === headName" type="success">-->
          <!--            {{ row[headName] }}-->
          <!--          </el-tag>-->
          <!--          <div v-else>{{ row[headName] }}</div>-->
        </template>
      </el-table-column>

      <el-table-column label="Status" class-name="status-col" width="75">
        <template slot-scope="{row}">
          <el-button
            v-if="buildRowStatus(row)"
            type="success"
            icon="el-icon-check"
            size="mini"
            circle
          />
          <el-button
            v-else
            type="warning"
            icon="el-icon-close"
            size="mini"
            circle
          />
        </template>
      </el-table-column>

      <el-table-column align="right" width="200" fixed="right">
        <template #header>
          <el-input
            v-model="newHeaderName"
            size="small"
            placeholder="输入新列名"
            style="display: inline-block;width: 60%"
          />
          <el-button type="primary" size="small" @click="addNewHeaderField">
            Add
          </el-button>
        </template>

        <template #default="scope">
          <el-button size="small" @click="handleEdit(scope.$index, scope.row)">
            Edit
          </el-button>
          <el-button
            size="small"
            type="danger"
            @click="handleDelete(scope.$index, scope.row)"
          >
            Delete
          </el-button>
        </template>
      </el-table-column>
    </el-table>

    <!--分页条-->
    <pagination
      v-show="filteredTableData() !== null && filteredTableData().length >0"
      :total="currentParams.listQuery.total"
      :page.sync="currentParams.listQuery.page"
      :limit.sync="currentParams.listQuery.limit"
    />

    <!--    表格单行编辑弹框-->
    <el-dialog :title="'编辑第 ' + currentParams.editRowIndex + '行数据'" :visible.sync="editRowFromVisible">

      <el-form
        ref="dataForm"
        :model="currentParams.editRowData"
        label-position="left"
        style="width: 400px; margin-left:50px;"
      >
        <el-form-item v-for="headName in fullHeaders" :label="headName" prop="headName">
          <el-input v-if="currentParams.editRowData !== null" v-model="currentParams.editRowData[headName]" />
        </el-form-item>
      </el-form>

      <div slot="footer" class="dialog-footer">
        <el-button @click="editRowFromVisible = false">
          Cancel
        </el-button>
        <el-button type="primary" @click="confirmEditRow">
          Confirm
        </el-button>
      </div>
    </el-dialog>

    <!--    添加界面-->
    <dynamic-field-load-from
      :ref="fieldLoadFromRef"
      :field-names="headers"
      :visible="addRowDataFromVisible"
      @batch-data-import="batchDataImportHandler"
    />
  </div>
</template>

<script>
import waves from '@/directive/waves' // waves directive
import Pagination from '@/components/Pagination'
import DynamicFieldLoadFrom from '@/views/custom/import/components/dynamic-field-load-from'

export default {
  name: 'DynamicAddColTable',
  components: { Pagination, DynamicFieldLoadFrom },
  directives: { waves },
  filters: {},
  props: {
    title: {
      type: String,
      default() {
        return ''
      }
    },
    headers: {
      type: Array,
      default() {
        return []
      }
    },
    customHeaders: {
      type: Array,
      default() {
        return []
      }
    },
    data: {
      type: Array,
      default() {
        return []
      }
    },
    batchQueryDataNetwork: {
      type: Function,
      default() {
        return () => {
        }
      }
    },
    uploadDataNetwork: {
      type: Function,
      default() {
        return () => {
        }
      }
    },
    deleteDataNetwork: {
      type: Function,
      default() {
        return () => {
        }
      }
    },
    updateDataNetwork: {
      type: Function,
      default() {
        return () => {
        }
      }
    }
  },
  data() {
    return {
      importData: [],
      newHeaderName: '',
      useImportData: false,
      editRowFromVisible: false,
      addRowDataFromVisible: false,

      typedParam: {
        import: {
          filteredTableDataIdxes: new Set(),
          headerFilterFieldValues: {},
          listQuery: {
            page: 1,
            limit: 20,
            total: 0
          },
          selectedDataList: [],
          editRowIndex: null,
          editRowData: null
        },
        display: {
          filteredTableDataIdxes: new Set(),
          headerFilterFieldValues: {},
          listQuery: {
            page: 1,
            limit: 20,
            total: 0
          },
          selectedDataList: [],
          editRowIndex: null,
          editRowData: null
        }
      }
    }
  },
  computed: {
    fullHeaders() {
      return this.headers.concat(this.customHeaders)
    },
    fieldLoadFromRef() {
      return 'dynamicFieldLoadFrom[' + this.headers + ']'
    },
    currentData() {
      return this.useImportData ? this.importData : this.data
    },
    currentParams() {
      return this.useImportData ? this.typedParam['import'] : this.typedParam['display']
    }
  },
  created() {
    this.queryDisplayData()
  },
  methods: {
    handleDelete(idx, row) {
      if (this.useImportData) {
        this.importData.splice(idx, 1)
      } else {
        this.deleteDataNetwork(row)
      }
    },
    handleEdit(idx, row) {
      this.currentParams.editRowIndex = idx
      this.currentParams.editRowData = JSON.parse(JSON.stringify(row))

      this.editRowFromVisible = true
    },
    handleSelectionChange(rows) {
      this.currentParams.selectedDataList = rows
    },
    handleFilter() {
      if (this.useImportData) {
        // 导入，前端筛选，
        this.currentParams.filteredTableDataIdxes.clear()

        for (let i = 0; i < this.currentData.length; i++) {
          const line = this.currentData[i]
          let flag = true
          for (const headName of this.fullHeaders) {
            const targetValue = this.currentParams.headerFilterFieldValues[headName]
            const currentValue = line[headName]

            if (targetValue !== undefined && targetValue !== currentValue) {
              flag = false
              break
            }
          }

          if (!flag) this.currentParams.filteredTableDataIdxes.add(i)
        }
        this.$forceUpdate()
      } else {
        // 展示，发送请求获取新数据
        this.queryDisplayData()
      }
    },
    handleUpload() {
      let uploadData = this.currentData
      if (this.currentParams.selectedDataList !== null && this.currentParams.selectedDataList.length > 0) {
        uploadData = this.currentParams.selectedDataList
      }
      this.uploadDataNetwork(uploadData)
    },
    /**
     * 批量添加数据
     * @param payload
     */
    batchDataImportHandler(payload) {
      console.log(payload)
      const newDataArray = payload.filteredData
      const customFields = payload.customFields

      this.importData.push(...newDataArray)

      if (customFields !== undefined && customFields !== null && customFields.length > 0) {
        this.customHeaders = [...new Set([...this.customHeaders, ...customFields])]
      }
    },
    confirmEditRow() {
      if (!this.useImportData) {
        this.updateDataNetwork(this.currentParams.editRowData)
      }

      this.$set(this.currentData, this.currentParams.editRowIndex, this.currentParams.editRowData)

      this.currentParams.editRowIndex = null
      this.currentParams.editRowData = null

      this.editRowFromVisible = false
    },
    addNewHeaderField() {
      if (this.newHeaderName === null ||
        this.newHeaderName === undefined ||
        this.newHeaderName === ''
      ) {
        return
      }

      if (this.customHeaders.indexOf(this.newHeaderName) === -1 && this.headers.indexOf(this.newHeaderName) === -1) {
        this.customHeaders.push(this.newHeaderName)
      }

      this.newHeaderName = ''
    },
    addBatchRowData() {
      this.$refs[this.fieldLoadFromRef].toggleVisible()
    },
    getFieldOptions(headerName) {
      const set = new Set()
      if (this.currentData === undefined || this.currentData === null) return {}

      for (const line of this.currentData) {
        const fieldValue = line[headerName]

        if (fieldValue !== undefined) {
          set.add(fieldValue == null ? 'null' : fieldValue)
        }
      }

      return set
    },
    buildRowStatus(row) {
      return this.headers.every(header => row[header] !== undefined &&
        row[header] !== null && row[header] !== '')
    },
    filteredTableData() {
      const curData = this.currentData

      const res = []
      for (let i = 0; i < curData.length; i++) {
        if (!this.currentParams.filteredTableDataIdxes.has(i)) {
          res.push(curData[i])
        }
      }
      const startIndex = (this.currentParams.listQuery.page - 1) * this.currentParams.listQuery.limit
      const endIndex = startIndex + this.currentParams.listQuery.limit
      return res.slice(startIndex, endIndex)
    },
    /**
     * 网络请求获取数据
     */
    queryDisplayData() {
      const display = this.typedParam.display

      this.batchQueryDataNetwork(display.listQuery, display.headerFilterFieldValues, pageInfo => {
        this.data = pageInfo.data
        display.listQuery.total = pageInfo.total
      })
    }
  }
}
</script>
<template>
  <el-dialog
    :close-on-click-modal="false"
    :visible.sync="isVisible"
    width="80%"
  >

    <div slot="title" class="components-container">
      <h3>请按照下方输入框中模板填入需导入的数据</h3>

      <el-switch
        v-model="isJsonType"
        style="display: block;float: right"
        active-color="#c59172"
        inactive-color="#13ce66"
        active-text="JSON格式"
        :active-value="true"
        inactive-text="Excel格式"
        :inactive-value="false"
      />
    </div>

    <div class="scrollbar-wrapper">
      <!--    json类型数据导入-->
      <div v-if="isJsonType" class="components-container">
        <aside>
          注意, 格式为一个JSON数组, 数组里的元素为每一条数据
          <br>
          需包含 {{ fieldNames }} 字段
        </aside>

        <div class="editor-container">
          <json-editor ref="jsonEditor" v-model="jsonValue" />
        </div>
      </div>
      <!--    excel类型数据导入-->
      <div v-else class="components-container">
        <aside>
          注意, excel文件的列
          <br>
          需包含 {{ fieldNames }} 字段
        </aside>

        <upload-excel-component :on-success="handleExcelUploadSuccess" :before-upload="beforeExcelUpload" />

        <el-table
          :data="excelValue"
          border
          show-header
          highlight-current-row
          height="600"
          :row-class-name="tableRowClassName"
          style="width: 100%;margin-top:20px;"
        >
          <el-table-column v-for="item of useHeader" :key="item" :prop="item" :label="item">
            <template slot="header">
              {{ item }}
              <el-badge
                v-if="fieldNames.includes(item)"
                class="header-badge"
                :value="''"
                :max="99"
                :is-dot="true"
              />
            </template>
          </el-table-column>
        </el-table>
      </div>
    </div>

    <div slot="footer" class="dialog-footer">
      <el-button @click="isVisible = false">
        Cancel
      </el-button>
      <el-button type="primary" @click="addBatchData">
        Confirm
      </el-button>
    </div>
  </el-dialog>
</template>

<script>
import JsonEditor from '@/components/JsonEditor/index.vue'
import UploadExcelComponent from '@/components/UploadExcel/index.vue'

export default {
  name: 'DynamicFieldLoadFrom',
  components: { UploadExcelComponent, JsonEditor },
  props: {
    fieldNames: {
      type: Array,
      default() {
        return []
      }
    },
    fieldExamples: {
      type: Array,
      default() {
        return []
      }
    },
    visible: {
      type: Boolean,
      default() {
        return false
      }
    }
  },
  data() {
    return {
      jsonValue: [],
      excelValue: [],
      excelHeaders: [],
      isVisible: this.visible,
      isJsonType: false,
      customFields: []
    }
  },
  computed: {
    useHeader() {
      return this.excelHeaders.length === 0 ? this.fieldNames : this.excelHeaders
    }
  },
  created() {
    const template = {}

    this.fieldNames.forEach(name => {
      const fieldExample = this.fieldExamples[name]
      template[name] = fieldExample === undefined ? null : fieldExample
    })

    this.jsonValue.push(template)
  },
  methods: {
    toggleVisible() {
      // 修改 data 属性
      this.isVisible = !this.isVisible
    },
    /**
     * 点击upload按钮触发，会发送事件将数据发送给父组件
     */
    addBatchData() {
      if (this.isJsonType) {
        this.jsonTypeAddBatchData()
      } else {
        this.excelTypeAddBatchData()
      }
    },
    beforeExcelUpload(file) {
      const isLt1M = file.size / 1024 / 1024 < 50

      if (isLt1M) {
        return true
      }

      this.$message({
        message: 'Please do not upload files larger than 50m in size.',
        type: 'warning'
      })
      return false
    },
    handleExcelUploadSuccess({ results, header }) {
      // excel 的header含有需要的全部字段
      console.log(this.fieldNames, header)
      if (this.fieldNames.every(item => header.includes(item))) {
        // 展示
        this.excelValue = results
        this.excelHeaders = header
        this.customFields = header.filter(customField => !this.fieldNames.includes(customField))

        console.log(this.customFields)
      } else {
        this.$message({
          message: 'excel文件没有完全包含需要的字段',
          type: 'error'
        })
      }
    },
    jsonTypeAddBatchData() {
      let isEdit = true
      let errorMsg = ''

      if (this.jsonValue instanceof Array) {
        isEdit = false
        errorMsg = '你还未输入内容'
      }

      let jsonArray = null
      if (isEdit) {
        try {
          jsonArray = JSON.parse(this.jsonValue)

          if (jsonArray instanceof Array) {
            this.trySendImportEvent(this.filterBatchData(jsonArray))

            return
          } else {
            // 警告数据格式不对
            errorMsg = 'json 格式错误'
          }
        } catch (e) {
          errorMsg = '系统异常' + e.message
        }
      }

      this.$msgbox(
        '导入数据发生错误,' + errorMsg + ', 请检查输入内容再点击确定',
        '警告',
        {
          confirmButtonText: '确定',
          type: 'error'
        }
      )
    },

    excelTypeAddBatchData() {
      const filteredData = this.filterBatchData(this.excelValue)

      this.trySendImportEvent(filteredData)
    },

    filterBatchData(batchData) {
      const res = []

      // 逐条检查数据格式对不对
      for (const item of batchData) {
        if (this.checkDataItem(item)) {
          res.push(item)
        }
      }

      return res
    },

    checkDataItem(item) {
      let f = true

      for (const fieldName of this.fieldNames) {
        const itemElement = item[fieldName]
        if (itemElement === undefined || itemElement === null || itemElement === '') {
          f = false
          break
        }
      }
      return f
    },
    trySendImportEvent(filteredData) {
      if (filteredData.length === 0) {
        this.$msgbox(
          '导入数据发生错误, 没有任何合法数据, 请检查输入内容再点击确定',
          '警告',
          {
            confirmButtonText: '确定',
            type: 'error'
          }
        )
      } else {
        this.$emit('batch-data-import', { filteredData, customFields: this.customFields })
        this.isVisible = false
      }
    },

    tableRowClassName({ row, rowIndex }) {
      if (this.checkDataItem(row)) {
        return 'success-row'
      } else {
        return 'warning-row'
      }
    }
  }
}
</script>

<style>
.el-table .warning-row {
  background: oldlace;
}

.el-table .success-row {
  background: #ebf9eb;
}
</style>
