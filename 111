package cn.com.vortexa.web3.constants;

import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import lombok.Data;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author h30069248
 * @since 2025/4/23 10:27
 */
@Data
public class Web3ChainDict {
    public static final String RESOURCE_FILE_NAME = "chain-info.yaml";
    public static final List<String> PREFIX = List.of("vortexa", "web3");
    public static final Web3ChainDict INSTANCE;

    static {
        try (InputStream is = Web3ChainDict.class.getClassLoader().getResourceAsStream(RESOURCE_FILE_NAME)){
            INSTANCE = YamlConfigLoadUtil.load(RESOURCE_FILE_NAME, is, PREFIX, Web3ChainDict.class);
            if (INSTANCE.chainInfo != null) {
                INSTANCE.name2ChainInfoMap = INSTANCE.chainInfo.stream().collect(Collectors.toMap(Web3ChainInfo::getName, w->w));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    private List<Web3ChainInfo> chainInfo;

    private Map<String, Web3ChainInfo> name2ChainInfoMap;

    public Web3ChainInfo getChainInfo(String name) {
        return name2ChainInfoMap.get(name);
    }

    public static void main(String[] args) {
        System.out.println(INSTANCE);
    }
}
package cn.com.vortexa.web3.constants;

/**
 * @author h30069248
 * @since 2025/4/23 10:54
 */
public enum Web3jFunctionType {
    Uint256,
    Address
}
package cn.com.vortexa.web3.dto;

import lombok.Data;

import java.io.Serializable;

/**
 * @author helei
 * @since 2025/4/23 10:05
 */
@Data
public class ContractABI implements Serializable {

    /**
     * 链的类型
     */
    private String chainType;

    /**
     * 合约地址
     */
    private String contractAddress;

    /**
     * abi内容的字符串
     */
    private String abiContent;
}
package cn.com.vortexa.web3.dto;

import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.hutool.core.lang.Pair;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


import java.io.Serializable;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/23 11:05
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SCInvokeParams implements Serializable {
    /**
     * 钱包id
     */
    private Integer walletId;

    /**
     * 钱包信息
     */
    private WalletInfo walletInfo;

    /**
     * 链信息
     */
    private Web3ChainInfo chainInfo;

    /**
     * 调用的合约地址
     */
    private String contractAddress;
    /**
     * abi方法名
     */
    private String functionName;
    /**
     * 只读方法
     */
    private Boolean readFunction;
    /**
     * 参数类型
     */
    private List<Pair<Web3jFunctionType, Object>> paramsTypes;
    /**
     * 返回值类型
     */
    private List<Web3jFunctionType> resultTypes;
}
package cn.com.vortexa.web3.dto;

import lombok.Data;

import java.io.Serializable;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/23 11:48
 */
@Data
public class SCInvokeResult implements Serializable {

    /**
     * 交易类型合约交互时返回的交易hash
     */
    private String transactionHash;

    /**
     * 查询类型合约交互时得到的结果
     */
    private List<Object> result;
}
package cn.com.vortexa.web3.dto;


import cn.com.vortexa.common.constants.ChainType;
import cn.com.vortexa.common.entity.Web3Wallet;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

/**
 * @author helei
 * @since 2025-04-05
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class WalletInfo implements Serializable {
    private String address;
    private String privateKey;
    private String publicKey;
    private String mnemonic;

    public WalletInfo(ChainType chainType, Web3Wallet web3Wallet) {
        switch (chainType) {
            case ETH -> {
                this.address = web3Wallet.getEthAddress();
                this.privateKey = web3Wallet.getEthPrivateKey();
            }
            case SOL -> {
                this.address = web3Wallet.getSolAddress();
                this.privateKey = web3Wallet.getSolPrivateKey();
            }
        }
        this.mnemonic = web3Wallet.getMnemonic();
    }
}
package cn.com.vortexa.web3.dto;


import cn.com.vortexa.common.constants.ChainType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Web3ChainInfo implements Serializable {
    /**
     * 链类型
     */
    private ChainType chainType;

    private String rpcUrl;

    private String name;

    private Integer chainId;

    private String originTokenSymbol;

    private String blockExploreUrl;
}
package cn.com.vortexa.web3.util;

import cn.com.vortexa.web3.constants.Web3jFunctionType;

import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/23 10:51
 */
public class ABIFunctionBuilder {
    private String functionName;
    private final List<Type> parameterTypes = new ArrayList<>();
    private final List<TypeReference<?>> returnTypes = new ArrayList<>();

    public static ABIFunctionBuilder builder() {
        return new ABIFunctionBuilder();
    }

    public ABIFunctionBuilder functionName(String functionName) {
        this.functionName = functionName;
        return this;
    }

    public ABIFunctionBuilder addParameterType(Web3jFunctionType type, Object value) {
        parameterTypes.add(switch (type) {
            case Uint256 -> new Uint256(BigInteger.valueOf((Long) value));
            case Address -> new Address(String.valueOf(value));
        });
        return this;
    }

    public ABIFunctionBuilder addReturnType(Web3jFunctionType type) {
        returnTypes.add(switch (type) {
            case Uint256 -> new TypeReference<Uint256>() {};
            case Address -> new TypeReference<Address>() {};
        });
        return this;
    }

    public Function build() {
        return new Function(functionName, parameterTypes, returnTypes);
    }
}
package cn.com.vortexa.web3;

import cn.com.vortexa.web3.dto.WalletInfo;
import cn.com.vortexa.web3.util.ABIFunctionBuilder;

import org.bitcoinj.crypto.*;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.crypto.*;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.EthCall;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.http.HttpService;
import org.web3j.tx.gas.DefaultGasProvider;
import org.web3j.utils.Numeric;

import java.io.IOException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;

/**
 * @author helei
 * @since 2025/3/28 11:16
 */
public class EthWalletUtil {

    private static final SecureRandom secureRandom = new SecureRandom();

    public static WalletInfo generateEthWallet() {
        return generateWalletInfoFromMnemonic(generateMnemonic());
    }

    public static String generateMnemonic() {
        // 1. 生成助记词
        SecureRandom secureRandom = new SecureRandom();
        byte[] entropy = new byte[16]; // 128 bits entropy
        secureRandom.nextBytes(entropy);

        // 使用 bitcoinj 生成助记词
        var mnemonicCode = MnemonicCode.INSTANCE;
        List<String> mnemonicWords = null;
        try {
            mnemonicWords = mnemonicCode.toMnemonic(entropy);
        } catch (MnemonicException.MnemonicLengthException e) {
            throw new RuntimeException(e);
        }
        return String.join(" ", mnemonicWords);
    }

    public static WalletInfo generateWalletInfoFromMnemonic(String mnemonic) {
        // 2. 生成 seed
        byte[] seed = MnemonicUtils.generateSeed(mnemonic, ""); // passphrase 可设置

        // 3. 创建 HD 钱包根节点 (BIP32 Root Key)
        DeterministicKey rootPrivateKey = HDKeyDerivation.createMasterPrivateKey(seed);

        // 4. 分步派生 BIP44 路径 m/44'/60'/0'/0/0
        DeterministicKey purposeKey = HDKeyDerivation.deriveChildKey(rootPrivateKey, new ChildNumber(44, true));
        DeterministicKey coinTypeKey = HDKeyDerivation.deriveChildKey(purposeKey, new ChildNumber(60, true));
        DeterministicKey accountKey = HDKeyDerivation.deriveChildKey(coinTypeKey, new ChildNumber(0, true));
        DeterministicKey externalKey = HDKeyDerivation.deriveChildKey(accountKey, ChildNumber.ZERO); // change = 0
        DeterministicKey addressKey = HDKeyDerivation.deriveChildKey(externalKey,
            ChildNumber.ZERO); // address index = 0

        byte[] privateKeyBytes = addressKey.getPrivKeyBytes();

        // 转为 web3j 的 ECKeyPair
        ECKeyPair keyPair = ECKeyPair.create(privateKeyBytes);
        Credentials credentials = Credentials.create(keyPair);

        // 6. 输出钱包信息
        return WalletInfo.builder()
            .mnemonic(mnemonic)
            .privateKey(keyPair.getPrivateKey().toString(16))
            .publicKey(keyPair.getPublicKey().toString(16))
            .address(credentials.getAddress())
            .build();
    }

    public static Sign.SignatureData signatureMessage2Data(String privateKey, String message) {
        byte[] contentHashBytes = message.getBytes();
        // 根据私钥获取凭证对象
        Credentials credentials = Credentials.create(privateKey);
        return Sign.signPrefixedMessage(contentHashBytes, credentials.getEcKeyPair());
    }

    public static String signatureMessage2String(String privateKey, String message) {
        Sign.SignatureData signMessage = signatureMessage2Data(privateKey, message);

        byte[] r = signMessage.getR();
        byte[] s = signMessage.getS();
        byte[] v = signMessage.getV();

        byte[] signByte = Arrays.copyOf(r, v.length + r.length + s.length);
        System.arraycopy(s, 0, signByte, r.length, s.length);
        System.arraycopy(v, 0, signByte, r.length + s.length, v.length);

        return Numeric.toHexString(signByte);
    }

    public static String getETHAddress(String privateKeyHex) {
        Credentials credentials = Credentials.create(privateKeyHex);

        // 获取原始地址（小写）
        String rawAddress = credentials.getAddress();

        // 将地址转换为区分大小写的 Checksum 地址
        return Keys.toChecksumAddress(rawAddress);
    }

    public static BigInteger getNonce(String rpcUrl, String address) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        EthGetTransactionCount transactionCount = web3j.ethGetTransactionCount(
                address, org.web3j.protocol.core.DefaultBlockParameterName.LATEST)
            .send();

        return transactionCount.getTransactionCount();
    }

    public static String getRandomNonce() {
        // 生成 32 字节的随机数
        byte[] randomBytes = new byte[32];
        secureRandom.nextBytes(randomBytes);

        // 将字节数组转换为十六进制字符串
        return toHex(randomBytes);
    }

    // 将字节数组转换为十六进制字符串
    public static String toHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));  // 格式化为两位十六进制
        }
        return hexString.toString();
    }

    /**
     * 制度的智能合约调用
     *
     * @param rpcUrl rpcUrl
     * @param contractAddress contractAddress
     * @param address address
     * @param functionBuilder functionBuilder
     * @return List<Type>
     * @throws IOException IOException
     */
    public static List<Type> smartContractCallInvoke(
        String rpcUrl,
        String contractAddress,
        String address,
        ABIFunctionBuilder functionBuilder
    ) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        Function function = functionBuilder.build();
        Transaction transaction = Transaction.createEthCallTransaction(
            address,
            contractAddress,
            FunctionEncoder.encode(function)
        );

        EthCall response = web3j.ethCall(
            transaction,
            DefaultBlockParameterName.LATEST
        ).send();
        return FunctionReturnDecoder.decode(response.getValue(), function.getOutputParameters());
    }

    /**
     * 制度的智能合约调用
     *
     * @param rpcUrl rpcUrl
     * @param contractAddress contractAddress
     * @param address address
     * @param functionBuilder functionBuilder
     * @return String   ethSendTransaction
     * @throws IOException IOException
     */
    public static String smartContractTransactionInvoke(
        String rpcUrl,
        String contractAddress,
        String address,
        ABIFunctionBuilder functionBuilder
    ) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        Function function = functionBuilder.build();

        Transaction transaction = Transaction.createFunctionCallTransaction(
            address,
            null,
            DefaultGasProvider.GAS_PRICE,
            DefaultGasProvider.GAS_LIMIT,
            contractAddress,
            FunctionEncoder.encode(function)
        );
        EthSendTransaction ethSendTransaction = web3j.ethSendTransaction(transaction).send();
        return ethSendTransaction.getTransactionHash();
    }
}
vortexa:
  web3:
    chain-info:
      - name: Monad_Testnet
        rpcUrl: https://testnet-rpc.monad.xyz/
        chainId: 10143
        originTokenSymbol: MON
        blockExploreUrl: https://testnet.monadexplorer.com

      - name: Eth_Sepora
        rpcUrl: https://testnet-rpc.monad.xyz/
        chainId: 10143
        originTokenSymbol: MON
        blockExploreUrl: https://testnet.monadexplorer.com

package cn.com.vortexa.bot_platform.controller;

import cn.com.vortexa.bot_platform.service.IScriptNodeService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.control.RegisteredScriptNode;
import cn.hutool.core.util.StrUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@RestController
@RequestMapping("/script-node")
public class ScriptNodeController {

    @Autowired
    private IScriptNodeService scriptNodeService;

    @PostMapping("/remote-config/{scriptNodeName}")
    public Result remoteConfig(@PathVariable("scriptNodeName") String scriptNodeName) {
        String configStr = null;
        try {
            configStr = scriptNodeService.loadScriptNodeConfig(scriptNodeName);
            if (StrUtil.isBlank(configStr)) {
                return Result.fail(scriptNodeName + " config is empty");
            }
            return Result.ok(configStr);
        } catch (IOException e) {
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @PostMapping("/remote-config")
    public Result botRemoteConfig(
            @RequestParam("scriptNodeName") String scriptNodeName,
            @RequestParam("botKey") String botKey
    ) {
        String configStr = null;
        try {
            configStr = scriptNodeService.loadScriptNodeBotConfig(scriptNodeName, botKey);
            if (StrUtil.isBlank(configStr)) {
                return Result.fail(" config is empty");
            }
            return Result.ok(configStr);
        } catch (IOException e) {
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @PostMapping("/all")
    public Result queryAllScriptNode() {
        List<RegisteredScriptNode> list = scriptNodeService.queryAllScriptNode();
        return Result.ok(list);
    }
}

package cn.com.vortexa.bot_platform.controller;

import cn.com.vortexa.bot_platform.service.IWeb3WalletService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.web3.dto.SCInvokeParams;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@RestController
@RequestMapping("/web3")
public class Web3WalletController {
    @Autowired
    public IWeb3WalletService web3WalletService;

    @PostMapping("/signature")
    public Result signatureWalletMessage(SignatureMessage message) {
        return Result.ok(web3WalletService.signatureMessage(message));
    }

    @PostMapping("/smart_contract_invoke")
    public Result smartContractInvoke(@RequestBody SCInvokeParams invokeParams) {
        try {
            return web3WalletService.smartContractInvoke(invokeParams);
        } catch (Exception e) {
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import static cn.com.vortexa.common.entity.Web3Wallet.PUBLIC_FIELDS;

import cn.com.vortexa.bot_platform.web3.SmartContractInvoker;
import cn.com.vortexa.web3.dto.SCInvokeParams;
import cn.com.vortexa.web3.dto.SCInvokeResult;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import cn.hutool.core.collection.CollUtil;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.bot_platform.mapper.Web3WalletMapper;
import cn.com.vortexa.bot_platform.service.IWeb3WalletService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.excel.ExcelReadUtil;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.rpc.api.platform.IWeb3WalletRPC;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.SolanaWalletUtil;
import cn.com.vortexa.common.constants.ChainType;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@Slf4j
@Service
public class Web3WalletServiceImpl extends AbstractBaseService<Web3WalletMapper, Web3Wallet>
    implements IWeb3WalletRPC, IWeb3WalletService {

    private final Web3WalletMapper web3WalletMapper;

    public Web3WalletServiceImpl(Web3WalletMapper web3WalletMapper) {
        super();
        this.web3WalletMapper = web3WalletMapper;
    }

    @Override
    public Result signatureMessageRPC(SignatureMessage message) {
        return signatureMessage(message);
    }

    @Override
    public List<Web3Wallet> batchQueryByIdsRPC(List<Serializable> ids) {
        return batchQueryByIds(ids);
    }

    @Override
    public List<Web3Wallet> batchQueryByIds(List<Serializable> ids) {
        if (CollUtil.isEmpty(ids)) {
            return List.of();
        }
        QueryWrapper<Web3Wallet> queryWrapper = new QueryWrapper<>();
        queryWrapper.select(PUBLIC_FIELDS);
        queryWrapper.in("id", ids);
        return baseMapper.selectList(queryWrapper);
    }

    @Override
    public Result signatureMessage(SignatureMessage signatureMessage) {
        Integer walletId;
        String message;
        if ((walletId = signatureMessage.getWalletId()) == null || walletId < 0 || StrUtil.isBlank(
            message = signatureMessage.getMessage())) {
            return Result.fail("params illegal");
        }

        Web3Wallet web3Wallet = baseMapper.selectOne(new QueryWrapper<>(Web3Wallet.builder().id(walletId).build()));
        if (web3Wallet == null) {
            return Result.fail("wallet %s not exist".formatted(walletId));
        }

        ChainType chainType = signatureMessage.getChainType();
        try {
            String signature = switch (chainType) {
                case ETH -> EthWalletUtil.signatureMessage2String(web3Wallet.getEthPrivateKey(), message);
                case SOL -> SolanaWalletUtil.signatureMessage2String(web3Wallet.getSolPrivateKey(), message);
                case null -> throw new IllegalArgumentException("chain type[%s] not support".formatted(chainType));
            };
            return Result.ok(signature);
        } catch (Exception e) {
            log.error("{} signature chain[{}] message[{}] fail", walletId, chainType, message, e);
            return Result.fail("signature failed");
        }
    }

    @Override
    public Result smartContractInvoke(SCInvokeParams invokeParams) throws IOException {
        if (invokeParams.getWalletId() == null && invokeParams.getWalletInfo() == null) {
            return Result.fail("walletId or walletInfo must be provided");
        }

        Web3ChainInfo chainInfo = invokeParams.getChainInfo();
        if (chainInfo == null) {
            return Result.fail("chainInfo must be provided");
        }

        WalletInfo wallet = invokeParams.getWalletInfo() == null
            ? new WalletInfo(chainInfo.getChainType(), web3WalletMapper.selectById(invokeParams.getWalletId()))
            : invokeParams.getWalletInfo();

        SCInvokeResult result = switch (chainInfo.getChainType()) {
            case ETH -> SmartContractInvoker.CHAIN.ETH.invokeSCFunction(wallet, chainInfo, invokeParams);
            default ->
                throw new IllegalArgumentException("chain type[%s] not support".formatted(chainInfo.getChainType()));
        };

        return Result.ok(result);
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getAppResourceSystemConfigDir() + File.separator + fileBotConfigPath;
        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);
            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("read wallet file[{}] error", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<Web3Wallet> web3Wallets = new ArrayList<>();
        for (Map<String, Object> line : rawLines) {
            String mnemonic = String.valueOf(line.get("mnemonic"));
            Web3Wallet.Web3WalletBuilder builder = Web3Wallet.builder().mnemonic(mnemonic);

            WalletInfo ethWallet = EthWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.ethPrivateKey(ethWallet.getPrivateKey());
            builder.ethAddress(ethWallet.getAddress());

            WalletInfo solWallet = SolanaWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.solPrivateKey(solWallet.getPrivateKey());
            builder.solAddress(solWallet.getAddress());
        }
        return insertOrUpdateBatch(web3Wallets);
    }
}
package cn.com.vortexa.bot_platform.service;

import com.baomidou.mybatisplus.extension.service.IService;

import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.db_layer.service.ImportService;
import cn.com.vortexa.web3.dto.SCInvokeParams;

import java.io.IOException;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
public interface IWeb3WalletService extends IService<Web3Wallet>, ImportService {

    Result signatureMessage(SignatureMessage signatureMessage);

    /**
     * 智能合约交互
     *
     * @param invokeParams  invokeParams
     * @return  Result
     */
    Result smartContractInvoke(SCInvokeParams invokeParams) throws IOException;
}
package cn.com.vortexa.bot_platform.web3;

import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.com.vortexa.web3.dto.SCInvokeParams;
import cn.com.vortexa.web3.dto.SCInvokeResult;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import cn.com.vortexa.web3.util.ABIFunctionBuilder;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.lang.Pair;

import org.web3j.abi.datatypes.Type;

import java.io.IOException;

import java.util.List;
/**
 * 智能合约调用器
 *
 * @author helei
 * @since 2025/4/23 10:11
 */
public interface SmartContractInvoker {
    /**
     * 执行智能合约交互
     *
     * @param walletInfo  钱包信息
     * @param chainInfo  链信息
     * @param scInvokeParams 调用参数
     * @return  SCInvokeResult
     * @throws IOException  IOException
     */
    SCInvokeResult invokeSCFunction(
        WalletInfo walletInfo,
        Web3ChainInfo chainInfo,
        SCInvokeParams scInvokeParams
    ) throws IOException;

    enum CHAIN implements SmartContractInvoker {
        ETH {
            @Override
            public  SCInvokeResult invokeSCFunction(
                WalletInfo walletInfo,
                Web3ChainInfo chainInfo,
                SCInvokeParams scInvokeParams
            ) throws IOException {
                List<Web3jFunctionType> resultTypes = scInvokeParams.getResultTypes();

                // Step 1 构建合约调用方法
                ABIFunctionBuilder functionBuilder = ABIFunctionBuilder
                    .builder()
                    .functionName(scInvokeParams.getFunctionName());

                if (CollUtil.isNotEmpty(scInvokeParams.getParamsTypes())) {
                    for (Pair<Web3jFunctionType, Object> paramsType : scInvokeParams.getParamsTypes()) {
                        functionBuilder.addParameterType(paramsType.getKey(), paramsType.getValue());
                    }
                }
                if (CollUtil.isNotEmpty(resultTypes)) {
                    for (Web3jFunctionType resultType : resultTypes) {
                        functionBuilder.addReturnType(resultType);
                    }
                }

                // Step 3 调用合约
                SCInvokeResult result = new SCInvokeResult();
                if (scInvokeParams.getReadFunction()) {
                    List<Type> types = EthWalletUtil.smartContractCallInvoke(
                        chainInfo.getRpcUrl(),
                        scInvokeParams.getContractAddress(),
                        walletInfo.getAddress(),
                        functionBuilder
                    );
                    result.setResult(types.stream().map(Type::getValue).toList());
                } else {
                    String transactionHash = EthWalletUtil.smartContractTransactionInvoke(
                        chainInfo.getRpcUrl(),
                        scInvokeParams.getContractAddress(),
                        walletInfo.getAddress(),
                        functionBuilder
                    );
                    result.setTransactionHash(transactionHash);
                }

                return result;
            }
        }
    }
}
package cn.com.vortexa.script_node.config;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import com.alibaba.fastjson.JSONObject;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.env.EnvironmentPostProcessor;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;
import org.yaml.snakeyaml.Yaml;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;

public class RemoteConfigLoader implements EnvironmentPostProcessor {


    @Override
    public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
        try {
            final String appConfigPath = FileUtil.USER_DIR + File.separator + "config" + File.separator + "application.yaml";
            ScriptNodeConfiguration preLoadSNConfig = YamlConfigLoadUtil.load(new File(appConfigPath),
                List.of("vortexa", "scriptNode"), ScriptNodeConfiguration.class);

            String configUrl = preLoadSNConfig.buildRemoteConfigRestApi();
            String scriptNodeName = preLoadSNConfig.getScriptNodeName();
            if (configUrl == null || scriptNodeName == null) {
                System.err.println("no remote.config-url or script node name，skip load remote config");
                return;
            }

            // 拉取 YAML 内容
            String yamlContent = fetchRemoteConfig(configUrl, scriptNodeName);
            Yaml yaml = new Yaml();

            // 使用 SnakeYAML 2.2 解析成 Map
            Map<String, Object> yamlMap = yaml.load(yamlContent);

            // 转成 PropertySource，放在最前面
            MapPropertySource propertySource = new MapPropertySource(
                    "remote-config", YamlConfigLoadUtil.flattenMap(yamlMap)
            );
            environment.getPropertySources().addFirst(propertySource);
        } catch (Exception e) {
            System.err.println("remote config load error，use local config: " + e.getMessage());
        }
    }

    private String fetchRemoteConfig(String configUrl, String scriptNodeName) throws IOException {
        try {
            String response = RestApiClientFactory.getClient().request(
                    configUrl + "/script-node/remote-config" + scriptNodeName,
                    HttpMethod.POST,
                    new HashMap<>(),
                    null,
                    new JSONObject()
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                return String.valueOf(result.getData());
            } else {
                throw new IOException(result.getErrorMsg());
            }
        } catch (InterruptedException | ExecutionException e) {
            throw new IOException("fetch remote config error", e);
        }
    }
}

package cn.com.vortexa.script_node.constants;


/**
 * @author helei
 * @since 2025-04-19
 */
public class ScriptNodeConstants {

}
spring:
  datasource:
    driver-class-name: org.sqlite.JDBC
    url:
    username:
    password:
  quartz:
    job-store-type: jdbc
    jdbc:
      table-prefix: QRTZ_
      driver-class: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/job_store
      user: helei
      password: 123456
      scheduler:
        instance-name: QuartzScheduler


vortexa:
  script-node:
    remote-rest-url: http://192.168.1.98:10110
    script-node-name: helei-macbook
    auto-launch-bot-keys:
      # - optim_ai_test
#      - klok_test
      # - flow3_bot_test
      - taker_google
      - magic_newton_v2
#      - beamable_test
  #    bot-instance-locations: "reactive:"
    bot-common-config:
      two_captcha_api_key: ''
    bot-instance-jar-names:
      - vortexa-script-bot

  script-agent:
    registryCenterUrl: ws://localhost:18848
    nio-thread-count: 1
    service-offline-ttl: 60
    serviceInstance:
      host: localhost
      port: 20001
      groupId: default
      serviceId: script-node
      instanceId: script-node-macbook

