package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.config.BaseAutoBotConfig;
import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.constants.DepinBotStatus;
import cn.com.helei.bot.core.dto.AutoBotRuntimeInfo;
import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.exception.DepinBotInitException;
import cn.com.helei.bot.core.exception.DepinBotStatusException;
import cn.com.helei.bot.core.pool.ProxyPool;
import cn.com.helei.bot.core.util.FileUtil;
import cn.com.helei.bot.core.util.NamedThreadFactory;
import cn.com.helei.bot.core.util.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationContext;

import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

@Slf4j
@Getter
public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 配置
     */
    private final BaseAutoBotConfig baseAutoBotConfig;

    /**
     * 状态
     */
    private DepinBotStatus status = DepinBotStatus.NEW;

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot运行时信息
     */
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * spring 上下文
     */
    private final ApplicationContext applicationContext;

    public AbstractAutoBot(BaseAutoBotConfig baseAutoBotConfig, ApplicationContext applicationContext) {
        if (StrUtil.isBlank(baseAutoBotConfig.getName())) throw new IllegalArgumentException("bot 名字不能为空");

        this.baseAutoBotConfig = baseAutoBotConfig;
        this.executorService = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(baseAutoBotConfig.getName() + "-executor"));

        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();

        this.applicationContext = applicationContext;
    }


    public void init() {
        updateState(DepinBotStatus.INIT);
        try {
            doInit();

            //更新状态
            updateState(DepinBotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化DepinBot[{}}发生错误", getBaseAutoBotConfig().getName(), e);
            updateState(DepinBotStatus.INIT_ERROR);
        }
    }




    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;


    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            String method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {

        Semaphore networkController = networkSyncControllerMap
                .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                    if (v == null) {
                        v = new Semaphore(baseAutoBotConfig.getConcurrentCount());
                    }
                    return v;
                });


        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "开始";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                log.info("同步器允许发送请求-{}", str);

                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, getBaseAutoBotConfig().getName());
    }


    /**
     * 更新DepinBotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(DepinBotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(DepinBotStatus.SHUTDOWN)) {
            status = DepinBotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> DepinBotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(DepinBotStatus.INIT_FINISH)
                        || newStatus.equals(DepinBotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(DepinBotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(DepinBotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(DepinBotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }
}
package cn.com.helei.bot.core.bot.base;


import cn.com.helei.bot.core.entity.AccountContext;

import javax.mail.Message;
import java.util.concurrent.CompletableFuture;

public interface AccountAutoBot {

    /**
     * 注册账户
     *
     * @param accountContext accountContext
     * @param inviteCode     inviteCode
     * @return CompletableFuture<Boolean> 是否注册成功
     */
    CompletableFuture<Boolean> registerAccount(AccountContext accountContext, String inviteCode);

    /**
     * 从message提取需要的内容验证邮箱
     *
     * @param accountContext accountContext
     * @param message        message
     * @return CompletableFuture<Boolean>
     */
    CompletableFuture<Boolean> verifierAccountEmail(AccountContext accountContext, Message message);

    /**
     * 请求获取账户token
     *
     * @param accountContext accountContext
     * @return CompletableFuture<String> token
     */
    CompletableFuture<String> requestTokenOfAccount(AccountContext accountContext);


    /**
     * 开始账户自动收获,会自动循环。返回false则跳出自动循环
     *
     * @return CompletableFuture<Void>
     */
    boolean doAccountClaim(AccountContext accountContext);


    /**
     * 更新账户奖励信息
     *
     * @param accountContext accountContext
     * @return CompletableFuture<Boolean>
     */
    CompletableFuture<Boolean> updateAccountRewordInfo(AccountContext accountContext);

}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.config.AccountMailConfig;
import cn.com.helei.bot.core.config.BaseAutoBotConfig;
import cn.com.helei.bot.core.config.TypedAccountConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.exception.RewardQueryException;
import cn.com.helei.bot.core.exception.DepinBotInitException;
import cn.com.helei.bot.core.supporter.mail.constants.MailProtocolType;
import cn.com.helei.bot.core.supporter.mail.factory.MailReaderFactory;
import cn.com.helei.bot.core.supporter.mail.reader.MailReader;
import cn.com.helei.bot.core.supporter.persistence.AccountPersistenceManager;
import cn.com.helei.bot.core.supporter.persistence.impl.FileAccountPersistenceManager;
import cn.com.helei.bot.core.util.ClosableTimerTask;
import cn.hutool.core.collection.ConcurrentHashSet;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationContext;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

import static cn.com.helei.bot.core.constants.MapConfigKey.EMAIL_VERIFIED_KEY;
import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AccountManageAutoBot extends AbstractAutoBot implements AccountAutoBot {

    /**
     * 持久化管理器
     */
    @Setter
    private AccountPersistenceManager persistenceManager;

    /**
     * 账号列表
     */
    @Getter
    private final Map<String, List<AccountContext>> typedAccountMap = new HashMap<>();

    /**
     * 是否允许账户收益查询
     */
    private final AtomicBoolean isRunningAccountRewardQuery = new AtomicBoolean(true);

    /**
     * 存放账户对应的addTimer添加的任务
     */
    private final Map<AccountContext, Set<ClosableTimerTask>> accountTimerTaskMap;

    /**
     * task 任务并发控制
     */
    private final Semaphore taskSyncController;

    /**
     * 是否开始过链接所有账号
     */
    private final Set<String> startedAccountType = new ConcurrentHashSet<>();


    public AccountManageAutoBot(BaseAutoBotConfig baseAutoBotConfig, ApplicationContext applicationContext) {
        super(baseAutoBotConfig, applicationContext);

        this.persistenceManager = new FileAccountPersistenceManager(baseAutoBotConfig.getName());
        this.accountTimerTaskMap = new ConcurrentHashMap<>();
        this.taskSyncController = new Semaphore(baseAutoBotConfig.getConcurrentCount());
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        // Step 1 初始化保存的线程
        persistenceManager.init();

        // Step 2 初始化账户
        initAccounts();
    }

    /**
     * 添加定时任务,closableTimerTask执行run方法放回true会继续执行， 返回false则会跳出循环
     *
     * @param taskLogic taskLogic
     * @param delay     delay
     * @param timeUnit  timeUnit
     */
    public ClosableTimerTask addTimer(
            Supplier<Boolean> taskLogic,
            long delay,
            TimeUnit timeUnit,
            AccountContext timerOwner
    ) {
        ClosableTimerTask closableTimerTask = new ClosableTimerTask(taskLogic);

        accountTimerTaskMap.compute(timerOwner, (k, v) -> {
            if (v == null) {
                v = new HashSet<>();
            }
            v.add(closableTimerTask);
            return v;
        });

        getExecutorService().execute(() -> {
            while (true) {
                try {
                    taskSyncController.acquire();

                    if (closableTimerTask.isRunning()) {
                        closableTimerTask.setRunning(closableTimerTask.getTask().get());
                    }

                    if (!closableTimerTask.isRunning()) {
                        // 运行完毕后移除
                        accountTimerTaskMap.get(timerOwner).remove(closableTimerTask);
                        break;
                    }

                    timeUnit.sleep(delay);
                } catch (Exception e) {
                    log.error("定时任务执行失败", e);
                    // 异常退出后移除
                    accountTimerTaskMap.get(timerOwner).remove(closableTimerTask);
                    break;
                } finally {
                    taskSyncController.release();
                }
            }
        });

        return closableTimerTask;
    }

    /**
     * 去除账户的所有计时任务
     *
     * @param accountContext accountContext
     */
    public void removeAccountTimer(AccountContext accountContext) {
        accountTimerTaskMap.compute(accountContext, (k, v) -> {
            if (v != null) {
                v.forEach(task -> task.setRunning(false));
                v.removeIf(task -> true);
            }
            return v;
        });
    }


    /**
     * 注册type账号
     *
     * @return String
     */
    public String registerTypeAccount(String type) {
        if (!getTypedAccountMap().containsKey(type)) {
            return type + " 类型账户不存在";
        }

        StringBuilder sb = new StringBuilder("已开始账户注册, type: [");

        // Step 1 遍历不同类型的账户
        List<AccountContext> accountContexts = getTypedAccountMap().get(type);

        sb.append(type).append(", ");

        // Step 2 遍历不同类型下的所有账户
        List<CompletableFuture<Boolean>> futures = accountContexts.stream()
                .map(account -> {
                    if (!checkAccountProxyUsable(type, account)) {
                        return CompletableFuture.completedFuture(false);
                    }

                    // 账户注册过，
                    if (BooleanUtil.isTrue(account.getSignUp())) {
                        log.warn("[{}]账户[{}]-email[{}]注册过", type, account.getName(),
                                account.getAccountBaseInfo().getEmail());

                        return CompletableFuture.completedFuture(false);
                    } else {
                        return registerAccount(account, getBaseAutoBotConfig().getConfig(INVITE_CODE_KEY));
                    }
                }).toList();

        // Step 3 等待注册完成
        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            CompletableFuture<Boolean> future = futures.get(i);
            AccountContext accountContext = accountContexts.get(i);

            try {
                if (future.get()) {
                    //注册成功
                    successCount++;
                    accountContext.setSignUp(true);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("注册[{}]账号[{}]发生错误", type, accountContext.getName(), e);
            }
        }

        log.info("[{}] 所有账号注册完毕，[{}/{}}]", type, successCount, accountContexts.size());

        return sb.append("]").toString();
    }


    public String verifierEmail(String type) {
        List<AccountContext> accounts = getTypedAccountMap().get(type);

        // Step 1  获取type类型的邮件设置
        BaseAutoBotConfig botConfig = getBaseAutoBotConfig();

        Optional<AccountMailConfig> first = botConfig.getAccountConfigs().stream()
                .filter(accountConfig -> type.equals(accountConfig.getType()))
                .map(TypedAccountConfig::getMail)
                .findFirst();

        if (first.isEmpty()) {
            return "没有找到 " + type + "类型的账户邮件设置";
        }

        AtomicInteger successCount = new AtomicInteger();

        first.ifPresent(accountMailConfig -> {
            System.out.println("已开始 " + type + " 类型邮箱验证");

            // Step 2 根据设置获取mailReader
            MailReader mailReader = MailReaderFactory.getMailReader(
                    MailProtocolType.valueOf(accountMailConfig.getProtocol().toLowerCase()),
                    accountMailConfig.getHost(),
                    String.valueOf(accountMailConfig.getPort()),
                    accountMailConfig.isSslEnable());

            List<CompletableFuture<Boolean>> accountVerifiedFuture = accounts.stream()
                    .filter(accountContext -> {
                        String emailVerified = accountContext.getParam(EMAIL_VERIFIED_KEY);

                        // 注册的、验证状态为false的才需要验证邮件
                        return BooleanUtil.isTrue(accountContext.getSignUp())
                                && emailVerified != null && BooleanUtil.isFalse(Boolean.valueOf(emailVerified));
                    })
                    .map(accountContext -> CompletableFuture.supplyAsync(() -> {
                        AccountBaseInfo accountBaseInfo = accountContext.getAccountBaseInfo();

                        List<CompletableFuture<Boolean>> futureList = mailReader.readMessage(
                                accountBaseInfo.getEmail(),
                                accountBaseInfo.getPassword(),
                                1,
                                m -> {
                                    return verifierAccountEmail(accountContext, m);
                                }
                        );

                        for (CompletableFuture<Boolean> future : futureList) {
                            try {
                                if (future.get()) {
                                    log.info("{} 邮件验证成功", accountContext.getSimpleInfo());
                                    return true;
                                }
                            } catch (ExecutionException | InterruptedException e) {
                                log.error("{} 验证邮件发生异常, {}", accountContext.getSimpleInfo(), e.getMessage());
                            }
                        }
                        return false;
                    }, getExecutorService()))
                    .toList();

            for (CompletableFuture<Boolean> future : accountVerifiedFuture) {
                try {
                    if (future.get()) {
                        successCount.getAndIncrement();
                    }
                } catch (Exception e) {
                    log.error("验证[{}]邮件出错, {}", type, e.getMessage());
                }
            }


        });


        return type + " 类型邮箱验证完毕，成功：" + successCount + "错误：" + (accounts.size() - successCount.get());
    }


    /**
     * 获取账号的token
     *
     * @return String
     */
    public String loadTypedAccountToken(String type) {
        List<AccountContext> accountContexts = typedAccountMap.get(type);

        log.info("开始获取[{}]类型账号token", type);
        Semaphore semaphore = new Semaphore(getBaseAutoBotConfig().getConcurrentCount());

        List<CompletableFuture<String>> futures = accountContexts.stream()
                .map(accountContext -> {
                    try {
                        semaphore.acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    if(!checkAccountProxyUsable(type, accountContext)) {
                        semaphore.release();
                        return CompletableFuture.completedFuture("");
                    }

                    return requestTokenOfAccount(accountContext)
                            .whenComplete((token, throwable) -> semaphore.release());
                }).toList();

        int successCount = 0;
        for (int i = 0; i < futures.size(); i++) {
            CompletableFuture<String> future = futures.get(i);
            AccountContext accountContext = accountContexts.get(i);
            try {
                String token = future.get();
                if (StrUtil.isNotBlank(token)) {
                    successCount++;
                    accountContext.getParams().put(MapConfigKey.TOKEN_KEY, token);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("[{}] {} 获取token发生错误", type, accountContext.getSimpleInfo(), e);
            }
        }

        log.info("[{}]类型账号token获取完毕, [{}/{}]", type, successCount, accountContexts.size());

        return "已开始获取账户token";
    }


    public List<AccountContext> getAccounts() {
        List<AccountContext> accountContexts = new ArrayList<>();
        for (List<AccountContext> value : getTypedAccountMap().values()) {
            accountContexts.addAll(value);
        }
        return accountContexts;
    }

    /**
     * 账号被加载后调用
     *
     * @param typedAccountMap typedAccountMap
     */
    protected void typedAccountsLoadedHandler(Map<String, List<AccountContext>> typedAccountMap) {

    }

    /**
     * 开始所有账户Claim
     *
     * @return String 打印的消息
     */
    public String startAccountsClaim(String type, List<AccountContext> accountContexts) {
        if (startedAccountType.add(type)) {
            doAccountsClaim(type, accountContexts);
            return "已开始[" + type + "]类型账号自动收获";
        }

        return type + " 类型账户自动收获任务已开启";
    }

    /**
     * 开始账户claim
     */
    protected void doAccountsClaim(String type, List<AccountContext> accountContexts) {
        log.info("开始[{}]账户claim", type);

        accountContexts.forEach(account -> {
            if (checkAccountProxyUsable(type, account)) {
                account.getConnectStatusInfo().setStartDateTime(LocalDateTime.now());

                // 添加定时任务
                addTimer(
                        () -> doAccountClaim(account),
                        getBaseAutoBotConfig().getAutoClaimIntervalSeconds(),
                        TimeUnit.SECONDS,
                        account
                );
            }
        });
    }


    /**
     * 开启账户奖励查询任务
     */
    private void startAccountRewardQueryTask() {
        getExecutorService().execute(() -> {
            while (isRunningAccountRewardQuery.get()) {
                for (Map.Entry<String, List<AccountContext>> entry : getTypedAccountMap().entrySet()) {
                    List<AccountContext> accounts = entry.getValue();

                    List<CompletableFuture<Boolean>> futures = accounts.stream().map(accountContext -> {
                        try {
                            return updateAccountRewordInfo(accountContext);
                        } catch (Exception e) {
                            throw new RewardQueryException(e);
                        }
                    }).toList();

                    for (int i = 0; i < futures.size(); i++) {
                        try {
                            futures.get(i).get();
                        } catch (InterruptedException | ExecutionException e) {
                            log.error("查询账户[" + accounts.get(i).getName() + "]奖励失败", e.getMessage());
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(getBaseAutoBotConfig().getAccountRewardRefreshIntervalSeconds());
                    } catch (InterruptedException e) {
                        log.error("等待执行账户查询时发生异常", e);
                    }
                }
            }
        });
    }


    /**
     * 初始化账号方法
     */
    private void initAccounts() throws DepinBotInitException {
        Integer projectId = getBaseAutoBotConfig().getProjectId();

        try {
            // Step 1 获取持久化的
            Map<String, List<AccountContext>> typedAccountMap = persistenceManager.loadAccountContexts(projectId);

            // Step 2 没有保存的数据，加载新的
            if (typedAccountMap == null || typedAccountMap.isEmpty()) {
                log.info("bot[{}]加载新账户数据", getBaseAutoBotConfig().getName());
                // Step 2.1 加载新的
                typedAccountMap = persistenceManager.createAccountContexts(projectId, getBaseAutoBotConfig().getAccountConfigs());

                // Step 2.2 持久化
                persistenceManager.persistenceAccountContexts(typedAccountMap);
            } else {
                log.info("bot[{}]使用历史账户数据", getBaseAutoBotConfig().getName());
            }


            // Step 3 加载到bot
            registerAccountsInBot(typedAccountMap);

            typedAccountsLoadedHandler(typedAccountMap);

            this.typedAccountMap.putAll(typedAccountMap);
        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }


    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param typedAccountMap typedAccountMap
     */
    private void registerAccountsInBot(Map<String, List<AccountContext>> typedAccountMap) {
        typedAccountMap.forEach(persistenceManager::registerPersistenceListener);
    }



    private static boolean checkAccountProxyUsable(String type, AccountContext account) {
        if (true) return true;

        if (account.getProxy() != null && BooleanUtil.isFalse(account.getProxy().isUsable())) {
            log.warn("[{}]账户[{}]-email[{}]代理不可用", type, account.getName(),
                    account.getAccountBaseInfo().getEmail());
            return false;
        }
        return true;
    }
}
package cn.com.helei.bot.core.bot.view;


import cn.com.helei.bot.core.bot.base.AccountManageAutoBot;
import cn.com.helei.bot.core.config.BaseAutoBotConfig;
import cn.com.helei.bot.core.supporter.AccountInfoPrinter;
import cn.com.helei.bot.core.supporter.commandMenu.CommandMenuNode;
import cn.com.helei.bot.core.supporter.commandMenu.DefaultMenuType;
import cn.com.helei.bot.core.supporter.commandMenu.MenuNodeMethod;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;

import static cn.com.helei.bot.core.constants.MapConfigKey.*;


@Slf4j
public class MenuCMDLineAutoBot<C extends BaseAutoBotConfig> extends CommandLineAutoBot {
    /**
     * 刷新节点
     */
    public static final CommandMenuNode REFRESH_NODE = new CommandMenuNode(true, "刷新", "当前数据已刷新", null);


    private final List<DefaultMenuType> defaultMenuTypes;

    @Setter
    private Consumer<CommandMenuNode> addCustomMenuNode;

    public MenuCMDLineAutoBot(AccountManageAutoBot bot,  List<DefaultMenuType> defaultMenuTypes) {
        super(bot);
        this.defaultMenuTypes = new ArrayList<>(defaultMenuTypes);

        this.defaultMenuTypes.add(DefaultMenuType.ACCOUNT_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.PROXY_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.BROWSER_ENV_LIST);

        // 解析MenuNodeMethod注解添加菜单节点
        for (Method method : bot.getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            if (method.isAnnotationPresent(MenuNodeMethod.class)) {
                if (method.getParameterCount() > 0) {
                    throw new IllegalArgumentException("菜单方法参数数量必须为0");
                }

                MenuNodeMethod anno = method.getAnnotation(MenuNodeMethod.class);
                String title = anno.title();
                String description = anno.description();

                CommandMenuNode menuNode = new CommandMenuNode(title, description, () -> {
                    try {
                        return method.invoke(bot).toString();
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new RuntimeException(e);
                    }
                });

                getMainManu().addSubMenu(menuNode);
            }
        }
    }


    @Override
    public final void buildMenuNode(CommandMenuNode mainManu) {
        if (addCustomMenuNode != null) {
            addCustomMenuNode.accept(mainManu);
        }

        for (DefaultMenuType menuType : defaultMenuTypes) {
            mainManu.addSubMenu(switch (menuType) {
                case REGISTER -> buildRegisterMenuNode();
                case VERIFIER -> buildVerifierMenuNode();
                case LOGIN -> buildQueryTokenMenuNode();
                case ACCOUNT_LIST -> buildAccountListMenuNode();
                case PROXY_LIST -> buildProxyListMenuNode();
                case BROWSER_ENV_LIST -> buildBrowserListMenuNode();
                case START_ACCOUNT_CLAIM -> buildStartAccountConnectMenuNode();
            });
        }
    }

    /**
     * 构建注册菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildRegisterMenuNode() {
        CommandMenuNode registerMenu = new CommandMenuNode("注册",
                "请确认设置后运行", this::printCurrentRegisterConfig);

        CommandMenuNode interInvite = new CommandMenuNode(
                "填入邀请码",
                "请输入邀请码：",
                this::printCurrentRegisterConfig
        );
        interInvite.setResolveInput(input -> {
            log.info("邀请码修改[{}]->[{}]", getBotConfig().getConfig(INVITE_CODE_KEY), input);
            getBotConfig().setConfig(INVITE_CODE_KEY, input);
        });

        CommandMenuNode typeSelect = new CommandMenuNode(
                "选择账户类型",
                "请选择账户类型",
                this::printCurrentRegisterConfig
        );

        List<String> typeList = new ArrayList<>(getBot().getTypedAccountMap().keySet());
        for (String type : typeList) {
            CommandMenuNode typeInput = new CommandMenuNode(
                    true,
                    type + " 账户",
                    "type",
                    () -> {
                        getBotConfig().setConfig(REGISTER_TYPE_KEY, type);
                        return "注册[" + type + "]类型账户，共：" + getBot().getTypedAccountMap().get(type).size();
                    }
            );

            typeSelect.addSubMenu(typeInput);
        }


        return registerMenu
                .addSubMenu(interInvite)
                .addSubMenu(typeSelect)
                .addSubMenu(new CommandMenuNode(
                        true,
                        "开始注册",
                        "开始注册所有账号...",
                        () -> {
                            return getBot().registerTypeAccount(getBot().getBaseAutoBotConfig().getConfig(REGISTER_TYPE_KEY));
                        }
                ));
    }

    private CommandMenuNode buildVerifierMenuNode() {
        CommandMenuNode verifier = new CommandMenuNode("验证邮箱", "请选择验证的账户类型",
                () -> "当前的邮箱类型：" + getBotConfig().getConfig(EMAIL_VERIFIER_TYPE));

        for (String type : getBot().getTypedAccountMap().keySet()) {
            verifier.addSubMenu(new CommandMenuNode(true, type + " 类型", "",
                    () -> getBot().verifierEmail(type)));
        }
        return verifier;
    }


    /**
     * 获取token
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildQueryTokenMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode("获取token", "请选择邮箱类型", null);

        for (String type : getBot().getTypedAccountMap().keySet()) {
            CommandMenuNode typeInput = new CommandMenuNode(
                    true,
                    type + " 账户",
                    "type",
                    () -> getBot().loadTypedAccountToken(type)
            );
            menuNode.addSubMenu(typeInput);
        }
        return menuNode;
    }

    /**
     * 构建查看代理列表的菜单节点
     *
     * @return 查看代理列表菜单节点
     */
    private CommandMenuNode buildProxyListMenuNode() {
        return new CommandMenuNode(
                "查看代理列表",
                "当前代理列表:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 构建查看浏览器环境列表的菜单节点
     *
     * @return 查看浏览器环境列表菜单节点
     */
    private CommandMenuNode buildBrowserListMenuNode() {
        return new CommandMenuNode(
                "查看浏览器环境列表",
                "当前浏览器环境:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 账户列表菜单节点
     *
     * @return 账户列表节点
     */
    private CommandMenuNode buildAccountListMenuNode() {
        CommandMenuNode accountListMenuNode = new CommandMenuNode(
                "查看账号",
                "当前账户详情列表:",
                () -> AccountInfoPrinter.printAccountList(getBot().getTypedAccountMap())
        );

        return accountListMenuNode
                .addSubMenu(buildAccountRewardMenuNode())
                .addSubMenu(buildAccountConnectStatusMenuNode())
                .addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户收益菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountRewardMenuNode() {
        return new CommandMenuNode(
                "查看账号收益",
                "账号收益详情列表:",
                () -> AccountInfoPrinter.printAccountReward(getBot().getTypedAccountMap())
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户连接情况菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountConnectStatusMenuNode() {
        return new CommandMenuNode(
                "查看账号连接情况",
                "账号连接情况列表:",
                () -> AccountInfoPrinter.printAccountConnectStatusList(getBot().getTypedAccountMap())
        ).addSubMenu(REFRESH_NODE);
    }


    /**
     * 开始账户连接菜单节点
     *
     * @return 连接账户菜单节点
     */
    private CommandMenuNode buildStartAccountConnectMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode(
                "启动账号",
                "选择启动账号类型",
                null
        );

        Set<String> typeSet = getBot().getTypedAccountMap().keySet();
        for (String type : typeSet) {
            CommandMenuNode typeInput = new CommandMenuNode(true, type + " 账户", "type",
                    () -> getBot().startAccountsClaim(type, getBot().getTypedAccountMap().get(type))
            );

            menuNode.addSubMenu(typeInput);
        }
        menuNode.addSubMenu(new CommandMenuNode(true, "全部类型账户", "", () -> {
            getBot().getTypedAccountMap().forEach(getBot()::startAccountsClaim);

            return "开始全部类型" + typeSet + "账户";
        }));

        CommandMenuNode refresh = new CommandMenuNode(true, "刷新", "当前账户列表",
                () -> AccountInfoPrinter.printAccountList(getBot().getTypedAccountMap()));

        menuNode.addSubMenu(refresh);
        return menuNode;
    }


    /**
     * 打印当前的邀请码
     *
     * @return 邀请码
     */
    private String printCurrentRegisterConfig() {
        String inviteCode = (String) getBotConfig().getConfigMap().get(INVITE_CODE_KEY);
        String registerType = (String) getBotConfig().getConfigMap().get(REGISTER_TYPE_KEY);

        return "(当前邀请码为:" + inviteCode + ")\n"
                + "(当前注册类型为:" + registerType + ")\n";
    }
}
package cn.com.helei.bot.core.bot;

import cn.com.helei.bot.core.BaseBotWSClient;
import cn.com.helei.bot.core.config.WSAutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.exception.DepinBotStatusException;
import cn.com.helei.bot.core.netty.constants.WebsocketClientStatus;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Semaphore;

@Slf4j
public abstract class WSTaskAutoBot<C extends WSAutoBotConfig, Req, Resp> extends RestTaskAutoBot {

    /**
     * WS链接完成数量
     */
    protected static final String WS_COMPLETE_COUNT_KEY = "ws_complete_count";

    /**
     * 账户ws创建数量
     */
    protected static final String WS_CREATE_COUNT_KEY = "ws_create_count";

    /**
     * AccountContext map BaseDepinWSClient
     */
    private final Map<AccountContext, BaseBotWSClient<Req, Resp>> accountWSClientMap;

    /**
     * 控制并发数量的信号量
     */
    private final Semaphore wsConnectSemaphore;

    @Getter
    private final C botConfig;

    public WSTaskAutoBot(C config) {
        super(config);

        this.botConfig = config;
        this.wsConnectSemaphore = new Semaphore(config.getWsConnectCount());
        this.accountWSClientMap = new ConcurrentHashMap<>();
    }

    /**
     * 开始账户claim
     */
    @Override
    protected final void doAccountsClaim(String type, List<AccountContext> accountContexts) {
        accountContexts.forEach(account -> {
            account.getConnectStatusInfo().setStartDateTime(LocalDateTime.now());
            getExecutorService().execute(() -> doAccountClaim(account));
        });
    }


    @Override
    public final boolean doAccountClaim(AccountContext accountContext) {
        // Step 1 获取锁，才能进行claim
        try {
            wsConnectSemaphore.acquire();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        // Step 2 创建或获取账户对应的depinWSClient
        BaseBotWSClient<Req, Resp> depinWSClient = accountWSClientMap.compute(accountContext, (k, v) -> {
            // 没有创建过，或被关闭，创建新的
            if (v == null || v.getClientStatus().equals(WebsocketClientStatus.SHUTDOWN)) {
                v = buildAccountWSClient(accountContext);

                if (v != null) {
                    v.setReconnectCountDownSecond(getBotConfig().getReconnectCountDownSecond());
                    v.setAllIdleTimeSecond(getBotConfig().getHeartBeatIntervalSecond());

                    // 记录创建的ws数量
                    addWSRuntimeInfoCount(WS_CREATE_COUNT_KEY);
                }
            }

            return v;
        });

        // Step 3 获取到null，释放资源返回失败
        if (depinWSClient == null) {
            wsConnectSemaphore.release();
            return false;
        }

        String accountName = accountContext.getAccountBaseInfo().getName();

        //Step 4 设置相关回调
        WebsocketClientStatus currentStatus = depinWSClient.getClientStatus();

        depinWSClient.setClientStatusChangeHandler(newStatus -> {
            depinWSClient.whenClientStatusChange(newStatus);

            // 调用bot类的回调方法
            whenAccountClientStatusChange(depinWSClient, newStatus);

            // 释放资源
            if (newStatus.equals(WebsocketClientStatus.SHUTDOWN)) {

                // 记录完成的ws数量
                addWSRuntimeInfoCount(WS_COMPLETE_COUNT_KEY);

                wsConnectSemaphore.release();
            }
        });

        // Step 5 检查当前状态，如果为new 或stop才进行启动
        return switch (currentStatus) {
            case NEW, STOP:  // 新创建，停止状态，需要建立连接
                try {
                    yield !depinWSClient.connect().get() && getBotConfig().isWsUnlimitedRetry();
                } catch (InterruptedException | ExecutionException e) {
                    log.error("账户[{}]ws链接发生错误", accountName, e);
                    yield true;
                }
            case STARTING, RUNNING:
                yield false;
            case SHUTDOWN: // 被禁止使用，抛出异常
                throw new DepinBotStatusException("cannot start ws client when it shutdown, " + accountName);
        };
    }


    /**
     * 使用accountContext构建AbstractDepinWSClient
     *
     * @param accountContext accountContext
     * @return AbstractDepinWSClient
     */
    public abstract BaseBotWSClient<Req, Resp> buildAccountWSClient(AccountContext accountContext);


    /**
     * 当账户链接时调用
     *
     * @param depinWSClient depinWSClient
     * @param clientStatus  clientStatus
     */
    public abstract void whenAccountClientStatusChange(BaseBotWSClient<Req, Resp> depinWSClient, WebsocketClientStatus clientStatus);

    /**
     * 当ws连接收到响应
     *
     * @param depinWSClient depinWSClient
     * @param id            id
     * @param response      response
     */
    public abstract void whenAccountReceiveResponse(BaseBotWSClient<Req, Resp> depinWSClient, Object id, Resp response);

    /**
     * 当ws连接收到消息
     *
     * @param depinWSClient depinWSClient
     * @param message       message
     */
    public abstract void whenAccountReceiveMessage(BaseBotWSClient<Req, Resp> depinWSClient, Resp message);


    /**
     * 获取心跳消息
     *
     * @param depinWSClient depinWSClient
     * @return 消息体
     */
    public abstract Req getHeartbeatMessage(BaseBotWSClient<Req, Resp> depinWSClient);


    /**
     * 给key的DepinBotRuntimeInfo加1
     *
     * @param key key
     */
    protected void addWSRuntimeInfoCount(String key) {
        getAutoBotRuntimeInfo().getKeyValueInfoMap().compute(key, (k1, v1) -> {
            if (v1 == null) {
                v1 = 0;
            }
            return ((int) v1) + 1;
        });
    }
}
package cn.com.helei.bot.core.config;


import lombok.Data;
import lombok.ToString;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Data
@ToString
public class BaseAutoBotConfig {

    /**
     * 项目id
     */
    private Integer projectId;

    /**
     * 名字
     */
    private String name;

    /**
     * 并发数量
     */
    private int concurrentCount = 5;

    /**
     * 自动收获间隔
     */
    private int autoClaimIntervalSeconds = 60;

    /**
     * 是否开启账户收益自动刷新
     */
    private Boolean isAccountRewardAutoRefresh = false;

    /**
     * 账户奖励刷新间隔
     */
    private long accountRewardRefreshIntervalSeconds = 600;

    /**
     * 网络代理池配置文件名
     */
    private String staticPoolConfig = "proxy-static.yaml";

    /**
     * 动态代理池配置文件名
     */
    private String dynamicProxyConfig = "proxy-dynamic.yaml";

    /**
     * 浏览器环境池配置文件名
     */
    private String browserEnvPoolConfig = "browser-env.yaml";

    /**
     * 推特配置文件
     */
    private String twitterPoolConfig = "twitter.yaml";


    private List<TypedAccountConfig> accountConfigs;

    private Map<String, Object> configMap = new HashMap<>();

    public String getConfig(String key) {
        return String.valueOf(configMap.get(key));
    }

    public void setConfig(String key, String value) {
        this.configMap.put(key, value);
    }
}
package cn.com.helei.bot.core.config;

import java.util.List;

public class SystemConfig {

    public static final List<String> CONFIG_DIR_BOT_PATH = List.of("config", "bot");

    public static final List<String> CONFIG_DIR_APP_PATH = List.of("config", "app");

    public static final String SQL_LITE_DRIVER = "org.sqllite.JDBC";

    public static final String SQL_LITE_JDBC_URL = "jdbc:sqllite:botData/db/auto_bot.db";
}
package cn.com.helei.bot.core.config;

import cn.com.helei.bot.core.constants.ProxyType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class TypedAccountConfig {

    private String type;

    private ProxyType proxyType = ProxyType.NO;

    private AccountMailConfig mail;

    private String accountFileUserDirPath;

}
package cn.com.helei.bot.core.constants;

public enum ProxyProtocol {

    HTTP,
    SOCKT5
}
package cn.com.helei.bot.core.constants;

public enum ProxyType {
    STATIC,
    DYNAMIC,
    NO
}
package cn.com.helei.bot.core.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Collection;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Boolean success;
    private String errorMsg;
    private Object data;
    private Integer total;

    public static Result ok(){
        return new Result(true, null, null, null);
    }
    public static Result ok(Object data){
        return new Result(true, null, data, null);
    }
    public static Result ok(Collection<?> data, Integer total){
        return new Result(true, null, data, total);
    }
    public static Result fail(String errorMsg){
        return new Result(false, errorMsg, null, null);
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_account_base_info")
@AllArgsConstructor
@NoArgsConstructor
public class AccountBaseInfo {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("type")
    private String type;

    @TableField("name")
    private String name;

    @TableField("email")
    private String email;

    @TableField("password")
    private String password;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;



    public AccountBaseInfo(Object originLine) {
        String emailAndPassword = (String) originLine;

        String[] split = emailAndPassword.split(", ");
        email = split[0];

        password = split[1];

        if (split.length == 3) {
            name = split[2];
        }
        if (split.length == 4) {
            type = split[3];
        }
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenField;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_project_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
public class AccountContext {


    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("project_id")
    private Integer projectId;

    @TableField("account_base_info_id")
    private Integer accountBaseInfoId;

    private AccountBaseInfo accountBaseInfo;

    @TableField("reward_id")
    private Integer rewardId;

    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField("twitter_id")
    private Integer twitterId;

    private TwitterAccount twitter;

    @TableField("discord_id")
    private Integer discordId;

    private DiscordAccount discord;

    @TableField("proxy_id")
    private Integer proxyId;

    private ProxyInfo proxy;

    @TableField("browser_env_id")
    private Integer browserEnvId;

    private BrowserEnv browserEnv;

    @TableField("telegram_id")
    private Integer telegramId;

    @TableField("wallet_id")
    private Integer walletId;

    @PropertyChangeListenField
    @TableField("status")
    private Integer status;

    @PropertyChangeListenField
    @TableField("usable")
    private boolean usable = true;

    @PropertyChangeListenField
    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    private Map<String, String> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;

    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return params.get(key);
    }

    public void setParam(String key, String value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getAccountBaseInfo().getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().getAddressStr());
    }

    public Boolean getSignUp() {
        return status == 1;
    }

    public void setSignUp(boolean b) {
        status = 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;


/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_browser_env")
public class BrowserEnv {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("user_agent")
    private String userAgent;

    @TableField("other_header_json")
    private JSONObject otherHeaderJson;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;

    public Map<String, String> getHeaders() {
        HashMap<String, String> map = new HashMap<>();
        map.put("User-Agent", userAgent);
        otherHeaderJson.forEach((k,v)-> map.put(k, StrUtil.toString(v)));
        return map;
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDateTime;

import lombok.Getter;
import lombok.Setter;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_discord_account")
public class DiscordAccount {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("email")
    private String email;

    @TableField("password")
    private String password;

    @TableField("username")
    private String username;

    @TableField("bind_email")
    private String bindEmail;

    @TableField("bind_email_password")
    private String bindEmailPassword;

    @TableField("token")
    private String token;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.constants.ProxyProtocol;
import cn.com.helei.bot.core.constants.ProxyType;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.time.LocalDateTime;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_proxy_info")
@AllArgsConstructor
@NoArgsConstructor
public class ProxyInfo {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField(value = "proxy_type")
    private ProxyType proxyType;

    @TableField(value = "proxy_protocol")
    private ProxyProtocol proxyProtocol;

    @TableField("host")
    private String host;

    @TableField("port")
    private Integer port;

    @TableField("username")
    private String username;

    @TableField("password")
    private String password;

    private volatile boolean usable = true;

    private JSONObject metadata;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;

    public ProxyInfo(Object originLine) {
        String proxyUrl = (String) originLine;

        String[] split = proxyUrl.split("://");
        String protocol = split[0];

        proxyProtocol = switch (protocol) {
            case "http" -> ProxyProtocol.HTTP;
            case "sockt5" -> ProxyProtocol.SOCKT5;
            default -> throw new IllegalStateException("Unexpected value: " + protocol);
        };
        String[] upAndAddress = split[1].split("@");

        if (upAndAddress.length == 1) {
            String[] address = upAndAddress[0].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        } else if (upAndAddress.length == 2) {
            String[] up = upAndAddress[0].split(":");
            this.username = up[0];
            this.password = up[1];

            String[] address = upAndAddress[1].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        }
    }


    public SocketAddress getAddress() {
        return new InetSocketAddress(host, port);
    }

    public String getAddressStr() {
        return host + ":" + port;
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;


import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_reword_info")
public class RewordInfo {

    @TableId(value = "project_account_id", type = IdType.INPUT)
    private Integer projectAccountId;

    @TableField("total_points")
    private Double totalPoints;

    @TableField("session")
    private String session;

    @TableField("session_points")
    private Double sessionPoints;

    @TableField("daily_points")
    private Double dailyPoints;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;


    public RewordInfo newInstance() {
        RewordInfo rewordInfo = new RewordInfo();
        rewordInfo.totalPoints = this.totalPoints;
        rewordInfo.session = this.session;
        rewordInfo.sessionPoints = this.sessionPoints;
        rewordInfo.dailyPoints = this.dailyPoints;
        rewordInfo.insertDatetime = this.insertDatetime;
        rewordInfo.updateDatetime = this.updateDatetime;
        rewordInfo.isValid = this.isValid;

        return rewordInfo;
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTYpeHandler;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.time.LocalDateTime;

import lombok.Getter;
import lombok.Setter;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_twitter_account")
public class TwitterAccount {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("username")
    private String username;

    @TableField("password")
    private String password;

    @TableField("email")
    private String email;

    @TableField("email_password")
    private String emailPassword;

    @TableField("token")
    private String token;

    @TableField("f2a_key")
    private String f2aKey;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTYpeHandler.class)
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/browserEnv")
public class BrowserEnvController {
    @Autowired
    private IBrowserEnvService browserEnvService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody List<BrowserEnv> browserEnvs) {
        if (browserEnvs == null) {
            return Result.fail("参数不能为空");
        }
        boolean b = browserEnvService.saveBatch(browserEnvs);
        return b ? Result.ok() : Result.fail("批量添加浏览器环境失败");
    }

}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.entity.DiscordAccount;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import cn.com.helei.bot.core.mvc.service.IDiscordAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/discordAccount")
public class DiscordAccountController {
    @Autowired
    private IDiscordAccountService discordAccountService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody List<DiscordAccount> discordAccounts) {
        if (discordAccounts == null) {
            return Result.fail("参数不能为空");
        }
        boolean b = discordAccountService.saveBatch(discordAccounts);
        return b ? Result.ok() : Result.fail("批量添加discord账号失败");
    }
}
package cn.com.helei.bot.core.mvc.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/core/projectAccountContext")
public class ProjectAccountContextController {

}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.mvc.service.IProxyInfoService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/proxyInfo")
public class ProxyInfoController {

    @Autowired
    private IProxyInfoService proxyInfoService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody List<ProxyInfo> proxyInfos) {
        if (proxyInfos == null) {
            return Result.fail("参数不能为空");
        }
        boolean b = proxyInfoService.saveBatch(proxyInfos);
        return b ? Result.ok() : Result.fail("批量添加代理失败");
    }

}
package cn.com.helei.bot.core.mvc.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/core/rewordInfo")
public class RewordInfoController {

}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TwitterAccount;
import cn.com.helei.bot.core.mvc.service.ITwitterAccountService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/core/twitterAccount")
public class TwitterAccountController {
    @Autowired
    private ITwitterAccountService twitterAccountService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody List<TwitterAccount> twitterAccounts) {
        if (twitterAccounts == null) {
            return Result.fail("参数不能为空");
        }
        boolean b = twitterAccountService.saveBatch(twitterAccounts);
        return b ? Result.ok() : Result.fail("批量添加twitter账号失败");
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.AccountBaseInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.AccountBaseInfo">
        <id column="id" property="id" />
        <result column="type" property="type" />
        <result column="name" property="name" />
        <result column="email" property="email" />
        <result column="password" property="password" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.BrowserEnvMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.BrowserEnv">
        <id column="id" property="id" />
        <result column="user_agent" property="userAgent" />
        <result column="other_header_json" property="otherHeaderJson" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.DiscordAccountMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.DiscordAccount">
        <id column="id" property="id" />
        <result column="email" property="email" />
        <result column="password" property="password" />
        <result column="username" property="username" />
        <result column="bind_email" property="bindEmail" />
        <result column="bind_email_password" property="bindEmailPassword" />
        <result column="token" property="token" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.ProjectAccountContextMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.AccountContext">
        <id column="id" property="id" />
        <result column="project_id" property="projectId" />
        <result column="account_base_info_id" property="accountBaseInfoId" />
        <result column="twitter_id" property="twitterId" />
        <result column="discord_id" property="discordId" />
        <result column="proxy_id" property="proxyId" />
        <result column="browser_env_id" property="browserEnvId" />
        <result column="telegram_id" property="telegramId" />
        <result column="wallet_id" property="walletId" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.ProxyInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.ProxyInfo">
        <id column="id" property="id" />
        <result column="host" property="host" />
        <result column="port" property="port" />
        <result column="username" property="username" />
        <result column="password" property="password" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.RewordInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.RewordInfo">
        <id column="project_account_id" property="projectAccountId" />
        <result column="total_points" property="totalPoints" />
        <result column="session" property="session" />
        <result column="session_points" property="sessionPoints" />
        <result column="daily_points" property="dailyPoints" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mvc.mapper.TwitterAccountMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.TwitterAccount">
        <id column="id" property="id" />
        <result column="username" property="username" />
        <result column="password" property="password" />
        <result column="email" property="email" />
        <result column="email_password" property="emailPassword" />
        <result column="token" property="token" />
        <result column="f2a_key" property="f2aKey" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="id_valid" property="idValid" />
    </resultMap>

</mapper>
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.AccountBaseInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface AccountBaseInfoMapper extends BaseMapper<AccountBaseInfo> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.BrowserEnv;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface BrowserEnvMapper extends BaseMapper<BrowserEnv> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.DiscordAccount;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface DiscordAccountMapper extends BaseMapper<DiscordAccount> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.AccountContext;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface ProjectAccountContextMapper extends BaseMapper<AccountContext> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.ProxyInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface ProxyInfoMapper extends BaseMapper<ProxyInfo> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.RewordInfo;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface RewordInfoMapper extends BaseMapper<RewordInfo> {

}
package cn.com.helei.bot.core.mvc.mapper;

import cn.com.helei.bot.core.entity.TwitterAccount;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface TwitterAccountMapper extends BaseMapper<TwitterAccount> {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.AccountBaseInfo;
import cn.com.helei.bot.core.mvc.mapper.AccountBaseInfoMapper;
import cn.com.helei.bot.core.mvc.service.IAccountBaseInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class AccountBaseInfoServiceImpl extends ServiceImpl<AccountBaseInfoMapper, AccountBaseInfo> implements IAccountBaseInfoService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.mvc.mapper.BrowserEnvMapper;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class BrowserEnvServiceImpl extends ServiceImpl<BrowserEnvMapper, BrowserEnv> implements IBrowserEnvService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.DiscordAccount;
import cn.com.helei.bot.core.mvc.mapper.DiscordAccountMapper;
import cn.com.helei.bot.core.mvc.service.IDiscordAccountService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class DiscordAccountServiceImpl extends ServiceImpl<DiscordAccountMapper, DiscordAccount> implements IDiscordAccountService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.mvc.mapper.ProjectAccountContextMapper;
import cn.com.helei.bot.core.mvc.service.IProjectAccountContextService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class ProjectAccountContextServiceImpl extends ServiceImpl<ProjectAccountContextMapper, AccountContext> implements IProjectAccountContextService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.mvc.mapper.ProxyInfoMapper;
import cn.com.helei.bot.core.mvc.service.IProxyInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class ProxyInfoServiceImpl extends ServiceImpl<ProxyInfoMapper, ProxyInfo> implements IProxyInfoService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.RewordInfo;
import cn.com.helei.bot.core.mvc.mapper.RewordInfoMapper;
import cn.com.helei.bot.core.mvc.service.IRewordInfoService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class RewordInfoServiceImpl extends ServiceImpl<RewordInfoMapper, RewordInfo> implements IRewordInfoService {

}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.entity.TwitterAccount;
import cn.com.helei.bot.core.mvc.mapper.TwitterAccountMapper;
import cn.com.helei.bot.core.mvc.service.ITwitterAccountService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Service
public class TwitterAccountServiceImpl extends ServiceImpl<TwitterAccountMapper, TwitterAccount> implements ITwitterAccountService {

}
