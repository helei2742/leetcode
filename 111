package com.helei.dto.account;


import com.helei.constants.CEXType;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.ASKey;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserAccountInfo implements Serializable {

    /**
     * 账户id
     */
    private long id;

    /**
     * 用户id
     */
    private long userId;

    /**
     * 验证key
     */
    private ASKey asKey;

    /**
     * 是否可用
     */
    private final AtomicBoolean usable = new AtomicBoolean(false);

    /**
     * 运行环境，测试网还是主网
     */
    private RunEnv runEnv;

    /**
     * 交易类型
     */
    private TradeType tradeType;

    /**
     * 账户交易所类型
     */
    private CEXType cexType = CEXType.BINANCE;

    /**
     * 订阅的交易对
     */
    private List<String> subscribeSymbol;

    /**
     * 账户详情
     */
    private UserAccountTradeDetail detail;

    /**
     * 账户仓位设置
     */
    private AccountPositionConfig accountPositionConfig;

    /**
     * 账户资金信息
     */
    private final AccountBalanceInfo accountBalanceInfo = new AccountBalanceInfo();


    /**
     * 账户仓位信息
     */
    private final AccountPositionInfo accountPositionInfo = new AccountPositionInfo();

    public void setId(long id) {
        this.id = id;
        this.accountBalanceInfo.setAccountId(id);
        this.accountPositionInfo.setAccountId(id);
    }
}

package com.helei.dto.account;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.math.BigDecimal;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserAccountTradeDetail implements Serializable {


    /**
     * 手续费等级
     */
    private int feeTier;

    /**
     * 是否可以交易
     */
    private boolean canTrade;

    /**
     *  是否可以入金
     */
    private boolean canDeposit;

    /**
     * 是否可以出金
     */
    private boolean canWithdraw;

    /**
     * 保留字段，请忽略
     */
    private int updateTime;

    /**
     * 是否是多资产模式
     */
    private boolean multiAssetsMargin;


    private int tradeGroupId;

    /**
     * 当前所需起始保证金总额(存在逐仓请忽略), 仅计算usdt资产
     */
    private BigDecimal totalInitialMargin;

    /**
     * 维持保证金总额, 仅计算usdt资产
     */
    private BigDecimal totalMaintMargin;

    /**
     * 账户总余额, 仅计算usdt资产
     */
    private BigDecimal totalWalletBalance;

    /**
     * 持仓未实现盈亏总额, 仅计算usdt资产
     */
    private BigDecimal totalUnrealizedProfit;

    /**
     * 保证金总余额, 仅计算usdt资产
     */
    private BigDecimal totalMarginBalance;

    /**
     * 持仓所需起始保证金(基于最新标记价格), 仅计算usdt资产
     */
    private BigDecimal totalPositionInitialMargin;

    /**
     * 当前挂单所需起始保证金(基于最新标记价格), 仅计算usdt资产
     */
    private BigDecimal totalOpenOrderInitialMargin;

    /**
     * 全仓账户余额, 仅计算usdt资产
     */
    private BigDecimal totalCrossWalletBalance;

    /**
     * 全仓持仓未实现盈亏总额, 仅计算usdt资产
     */
    private BigDecimal totalCrossUnPnl;

    /**
     * 可用余额, 仅计算usdt资产
     */
    private BigDecimal availableBalance;

    /**
     * 最大可转出余额, 仅计算usdt资产
     */
    private BigDecimal maxWithdrawAmount;
}


package com.helei.dto.base;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.function.Consumer;

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class HandlerEntity<T> {
    private long expireTime;

    private Consumer<T> callback;
}


package com.helei.netty.base;


import com.alibaba.fastjson.JSON;
import com.helei.netty.NettyConstants;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.Socks5ProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    protected String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    @Getter
    protected final ExecutorService callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected InetSocketAddress proxy = null;

    /**
     * 重链接次数
     */
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);

    /**
     * 重连锁
     */
    private final ReentrantLock reconnectLock = new ReentrantLock();

    /**
     * 当前是否在允许
     */
    @Getter
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    @Setter
    @Getter
    private String name;

    private Bootstrap bootstrap;

    private EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        this.callbackInvoker = Executors.newVirtualThreadPerTaskExecutor();
    }

    private void init() throws SSLException, URISyntaxException {

        resolveParamFromUrl();

        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders()
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            p.addLast(new Socks5ProxyHandler(proxy));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }

    /**
     * 链接服务端
     *
     * @throws SSLException Exception
     */
    public CompletableFuture<Void> connect() throws SSLException, URISyntaxException {
        if (isRunning.get()) {
            log.warn("WS客户端[{}}已链接", url);
            return CompletableFuture.runAsync(() -> {
            });
        }

        log.info("开始初始化WS客户端");
        init();
        log.info("初始化WS客户端完成，开始链接服务器 [{}]", url);

        return reconnect();
    }


    /**
     * 重链接
     *
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> reconnect() {
        return CompletableFuture.runAsync(() -> {
            if (reconnectTimes.get() > NettyConstants.RECONNECT_LIMIT) {
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
                return;
            }

            AtomicBoolean isSuccess = new AtomicBoolean(false);

            reconnectLock.lock();
            try {
                while (reconnectTimes.incrementAndGet() <= NettyConstants.RECONNECT_LIMIT) {
                    eventLoopGroup.schedule(() -> {
                        reconnectTimes.decrementAndGet();
                    }, 60, TimeUnit.SECONDS);

                    log.info("start connect client [{}], url[{}], current times [{}]", name, url, reconnectTimes.get());
                    CountDownLatch latch = new CountDownLatch(1);

                    eventLoopGroup.schedule(() -> {
                        try {
                            channel = bootstrap.connect().sync().channel();
                            // 8. 等待 WebSocket 握手完成
                            handler.handshakeFuture().sync();

                            channel.attr(NettyConstants.CLIENT_NAME).set(name);

                            isSuccess.set(true);
                        } catch (Exception e) {
                            log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                        } finally {
                            latch.countDown();
                        }
                    }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                    }

                    if (isSuccess.get()) {
                        log.info("connect client [{}], url[{}] success, current times [{}]", name, url, reconnectTimes.get());
                        isRunning.set(true);
                        reconnectTimes.set(0);
                        break;
                    }
                }
            } finally {
                reconnectLock.unlock();
            }

            if (!isSuccess.get()) {
                isRunning.set(false);
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();

                throw new RuntimeException("reconnect times out of limit");
            }
        }, callbackInvoker);
    }


    /**
     * 关闭WebSocketClient
     */
    public void close() {
        log.info("start close websocket client [{}]", name);
        if (channel != null) {
            channel.close();
        }
        if (eventLoopGroup != null) {
            eventLoopGroup.shutdownGracefully();
        }

        reconnectTimes.set(0);
        isRunning.set(false);
        log.info("web socket client [{}] closed", name);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request  请求体
     * @param callback 请求结果的回调
     */
    public void sendRequest(P request, Consumer<T> callback) {
        sendRequest(request, callback, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request         请求体
     * @param callback        请求结果的回调
     * @param executorService 执行回调的线程池，传入为空则会尝试使用本类的线程池以及netty线程池
     */
    public void sendRequest(P request, Consumer<T> callback, ExecutorService executorService) {
        boolean flag = handler.registryRequest(request, response -> {
            if (executorService == null) {
                //此类线程处理
                callbackInvoker.submit(() -> {
                    callback.accept(response);
                });
            } else { //参数线程池处理
                executorService.submit(() -> {
                    callback.accept(response);
                });
            }
        });

        if (flag) {
            log.debug("send request [{}]", request);
            channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
        } else {
            throw new IllegalArgumentException("request id registered");
        }
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = handler.registryRequest(request, response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        log.debug("client [{}] send ping {}", name, url);
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        log.debug("client [{}] send pong {}", name, url);
        channel.writeAndFlush(new PongWebSocketFrame());
    }

    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }
}

package com.helei.netty.base;

import cn.hutool.core.util.StrUtil;
import com.helei.dto.base.HandlerEntity;
import com.helei.netty.NettyConstants;
import lombok.extern.slf4j.Slf4j;

import io.netty.channel.*;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;


/**
 * WebSocket客户端处理器抽象类
 * 能够处理请求响应类型的消息。
 * 其它类型的消息要通过handleOtherMessage()抽象方法处理
 *
 * @param <T>
 */
@Slf4j
@ChannelHandler.Sharable
public abstract class AbstractWebSocketClientHandler<P, T> extends BaseWebSocketClientHandler<P, T> {


    /**
     * 存放请求响应的回调
     */
    protected final ConcurrentMap<String, HandlerEntity<T>> requestIdMap = new ConcurrentHashMap<>();


    @Override
    protected void whenReceiveMessage(String text) {
        T message = convertMessageToRespType(text);

        String responseId = getResponseId(message);

        if (StrUtil.isNotBlank(responseId)) {
            //有id，是发送请求的响应
            //提交response
            handleResponseMessage(responseId, message);
        } else {
            //没有id，按其它格式处理
            handleOtherMessage(message);
        }
    }


    /**
     * 注册request
     *
     * @param request request
     * @return 是否注册成功
     */
    public boolean registryRequest(P request, Consumer<T> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        String requestId = getRequestId(request);

        requestIdMap.compute(requestId, (k, v) -> {
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", requestId, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 处理请求响应的消息
     *
     * @param id       id
     * @param response 响应消息体
     */
    protected void handleResponseMessage(String id, T response) {
        HandlerEntity<T> handlerEntity = requestIdMap.get(id);

        if (System.currentTimeMillis() > handlerEntity.getExpireTime()) {
            log.warn("请求[{}]得到响应超时", id);
        } else {
            websocketClient.callbackInvoker.execute(() -> handlerEntity.getCallback().accept(response));
        }
    }

    /**
     * 处理其他类型消息
     *
     * @param message 消息
     */
    protected abstract void handleOtherMessage(T message);


    /**
     * 将websocket收到的文本消息转换为响应类型 T
     *
     * @param message websocket收到的原始消息
     * @return typedMessage
     */
    public abstract T convertMessageToRespType(String message);


    /**
     * 获取请求id
     *
     * @param request request
     * @return id
     */
    public abstract String getRequestId(P request);

    /**
     * 获取响应id
     *
     * @param response 响应
     * @return id
     */
    public abstract String getResponseId(T response);
}


package com.helei.netty.base;

import com.helei.netty.NettyConstants;
import io.netty.channel.*;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.util.CharsetUtil;
import lombok.extern.slf4j.Slf4j;


/**
 * WebSocket客户端处理器基础类
 * 处理连接握手
 *
 * @param <P>
 * @param <T>
 */
@Slf4j
@ChannelHandler.Sharable
public abstract class BaseWebSocketClientHandler<P, T> extends SimpleChannelInboundHandler<Object> {
    private WebSocketClientHandshaker handshaker;

    private ChannelPromise handshakeFuture;

    protected AbstractWebsocketClient<P, T> websocketClient;

    /**
     * 收到消息处理
     *
     * @param text 消息字符串
     */
    protected abstract void whenReceiveMessage(String text);


    public void init(WebSocketClientHandshaker handshaker) {
        this.handshaker = handshaker;
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        handshakeFuture = ctx.newPromise();
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        log.info("WebSocket Client [{}] connected!", websocketClient.getName());
        channel.attr(NettyConstants.CLIENT_NAME).set(websocketClient.getName());
        handshaker.handshake(channel);
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        log.info("WebSocket Client [{}] disconnected!", ctx.channel().attr(NettyConstants.CLIENT_NAME).get());
        websocketClient.getIsRunning().set(false);
    }

    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        log.info("WebSocket Client [{}] unregistered!, start reconnect", ctx.channel().attr(NettyConstants.CLIENT_NAME).get());

        websocketClient.reconnect();
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        Channel ch = ctx.channel();
        // 如果握手未完成，处理 FullHttpResponse
        if (!handshaker.isHandshakeComplete()) {
            if (msg instanceof FullHttpResponse response) {
                try {
                    handshaker.finishHandshake(ch, response);
                    log.info("WebSocket client [{}] Handshake complete!", ch.attr(NettyConstants.CLIENT_NAME).get());
                    handshakeFuture.setSuccess();
                } catch (WebSocketHandshakeException e) {
                    log.info("WebSocket client [{}] Handshake failed!", ch.attr(NettyConstants.CLIENT_NAME).get());
                    handshakeFuture.setFailure(e);
                }
                return;
            }
        }

        if (msg instanceof FullHttpResponse response) {
            if (response.status().code() / 100 > 3) {
                throw new IllegalStateException(
                        "Unexpected FullHttpResponse (getStatus=" + response.status() +
                                ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
            }
        } else if (msg instanceof WebSocketFrame frame) {
            if (frame instanceof TextWebSocketFrame textFrame) {
                log.info("websocket client [{}] 接收到的消息：{}", ch.attr(NettyConstants.CLIENT_NAME).get(), textFrame.text());

                whenReceiveMessage(textFrame.text());

            } else if (frame instanceof PongWebSocketFrame) {
                log.debug("WebSocket Client [{}] received pong", ch.attr(NettyConstants.CLIENT_NAME).get());
            } else if (frame instanceof PingWebSocketFrame) {
                log.debug("WebSocket Client [{}] received ping", ch.attr(NettyConstants.CLIENT_NAME).get());
                websocketClient.sendPong();
            } else if (frame instanceof CloseWebSocketFrame) {
                log.warn("websocket client关闭");
                ch.close();
            }
        }
    }


    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        if (!handshakeFuture.isDone()) {
            handshakeFuture.setFailure(cause);
        }
        ctx.close();
        log.error("业务处理错误，websocket client关闭", cause);
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        websocketClient.sendPing();
    }

    public ChannelFuture handshakeFuture() {
        return handshakeFuture;
    }
}


package com.helei.binanceapi.api.ws;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.binanceapi.constants.command.AccountCommandType;
import com.helei.binanceapi.constants.command.BaseCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;


@Slf4j
public class BinanceWSBaseApi extends AbstractBinanceWSApi {
    public BinanceWSBaseApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 测试服务端联通性
     */
    public void pingServer() {
        binanceWSApiClient.sendPing();
    }


    /**
     * 查询服务端的时间
     *
     * @param callback callback, 失败则会传入null. 由父类的线程池执行
     */
    public void queryServerTime(Consumer<Long> callback) {
        JSONObject command = WebSocketCommandBuilder.builder().setCommandType(BaseCommandType.TIME).build();

        String id = command.getString("id");
        binanceWSApiClient.sendRequest(1, command, result -> {
            if (result != null) {
                try {
                    callback.accept(result.getLong("serverTime"));
                    log.debug("get server time [{}], request id[{}] success", result, id);
                } catch (Exception e) {
                    callback.accept(null);
                    log.error("parse server time error, requestId [{}]", id, e);
                }
            } else {
                callback.accept(null);
                log.warn("get server time, request id[{}] fail", id);
            }
        });
    }


    /**
     * 查询交易规范信息,
     *
     * @param permissions permissions
     * @param callback    callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            Consumer<JSONObject> callback,
            List<String> permissions
    ) {
        queryExchangeInfo(null, null, permissions, callback);
    }

    /**
     * 查询交易规范信息,
     *
     * @param symbols  symbols
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            List<String> symbols,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(null, symbols, null, callback);
    }

    /**
     * 查询交易规范信息, symbol,
     *
     * @param symbol   symbol
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(symbol, null, null, callback);
    }


    /**
     * 查询交易规范信息, symbol,symbols,permissions三个参数只能生效一个，从前到后第一个不为空的生效
     *
     * @param symbol      symbol
     * @param symbols     symbols
     * @param permissions permissions
     * @param callback    callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            List<String> symbols,
            List<String> permissions,
            Consumer<JSONObject> callback
    ) {


        JSONObject jb = new JSONObject();
        if (StrUtil.isNotBlank(symbol)) {
            jb.put("symbol", symbol);
        } else if (symbols != null && !symbols.isEmpty()) {
            jb.put("symbols", symbols);
        } else if (permissions != null && !permissions.isEmpty()) {
            jb.put("permissions", permissions);
        }
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(BaseCommandType.EXCHANGE_INFO)
                .setParams(jb)
                .build();
        binanceWSApiClient.sendRequest(20, command, callback);
    }


    /**
     * 请求listenKey
     *
     * @return CompletableFuture<String> listenKey
     */
    public CompletableFuture<String> requestListenKey(ASKey asKey) {
        JSONObject command = WebSocketCommandBuilder.builder()
                .setCommandType(AccountCommandType.USER_DATA_STREAM_START)
                .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                .build();

        log.info("请求获取listenKey， 请求[{}}", command);
        return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                .thenApplyAsync(json -> json.getJSONObject("result").getString("listenKey"));
    }

    /**
     * Websocket API延长listenKey有效期
     * 有效期延长至本次调用后60分钟
     *
     * @return CompletableFuture<String> listenKey
     */
    public CompletableFuture<String> lengthenListenKey(String listenKey, ASKey asKey) {
        JSONObject command = WebSocketCommandBuilder.builder()
                .setCommandType(AccountCommandType.USER_DATA_STREAM_PING)
                .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                .addParam(WebSocketStreamParamKey.LISTEN_KEY, listenKey)
                .build();

        log.info("请求延长listenKey， 请求[{}}", command);
        return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                .thenApplyAsync(json -> json.getJSONObject("result").getString("listenKey"));
    }

    /**
     * Websocket API关闭listenKey
     *
     * @return CompletableFuture<String> listenKey
     */
    public CompletableFuture<Boolean> closeListenKey(String listenKey, ASKey asKey) {
        JSONObject command = WebSocketCommandBuilder.builder()
                .setCommandType(AccountCommandType.USER_DATA_STREAM_CLOSE)
                .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                .addParam(WebSocketStreamParamKey.LISTEN_KEY, listenKey)
                .build();

        log.info("请求关闭listenKey， 请求[{}}", command);
        return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                .thenApplyAsync(json -> json.getInteger("status") == 200);
    }

}



package com.helei.binanceapi.api.ws;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.command.AccountCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 合约账户api
 */
@Slf4j
public class BinanceWSContractAccountApi extends AbstractBinanceWSApi {

    public BinanceWSContractAccountApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    /**
     * 账户余额 , 查询账户余额
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>、
     * {
     *     "id": "605a6d20-6588-4cb9-afa0-b0ab087507ba",
     *     "status": 200,
     *     "result": {
     *         [
     *            {
     *              "accountAlias": "SgsR",              // 账户唯一识别码
     *              "asset": "USDT",  	                // 资产
     *              "balance": "122607.35137903",        // 总余额
     *              "crossWalletBalance": "23.72469206", // 全仓余额
     *              "crossUnPnl": "0.00000000"           // 全仓持仓未实现盈亏
     *              "availableBalance": "23.72469206",   // 下单可用余额
     *              "maxWithdrawAmount": "23.72469206",  // 最大可转出余额
     *              "marginAvailable": true,            // 是否可用作联合保证金
     *             "updateTime": 1617939110373
     *             }
     *         ]
     *     },
     *     "rateLimits": [
     *       {
     *         "rateLimitType": "REQUEST_WEIGHT",
     *         "interval": "MINUTE",
     *         "intervalNum": 1,
     *         "limit": 2400,
     *         "count": 20
     *       }
     *     ]
     * }
     */
    public CompletableFuture<JSONObject> accountBalance(
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(AccountCommandType.ACCOUNT_BALANCE)
                .build();

        log.info("查询账户余额，请求[{}]", command);
        return binanceWSApiClient.sendRequest(5, command, asKey);
    }


    /**
     * 账户信息
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountStatus(
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(AccountCommandType.ACCOUNT_STATUS)
                .build();

        log.info("查询账户信息，请求[{}]", command);
        return binanceWSApiClient.sendRequest(5, command, asKey);
    }

}

package com.helei.binanceapi.api.ws;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.constants.trade.KLineInterval;
import com.helei.binanceapi.constants.command.MarketCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;


/**
 * 现货api
 */
@Slf4j
public class BinanceWSMarketApi extends AbstractBinanceWSApi {


    public BinanceWSMarketApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    /**
     * 获取当前深度信息。
     * 请注意，此请求返回有限的市场深度。
     * 如果需要持续监控深度信息更新，请考虑使用 WebSocket Streams：
     * <symbol>@depth<levels>
     * <symbol>@depth
     * 如果需要维护本地orderbook，您可以将 depth 请求与 <symbol>@depth streams 一起使用。
     * 权重(IP): 根据限制调整：
     * 限制	重量
     * 1–100	5
     * 101–500	25
     * 501–1000	50
     * 1001-5000	250
     * 参数:
     * 名称	类型	是否必需	描述
     * symbol	STRING	YES
     * limit	INT	NO	默认 100; 最大值 5000
     *
     * @param symbol   symbol
     * @param limit    limit
     * @param callback callback
     *                 {
     *                 "lastUpdateId": 2731179239,
     *                 // bid 水平从最高价到最低价排序。
     *                 "bids": [
     *                 [
     *                 "0.01379900",   // 价格
     *                 "3.43200000"    // 重量
     *                 ]
     *                 ],
     *                 // ask 水平从最低价到最高价排序。
     *                 "asks": [
     *                 [
     *                 "0.01380000",
     *                 "5.91700000"
     *                 ]
     *                 ]
     *                 }
     */
    public void queryDepth(String symbol, Integer limit, Consumer<JSONObject> callback) {
        int ipWeight = 100;
        if (limit >= 1 && limit <= 100) {
            ipWeight = 5;
        } else if (limit >= 101 && limit <= 500) {
            ipWeight = 25;
        } else if (limit >= 501 && limit <= 1000) {
            ipWeight = 50;
        } else if (limit >= 1001 && limit <= 5000) {
            ipWeight = 250;
        } else {
            ipWeight = 250;
            limit = 5000;
        }

        WebSocketCommandBuilder builder = WebSocketCommandBuilder
                .builder();
        builder.setCommandType(MarketCommandType.DEPTH);
        builder.addParam("symbol", symbol);
        builder.addParam("limit", limit);
        JSONObject command = builder
                .build();


        binanceWSApiClient.sendRequest(ipWeight, command, callback);
    }


    /**
     * 查询最近交易信息
     *
     * @param symbol   symbol
     * @param limit    多少条
     * @param callback callback
     *                 [
     *                 {
     *                 "id": 194686783,
     *                 "price": "0.01361000",
     *                 "qty": "0.01400000",
     *                 "quoteQty": "0.00019054",
     *                 "time": 1660009530807,
     *                 "isBuyerMaker": true,
     *                 "isBestMatch": true
     *                 }
     *                 ]
     */
    public void queryTradesRecent(String symbol, int limit, Consumer<JSONObject> callback) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(MarketCommandType.TRADES_RECENT)
                .addParam("symbol", symbol)
                .addParam("limit", limit)
                .build();

        binanceWSApiClient.sendRequest(20, command, callback);
    }


    /**
     * 查询历史k线数据
     *
     * @param symbol          symbol
     * @param interval        interval
     * @param startTimeSecond startTimeSecond
     * @param limit           limit
     * @return result
     */
    public CompletableFuture<JSONObject> queryHistoryKLine(
            String symbol,
            KLineInterval interval,
            long startTimeSecond,
            int limit
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(MarketCommandType.KLINES)
                .addParam("symbol", symbol)
                .addParam("interval", interval.getDescribe())
                .addParam("startTime", startTimeSecond * 1000)
                .addParam("limit", limit)
                .build();

        return binanceWSApiClient.sendRequest(2, command, ASKey.EMPTY_ASKEY);
    }
}


package com.helei.binanceapi.api.ws;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.command.AccountCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 用户相关api
 */
@Slf4j
public class BinanceWSSpotAccountApi extends AbstractBinanceWSApi {

    public BinanceWSSpotAccountApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    /**
     * 账户信息
     * @param omitZeroBalances 是否显示非0余额
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountStatus(
            Boolean omitZeroBalances,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("omitZeroBalances", omitZeroBalances)
                .setCommandType(AccountCommandType.ACCOUNT_STATUS)
                .build();

        log.info("query account status command [{}]", command);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }

    /**
     * 显示用户在所有时间间隔内的未成交订单计数。
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountRateLimitsOrders(ASKey asKey) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(AccountCommandType.ACCOUNT_RATE_LIMITS_ORDERS)
                .build();

        log.info("query account rate limit orders command [{}]", command);
        return binanceWSApiClient.sendRequest(40, command, asKey);
    }

    /**
     * 账户订单历史
     * 获取所有账户订单； 有效，已取消或已完成。按时间范围过滤。
     * 订单状态报告与 order.status 相同。
     * 请注意，某些字段是可选的，仅在订单中有设置它们时才包括。
     * --
     * 如果指定了 startTime 和/或 endTime，则忽略 orderId。
     * 订单是按照最后一次更新的执行状态的time过滤的。
     * 如果指定了 orderId，返回的订单将是订单ID >= orderId
     * 如果不指定条件，则返回最近的订单。
     * 对于某些历史订单，cummulativeQuoteQty 响应字段可能为负数，代表着此时数据还不可用。
     * @param symbol 必须
     * @param orderId 起始订单ID，可选
     * @param startTime 可选
     * @param endTime 可选
     * @param limit 可选
     * @param asKey 签名参数
     * @return  CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountAllOrders(
            String symbol,
            Integer orderId,
            Long startTime,
            Long endTime,
            Integer limit,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("startTime", startTime)
                .addParam("endTime", endTime)
                .addParam("limit", limit)
                .setCommandType(AccountCommandType.ACCOUNT_ALL_ORDERS)
                .build();

        log.info("query account [{}] orders", symbol);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }


    /**
     * 账户成交历史
     * 如果指定了 fromId，则返回的交易将是 交易ID >= fromId。
     * 如果指定了 startTime 和/或 endTime，则交易按执行时间（time）过滤。
     * fromId 不能与 startTime 和 endTime 一起使用。
     * 如果指定了 orderId，则只返回与该订单相关的交易。
     * startTime 和 endTime 不能与 orderId 一起使用。
     * 如果不指定条件，则返回最近的交易。
     * @param symbol 必须
     * @param orderId 起始订单ID，可选
     * @param startTime 可选
     * @param endTime 可选
     * @param fromId 起始交易 ID
     * @param limit 可选
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountTrades(
            String symbol,
            Integer orderId,
            Long startTime,
            Long endTime,
            Integer fromId,
            Integer limit,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("startTime", startTime)
                .addParam("endTime", endTime)
                .addParam("fromId", fromId)
                .addParam("limit", limit)
                .setCommandType(AccountCommandType.ACCOUNT_ALL_ORDERS)
                .build();

        log.info("query account all trades, command[{}]", command);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }
}

package com.helei.binanceapi.api.ws;

import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.binanceapi.constants.WebSocketStreamType;
import com.helei.dto.ASKey;
import com.helei.binanceapi.dto.StreamSubscribeEntity;

import java.util.concurrent.ExecutorService;

import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * 币按stream api
 */
public class BinanceWSStreamApi extends AbstractBinanceWSApi {

    public BinanceWSStreamApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    public StreamCommandBuilder builder() {
        return new StreamCommandBuilder(binanceWSApiClient);
    }


    public static class StreamCommandBuilder {
        private final AbstractBinanceWSApiClient binanceWSApiClient;

        private String symbol = null;

        private List<StreamSubscribeEntity> subscribeList = null;

        StreamCommandBuilder(AbstractBinanceWSApiClient binanceWSApiClient) {
            this.binanceWSApiClient = binanceWSApiClient;
        }

        /**
         * 设置symbol
         *
         * @param symbol symbol
         * @return StreamCommandBuilder
         */
        public StreamCommandBuilder symbol(String symbol) {
            this.symbol = symbol;
            return this;
        }


        /**
         * 添加订阅类型， 必须在设置symbol之后
         *
         * @param subscribeType     subscribeType
         * @param invocationHandler invocationHandler
         * @return StreamCommandBuilder
         */
        public StreamCommandBuilder addSubscribeEntity(
                WebSocketStreamType subscribeType,
                SubscribeResultInvocationHandler invocationHandler
        ) {
            return addSubscribeEntity(subscribeType, invocationHandler, null);
        }

        /**
         * 添加订阅类型， 必须在设置symbol之后
         *
         * @param subscribeType     subscribeType
         * @param invocationHandler invocationHandler
         * @param params            params
         * @return StreamCommandBuilder
         */
        public StreamCommandBuilder addSubscribeEntity(
                WebSocketStreamType subscribeType,
                SubscribeResultInvocationHandler invocationHandler,
                Map<String, Object> params
        ) {
            return addSubscribeEntity(subscribeType, invocationHandler, null, params);
        }

        /**
         * 添加订阅类型， 必须在设置symbol之后
         *
         * @param subscribeType     subscribeType
         * @param invocationHandler invocationHandler
         * @param executorService   执行的线程池，如果设置了，在收到订阅的消息的时候会优先使用该线程池
         * @return StreamCommandBuilder
         */
        public StreamCommandBuilder addSubscribeEntity(
                WebSocketStreamType subscribeType,
                SubscribeResultInvocationHandler invocationHandler,
                ExecutorService executorService,
                Map<String, Object> params
        ) {
            return addSubscribeEntity(subscribeType, invocationHandler, executorService, null, params);
        }

        /**
         * 添加订阅类型， 必须在设置symbol之后
         *
         * @param subscribeType     subscribeType
         * @param invocationHandler invocationHandler
         * @param executorService   执行的线程池，如果设置了，在收到订阅的消息的时候会优先使用该线程池
         * @return StreamCommandBuilder
         */
        public StreamCommandBuilder addSubscribeEntity(
                WebSocketStreamType subscribeType,
                SubscribeResultInvocationHandler invocationHandler,
                ExecutorService executorService,
                ASKey asKey,
                Map<String, Object> params
        ) {
            return addSubscribeEntity(new StreamSubscribeEntity(symbol, subscribeType, invocationHandler, executorService, params, asKey));
        }

        /**
         * 添加订阅类型， 必须在设置symbol之后
         *
         * @param subscribeEntity subscribeEntity
         * @return StreamCommandBuilder
         */
        public synchronized StreamCommandBuilder addSubscribeEntity(
                StreamSubscribeEntity subscribeEntity
        ) {
            if (subscribeList == null) {
                subscribeList = new ArrayList<>();
            }

            subscribeList.add(subscribeEntity);
            return this;
        }

        public void subscribe() {
            binanceWSApiClient.subscribeStream(subscribeList);
        }
    }

}





package com.helei.binanceapi.api.ws;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.CancelRestrictions;
import com.helei.binanceapi.constants.command.TradeCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import com.helei.dto.order.BaseOrder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 交易相关api
 */
@Slf4j
public class BinanceWSTradeApi extends AbstractBinanceWSApi {

    public BinanceWSTradeApi(AbstractBinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 提交订单，
     *
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitOrder(BaseOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_PLACE)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 提交测试订单，
     *
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitTestOrder(BaseOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_TEST)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit test order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 查询订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * 对于某些历史订单，cummulativeQuoteQty 响应字段可能为负数，意味着此时数据不可用。
     *
     * @param symbol            symbol
     * @param orderId           orderId
     * @param origClientOrderId origClientOrderId
     * @param asKey             签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> queryOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .setCommandType(TradeCommandType.ORDER_STATUS)
                .build();

        log.info("query order [{}]", command);
        return binanceWSApiClient.sendRequest(4, command, asKey);
    }


    /**
     * 撤销订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * newClientOrderId 将替换已取消订单的 clientOrderId，为新订单腾出空间。
     * 如果您取消属于订单列表的订单，则整个订单列表将被取消。
     *
     * @param symbol             symbol
     * @param orderId            按 orderId 取消订单
     * @param origClientOrderId  按 clientOrderId 取消订单
     * @param newClientOrderId   已取消订单的新 ID。如果未发送，则自动生成
     * @param cancelRestrictions 支持的值:
     *                           ONLY_NEW - 如果订单状态为 NEW，撤销将成功。
     *                           ONLY_PARTIALLY_FILLED - 如果订单状态为 PARTIALLY_FILLED，撤销将成功。
     * @param asKey              签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> cancelOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .addParam("newClientOrderId", newClientOrderId)
                .addParam("cancelRestrictions", cancelRestrictions)
                .setCommandType(TradeCommandType.ORDER_CANCEL)
                .build();

        log.info("cancel order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 撤销单一交易对的所有挂单
     *
     * @param symbol symbol
     * @param asKey  签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersCancelAll(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_CANCEL_ALL)
                .build();

        log.info("cancel all order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }


    /**
     * 查询用户当前挂单情况
     *
     * @param symbol symbol
     * @param asKey  签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersStatus(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_STATUS)
                .build();
        int weight = 6;
        if (StrUtil.isBlank(symbol)) {
            weight = 80;
        }

        log.info("open order status [{}]", command);
        return binanceWSApiClient.sendRequest(weight, command, asKey);
    }
}






package com.helei.binanceapi.base;


import java.net.URISyntaxException;

/**
 * 币安接口基础类
 */
public class AbstractBinanceWSApi {
    protected final AbstractBinanceWSApiClient binanceWSApiClient;

    public AbstractBinanceWSApi(
            AbstractBinanceWSApiClient binanceWSApiClient
    ) throws URISyntaxException {
        this.binanceWSApiClient = binanceWSApiClient;
    }


}





package com.helei.binanceapi.base;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.dto.ASKey;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import com.helei.dto.WebSocketCommandBuilder;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.binanceapi.util.SignatureUtil;
import com.helei.binanceapi.constants.command.BaseCommandType;
import com.helei.netty.base.AbstractWebsocketClient;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.security.InvalidKeyException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

/**
 * 币按ws接口客户端抽象类
 */
@Slf4j
public class AbstractBinanceWSApiClient extends AbstractWebsocketClient<JSONObject, JSONObject> {
    /**
     * 币安客户端类型
     */
    private final BinanceWSClientType clientType;

    /**
     * 处理ip限制相关
     */
    private final IpWeightSupporter ipWeightSupporter;

    private final AbstractBinanceWSApiClientHandler handler;


    public AbstractBinanceWSApiClient(
            BinanceWSClientType clientType,
            String url,
            IpWeightSupporter ipWeightSupporter,
            AbstractBinanceWSApiClientHandler handler
    ) throws URISyntaxException {
        super(url, handler);
        this.clientType = clientType;
        this.ipWeightSupporter = ipWeightSupporter;
        this.handler = handler;
    }

    /**
     * 发生请求
     *
     * @param ipWeight ip weight
     * @param request  请求体
     * @param callback 回调
     */
    public void sendRequest(
            int ipWeight,
            JSONObject request,
            Consumer<JSONObject> callback
    ) {
        sendRequest(ipWeight, request, null, callback);
    }

    /**
     * 发生请求
     *
     * @param ipWeight ip weight
     * @param request  请求体
     * @param asKey    签名参数
     * @param callback 回调
     */
    public void sendRequest(
            int ipWeight,
            JSONObject request,
            ASKey asKey,
            Consumer<JSONObject> callback
    ) {
        try {
            if (ipWeightSupporter.submitIpWeight(ipWeight)) {
                String id = handler.getRequestId(request);

                //需要签名
                if (asKey != null) {
                    JSONObject params = request.getJSONObject("params");
                    params.put("timestamp", System.currentTimeMillis());
                    try {
                        params.put("signature", SignatureUtil.signatureHMAC(asKey.getSecretKey(), params));
                    } catch (InvalidKeyException e) {
                        throw new IllegalArgumentException("signature params error");
                    }
                    params.put("apiKey", asKey.getApiKey());
                }

                super.sendRequest(request, response -> {
                    if (response != null) {

                        if (response.getInteger("status") != null && response.getInteger("status") != 200) {
                            log.error("receive error response [{}]", response);
                        }
                        log.debug("send request id[{}] success, response[{}]", id, response);
                        callback.accept(response);
                    } else {
                        callback.accept(null);
                        log.error("send request id[{}] fail", id);
                    }
                });
            } else {
                log.warn("current ipWeight[{}] not support send request", ipWeightSupporter.currentWeight());
            }
        } catch (Exception e) {
            log.error("send request error", e);
        }
    }

    /**
     * 发生请求
     *
     * @param ipWeight ip weight
     * @param request  请求体
     * @param asKey    签名
     */
    public CompletableFuture<JSONObject> sendRequest(
            int ipWeight,
            JSONObject request,
            ASKey asKey
    ) {
        if (!ipWeightSupporter.submitIpWeight(ipWeight)) {
            log.error("ipWeight[{}] not support send request", ipWeightSupporter.currentWeight());
            return null;
        }
        return super.sendRequest(trySignatureRequest(request, asKey))
                .thenApplyAsync(
                        jb -> {
                            if (jb == null || jb.getInteger("status") != 200) {
                                log.error("请求不成功，响应为 [{}]", jb);
                                throw new RuntimeException("请求不成功");
                            }
                            return jb;
                        }
                );
    }


    /**
     * 如果askey不为空，则对请求进行签名
     *
     * @param request request
     * @param asKey   asKey
     * @return JSONObject 签名后的请求
     */
    private JSONObject trySignatureRequest(JSONObject request, ASKey asKey) {
        //需要签名
        if (asKey != null && StrUtil.isNotBlank(asKey.getApiKey()) && StrUtil.isNotBlank(asKey.getSecretKey())) {
            JSONObject params = request.getJSONObject("params");
            params.put("timestamp", System.currentTimeMillis());
            params.put("apiKey", asKey.getApiKey());
            try {
                params.put("signature", SignatureUtil.signatureHMAC(asKey.getSecretKey(), params));
            } catch (Exception e) {
                log.error("signature params error", e);
                return null;
            }
        }
        return request;
    }


    /**
     * 订阅stream
     *
     * @param subList 需订阅的类型
     */
    public void subscribeStream(List<StreamSubscribeEntity> subList) {

        WebSocketCommandBuilder builder = WebSocketCommandBuilder.builder().setCommandType(BaseCommandType.SUBSCRIBE);

        /*
         * 由于StreamSubscribeEntity中可能存在鉴权的ASKey，需要每个单独发请求
         */
        for (StreamSubscribeEntity subscribeEntity : subList) {
            builder.clear();
            builder.addArrayParam(subscribeEntity.getStreamName());
            JSONObject command = builder.build();

            log.info("subscribe stream command: {}", command);

            String id = command.getString("id");

            sendRequest(1, command, subscribeEntity.getAsKey(), response -> {
                if (response != null) {
                    log.debug("get subscribe response: {}", response);
                    handler.addSubscribe(List.of(subscribeEntity));
                } else {
                    log.error("get subscribe response error, requestId[{}]", id);
                }
            });
        }
    }
}






package com.helei.binanceapi.base;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import com.helei.netty.base.AbstractWebSocketClientHandler;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;


/**
 * 能够处理推送的消息，只要消息体的 e 字段为已注册的名
 */
@Slf4j
public abstract class AbstractBinanceWSApiClientHandler extends AbstractWebSocketClientHandler<JSONObject, JSONObject> {
    /**
     * 存储订阅流的信息，包含有收到流消息的回调。
     */
    protected final ConcurrentMap<String, StreamSubscribeEntity> subscribeMap;


    public AbstractBinanceWSApiClientHandler() {
        this.subscribeMap = new ConcurrentHashMap<>();
    }

    @Override
    public JSONObject convertMessageToRespType(String message) {
        return JSONObject.parseObject(message);
    }

    @Override
    public String getRequestId(JSONObject request) {
        return request.getString("id");
    }

    @Override
    public String getResponseId(JSONObject response) {
        return response.getString("id");
    }

    @Override
    protected void handleOtherMessage(JSONObject message) {
        String streamName = message.getString("e");

        if (!StrUtil.isBlank(streamName)) {
            handleStreamMessage(streamName, message);
        }
    }




    /**
     * 处理stream流推送消息
     *
     * @param streamName stream 流名称
     * @param content    推送消息
     */
    protected abstract void handleStreamMessage(String streamName, JSONObject content);

    /**
     * 创建订阅
     *
     * @param subList stream订阅类型列表
     */
    public void addSubscribe(List<StreamSubscribeEntity> subList) {
        for (StreamSubscribeEntity subscribeEntity : subList) {
            subscribeMap.putIfAbsent(subscribeEntity.getStreamName(), subscribeEntity);
        }
    }

}


package com.helei.binanceapi.base;

import com.helei.binanceapi.dto.accountevent.AccountEvent;

public interface AccountEventInvocation {

    void whenReceiveEvent(AccountEvent event);

    String lengthListenKey(String oldListenKey);
}



package com.helei.binanceapi.base;


import com.alibaba.fastjson.JSONObject;

import java.util.Map;


/**
 * 订阅流消息结果处理
 */
public interface SubscribeResultInvocationHandler {

    void invoke(String streamName, Map<String, Object> params, JSONObject result);

}

