package cn.com.vortexa.websocket.netty.handler;

import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.com.vortexa.websocket.netty.util.HandlerEntity;
import io.netty.channel.*;
import io.netty.handler.timeout.IdleStateEvent;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * WebSocket客户端处理器基础类
 * 处理连接握手
 */
@Slf4j
@Getter
@ChannelHandler.Sharable
public abstract class BaseWebSocketInboundHandler<T> extends SimpleChannelInboundHandler<T> {

    /**
     * 存放请求响应的回调
     */
    protected final ConcurrentMap<Object, HandlerEntity<T>> requestIdMap = new ConcurrentHashMap<>();

    /**
     * 执行回调的线程池
     */
    private ExecutorService callbackInvoker;

    protected void init(ExecutorService callbackInvoker) {
        this.callbackInvoker = callbackInvoker;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
    }

    @Override
    protected final void channelRead0(ChannelHandlerContext ctx, T message) throws Exception {
        Channel channel = ctx.channel();
        log.debug("{} -> {}  message: {}", channel.remoteAddress(), channel.localAddress(), message);
        // Step 1 尝试调用请求回调
        tryInvokeResponseCallback(message)
                .thenAccept(success -> {
                    // Step 2 返回false，说明不是是请求的响应, 往下处理
                    if (!success) {
                        handlerMessage(ctx, message);
                    }
                })
                .exceptionally(throwable -> {
                    if (throwable != null) {
                        log.error("request callback invoke error", throwable);
                    }
                    return null;
                });
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }


    /**
     * 注册request
     *
     * @param request request
     * @return 是否注册成功
     */
    public boolean registryRequest(T request, Consumer<T> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        Object requestId = getMessageId(request);

        if (requestId == null) {
            return false;
        }

        requestIdMap.compute(requestId, (k, v) -> {
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", requestId, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 调用响应的回调
     *
     * @param response response
     */
    public CompletableFuture<Boolean> tryInvokeResponseCallback(T response) {
        Object responseId = getMessageId(response);
        log.debug("responseId[{}] is, {}", responseId, response);

        if (responseId == null || !requestIdMap.containsKey(responseId)) {
            return CompletableFuture.completedFuture(false);
        }

        return CompletableFuture.supplyAsync(() -> {
            try {
                HandlerEntity<T> remove = requestIdMap.remove(responseId);
                if (remove != null) {
                    remove.getCallback().accept(response);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            return true;
        }, callbackInvoker);
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 从消息中取id
     *
     * @param message message
     * @return id
     */
    protected abstract Object getMessageId(T message);

    /**
     * 处理消息
     *
     * @param ctx     ctx
     * @param message message
     */
    protected abstract void handlerMessage(ChannelHandlerContext ctx, T message);
}
package cn.com.vortexa.nameserver.processor;


import cn.com.vortexa.nameserver.NameserverClient;
import cn.com.vortexa.nameserver.config.NameserverClientConfig;
import cn.com.vortexa.nameserver.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import cn.com.vortexa.websocket.netty.handler.AbstractWebSocketClientHandler;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;

/**
 * @author helei
 * @since 2025-03-13
 */
@Slf4j
public class NameClientProcessorAdaptor extends AbstractWebSocketClientHandler<RemotingCommand> {

    @Getter
    private final NameserverClientConfig clientConfig;

    @Setter
    private NameserverClient nameserverClient;

    public NameClientProcessorAdaptor(NameserverClientConfig clientConfig) {
        this.clientConfig = clientConfig;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        super.channelActive(ctx);
        ctx.channel().attr(NettyConstants.CLIENT_NAME).set(nameserverClient.getName());
        sendRegistryCommand();
    }

    @Override
    protected void handlerMessage(ChannelHandlerContext ctx, RemotingCommand message) {
        log.debug("receive [{}] ", message);
    }

    @Override
    protected Object getMessageId(RemotingCommand message) {
        return message.getTransactionId();
    }

    /**
     * 发送服务注册命令
     */
    private void sendRegistryCommand() {
        RemotingCommand remotingCommand = new RemotingCommand();
        remotingCommand.setFlag(RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE);
        remotingCommand.setTransactionId(
                DistributeIdMaker.DEFAULT.nextId(clientConfig.getServiceInstance().getServiceId())
        );

        remotingCommand.setBodyFromObject(new HashMap<>());

        nameserverClient.sendRequest(remotingCommand).whenComplete((response, throwable) -> {
            if (throwable != null) {
                log.error("{} -> [{}] channel active error",
                        clientConfig.getServiceInstance(), clientConfig.getRegistryCenterUrl(), throwable);
            }

            if (response.getFlag() == RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE_RESPONSE) {
                log.info("{} client registry success", clientConfig.getServiceInstance());
            }
        });
    }
}
package cn.com.vortexa.nameserver;


import cn.com.vortexa.nameserver.config.NameserverClientConfig;
import cn.com.vortexa.nameserver.constant.NameserverSystemConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.ServiceInstance;
import cn.com.vortexa.nameserver.processor.NameClientProcessorAdaptor;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import cn.com.vortexa.nameserver.util.RemotingCommandDecoder;
import cn.com.vortexa.nameserver.util.RemotingCommandEncoder;
import cn.com.vortexa.websocket.netty.base.AbstractWebsocketClient;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.*;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.extern.slf4j.Slf4j;

import java.util.Optional;

/**
 * @author helei
 * @since 2025-03-13
 */
@Slf4j
public class NameserverClient extends AbstractWebsocketClient<RemotingCommand> {

    private final NameserverClientConfig clientConfig;

    private final String clientName;

    public NameserverClient(NameserverClientConfig clientConfig) {
        this(clientConfig, new NameClientProcessorAdaptor(clientConfig));
    }

    public NameserverClient(NameserverClientConfig clientConfig, NameClientProcessorAdaptor nameClientProcessorAdaptor) {
        super(clientConfig.getRegistryCenterUrl(), clientConfig.getServiceInstance().toString(), nameClientProcessorAdaptor);
        super.setHandshake(false);
        this.clientConfig = clientConfig;
        this.clientName = clientConfig.getServiceInstance().toString();
        ((NameClientProcessorAdaptor) getHandler()).setNameserverClient(this);
    }

    @Override
    public void addPipeline(ChannelPipeline p) {
        p.addLast(new IdleStateHandler(0,
                0, clientConfig.getServiceOfflineTtl()));

        p.addLast(new LengthFieldBasedFrameDecoder(NameserverSystemConstants.MAX_FRAME_LENGTH,
                0, 4, 0, 4));
        p.addLast(new LengthFieldPrepender(4));

        p.addLast(new RemotingCommandDecoder());
        p.addLast(new RemotingCommandEncoder());
        p.addLast(getHandler());
    }

    @Override
    public Object getIdFromMessage(RemotingCommand message) {
        return message.getTransactionId();
    }

    @Override
    protected void doSendMessage(RemotingCommand message, boolean b) {
        log.debug("send message to nameserver: {}", message);

        ServiceInstance serviceInstance = clientConfig.getServiceInstance();

        if (b && StrUtil.isBlank(message.getTransactionId())) {
            message.setTransactionId(clientName);
        }

        message.setGroup(serviceInstance.getGroup());
        message.setServiceId(serviceInstance.getServiceId());
        message.setClientId(serviceInstance.getClientId());

        Optional.of(getChannel()).ifPresent(channel -> channel.writeAndFlush(message));
    }

    @Override
    public void sendPing() {
        sendRequest(RemotingCommand.generatePingCommand(clientName));
    }



    @Override
    public void sendPong() {
        sendRequest(RemotingCommand.generatePongCommand(clientName));
    }
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.nameserver.constant.*;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.server.NameserverService;
import cn.com.vortexa.nameserver.service.IRegistryService;
import cn.com.vortexa.websocket.netty.handler.BaseWebSocketInboundHandler;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;

/**
 * @author helei
 * @since 2025/03/11
 */
@Slf4j
@ChannelHandler.Sharable
public class NameserverProcessorAdaptor extends BaseWebSocketInboundHandler<RemotingCommand> {

    @Getter
    private final NameserverService nameserverService;
    private final PingCommandProcessor pingCommandProcessor;
    private final PongCommandProcessor pongCommandProcessor;
    private final ServiceRegistryProcessor serviceRegistryProcessor;
    private final ServiceDiscoverProcessor serviceDiscoverProcessor;

    public NameserverProcessorAdaptor(
            NameserverService nameServerService,
            IRegistryService registryService
    ) {
        super();
        this.nameserverService = nameServerService;
        this.pingCommandProcessor = new PingCommandProcessor();
        this.pongCommandProcessor = new PongCommandProcessor();
        this.serviceRegistryProcessor = new ServiceRegistryProcessor(registryService);
        this.serviceDiscoverProcessor = new ServiceDiscoverProcessor(registryService);

        init(Executors.newThreadPerTaskExecutor(new NamedThreadFactory("nameserver-processor")));
    }


    @Override
    protected void handlerMessage(ChannelHandlerContext ctx, RemotingCommand remotingCommand) {
        Integer opt = remotingCommand.getFlag();
        String txId = remotingCommand.getTransactionId();

        Channel channel = ctx.channel();
        String clientName = channel.attr(NettyConstants.CLIENT_NAME).get();
        log.debug("receive client[{}] command [{}]", clientName, remotingCommand);

        CompletableFuture.supplyAsync(() -> switch (opt) {
                    case RemotingCommandFlagConstants.PING ->
                            pingCommandProcessor.handlerPing(clientName, channel, remotingCommand);
                    case RemotingCommandFlagConstants.PONG ->
                            pongCommandProcessor.handlerPong(clientName, channel, remotingCommand);
                    case RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE ->
                            serviceRegistryProcessor.handlerClientServiceRegistry(channel, remotingCommand);
                    case RemotingCommandFlagConstants.CLIENT_DISCOVER_SERVICE ->
                            serviceDiscoverProcessor.handlerDiscoverService(channel, remotingCommand);
                    default -> throw new IllegalStateException("Unexpected value: " + opt);
                }, getCallbackInvoker())
                .whenCompleteAsync((response, ex) -> {
                    if (ex != null) {
                        log.error("client[{}] command process failed", clientName, ex);
                    }
                    if (response != null) {
                        response.setTransactionId(txId);
                        ctx.channel().writeAndFlush(response);
                    }
                });
    }

    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        nameserverService.closeChannel(ctx.channel());
    }

    @Override
    protected Object getMessageId(RemotingCommand message) {
        return message.getTransactionId();
    }
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.nameserver.dto.RemotingCommand;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

/**
 * @author h30069248
 * @since 2025/3/18 9:46
 */
@Slf4j
public class PingCommandProcessor {
    public RemotingCommand handlerPing(String clientName, Channel channel, RemotingCommand remotingCommand) {
        log.debug("receive client[{}] ping,", clientName);

        return null;
    }
}
package cn.com.vortexa.nameserver.dto;

import cn.com.vortexa.nameserver.constant.LanguageCode;
import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.nameserver.protocol.Serializer;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.HashMap;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class RemotingCommand {

    public static final RemotingCommand TIME_OUT_COMMAND;
    public static final RemotingCommand PARAMS_ERROR;

    public static final String TRANSACTION_ID_KEY = "transaction_id";
    public static final String GROUP_KEY = "group";
    public static final String SERVICE_ID_KEY = "service_id";
    public static final String CLIENT_ID_KEY = "client_id";

    static {
        TIME_OUT_COMMAND = new RemotingCommand();
        TIME_OUT_COMMAND.setFlag(RemotingCommandFlagConstants.TIME_OUT_EXCEPTION);
        TIME_OUT_COMMAND.setCode(RemotingCommandCodeConstants.FAIL);

        PARAMS_ERROR = new RemotingCommand();
        PARAMS_ERROR.setFlag(RemotingCommandFlagConstants.PARAMS_ERROR);
        PARAMS_ERROR.setCode(RemotingCommandCodeConstants.FAIL);
    }

    private Integer flag;
    private Integer code;
    private LanguageCode language = LanguageCode.JAVA;
    private Integer version = 0;
    private String remark;
    private HashMap<String, String> extFields;

    private byte[] body;

    private Object payLoad;

    @Override
    public RemotingCommand clone() {
        RemotingCommand remotingCommand = new RemotingCommand();
        remotingCommand.setFlag(this.flag);
        remotingCommand.setCode(this.code);
        remotingCommand.setLanguage(this.language);
        remotingCommand.setVersion(this.version);
        remotingCommand.setRemark(this.remark);
        remotingCommand.setExtFields(this.extFields);
        remotingCommand.setBody(this.body);
        remotingCommand.setPayLoad(this.payLoad);
        return remotingCommand;
    }

    public String getTransactionId() {
        return getExtFieldsValue(TRANSACTION_ID_KEY);
    }

    public void setTransactionId(String tsId) {
        addExtField(TRANSACTION_ID_KEY, tsId);
    }

    public String getGroup() {
        String value = getExtFieldsValue(GROUP_KEY);
        return (value == null || value.isEmpty()) ? "default" : value;
    }

    public void setGroup(String group) {
        addExtField(GROUP_KEY, group);
    }

    public String getServiceId() {
        return getExtFieldsValue(SERVICE_ID_KEY);
    }

    public void setServiceId(String serviceId) {
        addExtField(SERVICE_ID_KEY, serviceId);
    }

    public String getClientId() {
        return getExtFieldsValue(CLIENT_ID_KEY);
    }

    public void setClientId(String clientId) {
        addExtField(CLIENT_ID_KEY, clientId);
    }

    public String getExtFieldsValue(String extFieldsKey) {
        if (extFields == null) return null;
        return extFields.get(extFieldsKey);
    }

    public Integer getExtFieldsInt(String extFieldsKey) {
        String value = getExtFieldsValue(extFieldsKey);
        if (value == null || value.isEmpty()) return null;
        return Integer.parseInt(value);
    }

    public Long getExtFieldsLong(String extFieldsKey) {
        String value = getExtFieldsValue(extFieldsKey);
        if (value == null || value.isEmpty()) return null;
        return Long.parseLong(value);
    }

    public void addExtField(String key, String value) {
        if (this.extFields == null) {
            this.extFields = new HashMap<>();
        }
        this.extFields.put(key, value);
    }

    public void setBodyFromObject(Object body) {
        this.body = Serializer.Algorithm.Protostuff.serialize(body);
    }

    public void release() {
    }

    protected void clear() {
        this.flag = null;
        this.code = null;
        this.language = null;
        this.version = null;
        this.remark = null;
        if (extFields == null) extFields = new HashMap<>();
        else this.extFields.clear();
        this.body = null;
    }

    public static RemotingCommand generatePingCommand(String key) {
        String txId = DistributeIdMaker.DEFAULT.nextId(key);
        RemotingCommand ping = new RemotingCommand();
        ping.setFlag(RemotingCommandFlagConstants.PING);
        ping.setTransactionId(txId);
        ping.setCode(RemotingCommandCodeConstants.SUCCESS);
        return ping;
    }
    public static RemotingCommand generatePongCommand(String key) {
        String txId = DistributeIdMaker.DEFAULT.nextId(key);
        RemotingCommand pong = new RemotingCommand();
        pong.setFlag(RemotingCommandFlagConstants.PONG);
        pong.setTransactionId(txId);
        pong.setCode(RemotingCommandCodeConstants.SUCCESS);
        return pong;
    }

    @Override
    public String toString() {
        return "RemotingCommand{" +
                "flag=" + flag +
                ", code=" + code +
                ", language=" + language +
                ", version=" + version +
                ", remark='" + remark + '\'' +
                ", extFields=" + extFields +
                ", body=" + ((body == null || body.length == 0) ? "empty" : "not empty") +
                '}';
    }
}
