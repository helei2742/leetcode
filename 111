package cn.com.vortexa.common.entity;

import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.annotation.*;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_info")
public class BotInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 1000026515674412242L;

    public static final String CONFIG_PARAMS_KEY = "config_params_key";

    public static final String ACCOUNT_PARAMS_KEY = "account_params_key";

    public static final String BASIC_JOB_LIST_KEY = "basic_job_list";

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("description")
    private String description;

    @TableField("image")
    private String image;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField("job_params")
    private Map<String, AutoBotJobParam> jobParams = new HashMap<>();

    @TableField("params")
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    /**
     * 序列化为Json保存的，读取时会存在将AutoBotJobParam变成泛型JsonObject
     */
    public void fixMapValueType() {
        if (jobParams == null || jobParams.isEmpty()) return;
        for (Map.Entry<String, ?> entry : jobParams.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (value instanceof AutoBotJobParam param) {
                this.jobParams.put(key, param);
            } else if (value instanceof JSONObject jb) {
                this.jobParams.put(key, JSONObject.parseObject(jb.toJSONString(), AutoBotJobParam.class));
            } else {
                throw new IllegalArgumentException("error map entity value type");
            }
        }

    }
}
package cn.com.vortexa.common.util;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class ConditionBuildUtil {

    private final static Map<Class<?>, Map<String, Field>> classFieldMap = new ConcurrentHashMap<>();


    public static <T> T getMapContainsCondition(
            Map<String, Object> filterMap,
            String mapParamsFieldName,
            Class<T> tClass
    ) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Constructor<T> constructor = tClass.getConstructor();
        T condition = constructor.newInstance();

        if (filterMap == null || filterMap.isEmpty()) {
            return condition;
        }

        Map<String, Field> fields = getClassFieldMap(tClass);
        if (!fields.containsKey(mapParamsFieldName)) {
            throw new IllegalAccessException("目标类字段没有[" + mapParamsFieldName + "]");
        }

        for (Map.Entry<String, Object> entry : filterMap.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (fields.containsKey(key)) {
                // 是原生字段
                Field field = fields.get(key);
                field.setAccessible(true);
                try {
                    field.set(condition, value);
                } catch (IllegalAccessException e) {
                    throw new IllegalAccessException("参数类型[%s]值[%s]设置错误".formatted(key, value));
                }
            } else {
                // 是params里的字段
                Field field = fields.get(mapParamsFieldName);
                field.setAccessible(true);
                Object obj = field.get(condition);
                if (obj == null) {
                    field.set(condition, new HashMap<String, Object>());
                    obj = field.get(condition);
                }
                Map<String, Object> map = (Map<String, Object>) obj;
                map.put(key, value);
            }
        }

        return condition;
    }

    private static Map<String, Field> getClassFieldMap(Class<?> tClass) {
        return classFieldMap.compute(tClass, (k, v) -> {
            if (v == null) {
                v = Arrays.stream(tClass.getDeclaredFields())
                        .collect(Collectors.toMap(Field::getName, field -> field));
            }
            return v;
        });
    }
}
package cn.com.vortexa.db_layer.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;

import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface IBaseMapper<T> extends BaseMapper<T> {
    Integer insertOrUpdate(T t);

    Integer insertOrUpdateBatch(@Param("list") List<T> t);

    List<T> multipleConditionQuery(T query);
}
package cn.com.vortexa.db_layer.service;

import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.util.ConditionBuildUtil;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.db_layer.mapper.IBaseMapper;
import cn.com.vortexa.db_layer.util.ConditionQueryUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.PageInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public abstract class AbstractBaseService<M extends IBaseMapper<T>, T> extends ServiceImpl<M, T> implements IBaseService<T> {

    private final Consumer<T> fillFunction;

    protected AbstractBaseService(Consumer<T> fillFunction) {
        this.fillFunction = fillFunction;
    }

    @Override
    public T queryById(Serializable id) {
        return getById(id);
    }

    /**
     * 插入或更新
     *
     * @param t t
     * @return Integer
     */
    @Override
    public Integer insertOrUpdate(T t) throws SQLException {
        fillFunction.accept(t);
        return getBaseMapper().insertOrUpdate(t);
    }


    /**
     * 批量插入或更新
     *
     * @param tList tList
     * @return Integer
     */
    @Override
    public Integer insertOrUpdateBatch(List<T> tList) throws SQLException {
        int successCount = 0;
        for (T t : tList) {
            try {
                Integer count = insertOrUpdate(t);
                successCount += count == null ? 0 : count;
            } catch (Exception e) {
                throw new SQLException("insert or update error", e);
            }
        }

        return successCount;
    }

    /**
     * 条件分页查询
     *
     * @param page page
     * @param limit limit
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            Map<String, Object> filterMap
    ) throws SQLException {
        return conditionPageQuery(page, limit, "params", filterMap);
    }


    @Override
    public List<T> batchQueryByIds(List<Serializable> ids) {
        if (ids == null || ids.isEmpty()) return new ArrayList<>();
        return getBaseMapper().selectBatchIds(ids);
    }

    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param paramsKey paramsKey
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            String paramsKey,
            Map<String, Object> filterMap
    ) throws SQLException {
        try {
            PageInfo<T> pageInfo = ConditionQueryUtil.conditionQuery(
                    page,
                    limit,
                    filterMap,
                    paramsKey,
                    condition -> getBaseMapper().multipleConditionQuery(condition),
                    entityClass
            );
            List<T> list = pageInfo.getList();
            PageResult<T> pageResult = new PageResult<>();
            pageResult.setPages(pageInfo.getPages());
            pageResult.setPageNum(pageInfo.getPageNum());
            pageResult.setPageSize(pageInfo.getPageSize());
            pageResult.setTotal(pageInfo.getTotal());
            pageResult.setList(list);
            return pageResult;
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException |
                 IllegalAccessException e
        ) {
            throw new SQLException("condition query error", e);
        }
    }

    @Override
    public List<T> conditionQuery(Map<String, Object> filterMap) throws SQLException {
        return conditionQuery("params", filterMap);
    }

    @Override
    public List<T> conditionQuery(String paramsKey, Map<String, Object> filterMap) throws SQLException {
        T condition = null;
        try {
            condition = ConditionBuildUtil.getMapContainsCondition(
                    filterMap,
                    paramsKey,
                    entityClass
            );
        } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                 IllegalAccessException e) {
            throw new SQLException(e);
        }

        return getBaseMapper().multipleConditionQuery(condition);
    }

    /**
     * 删除
     *
     * @param ids ids
     * @return Result
     */
    @Transactional
    public Boolean delete(List<Integer> ids) {
        return removeBatchByIds(ids);
    }


    protected <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }

    protected Integer toInteger(Object obj) {
        return obj == null ? null : Integer.valueOf(obj.toString());
    }
}
package cn.com.vortexa.db_layer;

import cn.com.vortexa.common.util.typehandler.JsonTypeHandler;
import cn.com.vortexa.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.vortexa.common.util.typehandler.MapTextTypeHandler;
import cn.com.vortexa.db_layer.config.MybatisConfig;
import com.baomidou.mybatisplus.core.MybatisConfiguration;
import com.baomidou.mybatisplus.core.config.GlobalConfig;
import com.baomidou.mybatisplus.extension.spring.MybatisSqlSessionFactoryBean;
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import org.apache.ibatis.logging.stdout.StdOutImpl;
import org.apache.ibatis.session.SqlSessionFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.sql.DataSource;

@Configuration
@Import(MybatisConfig.class)
public class DBLayerAutoConfig {
    @Value("${spring.datasource.driver-class-name}")
    private String driverClassName;

    @Value("${spring.datasource.url}")
    private String url;

    @Value("${spring.datasource.username}")
    private String username;

    @Value("${spring.datasource.password}")
    private String password;

    @Bean
    @Qualifier("vortexaDataSource")
    @ConditionalOnMissingBean(name = "vortexaDataSource")
    public DataSource vortexaDataSource() {
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(url);
        hikariConfig.setUsername(username);
        hikariConfig.setPassword(password);
        hikariConfig.setDriverClassName(driverClassName);
        hikariConfig.setMaximumPoolSize(10);
        hikariConfig.setMinimumIdle(5);

        return new HikariDataSource(hikariConfig);
    }


    @Bean
    @ConditionalOnMissingBean(SqlSessionFactory.class)
    public SqlSessionFactory sqlSessionFactory(@Qualifier("vortexaDataSource") DataSource dataSource) throws Exception {
        MybatisSqlSessionFactoryBean factoryBean = new MybatisSqlSessionFactoryBean();
        factoryBean.setDataSource(dataSource);
        factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:/mapper/*.xml"));
        factoryBean.setTypeHandlers(
                jsonTypeHandler(), mapTextTypeHandler()
        );
        factoryBean.setTypeAliasesPackage("cn.com.vortexa.entity");
        MybatisConfiguration configuration = new MybatisConfiguration();
        factoryBean.setConfiguration(configuration);
        configuration.setMapUnderscoreToCamelCase(true);
        configuration.setLogImpl(StdOutImpl.class);
        GlobalConfig globalConfig = new GlobalConfig();
        GlobalConfig.DbConfig dbConfig = new GlobalConfig.DbConfig();
        dbConfig.setLogicDeleteField("isValid");
        dbConfig.setLogicDeleteValue("0");
        dbConfig.setLogicNotDeleteValue("1");
        globalConfig.setDbConfig(dbConfig);
        globalConfig.setBanner(false);
        factoryBean.setGlobalConfig(globalConfig);
        return factoryBean.getObject();
    }

    @Bean
    @ConditionalOnMissingBean
    public JsonTypeHandler jsonTypeHandler() {
        return new JsonTypeHandler();
    }

    @Bean
    @ConditionalOnMissingBean
    public MapTextTypeHandler mapTextTypeHandler() {
        return new MapTextTypeHandler();
    }

    @Bean
    @ConditionalOnMissingBean
    public LocalDateTimeTypeHandler localDateTimeTypeHandler() {
        return new LocalDateTimeTypeHandler();
    }
}
package cn.com.vortexa.bot_platform.script_control;

import cn.com.vortexa.bot_platform.script_control.service.BotLogUploadService;
import cn.com.vortexa.bot_platform.wsController.FrontWebSocketServer;
import cn.com.vortexa.bot_platform.wsController.UIWSMessage;
import cn.com.vortexa.common.constants.BotExtFieldConstants;
import cn.com.vortexa.common.constants.BotInstanceStatus;
import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.config.ControlServerConfig;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.dto.*;
import cn.com.vortexa.control.exception.ControlServerException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.service.IConnectionService;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.util.ControlServerUtil;
import cn.com.vortexa.control.util.RPCMethodUtil;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author helei
 * @since 2025/3/26 15:42
 */
@Slf4j
public class BotPlatformControlServer extends BotControlServer {
    private final ConcurrentMap<String, Set<String>> scriptNodeKey2BotInstanceKeyMap = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, String> botInstanceKey2ScriptNodeKeyMap = new ConcurrentHashMap<>();

    private final List<RPCServiceInfo<?>> rpcServiceInfos;
    private final BotLogUploadService botLogUploadService;
    @Getter
    private final FrontWebSocketServer frontWebSocketServer;

    @Override
    public ChannelFuture start() throws ControlServerException {
        ChannelFuture start = super.start();
        FrontWebSocketServer.running = true;
        return start;
    }

    public BotPlatformControlServer(
        ControlServerConfig controlServerConfig,
        FrontWebSocketServer frontWebSocketServer,
        List<RPCServiceInfo<?>> rpcServiceInfos
    ) throws ControlServerException {
        super(controlServerConfig);
        this.rpcServiceInfos = rpcServiceInfos;
        this.frontWebSocketServer = frontWebSocketServer;
        this.botLogUploadService = new BotLogUploadService(this);
    }

    @Override
    public void init(IRegistryService registryService, IConnectionService connectionService) throws Exception {
        super.init(registryService, connectionService);

        // 1 RPC 服务
        for (RPCServiceInfo<?> rpcServiceInfo : rpcServiceInfos) {
            Class<?> interfaces = rpcServiceInfo.getInterfaces();

            Object ref = rpcServiceInfo.getRef();

            for (Method method : interfaces.getDeclaredMethods()) {
                method.setAccessible(true);
                String key = RPCMethodUtil.buildRpcMethodKey(interfaces.getName(), method);

                log.info("add custom command handler [{}]", key);

                super.addCustomCommandHandler(key, request -> {
                    RequestHandleResult result = new RequestHandleResult();

                    log.debug("invoke rpc method[{}]", method.getName());
                    try {
                        byte[] body = request.getBody();
                        RPCArgsWrapper params = Serializer.Algorithm.JDK.deserialize(body, RPCArgsWrapper.class);

                        Object invoke = method.invoke(ref, params.getArgs());
                        log.info("invoke rpc[{}] method[{}] return [{}]",
                            request.getTransactionId(), key, invoke == null ? "null" : "not null");
                        result.setData(invoke);
                        result.setSuccess(true);
                        return result;
                    } catch (Exception e) {
                        log.error("invoke rpc method [{}] error", method.getName());
                        throw new CustomCommandInvokeException(e);
                    }
                });
            }
        }

        // 1 expose bot 注册、下线
        initScriptNodeExposeBotHandler();

        // 2 日志上传
        initScriptNodeUploadLogHandler();
    }

    /**
     * 初始化script暴露bot命令
     */
    private void initScriptNodeExposeBotHandler() {
        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.SCRIPT_BOT_ON_LINE,
            this::scriptBotOnLineHandler
        );

        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.SCRIPT_BOT_OFF_LINE,
            this::scriptBotOffLineHandler
        );
    }

    /**
     * 初始化节点日志上传命令处理器
     */
    protected void initScriptNodeUploadLogHandler() {
        frontWebSocketServer.setCloseHandler((server, token) -> {
            botLogUploadService.stopFrontLogListener(token);
        });

        // 前端websocket server 监听命令
        frontWebSocketServer.addMessageHandler(
            BotRemotingCommandFlagConstants.START_UP_BOT_LOG,
            (token, session, request) -> {
                String group = request.getParams().getString(BotExtFieldConstants.TARGET_GROUP_KEY);
                String botName = request.getParams().getString(BotExtFieldConstants.TARGET_BOT_NAME_KEY);
                String botKey = request.getParams().getString(BotExtFieldConstants.TARGET_BOT_KEY_KEY);

                UIWSMessage response = botLogUploadService.browserRequestBotLogRCHandler(group, botName, botKey, token);
                request.setCode(BotRemotingCommandFlagConstants.START_UP_BOT_LOG_RESPONSE);
                return response;
            });

        // 后端websocket server 响应
        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG,
            botLogUploadService::botUploadLogRCHandler
        );
    }

    /**
     * 开启job
     *
     * @param group group
     * @param jobName jobName
     * @param botName botName
     * @param botKey botKey
     * @return CompletableFuture<Result>
     */
    public CompletableFuture<Result> startJob(String group, String botName, String botKey, String jobName)
        throws BotStartException {
        // Step 1 判断目标Bot是否在线
        String key = ControlServerUtil.generateServiceInstanceKey(group, botName, botKey);
        BotInstanceStatus status = getBotInstanceStatus(key);

        if (status != BotInstanceStatus.RUNNING) {
            throw new BotStartException("bot[%s][%s][%s] status is[%s] not RUNNING".formatted(
                group, botName, botKey, status
            ));
        }

        // Step 2 发送启动命令
        RemotingCommand command = newRemotingCommand(BotRemotingCommandFlagConstants.START_BOT_JOB, true);
        command.addExtField(BotExtFieldConstants.JOB_NAME, jobName);
        return sendCommandToServiceInstance(
            key,
            command
        ).thenApplyAsync(response -> {
            BotACJobResult result = response.getObjBodY(BotACJobResult.class);
            if (response.isSuccess()) {
                log.info("[{}] start job[{}] success", key, jobName);
                return Result.ok(result.getData());
            } else {
                log.error("[{}] start job[{}] fail, {}", key, jobName, response.getPayLoad());
                return Result.fail(result.getErrorMsg());
            }
        }).exceptionally(throwable -> {
            log.error("[{}] start job[{}] error", key, jobName, throwable);
            return Result.fail(throwable.getMessage());
        });
    }

    /**
     * 获取bot实例状态
     *
     * @param group group
     * @param botName botName
     * @param botKey botKey
     * @return BotInstanceStatus
     */
    public BotInstanceStatus getBotInstanceStatus(String group, String botName, String botKey) {
        String instanceKey = ControlServerUtil.generateServiceInstanceKey(group, botName, botKey);
        return getBotInstanceStatus(instanceKey);
    }

    /**
     * 获取bot实例所在的Script Node状态
     *
     * @param botInstanceKey botInstanceKey
     * @return BotInstanceStatus
     */
    public BotInstanceStatus getBotInstanceStatus(String botInstanceKey) {
        String scriptNodeKey = botInstanceKey2ScriptNodeKeyMap.get(botInstanceKey);
        if (scriptNodeKey == null) return BotInstanceStatus.STOPPED;
        ConnectEntry connectEntry = getConnectionService().getServiceInstanceChannel(scriptNodeKey);
        return connectEntry == null ? BotInstanceStatus.STOPPED :
            (connectEntry.isUsable() ? BotInstanceStatus.RUNNING : BotInstanceStatus.UN_USABLE);
    }

    /**
     * 脚本上线命令处理
     *
     * @param channel channel
     * @param remotingCommand remotingCommand
     * @return RemotingCommand
     */
    public RemotingCommand scriptBotOnLineHandler(Channel channel, RemotingCommand remotingCommand) {
        String group = remotingCommand.getGroup();
        String serviceId = remotingCommand.getServiceId();
        String instanceId = remotingCommand.getInstanceId();

        String scriptNodeKey = ControlServerUtil.generateServiceInstanceKey(group, serviceId, instanceId);

        String botGroup = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_GROUP_KEY);
        String botName = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_NAME_KEY);
        String botKey = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_KEY_KEY);

        String botInstanceKey = ControlServerUtil.generateServiceInstanceKey(botGroup, botName, botKey);

        scriptNodeKey2BotInstanceKeyMap.compute(scriptNodeKey, (k, v) -> {
            if (v == null) {
                v = new HashSet<>();
            }
            v.add(botInstanceKey);
            return v;
        });
        botInstanceKey2ScriptNodeKeyMap.put(botInstanceKey, scriptNodeKey);

        log.info("script node[{}] add bot instance[{}]", scriptNodeKey, botInstanceKey);

        RemotingCommand response = new RemotingCommand();
        response.setFlag(BotRemotingCommandFlagConstants.SCRIPT_BOT_ON_LINE_RESPONSE);
        response.setCode(RemotingCommandCodeConstants.SUCCESS);
        response.setTransactionId(remotingCommand.getTransactionId());

        return response;
    }

    /**
     * 脚本下线命令处理
     *
     * @param channel channel
     * @param remotingCommand remotingCommand
     * @return RemotingCommand
     */
    private RemotingCommand scriptBotOffLineHandler(Channel channel, RemotingCommand remotingCommand) {
        String group = remotingCommand.getGroup();
        String serviceId = remotingCommand.getServiceId();
        String instanceId = remotingCommand.getInstanceId();

        String scriptNodeKey = ControlServerUtil.generateServiceInstanceKey(group, serviceId, instanceId);

        String botGroup = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_GROUP_KEY);
        String botName = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_NAME_KEY);
        String botKey = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_KEY_KEY);

        String botInstanceKey = ControlServerUtil.generateServiceInstanceKey(botGroup, botName, botKey);

        Set<String> onLineBotInstanceKeys = scriptNodeKey2BotInstanceKeyMap.get(scriptNodeKey);
        if (onLineBotInstanceKeys == null || !onLineBotInstanceKeys.contains(botInstanceKey)) {
            log.info("script node[{}] remove bot instance[{}] fail, bot instance not exist", scriptNodeKey, botInstanceKey);
        } else {
            onLineBotInstanceKeys.remove(botInstanceKey);
            log.info("script node[{}] remove bot instance[{}]", scriptNodeKey, botInstanceKey);
        }

        RemotingCommand response = new RemotingCommand();
        response.setFlag(BotRemotingCommandFlagConstants.SCRIPT_BOT_OFF_LINE_RESPONSE);
        response.setCode(RemotingCommandCodeConstants.SUCCESS);
        response.setTransactionId(remotingCommand.getTransactionId());

        return response;
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import cn.com.vortexa.bot_platform.dto.BotJob;
import cn.com.vortexa.bot_platform.script_control.BotPlatformControlServer;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.bot_platform.mapper.BotInfoMapper;
import cn.com.vortexa.control.constant.WSControlSystemConstants;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.bot_platform.mapper.BotInstanceMapper;
import cn.com.vortexa.bot_platform.service.IBotInstanceService;

import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import lombok.extern.slf4j.Slf4j;

import org.quartz.JobExecutionContext;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.Serializable;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@Slf4j
@Service
public class BotInstanceServiceImpl extends AbstractBaseService<BotInstanceMapper, BotInstance>
    implements IBotInstanceRPC, IBotInstanceService {

    @Autowired
    private BotInfoMapper botInfoMapper;

    @Lazy
    @Autowired
    private BotPlatformControlServer botControlServer;

    @Autowired
    private Scheduler scheduler;

    public BotInstanceServiceImpl() {
        super(botInstance -> {
            botInstance.setInsertDatetime(LocalDateTime.now());
            botInstance.setUpdateDatetime(LocalDateTime.now());
            botInstance.setIsValid(1);
        });
    }

    @Override
    public PageResult<BotInstanceVO> conditionPageQueryAllInfo(Integer page, Integer limit,
        Map<String, Object> filterMap) throws SQLException, SchedulerException {

        PageResult<BotInstance> result = super.conditionPageQuery(page, limit, filterMap);

        // 填充botInfo
        List<Integer> botIds = result.getList().stream().map(BotInstance::getBotId).toList();
        Map<Integer, BotInfo> idMapBotInfo = botIds.isEmpty() ? new HashMap<>() : botInfoMapper.selectBatchIds(botIds)
            .stream().collect(Collectors.toMap(BotInfo::getId, botInfo -> botInfo));

        // 查询运行中的任务
        Map<String, List<Trigger>> groupByBotKey = scheduler.getCurrentlyExecutingJobs()
            .stream()
            .map(JobExecutionContext::getTrigger)
            .collect(Collectors.groupingBy(trigger -> trigger.getJobKey().getGroup()));

        ArrayList<BotInstanceVO> voList = new ArrayList<>();
        for (BotInstance instance : result.getList()) {
            BotInstanceVO vo = new BotInstanceVO();

            vo.setBotInstance(instance);
            vo.setBotInfo(idMapBotInfo.get(instance.getBotId()));
            vo.setRunningJob(JSONObject.toJSONString(groupByBotKey.get(instance.getBotKey())));

            voList.add(vo);

            instance.addParam(BotInstance.BOT_INSTANCE_STATUS_KEY, botControlServer.getBotInstanceStatus(
                WSControlSystemConstants.DEFAULT_GROUP, instance.getBotName(), instance.getBotKey()
            ));
        }

        return new PageResult<>(
            result.getTotal(),
            voList,
            result.getPages(),
            result.getPageNum(),
            result.getPageSize()
        );
    }

    @Override
    public Boolean existsBotInstance(BotInstance query) {
        return getBaseMapper().exists(new QueryWrapper<>(query));
    }

    @Override
    public List<RegisteredService> queryOnLineInstance() {
        List<RegisteredService> res = new ArrayList<>();
        List<String> keys = botControlServer.getConnectionService().queryOnlineInstanceKey();
        keys.forEach(key -> res.addAll(botControlServer.getRegistryService().queryServiceInstance(key)));
        return res;
    }

    @Override
    public Result startJob(BotJob botJob) throws BotStartException {
        try {
            return botControlServer.startJob(
                botJob.getGroup(),
                botJob.getBotName(),
                botJob.getBotKey(),
                botJob.getJobName()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("[{}] start job error", botJob, e);
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @Override
    public List<BotInstance> batchQueryByIdsRPC(List<Serializable> ids) {
        return super.batchQueryByIds(ids);
    }

    @Override
    public Boolean existsBotInstanceRPC(BotInstance query) {
        return existsBotInstance(query);
    }

    @Override
    public Integer insertOrUpdateRPC(BotInstance instance) throws SQLException {
        return insertOrUpdate(instance);
    }

    @Override
    public BotInstance selectOneRPC(BotInstance query) {
        return getOne(new QueryWrapper<>(query));
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.AccountBaseInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.AccountBaseInfo">
        <id column="id" property="id"/>
        <result column="type" property="type"/>
        <result column="name" property="name"/>
        <result column="email" property="email"/>
        <result column="password" property="password"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.AccountBaseInfo">
        INSERT INTO t_account_base_info
        (id, type, name, email, password, params, insert_datetime, update_datetime, is_valid)
        VALUES (NULL, #{type}, #{name}, #{email}, #{password}, #{params}, #{insertDatetime}, #{updateDatetime},
        #{isValid}) ON DUPLICATE KEY
        UPDATE
            type = values(type),
            name = values(name),
            password = values(password),
            update_datetime = values(update_datetime)
            params = values(params),
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_account_base_info
        (id, type, name, email, password, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (NULL, #{item.type}, #{item.name}, #{item.email}, #{item.password}, #{item.params}, #{item.insertDatetime},
            #{item.updateDatetime},#{item.isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        type = values(type),
        name = values(name),
        password = values(password),
        update_datetime = values(update_datetime)
        params = values(params),
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.AccountBaseInfo"
            resultType="cn.com.vortexa.common.entity.AccountBaseInfo">
        select
        t.id, t.type, t.name, t.email, t.password, t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_account_base_info as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="type != null">
                and t.type = #{type}
            </if>
            <if test="name != null">
                and t.name = #{name}
            </if>
            <if test="email != null">
                and t.email = #{email}
            </if>
            <if test="password != null">
                and t.password = #{password}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.BotInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.BotInfo">
        <id column="id" property="id" />
        <result column="name" property="name" />
        <result column="description" property="description" />
        <result column="image" property="image" />
        <result column="limit_project_ids" property="limitProjectIds" />
        <result column="job_params" property="jobParams" />
        <result column="params" property="params" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="is_valid" property="isValid" />
    </resultMap>


    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.BotInfo">
        INSERT INTO t_bot_info
        (name, description, limit_project_ids, image, job_params, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{name}, #{description}, #{limitProjectIds}, #{image}, #{jobParams}, #{params}, #{insertDatetime},
                #{updateDatetime},
                #{isValid}) ON DUPLICATE KEY
        UPDATE
            description =
        values (description), limit_project_ids =
        values (limit_project_ids), image =
        values (image), job_params =
        values (job_params), params =
        values (params), update_datetime =
        values (update_datetime)
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_bot_info
        (name, description, limit_project_ids, image, job_params, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{item.name}, #{item.description}, #{item.limitProjectIds}, #{item.image}, #{item.jobParams},
            #{item.params}, #{item.insertDatetime}, #{item.updateDatetime},#{item.isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        description = values(description),
        limit_project_ids = values(limit_project_ids),
        image = values(image),
        job_params = values(job_params),
        params = values(params),
        update_datetime = values(update_datetime)
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.BotInfo"
            resultType="cn.com.vortexa.common.entity.BotInfo">
        select
        t.id as id,
        t.name,
        t.description,
        t.image,
        t.job_params as jobParams,
        t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_bot_info as t
        <where>
            is_valid = 1
            <if test="name != null">
                and t.name = #{name}
            </if>
            <if test="description != null">
                and t.description = #{description}
            </if>
            <if test="image != null">
                and t.image = #{image}
            </if>
            <if test="jobParams != null and !params.isEmpty()">
                and t.job_params = #{jobParams}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.BotInstanceMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.BotInstance">
        <id column="id" property="id"/>
        <result column="bot_id" property="botId"/>
        <result column="bot_key" property="botKey"/>
        <result column="account_table_name" property="accountTableName"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.BotInstance">
        INSERT INTO t_bot_instance
        (bot_id, bot_name, bot_key, account_table_name, job_params, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{botId}, #{botName}, #{botKey}, #{accountTableName}, #{jobParams}, #{params}, #{insertDatetime},
                #{updateDatetime},
                #{isValid})
        ON DUPLICATE KEY UPDATE
        bot_id = values(bot_id),
        account_table_name = values(account_table_name),
        job_params = values(job_params),
        params = values(params),
        update_datetime = values(updateDatetime),
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_bot_instance
        (bot_id, bot_name, bot_key, account_table_name, job_params, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{item.botId}, #{item.botName}, #{item.botKey}, #{item.accountTableName}, #{item.jobParams},
            #{item.params}, #{item.insertDatetime},#{item.updateDatetime}, #{item.isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        bot_id = values(bot_id),
        account_table_name = values(account_table_name),
        job_params = values(job_params),
        params = values(params),
        update_datetime = values(updateDatetime),
    </insert>


    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.BotInstance"
            resultType="cn.com.vortexa.common.entity.BotInstance">
        select
        t.id as id,
        t.bot_id as botId,
        t.bot_key as botKey,
        t.bot_name as botName,
        t.account_table_name as accountTableName,
        t.job_params as jobParams,
        t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_bot_instance t
        <where>
            is_valid = 1
            <if test="botId != null">
                and t.bot_id = #{botId}
            </if>
            <if test="botKey != null">
                and t.bot_key = #{botKey}
            </if>
            <if test="botName != null">
                and t.bot_name = #{botName}
            </if>
            <if test="accountTableName != null">
                and t.account_table_name = #{accountTableName}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.BrowserEnvMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.BrowserEnv">
        <id column="id" property="id"/>
        <result column="user_agent" property="userAgent"/>

        <result column="other_header" property="otherHeader"/>

        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.BrowserEnv">
        INSERT INTO t_browser_env (user_agent, other_header, insert_datetime, update_datetime, is_valid)
        VALUES (#{userAgent}, #{otherHeader}, #{insertDatetime}, #{updateDatetime},
                #{isValid})
        ON DUPLICATE KEY
        UPDATE
        other_header = values(other_header),
        update_datetime = values(update_datetime),
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_browser_env (user_agent, other_header, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
        (#{userAgent}, #{otherHeader}, #{insertDatetime}, #{updateDatetime},#{isValid})
        </foreach>
            ON DUPLICATE KEY
        UPDATE
            other_header = values(other_header),
            update_datetime = values(update_datetime),
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.BrowserEnv"
            resultType="cn.com.vortexa.common.entity.BrowserEnv">
        select
            t.id as id,
        t.user_agent as userAgent, t.other_header as otherHeader,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_browser_env as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="userAgent != null">
                and t.user_agent = #{userAgent}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.other_header,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>

</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.DiscordAccountMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.DiscordAccount">
        <id column="id" property="id"/>
        <result column="password" property="password"/>
        <result column="username" property="username"/>
        <result column="bind_email" property="bindEmail"/>
        <result column="bind_email_password" property="bindEmailPassword"/>
        <result column="token" property="token"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.DiscordAccount">
        INSERT INTO t_discord_account
        (password, username, bind_email, bind_email_password, token, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{password}, #{username}, #{bindEmail}, #{bindEmailPassword}, #{token}, #{params}, #{insertDatetime},
                #{updateDatetime}, #{isValid}) ON DUPLICATE KEY
        UPDATE
        password = values(password),
        bind_email = values(bind_email),
        bind_email_password = values(bind_email_password),
        token = value(token),
        params = values(params),
        update_datetime = values(update_datetime),
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_discord_account
        (password, username, bind_email, bind_email_password, token, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{password}, #{username}, #{bindEmail}, #{bindEmailPassword}, #{token}, #{params}, #{insertDatetime},
            #{updateDatetime}, #{isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        password = values(password),
        bind_email = values(bind_email),
        bind_email_password = values(bind_email_password),
        token = value(token),
        params = values(params),
        update_datetime = values(update_datetime),
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.DiscordAccount"
            resultType="cn.com.vortexa.common.entity.DiscordAccount">
        select
        t.id as id,
        t.password, t.username, t.bind_email as bindEmail,
        t.bind_email_password as bindEmailPassword, t.token, t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_discord_account as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="password != null">
                and t.password = #{password}
            </if>
            <if test="username != null">
                and t.username = #{username}
            </if>
            <if test="bindEmail != null">
                and t.bind_email = #{bindEmail}
            </if>
            <if test="bindEmailPassword != null">
                and t.bind_email_password = #{bindEmailPassword}
            </if>
            <if test="token != null">
                and t.token = #{token}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.ProxyInfoMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.ProxyInfo">
        <id column="id" property="id"/>
        <result column="proxy_type" property="proxyType"/>
        <result column="proxy_protocol" property="proxyProtocol"/>
        <result column="host" property="host"/>
        <result column="port" property="port"/>
        <result column="username" property="username"/>
        <result column="password" property="password"/>
        <result column="usable" property="usable"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>


    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.ProxyInfo">
        INSERT INTO t_proxy_info
        (proxy_type, proxy_protocol, host, port, username, password, usable, params, insert_datetime, update_datetime,
         is_valid)
        VALUES (#{proxyType}, #{proxyProtocol}, #{host}, #{port}, #{username}, #{password}, #{usable}, #{params},
                #{insertDatetime}, #{updateDatetime}, #{isValid}) ON DUPLICATE KEY
        UPDATE
        <trim suffixOverrides=",">
            <if test="proxyType != null">
                proxy_type = values(proxy_type),
            </if>
            <if test="proxyProtocol != null">
                proxy_protocol = values(proxy_protocol),
            </if>
            <if test="username != null">
                username = values(username),
            </if>
            <if test="password != null">
                password = values(password),
            </if>
            <if test="usable != null">
                usable = values(usable),
            </if>
            <if test="params != null">
                params = values(params),
            </if>
            <if test="updateDatetime != null">
                update_datetime = values(update_datetime),
            </if>
        </trim>
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_proxy_info
        (proxy_type, proxy_protocol, host, port, username, password, usable, params, insert_datetime, update_datetime,
        is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{proxyType}, #{proxyProtocol}, #{host}, #{port}, #{username}, #{password}, #{usable}, #{params},
            #{insertDatetime}, #{updateDatetime}, #{isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        proxy_type = values(proxy_type),
        proxy_protocol = values(proxy_protocol),
        username = values(username),
        password = values(password),
        usable = values(usable),
        params = values(params),
        update_datetime = values(update_datetime),
    </insert>


    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.ProxyInfo"
            resultType="cn.com.vortexa.common.entity.ProxyInfo">
        select
        t.id as id,
        t.proxy_type as proxyType,
        t.proxy_protocol as proxyProtocol,
        t.host, t.port, t.username,
        t.password, t.usable, t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_proxy_info as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="proxyType != null">
                and t.proxy_type = #{proxyType}
            </if>
            <if test="proxyProtocol != null">
                and t.proxy_protocol = #{proxyProtocol}
            </if>
            <if test="host != null">
                and t.host = #{host}
            </if>
            <if test="port != null">
                and t.port = #{port}
            </if>
            <if test="username != null">
                and t.username = #{username}
            </if>
            <if test="password != null">
                and t.password = #{password}
            </if>
            <if test="usable != null">
                and t.usable = #{usable}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.TelegramAccountMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.TelegramAccount">
        <id column="id" property="id"/>
        <result column="username" property="username"/>
        <result column="password" property="password"/>
        <result column="phone_prefix" property="phonePrefix"/>
        <result column="phone" property="phone"/>
        <result column="token" property="token"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.TelegramAccount">
        INSERT INTO t_telegram_account
        (username, password, phone_prefix, phone, token, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{username}, #{password}, #{phonePrefix}, #{phone}, #{token}, #{params}, #{insertDatetime},
                #{updateDatetime}, #{isValid})
        ON DUPLICATE KEY
        UPDATE
        <trim suffixOverrides=",">
            <if test="username != null">
                username = values(username),
            </if>
            <if test="password != null">
                password = values(password),
            </if>
            <if test="token != null">
                token = values(token),
            </if>
            <if test="params != null">
                params = values(params),
            </if>
            <if test="updateDatetime != null">
                update_datetime = values(update_datetime),
            </if>
        </trim>
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_telegram_account
        (username, password, phone_prefix, phone, token, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{username}, #{password}, #{phonePrefix}, #{phone}, #{token}, #{params}, #{insertDatetime},
            #{updateDatetime}, #{isValid})
        </foreach>
        ON DUPLICATE KEY UPDATE
        username = values(username),
        password = values(password),
        token = values(token),
        params = values(params),
        update_datetime = values(update_datetime)
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.TelegramAccount"
            resultType="cn.com.vortexa.common.entity.TelegramAccount">
        select
        t.id,
        t.username,
        t.password,
        t.phone_prefix as phonePrefix, t.phone, t.token,
        t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_telegram_account as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="username != null">
                and t.username = #{username}
            </if>
            <if test="password != null">
                and t.password = #{password}
            </if>

            <if test="phonePrefix != null">
                and t.phone_prefix = #{phonePrefix}
            </if>
            <if test="phone != null">
                and t.phone = #{phone}
            </if>
            <if test="token != null">
                and t.token = #{token}
            </if>

            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.TwitterAccountMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.TwitterAccount">
        <id column="id" property="id"/>
        <result column="username" property="username"/>
        <result column="password" property="password"/>
        <result column="email" property="email"/>
        <result column="email_password" property="emailPassword"/>
        <result column="token" property="token"/>
        <result column="f2a_key" property="f2aKey"/>
        <result column="params" property="params"/>
        <result column="insert_datetime" property="insertDatetime"/>
        <result column="update_datetime" property="updateDatetime"/>
        <result column="is_valid" property="isValid"/>
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.TwitterAccount">
        INSERT INTO t_twitter_account
        (username, password, email, email_password, token, f2a_key, params, insert_datetime, update_datetime, is_valid)
        VALUES (#{username}, #{password}, #{email}, #{emailPassword}, #{token}, #{f2aKey}, #{params},
                #{insertDatetime}, #{updateDatetime}, #{isValid})
        ON DUPLICATE KEY
        UPDATE
        <trim suffixOverrides=",">
            <if test="username != null">
                password = values(password),
            </if>
            <if test="password != null">
                email = values(email),
            </if>
            <if test="emailPassword != null">
                email_password = values(email_password),
            </if>
            <if test="token != null">
                token = values(token),
            </if>
            <if test="f2aKey != null">
                f2a_key = values(f2a_key),
            </if>
            <if test="params != null">
                params = values(params),
            </if>
            <if test="updateDatetime != null">
                update_datetime = values(update_datetime),
            </if>
        </trim>
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_twitter_account
        (username, password, email, email_password, token, f2a_key, params, insert_datetime, update_datetime, is_valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{username}, #{password}, #{email}, #{emailPassword}, #{token}, #{f2aKey}, #{params},
            #{insertDatetime}, #{updateDatetime}, #{isValid})
        </foreach>
        ON DUPLICATE KEYUPDATE
        password = values (password),
        email =values (email),
        email_password = values (email_password),
        token =values (token),
        f2a_key = values (f2a_key),
        params = values (params),
        update_datetime =values (update_datetime)
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.TwitterAccount"
            resultType="cn.com.vortexa.common.entity.TwitterAccount">
        select
        t.id,
        t.username,
        t.password,
        t.email,
        t.email_password as emailPassword,
        t.token,
        t.f2a_key as f2aKey,
        t.params,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.is_valid as isValid
        from
        t_twitter_account as t
        <where>
            is_valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="username != null">
                and t.username = #{username}
            </if>
            <if test="password != null">
                and t.password = #{password}
            </if>

            <if test="email != null">
                and t.email = #{email}
            </if>
            <if test="emailPassword != null">
                and t.email_password = #{emailPassword}
            </if>
            <if test="token != null">
                and t.token = #{token}
            </if>
            <if test="f2aKey != null">
                and t.f2a_key = #{f2aKey}
            </if>
            <if test="params != null and !params.isEmpty()">
                AND JSON_CONTAINS(
                t.params,
                <foreach collection="params" item='value' index='key' separator=',' open="JSON_OBJECT(" close=")">
                    #{key}, #{value}
                </foreach>
                )
            </if>
        </where>
    </select>
</mapper>

spring:
  datasource:
#    url: "jdbc:sqlite://D://workspace//Vortexa-dev_3.0//vortexa-platform//src//main//resources//plantform.db"
#    url: "jdbc:sqlite://Users/helei/develop/ideaworkspace/BotFramework/botData/db/test_plantfrom.db"
    url: jdbc:mysql://localhost:3306/vortexa_plantform
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: 123456
  quartz:
    job-store-type: jdbc
    jdbc:
      table-prefix: QRTZ_
      driver-class: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/job_store
      user: root
      password: 123456
      scheduler:
        instance-name: QuartzScheduler


logging:
  level:
    org:
      apache:
        dubbo: WARN
        zookeeper: WARN
server:
  port: 10110


vortexa:
  control-server:
    nio-thread-count: 1 # netty nio 线程数
    service-offline-ttl: 120  # 服务下线时间
    service-instance:
      host: localhost # 命名服务host
      port: 18848 # 命名服务port
      group: test1
      serviceId: nameserver
      instanceId: nameserver-1
spring:
  datasource:
    driver-class-name: org.sqlite.JDBC
    url:
    username:
    password:
  quartz:
    job-store-type: jdbc
    jdbc:
      table-prefix: QRTZ_
      driver-class: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/job_store
      user: root
      password: 123456
      scheduler:
        instance-name: QuartzScheduler

vortexa:
  script-node:
    bot-group: helei-macbook
    bot-instance-locations: D:\workspace\Vortexa-dev_3.0\vortexa-script-bot\src\main\java\cn\com\vortexa\script_bot
    auto-launch-bot-keys:
      - magic_newton_test
  #    bot-instance-locations: "reactive:"
  script-agent:
    registryCenterUrl: ws://localhost:18848
    nio-thread-count: 1
    service-offline-ttl: 60
    service-instance:
      host: localhost
      port: 20001
      group: default
      serviceId: script-node
      instanceId: script-node-macbook
package cn.com.vortexa.script_node.bot;

import static cn.com.vortexa.script_node.service.impl.BotAccountContextServiceImpl.BOT_ACCOUNT_CONTEXT_TABLE_PREFIX;
import static cn.com.vortexa.common.entity.BotInfo.BASIC_JOB_LIST_KEY;

import cn.com.vortexa.script_node.service.BotApi;
import cn.com.vortexa.script_node.constants.BotStatus;
import cn.com.vortexa.common.config.SystemConfig;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.script_node.util.log.AppendLogger;
import cn.com.vortexa.common.dto.AutoBotRuntimeInfo;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStatusException;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

import lombok.Getter;
import lombok.Setter;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;
import java.util.function.Supplier;

public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    public final AppendLogger logger = new AppendLogger(getClass());

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot api
     */
    @Getter
    private BotApi botApi;

    /**
     * bot运行时信息
     */
    @Getter
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * 请求并发数量
     */
    @Getter
    @Setter
    private int requestConcurrentCount = 5;

    /**
     * bot信息
     */
    @Getter
    private BotInfo botInfo;

    @Getter
    private BotInstance botInstance;

    /**
     * 配置
     */
    @Getter
    private AutoBotConfig autoBotConfig;

    /**
     * 执行异步任务的线程池
     */
    @Getter
    private ExecutorService executorService;

    /**
     * 状态
     */
    @Getter
    private BotStatus status = BotStatus.NEW;

    public AbstractAutoBot() {
        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();
    }

    /**
     * 初始化方法
     *
     * @param autoBotConfig autoBotConfig
     * @throws BotInitException BotInitException
     */
    public final void init(BotApi botApi, AutoBotConfig autoBotConfig) throws BotInitException {
        this.botApi = botApi;

        // Step 1 参数校验
        if (StrUtil.isBlank(autoBotConfig.getBotKey())) {
            throw new IllegalArgumentException("bot key is empty!");
        }

        // Step 2 进入INIT状态，获取参数
        updateState(BotStatus.INIT);
        this.autoBotConfig = autoBotConfig;
        try {
            // Step 2.1 获取BotInfo,解析Bot Job
            botInfo = buildBotInfo();
            resolveBotJobMethod();
        } catch (Exception e) {
            throw new BotInitException("resolve bot job error", e);
        }

        // Step 2.2 保存bot info
        try {
            if (botApi.getBotInfoRPC().insertOrUpdateRPC(botInfo) == 1) {
                Map<String, Object> query = new HashMap<>();
                query.put("name", botInfo.getName());
                // 保存成还需查询botId
                Integer id = botApi.getBotInfoRPC().conditionQueryRPC(query).getFirst().getId();
                botInfo.setId(id);
                logger.info("save bot info success, id:" + botInfo.getId());
            }
        } catch (SQLException e) {
            throw new BotInitException("save bot info error", e);
        }

        this.botInstance = BotInstance.builder()
            .botId(botInfo.getId())
            .botName(botInfo.getName())
            .botKey(autoBotConfig.getBotKey())
            .build();

        // Step 2.3 设置logger前缀与线程池
        String botName = runtimeBotName();
        logger.append(botName);
        this.executorService = Executors.newThreadPerTaskExecutor(
            new NamedThreadFactory(botInfo.getName() + "-executor"));

        try {
            // Step 2.4 初始化存储的Table
            logger.info("start init database table");
            // 检查对应分表是否存在
            if (!botApi.getBotAccountService()
                .checkAndCreateShardedTable(botInfo.getId(), getAutoBotConfig().getBotKey(), true)) {
                throw new RuntimeException("bot account table create error");
            }
            logger.info("database table init finish");

            // Step 2.5 初始化BotInstance实例
            logger.info("start init bot instance");

            BotInstance dbInstance = getBotApi().getBotInstanceRPC().selectOneRPC(botInstance);

            // 数据库存在bot instance实例信息并且job信息没变化，用数据库的。 否则用BotInfo信息生成BotInstance信息写入库
            if (dbInstance != null && dbInstance.getJobParams().keySet().equals(botInfo.getJobParams().keySet())) {
                this.botInstance = dbInstance;
                logger.info("exist botInstance, use exist instance config");
            } else {
                logger.info("no instance or instance job update, create it...");

                String tableName = getBotApi().getTableShardStrategy().generateTableName(
                    BOT_ACCOUNT_CONTEXT_TABLE_PREFIX,
                    new Object[] {botInstance.getBotId(), botInstance.getBotKey()}
                );
                botInstance.setBotName(botInfo.getName());
                botInstance.setAccountTableName(tableName);
                botInstance.setJobParams(botInfo.getJobParams());
                botInstance.setParams(botInfo.getParams());

                if (botApi.getBotInstanceRPC().insertOrUpdateRPC(botInstance) > 0) {
                    logger.info("new bot instance create success");
                } else {
                    throw new BotInitException("new bot instance create error");
                }
            }

            // Step 2.5 子类初始化
            doInit();

            // Step 2。6 更新状态
            updateState(BotStatus.INIT_FINISH);
        } catch (Exception e) {
            logger.error("init error", e);
            updateState(BotStatus.INIT_ERROR);
        }
    }

    /**
     * 初始化方法
     */
    protected abstract void doInit() throws BotInitException;

    /**
     * 停止Bot
     */
    public void stop() {
        updateState(BotStatus.STOPPING);
        try {
            networkSyncControllerMap.clear();
            doStop();
            updateState(BotStatus.STOPPED);
        } catch (Exception e) {
            logger.error("stop bot error, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
            updateState(BotStatus.SHUTDOWN);
        }
    }

    protected abstract void doStop();

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, 1);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        int retryTimes
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null, retryTimes);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart
    ) {
        return syncRequest(
            proxy,
            url,
            method,
            headers,
            params,
            body,
            requestStart,
            1
        );
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart,
        int retryTimes
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).request(
                    url,
                    method,
                    headers,
                    params,
                    body,
                    retryTimes
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<List<String>> syncStreamRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).streamRequest(
                    url,
                    method,
                    headers,
                    params,
                    body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    public <R> CompletableFuture<R> syncCCHandler(
        ProxyInfo proxy,
        Supplier<String> requestStart,
        Supplier<R> request
    ) {

        Semaphore networkController = networkSyncControllerMap
            .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                if (v == null) {
                    v = new Semaphore(requestConcurrentCount);
                }
                return v;
            });

        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "start network request";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                logger.debug("同步器允许发送请求 - " + str);

                return request.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, getBotInstance().getBotKey());
    }

    /**
     * 更新BotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(BotStatus newStatus) throws BotStatusException {

        boolean b = switch (status) {
            //当前为NEW，新状态才能为NEW,SHUTDOWN
            case NEW -> BotStatus.INIT.equals(newStatus);
            //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
            case INIT -> newStatus.equals(BotStatus.INIT_FINISH)
                || newStatus.equals(BotStatus.INIT_ERROR);
            //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
            case INIT_ERROR -> newStatus.equals(BotStatus.INIT);
            //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
            case INIT_FINISH -> newStatus.equals(BotStatus.STARTING);
            //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
            case STARTING -> newStatus.equals(BotStatus.RUNNING);
            //RUNNING，新状态只能为 SHUTDOWN
            case RUNNING -> newStatus.equals(BotStatus.STOPPING);
            case STOPPING -> newStatus.equals(BotStatus.STOPPED) || newStatus.equals(BotStatus.SHUTDOWN);
            case STOPPED -> newStatus.equals(BotStatus.INIT);
            case SHUTDOWN -> throw new BotStatusException("bot already shutdown");
        };

        if (b) {
            logger.info("Status change [%s] => [%s]".formatted(status, newStatus));
            this.status = newStatus;
        } else {
            throw new BotStatusException(
                String.format("%s status can't from[%s] -> to[%s]", runtimeBotName(), status, newStatus));
        }
    }

    public String runtimeBotName() {
        return "Bot[%s]-[%s]".formatted(botInstance.getBotName(), autoBotConfig.getBotKey());
    }

    protected synchronized Map<String, AutoBotJobParam> getJobParams() {
        return this.botInstance == null ? new HashMap<>() : this.botInstance.getJobParams();
    }

    protected synchronized AutoBotJobParam getJobParam(String jobName) {
        return this.botInfo.getJobParams() == null ? null : this.botInfo.getJobParams().get(jobName);
    }

    protected synchronized void setJobParam(String jobKey, AutoBotJobParam jobParam) {
        this.botInfo.getJobParams().put(jobKey, jobParam);
    }

    protected synchronized void addBasicJob(BotJobType jobType) {
        if (this.botInfo.getParams() == null) {
            this.botInfo.setParams(new HashMap<>());
        }

        this.botInfo.getParams().compute(BASIC_JOB_LIST_KEY, (k, v) -> {
            if (v == null) {
                v = new HashSet<String>();
            }
            if (v instanceof JSONArray t) {
                v = new HashSet<String>();
                for (int i = 0; i < t.size(); i++) {
                    ((HashSet<String>) v).add(t.getString(i));
                }
            }
            Set<String> set = (HashSet<String>) v;
            set.add(jobType.name());
            return v;
        });
    }

    protected abstract BotInfo buildBotInfo() throws BotInitException;

    protected abstract void resolveBotJobMethod();
}
