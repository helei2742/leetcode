package cn.com.vortexa.bot_platform.service.impl;

import cn.com.vortexa.bot_platform.dto.BotJob;
import cn.com.vortexa.bot_platform.script_control.BotPlatformControlServer;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.bot_platform.mapper.BotInfoMapper;
import cn.com.vortexa.control.constant.WSControlSystemConstants;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.bot_platform.mapper.BotInstanceMapper;
import cn.com.vortexa.bot_platform.service.IBotInstanceService;

import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import lombok.extern.slf4j.Slf4j;

import org.quartz.JobExecutionContext;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@Slf4j
@Service
public class BotInstanceServiceImpl extends AbstractBaseService<BotInstanceMapper, BotInstance>
        implements IBotInstanceRPC, IBotInstanceService {

    @Autowired
    private BotInfoMapper botInfoMapper;

    @Lazy
    @Autowired
    private BotPlatformControlServer botControlServer;

    @Autowired
    private Scheduler scheduler;

    public BotInstanceServiceImpl() {
        super(botInstance -> {
            botInstance.setInsertDatetime(LocalDateTime.now());
            botInstance.setUpdateDatetime(LocalDateTime.now());
            botInstance.setIsValid(1);
        });
    }


    @Override
    public PageResult<BotInstanceVO> conditionPageQueryAllInfo(Integer page, Integer limit,
                                                               Map<String, Object> filterMap) throws SQLException, SchedulerException {

        PageResult<BotInstance> result = super.conditionPageQuery(page, limit, filterMap);

        // 填充botInfo
        List<Integer> botIds = result.getList().stream().map(BotInstance::getBotId).toList();
        Map<Integer, BotInfo> idMapBotInfo = botInfoMapper.selectBatchIds(botIds)
                .stream().collect(Collectors.toMap(BotInfo::getId, botInfo -> botInfo));


        // 查询运行中的任务
        Map<String, List<Trigger>> groupByBotKey = scheduler.getCurrentlyExecutingJobs()
                .stream()
                .map(JobExecutionContext::getTrigger)
                .collect(Collectors.groupingBy(trigger -> trigger.getJobKey().getGroup()));

        ArrayList<BotInstanceVO> voList = new ArrayList<>();
        for (BotInstance instance : result.getList()) {
            BotInstanceVO vo = new BotInstanceVO();

            vo.setBotInstance(instance);
            vo.setBotInfo(idMapBotInfo.get(instance.getBotId()));
            vo.setRunningJob(JSONObject.toJSONString(groupByBotKey.get(instance.getBotKey())));

            voList.add(vo);

            instance.addParam(BotInstance.BOT_INSTANCE_STATUS_KEY, botControlServer.getBotInstanceStatus(
                    WSControlSystemConstants.DEFAULT_GROUP, instance.getBotName(), instance.getBotKey()
            ));
        }

        return new PageResult<>(
                result.getTotal(),
                voList,
                result.getPages(),
                result.getPageNum(),
                result.getPageSize()
        );
    }

    @Override
    public Boolean existsBotInstance(BotInstance query) {
        return getBaseMapper().exists(new QueryWrapper<>(query));
    }

    @Override
    public List<RegisteredService> queryOnLineInstance() {
        List<RegisteredService> res = new ArrayList<>();
        List<String> keys = botControlServer.getConnectionService().queryOnlineInstanceKey();
        keys.forEach(key -> res.addAll(botControlServer.getRegistryService().queryServiceInstance(key)));
        res.forEach(service -> {
            BotInstanceMapper mapper = getBaseMapper();
            BotInstance botInstance = mapper.selectOne(
                    new QueryWrapper<>(BotInstance.builder().botKey(service.getAddress().getInstanceId()).build())
            );
            service.addProps("bot_info", botInstance);
        });
        return res;
    }

    @Override
    public Result startJob(BotJob botJob) throws BotStartException {
        try {
            return botControlServer.startJob(
                    botJob.getGroup(),
                    botJob.getBotName(),
                    botJob.getBotKey(),
                    botJob.getJobName()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("[{}] start job error", botJob, e);
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @Override
    public Boolean existsBotInstanceRPC(BotInstance query) {
        return existsBotInstance(query);
    }

    @Override
    public Integer insertOrUpdateRPC(BotInstance instance) throws SQLException {
        return insertOrUpdate(instance);
    }

    @Override
    public BotInstance selectOneRPC(BotInstance query) {
        return getOne(new QueryWrapper<>(query));
    }
}
package cn.com.vortexa.example.klok;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.RewordInfo;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.hutool.core.lang.Pair;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

import java.time.Instant;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static cn.com.vortexa.example.klok.KlokBot.*;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class KlokApi {

    private static final String VERIFY_API = "https://api1-pp.klokapp.ai/v1/verify";
    private static final String BASE_API = "https://api1-pp.klokapp.ai/v1/verify";
    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'")
        .withZone(java.time.ZoneOffset.UTC);
    private static final Logger log = LoggerFactory.getLogger(KlokApi.class);

    private final KlokBot klokBot;

    public KlokApi(KlokBot klokBot) {
        this.klokBot = klokBot;
    }

    public Result login(AccountContext accountContext) {
        try {
            Pair<String, String> signature = generateSignature(accountContext);
            klokBot.logger.debug(accountContext.getSimpleInfo() + " signature success");

            CompletableFuture<String> tokenFuture = verify(accountContext, signature.getKey(), signature.getValue(),
                null);
            String token = tokenFuture.get();
            klokBot.logger.info(accountContext.getSimpleInfo() + " login success, token: " + token);
            accountContext.setParam(SESSION_TOKEN, token);

            return Result.ok(token);
        } catch (Exception e) {
            String errorMsg = accountContext.getSimpleInfo() + " login success, token: " +
                (e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
            klokBot.logger.error(
                errorMsg
            );
            return Result.fail(errorMsg);
        }
    }

    public CompletableFuture<String> verify(
        AccountContext accountContext,
        String message,
        String signature,
        String inviteCode
    ) {
        JSONObject body = new JSONObject();
        body.put("signedMessage", signature);
        body.put("message", message);
        body.put("referral_code", inviteCode);

        Map<String, String> headers = generateACHeader(accountContext);

        return klokBot.syncRequest(
            accountContext.getProxy(),
            VERIFY_API,
            HttpMethod.POST,
            headers,
            null,
            body,
            () -> accountContext.getSimpleInfo() + " send verify request"
        ).thenApply(response -> {
            JSONObject result = JSONObject.parseObject(response);

            if ("Verification successful".equals(result.getString("message"))) {
                return result.getString("session_token");
            } else {
                throw new RuntimeException("Verification failed, " + response);
            }
        });
    }

    public void dailyTask(AccountContext accountContext) throws ExecutionException, InterruptedException {
        String simpleInfo = accountContext.getSimpleInfo();
        int count = (int) accountContext.getParams().getOrDefault(DAILY_TIMES, 10);
        Result result = login(accountContext);

        klokBot.logger.debug(simpleInfo + " start daily task, remaining: " + count);

        if (result.getSuccess()) {
            String token = accountContext.getParam(SESSION_TOKEN);

            Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();
            headers.put("x-session-token", token);

            int errorCount = 0;
            while (count > 0) {
                JSONObject limitCheck = accountRequestLimitCheck(accountContext, headers);
                if (limitCheck.getInteger("remaining") <= 0) {
                    klokBot.logger.warn(simpleInfo + " Daily limit reached " + count);
                    return;
                }

                JSONObject body = new JSONObject();
                body.put("id", UUID.randomUUID().toString());
                body.put("messages", buildChatMessage());
                body.put("model", "llama-3.3-70b-instruct");
                body.put("created_at", currentISOTime());
                body.put("language", "english");

                try {
                    int finalCount = count;
                    String chatResult = klokBot.syncRequest(
                        accountContext.getProxy(),
                        BASE_API + "/v1/chat",
                        HttpMethod.POST,
                        headers,
                        null,
                        body,
                        () -> simpleInfo + " send chat request - " + finalCount
                    ).get();
                    klokBot.logger.info("%s daily chat %d finish...".formatted(simpleInfo, count));
                } catch (Exception e) {
                    klokBot.logger.error("daily chat %d error, %s".formatted(count,
                        e.getCause() == null ? e.getCause().getMessage() : e.getMessage()));
                    errorCount++;
                }
                count++;
            }

            if (errorCount > 0) {
                accountContext.setParam(DAILY_TIMES, errorCount);
            }
        }
    }

    public JSONObject accountRequestLimitCheck(AccountContext accountContext, Map<String, String> headers)
        throws ExecutionException, InterruptedException {

        String limitResponse = klokBot.syncRequest(
            accountContext.getProxy(),
            BASE_API + "/v1/rate-limit",
            HttpMethod.GET,
            headers,
            null,
            null,
            () -> accountContext.getSimpleInfo() + " check request limit"
        ).get();

        return JSONObject.parseObject(limitResponse);
    }

    public Result rewordQuery(AccountContext accountContext) {
        String token = accountContext.getParam(SESSION_TOKEN);
        String simpleInfo = accountContext.getSimpleInfo();
        if (token == null) {
            return Result.fail(simpleInfo + " rewordQuery failed, token not found");
        }

        Map<String, String> headers = generateACHeader(accountContext);

        try {
            String responseStr = klokBot.syncRequest(
                accountContext.getProxy(),
                BASE_API + "/v1/chat/stats",
                HttpMethod.GET,
                headers,
                null,
                null,
                () -> simpleInfo + " send reword query request"
            ).get();

            JSONObject response = JSONObject.parseObject(responseStr);
            response.put("message", "Reword query success");
            if (!accountContext.getParams().containsKey(DAILY_LIMIT)) {
                accountContext.setParam(DAILY_LIMIT, response.getInteger("remaining"));
            }
            accountContext.getRewordInfo().setTotalPoints(response.getDouble("points_earned"));
            return Result.ok();
        } catch (InterruptedException | ExecutionException e) {
            String errorMsg = simpleInfo + " reword query error, " + (e.getCause() == null ? e.getCause().getMessage()
                : e.getMessage());
            klokBot.logger.error(errorMsg);
            return Result.fail(errorMsg);
        }
    }

    private static @NotNull Map<String, String> generateACHeader(AccountContext accountContext) {
        Map<String, String> headers = accountContext.getBrowserEnv().generateHeaders();
        headers.put("origin", "https://klokapp.ai");
        headers.put("referer", "https://klokapp.ai/");
        headers.put("content-type", "application/json");
        headers.put("accept", "*/*");
        return headers;
    }

    private JSONArray buildChatMessage() {
        JSONArray array = new JSONArray();
        JSONObject jb = new JSONObject();
        jb.put("role", "user");
        jb.put("content", "");
        array.add(jb);
        return array;
    }

    private String buildMessage(String address) {
        String template
            = "klokapp.ai wants you to sign in with your Ethereum account:\n%s\n\n\nURI: https://klokapp.ai/\nVersion: 1\nChain ID: 1\nNonce: %s\nIssued At: %s";

        // 使用自定义格式化器，确保毫秒部分保留 3 位
        String issuedAt = currentISOTime();

        return template.formatted(address, EthWalletUtil.getRandomNonce(), issuedAt);
    }

    private static @NotNull String currentISOTime() {
        // 获取当前时间的 Instant 对象（UTC 时间）
        Instant now = Instant.now();

        return formatter.format(now);
    }

    private Pair<String, String> generateSignature(AccountContext accountContext) {
        String primaryKey = accountContext.getParam(PRIMARY_KEY);
        String address = accountContext.getParam(ETH_ADDRESS);
        //        if (StrUtil.isBlank(address)) {
        address = EthWalletUtil.getETHAddress(primaryKey);
        accountContext.setParam(ETH_ADDRESS, address);
        //        }
        String message = buildMessage("0x2dB603E747E2db72747E5b972006f19B2D0d73a1");

        return new Pair<>(
            message,
            EthWalletUtil.signatureMessage2String(primaryKey, message)
        );
    }
}

package cn.com.vortexa.example.klok;


import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.script_node.ScriptNodeLauncher;
import cn.com.vortexa.script_node.anno.BotApplication;
import cn.com.vortexa.script_node.anno.BotMethod;
import cn.com.vortexa.script_node.bot.AutoLaunchBot;
import cn.com.vortexa.script_node.config.AutoBotConfig;
import cn.com.vortexa.script_node.service.BotApi;
import lombok.extern.slf4j.Slf4j;

import org.springframework.context.annotation.Bean;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;

@Slf4j
@BotApplication(
        name = "klok_bot",
        accountParams = {KlokBot.PRIMARY_KEY}
)
public class KlokBot extends AutoLaunchBot<KlokBot> {

    public static final String PRIMARY_KEY = "primary_key";
    public static final String ETH_ADDRESS = "eth_address";
    public static final String SESSION_TOKEN = "session_token";
    public static final String DAILY_TIMES = "daily_times";
    public static final String DAILY_LIMIT = "daily_limit";

    private KlokApi klokApi;

    @Override
    protected void botInitialized(AutoBotConfig botConfig, BotApi botApi) {
        klokApi = new KlokApi(this);
    }

    @Override
    protected KlokBot getInstance() {
        return this;
    }

    @BotMethod(jobType = BotJobType.LOGIN)
    public Result login(AccountContext accountContext) {
        if (accountContext.getId() != 1) return Result.fail("test error");
        return klokApi.login(accountContext);
    }

    @BotMethod(jobType = BotJobType.QUERY_REWARD, intervalInSecond = 24 * 60 * 60)
    public Result rewordQuery(AccountContext exampleAC, List<AccountContext> sameBAIDList) {
        return klokApi.rewordQuery(exampleAC);
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 6 * 60 * 60)
    public void dailyTask(AccountContext accountContext) throws ExecutionException, InterruptedException {
        klokApi.dailyTask(accountContext);
    }

    public static void main(String[] args) throws BotStartException, BotInitException {
        List<String> list = new ArrayList<>(java.util.List.of(args));
        list.add("--vortexa.botKey=klok_test");
        list.add("--vortexa.customConfig.invite_code=KMDiFtp9");
        list.add("--vortexa.accountConfig.configFilePath=klok_google.xlsx");
        list.add("--add-opens java.base/java.lang=ALL-UNNAMED");

        ScriptNodeLauncher.launch(KlokBot.class, list.toArray(new String[0]));
    }
}

package cn.com.vortexa.script_node;

import cn.com.vortexa.script_node.config.AutoBotConfig;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.typehandler.JsonTypeHandler;
import cn.com.vortexa.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.vortexa.common.util.typehandler.MapTextTypeHandler;
import cn.com.vortexa.db_layer.DBLayerAutoConfig;
import cn.com.vortexa.db_layer.plugn.table_shard.TableShardInterceptor;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import cn.com.vortexa.job.JobAutoConfig;
import cn.hutool.core.util.StrUtil;
import com.zaxxer.hikari.HikariDataSource;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Configuration
@ImportAutoConfiguration({DBLayerAutoConfig.class, JobAutoConfig.class})
@ComponentScan({"cn.com.vortexa.script_node.service.impl", "cn.com.vortexa.script_node.config"})
@MapperScan(basePackages = "cn.com.vortexa.script_node.mapper")
public class ScriptNodeAutoConfig {

    @Autowired
    private JsonTypeHandler jsonTypeHandler;

    @Autowired
    private MapTextTypeHandler mapTextTypeHandler;

    @Autowired
    private LocalDateTimeTypeHandler localDateTimeTypeHandler;

    @Autowired
    private AutoBotConfig botConfig;


    @Bean("vortexaDataSource")
    public DataSource vortexaDataSource() {
        String botKey = botConfig.getBotKey();
        if (StrUtil.isBlank(botKey)) {
            throw new IllegalArgumentException("botKey is empty");
        }

        try {
            String path = tryCreateDBFile(botKey);
            HikariDataSource dataSource = new HikariDataSource();
            dataSource.setJdbcUrl("jdbc:sqlite:/" + path);
            return dataSource;
        } catch (IOException e) {
            throw new RuntimeException("create Bot[%s]DB file error".formatted(botKey), e);
        }
    }


    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();

        factoryBean.setDataSource(vortexaDataSource());
        factoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()
                .getResources("classpath:/mapper/*.xml"));

        factoryBean.addTypeHandlers(jsonTypeHandler, mapTextTypeHandler, localDateTimeTypeHandler);
        factoryBean.addPlugins(tableShardInterceptor());

        return factoryBean.getObject();
    }

    // 配置事务管理器
    @Bean(name = "transactionManager")
    public PlatformTransactionManager transactionManager() {
        return new DataSourceTransactionManager(vortexaDataSource());
    }

    @Bean
    public ITableShardStrategy tableShardStrategy() {
        return new BotIdBasedTableShardStrategy();
    }

    @Bean
    public Interceptor tableShardInterceptor() {
        return new TableShardInterceptor(tableShardStrategy());
    }


    /**
     * 尝试创建DB File
     *
     * @param botKey botKey
     * @return db file absolutePath
     * @throws IOException IOException
     */
    private static String tryCreateDBFile(String botKey) throws IOException {
        // 创建BotKey对应的数据库文件
        Path absolutePath = Paths.get(FileUtil.getBotAppConfigPath(), botKey, "bot_" + botKey + ".db");

        if (Files.notExists(absolutePath)) {
            if (Files.notExists(absolutePath.getParent())) {
                Files.createDirectories(absolutePath.getParent());
            }
            Files.createFile(absolutePath);
        }

        return absolutePath.toString();
    }
}
