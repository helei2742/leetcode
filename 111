package cn.com.helei.bot.app.kile_ai;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.pool.IdMarkPool;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.util.List;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
@BotApplication(name = "Kile_AI_BOT")
public class KileAIBot extends AnnoDriveAutoBot<KileAIBot> {


    private static final List<String> AGENT_LIST = List.of("deployment-p5J9lz1Zxe7CYEoo0TZpRVay", "deployment-7sZJSiCqCNDy9bBHTEh7dwd9", "deployment-SoFftlsf9z4fyA3QCHYkaANq");

    private static final String QUESTION_CONFIRM_URL = "https://quests-usage-dev.prod.zettablock.com/api/report_usage";

    private static final String WALLET_KEY = "eth_address";

    private static final String TODAY_KEY = "today";

    private static final String TODAY_TOTAL_KEY = "today_TOTAL";

    private static final int QUESTION_CONFIRM_LIMIT = 3;

    private final Random random = new Random();

    private final IdMarkPool<String> questionPool;


    public KileAIBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        this.questionPool = IdMarkPool.create(List.of("你好", "666"), String.class);
    }

    @Override
    protected KileAIBot getInstance() {
        return this;
    }

    /**
     * 每日询问的定时任务
     *
     * @param accountContext accountContext
     * @return String
     */
    @BotMethod(
            jobType = BotJobType.TIMED_TASK,
            jobName = "每日询问 AI",
            intervalInSecond = 15
    )
    public String queryAgentClaim(AccountContext accountContext) {
        // Step 1 过滤完成的，或不能用的
        if (filterAccountContext(accountContext)) {
            return "account-%s claim error, account claimed or unusable".formatted(accountContext.getSimpleInfo());
        }

        // Step 2 获取需要查询的数量
        int queryCount = Integer.parseInt(accountContext.getParam(TODAY_TOTAL_KEY));

        int errorCount = 0;

        // Step 3 开始逐个查询
        for (int i = 0; i < queryCount; i++) {
            String agent = getRandomAgent();
            String question = questionPool.getLessUsedItem(1).getFirst();

            log.info("{} 开始询问Agent[{}], [{}/{}]", accountContext.getSimpleInfo(), agent, i + 1, queryCount);

            // Step 3.1 询问问题
            CompletableFuture<Boolean> future = askQuestion(accountContext, agent, question)
                    // Step 3.2 询问完成后，提交问题和答案
                    .thenApplyAsync(resultStr -> {
                        if (StrUtil.isNotBlank(resultStr)) {
                            log.info("{} 询问Agent成功 [{}] -> [{}]", accountContext.getSimpleInfo(), question, resultStr);
                            try {
                                return confirmQuestion(accountContext, agent, question, resultStr).get();
                            } catch (InterruptedException | ExecutionException e) {
                                log.error("{} 上报问答发生异常, {}", accountContext, e.getMessage());
                                return false;
                            }
                        } else {
                            log.error("{} 询问Agent失败, question.dat [{}]", accountContext, question);
                            return false;
                        }
                    });

            try {
                if (future.get()) {
                    log.info("{} - 问题提交成功, [{}/{}]", accountContext.getSimpleInfo(), i + 1, queryCount);
                }
            } catch (InterruptedException | ExecutionException e) {
                errorCount++;
                log.error("{} - 问题提交失败, [{}/{}]", accountContext.getSimpleInfo(), i + 1, queryCount);
            }
        }

        return "account-%s-claim-complete, [%d/%d]".formatted(accountContext.getSimpleInfo(), queryCount - errorCount, queryCount);
    }


    /**
     * 过滤不可用的账户
     *
     * @param accountContext accountContext
     * @return boolean 是否过滤
     */
    private boolean filterAccountContext(AccountContext accountContext) {
        if (StrUtil.isBlank(accountContext.getParam(WALLET_KEY))) {
            log.warn("{} 没有钱包参数", accountContext.getSimpleInfo());
            return true;
        }

        String today = LocalDate.now().toString();
        String acDay = accountContext.getParam(TODAY_KEY);

        // 今天没做过
        if (!today.equals(acDay)) {
            accountContext.setParam(TODAY_KEY, today);
            int dailyQueryCount = getDailyQueryCount();
            accountContext.setParam(TODAY_TOTAL_KEY, dailyQueryCount);

            log.info("{} 今日还未执行, 问题个数[{}]", accountContext.getSimpleInfo(), dailyQueryCount);
        } else {
            String todayTotalStr = accountContext.getParam(TODAY_TOTAL_KEY);
            Integer todayTotal = null;
            if (todayTotalStr == null) {
                accountContext.setParam(TODAY_TOTAL_KEY, getDailyQueryCount());
            } else if ((todayTotal = Integer.valueOf(todayTotalStr)) == 0) {
                log.warn("{} 今日已完成", accountContext.getSimpleInfo());
                return true;
            } else {
                log.info("{} 今日剩余[{}], 继续执行", accountContext.getSimpleInfo(), todayTotal);
            }
        }

        return false;
    }


    /**
     * 询问Agent
     *
     * @param accountContext accountContext
     * @param agent          agent
     * @param question       question
     * @return CompletableFuture<String>
     */
    private CompletableFuture<String> askQuestion(AccountContext accountContext, String agent, String question) {
        JSONObject body = new JSONObject();
        body.put("message", question);
        body.put("stream", false);

        return syncRequest(
                accountContext.getProxy(),
                "https://%s.stag-vxzy.zettablock.com/main".formatted(agent),
                "post",
                accountContext.getBrowserEnv().getHeaders(),
                null,
                body,
                () -> accountContext.getSimpleInfo() + " 询问Agent - " + question
        );
    }


    /**
     * 确认问答，，只有确认了才有分
     *
     * @param accountContext accountContext
     * @param agent          agent
     * @param question       question.dat
     * @param answer         answer
     * @return 是否确认成功
     */
    private CompletableFuture<Boolean> confirmQuestion(
            AccountContext accountContext,
            String agent,
            String question,
            String answer
    ) {
        ProxyInfo proxy = accountContext.getProxy();

        String wallet = accountContext.getParam(WALLET_KEY);

        JSONObject body = new JSONObject();
        body.put("wallet_address", wallet);
        body.put("agent_id", agent);
        body.put("request_text", question);
        body.put("response_text", answer);
        body.put("request_metadata", new JSONObject());

        return CompletableFuture.supplyAsync(() -> {
            Exception lastException = null;

            for (int i = 0; i < QUESTION_CONFIRM_LIMIT; i++) {
                try {
                    String resultStr = syncRequest(
                            proxy,
                            QUESTION_CONFIRM_URL,
                            "post",
                            accountContext.getBrowserEnv().getHeaders(),
                            null,
                            body,
                            () -> accountContext.getSimpleInfo() + " 上报问答 - " + question
                    ).get();

                    log.info("{} 上报问答成功, {}", accountContext.getSimpleInfo(), resultStr);
                    return true;
                } catch (InterruptedException | ExecutionException e) {
                    log.warn("{} 上报问答发生异常, [{}/{}]", accountContext.getSimpleInfo(), i + 1, QUESTION_CONFIRM_LIMIT);
                    lastException = e;
                }
            }
            throw new RuntimeException("上报问答超过次数限制，" + QUESTION_CONFIRM_LIMIT, lastException);
        });
    }

    /**
     * 获取每日运行多少次
     *
     * @return 数量
     */
    private int getDailyQueryCount() {
        return 20 + random.nextInt(3);
    }

    /**
     * 随机选取agent
     *
     * @return String
     */
    private String getRandomAgent() {
        return AGENT_LIST.get(random.nextInt(AGENT_LIST.size()));
    }
}
package cn.com.helei.bot.core.bot.anno;

import cn.com.helei.bot.core.bot.constants.BotJobType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotMethod {

    /**
     * job类型
     *
     * @return BotJobType
     */
    BotJobType jobType();

    /**
     * jobName
     *
     * @return string
     */
    String jobName() default "";

    /**
     * 描述
     *
     * @return String
     */
    String description() default "";

    /**
     * 时间表达式
     *
     * @return String
     */
    String cronExpression() default "";

    /**
     * 运行间隔
     *
     * @return int
     */
    int intervalInSecond() default 0;

    /**
     * 并发数
     *
     * @return int
     */
    int concurrentCount() default 20;


    BotWSMethodConfig bowWsConfig() default @BotWSMethodConfig();
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.persistence.impl.DBAccountPersistenceManager;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.supporter.persistence.AccountPersistenceManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.*;


@Slf4j
public abstract class AccountManageAutoBot extends AbstractAutoBot {

    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    /**
     * 持久化管理器
     */
    private final AccountPersistenceManager persistenceManager;


    public AccountManageAutoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        this.persistenceManager = new DBAccountPersistenceManager(botApi);
    }


    @Override
    protected void doInit() throws DepinBotInitException {
        // Step 1 初始化保存的线程
        persistenceManager.init();

        // Step 2 初始化账户
        initAccounts();
    }

    /**
     * 注册账户
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> registerAccount();

    /**
     * 登录并获取token
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> loginAndTakeTokenAccount();


    /**
     * 更新账户奖励信息
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> updateAccountRewordInfo();


    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> getBotJobNameList();

    /**
     * 运行指定job
     *
     * @param jobName jobName
     * @return CompletableFuture<Result>
     */
    public abstract BotACJobResult startBotJob(String jobName);


    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }

    /**
     * 初始化账号方法
     */
    private void initAccounts() throws DepinBotInitException {
        Integer botId = getBotInfo().getId();

        String name = getBotInfo().getName();

        try {
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                    .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                log.warn("bot[{}]没有账户数据", name);
            } else {
                log.info("bot[{}]使用历史账户数据, 共[{}]", name, accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }


    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.bot.AccountWSClientBuilder;
import cn.com.helei.bot.core.bot.WebSocketClientLauncher;
import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.util.exception.BotMethodFormatException;
import cn.com.helei.bot.core.util.exception.BotMethodInvokeException;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;

import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T> extends AccountManageAutoBot {

    /**
     * jobName -> jobParam
     */
    private final Map<String, AutoBotJobParam> autoBotJobMap;

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher;

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap;

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;


    public AnnoDriveAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        super(autoBotConfig, botApi);

        this.webSocketClientLauncher = new WebSocketClientLauncher(this);
        this.jobCCSemaphoreMap = new ConcurrentHashMap<>();

        this.autoBotJobMap = resolveBotMethodAnno();
    }

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() {
        return resolveAnnoBotInfo(getBotApi());
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.REGISTER.name(),
                    "未找到注册方法"
            ));
        }

        return asyncForACList(
                accountContext -> {
                    if (BooleanUtil.isTrue(accountContext.getSignUp())) {
                        // 账户注册过，
                        String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(), accountContext.getName(),
                                accountContext.getAccountBaseInfo().getEmail());

                        log.warn(errorMsg);

                        return CompletableFuture.completedFuture(Result.fail(errorMsg));
                    } else if (registerMethod != null) {
                        // 调用注册方法注册
                        return invokeBotMethod(registerMethod, accountContext, getAutoBotConfig().getConfig(INVITE_CODE_KEY));
                    } else {
                        return CompletableFuture.completedFuture(Result.fail("未知错误"));
                    }
                },
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        //注册成功
                        accountContext.setSignUp(true);
                    }
                    return result;
                },
                BotJobType.REGISTER.name()
        );
    }


    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.LOGIN.name(),
                    "未找到登录方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(loginMethod, accountContext),
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        String token = result.getData() == null ? null : (String) result.getData();

                        // token不为空，设置到accountContext里
                        if (StrUtil.isNotBlank(token)) {
                            accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                        } else {
                            log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                        }
                    }
                    return result;
                },
                BotJobType.LOGIN.name()
        );
    }


    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.QUERY_REWARD.name(),
                    "未找到奖励查询方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(updateRewordMethod, accountContext),
                (accountContext, result) -> result,
                BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> getBotJobNameList() {
        return autoBotJobMap.keySet();
    }

    @Override
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().registerJob(autoBotJobMap.get(jobName));
    }

    protected abstract T getInstance();

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        List<AccountContext> accountContexts = getAccountContexts();

        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult;
                    CompletableFuture<Result> future;

                    try {
                        botACJobResult = new BotACJobResult(
                                getBotInfo().getId(),
                                getBotInfo().getName(),
                                jobName,
                                accountContext.getId()
                        );

                        future = buildResultFuture.apply(accountContext);

                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        throw new RuntimeException(e);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) success++;

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            log.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInfo().getId(),
                                            getBotInfo().getName(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInfo().getId())
                            .botName(getBotInfo().getName())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 解析注解，添加botInfo
     */
    private BotInfo resolveAnnoBotInfo(BotApi botApi) {
        BotApplication annotation = this.getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            BotInfo dbBotInfo = botApi.getBotInfoService().query().eq("name", botName).one();

            // 查询bot是否存在，不存在则创建
            if (dbBotInfo == null) {
                log.warn("不存在[{}]bot info, 自动创建...", botName);

                BotInfo botInfo = new BotInfo();
                botInfo.setDescribe(annotation.describe());
                botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
                botInfo.setName(botName);
                if (botApi.getBotInfoService().save(botInfo)) {
                    log.info("自动创建[{}]bot info成功", botName);
                    return botInfo;
                } else {
                    throw new RuntimeException("保存bot[" + botName + "]信息失败");
                }
            } else {
                return dbBotInfo;
            }
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }


    /**
     * 解析注解中的方法
     *
     * @return List<AutoBotJob>
     */
    private Map<String, AutoBotJobParam> resolveBotMethodAnno() {
        Map<String, AutoBotJobParam> jobMap = new HashMap<>();

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod, jobMap);
                    case TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod, jobMap);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod, jobMap);
                }
            }
        }

        return jobMap;
    }

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                    "应为 Result methodName(AccountContext ac, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param jobMap       jobMap
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> jobMap) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            AutoBotJobParam queryRewardJob = buildAutoBotJobParam(method, botJobMethod);

            jobMap.put(BotJobType.QUERY_REWARD.name(), queryRewardJob);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param jobMap       jobMap
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> jobMap) {
        if (method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            AutoBotJobParam autoBotJob = buildAutoBotJobParam(method, botJobMethod);
            String jobName = autoBotJob.getJobName();

            if (!jobMap.containsKey(jobName)) {
                jobMap.put(jobName, autoBotJob);
            } else {
                throw new BotMethodFormatException("任务名称重复, " + jobName);
            }
        } else {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     * @param jobMap           jobMap
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno, Map<String, AutoBotJobParam> jobMap) {
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                AutoBotJobParam jobParam = buildAutoBotJobParam(WebSocketClientLauncher.lanuchMethod, botJobMethodAnno);

                // 更改执行target，添加额外参数
                jobParam.setTarget(webSocketClientLauncher);
                jobParam.setExtraParams(new Object[]{jobParam, new AccountWSClientBuilder() {
                    @Override
                    public BaseBotWSClient<?, ?> build(AccountContext accountContext) throws InvocationTargetException, IllegalAccessException {
                        Object invoke = method.invoke(getInstance(), accountContext);

                        return (BaseBotWSClient<?, ?>) invoke;
                    }
                }});

                // 添加到jobMap
                jobMap.put(jobParam.getJobName(), jobParam);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else {
            throw new BotMethodFormatException("websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 根据方法注解创建 AutoBotJob
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     * @return AutoBotJobParam
     */
    private @NotNull AutoBotJobParam buildAutoBotJobParam(Method method, BotMethod botJobMethodAnno) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
            } else {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            autoBotJobParam = new AutoBotJobParam(
                    this,
                    StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName(),
                    botJobMethodAnno.description(),
                    method,
                    cronExpression,
                    intervalInSecond,
                    botJobMethodAnno.concurrentCount(),
                    botJobMethodAnno.bowWsConfig(),
                    null,
                    null
            );
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format(
                            "[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInfo().getName(),
                            method.getName(),
                            botJobMethodAnno.cronExpression()
                    ),
                    e
            );
        }

        return autoBotJobParam;
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInfo().getName(),
                        registerMethod.getName()
                ), e);
            }
        }, getExecutorService());
    }


    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> new Semaphore(autoBotJobMap.get(key).getConcurrentCount()));
    }
}
package cn.com.helei.bot.core.bot.job;

import cn.com.helei.bot.core.bot.anno.BotWSMethodConfig;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import lombok.*;
import org.quartz.CronExpression;

import java.lang.reflect.Method;

@Data
@AllArgsConstructor
public class AutoBotJobParam {

    private final AnnoDriveAutoBot<?> bot;

    private final String jobName;

    @Getter
    private final String description;

    private final Method jobMethod;

    @Getter
    private final CronExpression cronExpression;

    @Getter
    private final Integer intervalInSecond;

    private final int concurrentCount;

    private final BotWSMethodConfig botWSMethodConfig;

    private Object target;

    private Object[] extraParams;

    public String getGroup() {
        return this.bot.getBotInfo().getName();
    }

    public Integer getBotId() {
        return bot.getBotInfo().getId();
    }
}
package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.bot.core.util.excel.IntegerStringConverter;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenField;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

        import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
@PropertyChangeListenClass
public class AccountContext {


    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("bot_key")
    @ExcelProperty(value = "bot_key", converter = IntegerStringConverter.class)
    private String botKey;

    @TableField("account_base_info_id")
    @ExcelProperty(value = "account_base_info_id", converter = IntegerStringConverter.class)
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty(value = "twitter_id", converter = IntegerStringConverter.class)
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty(value = "discord_id", converter = IntegerStringConverter.class)
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty(value = "proxy_id", converter = IntegerStringConverter.class)
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty(value = "browser_env_id", converter = IntegerStringConverter.class)
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty(value = "telegram_id", converter = IntegerStringConverter.class)
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty(value = "wallet_id", converter = IntegerStringConverter.class)
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    @TableField("status")
    @PropertyChangeListenField
    private Integer status;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    private ProxyInfo proxy;

    @TableField(exist = false)
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return String.valueOf(params.get(key));
    }

    public void setParam(String key, Object value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getAccountBaseInfo().getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().getAddressStr());
    }

    public Boolean getSignUp() {
        return status != null && status == 1;
    }

    public void setSignUp(boolean b) {
        status = 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }
}
package cn.com.helei.bot.core.supporter.botapi.impl;

import cn.com.helei.bot.core.bot.job.AutoBotJob;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.supporter.botapi.BotJobService;
import org.quartz.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static cn.com.helei.bot.core.bot.job.AutoBotJob.BOT_JOB_PARAM_Key;

@Component
public class QuartzBotJobService implements BotJobService {

    private static final Logger log = LoggerFactory.getLogger(QuartzBotJobService.class);

    @Autowired
    private Scheduler scheduler;

    @Override
    public List<BotACJobResult> registerJobList(Collection<AutoBotJobParam> autoBotJobParams) {

        List<BotACJobResult> resultList = new ArrayList<>(autoBotJobParams.size());

        for (AutoBotJobParam autoBotJob : autoBotJobParams) {
            resultList.add(registerJob(autoBotJob));
        }

        return resultList;
    }


    @Override
    public BotACJobResult registerJob(AutoBotJobParam jobParam) {
        BotACJobResult result = BotACJobResult.builder()
                .botId(jobParam.getBotId())
                .group(jobParam.getGroup())
                .jobName(jobParam.getJobName())
                .success(true)
                .build();

        JobKey jobKey = new JobKey(jobParam.getJobName(), jobParam.getGroup());

        try {
            // 存在这个job
            if (scheduler.checkExists(jobKey)) {
                result.setSuccess(false);
                result.setErrorMsg("job exist");
            } else {
                JobDataMap jobDataMap = new JobDataMap();
                jobDataMap.put(BOT_JOB_PARAM_Key, jobParam);

                // 不存在，创建并运行
                JobDetail jobDetail = JobBuilder.newJob(AutoBotJob.class)
                        .withIdentity(jobKey)
                        .withDescription(jobParam.getDescription())
                        .setJobData(jobDataMap)
                        .storeDurably()
                        .build();

                TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger()
                        .withIdentity(jobParam.getJobName(), jobParam.getGroup())
                        .startNow();

                if (jobParam.getIntervalInSecond() != null) {
                    triggerBuilder
                            .withSchedule(SimpleScheduleBuilder
                                    .simpleSchedule()
                                    .withIntervalInSeconds(jobParam.getIntervalInSecond())
                                    .repeatForever()
                            );
                } else if (jobParam.getCronExpression() != null) {
                    triggerBuilder
                            .withSchedule(CronScheduleBuilder.cronSchedule(jobParam.getCronExpression()));
                }

                scheduler.scheduleJob(jobDetail, triggerBuilder.build());
            }
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMsg(e.getMessage());

            log.error("注册[{}]job发生异常", jobKey, e);
        }

        return result;
    }

}
package cn.com.helei.bot.core.util.pool;

import cn.com.helei.bot.core.util.tableprinter.CommandLineTablePrintHelper;
import lombok.Getter;
import lombok.Setter;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

@Getter
public class IdMarkPool<T> {

    private final Class<T> tClass;

    @Getter
    @Setter
    private List<Object> list;

    @Setter
    private String configClassPath;


    private final ConcurrentMap<Integer, IdMarkPoolItem<T>> idMapItem = new ConcurrentHashMap<>();

    /**
     * 使用次数
     */
    private final Map<Integer, Integer> useCountMap = new HashMap<>();

    public IdMarkPool(Class<T> tClass) {
        this.tClass = tClass;
    }

     public static <C> IdMarkPool<C> create(List<C> items, Class<C> cClass) {
         IdMarkPool<C> tIdMarkPool = new IdMarkPool<>(cClass);

         AtomicInteger idCounter = new AtomicInteger();

         for (C item : items) {
             int id = idCounter.getAndIncrement();

             tIdMarkPool.getIdMapItem().put(id, new IdMarkPoolItem<>(id, item));
             tIdMarkPool.getUseCountMap().put(id, 0);
         }

         return tIdMarkPool;
     }

    /**
     * 获取代理
     *
     * @param id id
     * @return NetworkProxy
     */
    public synchronized T getItem(Integer id) {
        IdMarkPoolItem<T> compute = idMapItem.compute(id, (k, v) -> {
            if (v == null) return null;

            useCountMap.compute(id, (k1, v1) -> {
                if (v1 == null) v1 = 0;

                return v1 + 1;
            });

            return v;
        });

        if (compute == null) return null;

        return compute.data;
    }


    /**
     * 获取最少使用的
     *
     * @param count 数量
     * @return List<T>
     */
    public synchronized List<T> getLessUsedItem(int count) {
        int batchSize = Math.min(count, getUseCountMap().size());

        List<T> res = new ArrayList<>(count);

        int needCount = count;
        while (needCount > 0) {
            int currentSize = Math.min(needCount, batchSize);

            List<T> batch = getUseCountMap().entrySet().stream()
                    .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .limit(currentSize)
                    .map(e -> {
                        getUseCountMap().compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                        return (T) getIdMapItem().get(e.getKey()).getData();
                    }).toList();
            res.addAll(batch);

            needCount -= batch.size();
        }

        return res;
    }

    /**
     * 获取全部
     *
     * @return List<T>
     */
    public List<T> getAllItem() {
        return getIdMapItem().values().stream().map(e -> (T) e).toList();
    }


    /**
     * 打印池
     *
     * @return String
     */
    public String printPool() {
        return CommandLineTablePrintHelper.generateTableString(new ArrayList<>(idMapItem.values()), tClass);
    }


    public T buildTInstanceFromLineStr(Object originLine)
            throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Constructor<T> constructor = getTClass().getConstructor(Object.class);
        return constructor.newInstance(originLine);
    }


    @Getter
    @Setter
    public static class IdMarkPoolItem<T> {
        private T data;

        private Integer id;

        public IdMarkPoolItem(int id, T item) {
            this.id = id;
            this.data = item;
        }
    }
}
package cn.com.helei.bot.app.kile_ai;

import cn.com.helei.bot.core.AutoBotApplication;
import cn.com.helei.bot.core.bot.view.MenuCMDLineAutoBot;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.commandMenu.DefaultMenuType;
import cn.com.helei.bot.core.util.exception.DepinBotStartException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest(classes = AutoBotApplication.class)
class KileAIBotTest {

    private MenuCMDLineAutoBot<AutoBotConfig> menuCMDLineAutoBot;

    @Autowired
    public BotApi botApi;

    @BeforeEach
    public void setUp() throws DepinBotStartException {
        AutoBotConfig autoBotConfig = new AutoBotConfig();
        autoBotConfig.setBotKey("kile_ai_test");
        autoBotConfig.getCustomConfig().put("question_list", List.of("你好", "你是谁"));

        KileAIBot kileAIBot = new KileAIBot(autoBotConfig, botApi);

        menuCMDLineAutoBot = new MenuCMDLineAutoBot<>(kileAIBot, List.of(DefaultMenuType.IMPORT));
    }

    @Test
    public void test() throws DepinBotStartException {
        menuCMDLineAutoBot.start();
    }


}
