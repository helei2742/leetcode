package cn.com.vortexa.common.vo;

import com.alibaba.fastjson.JSONArray;

import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import lombok.Data;

import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/2 14:13
 */
@Data
public class BotInstanceVO {

    private BotInfo botInfo;

    /**
     * bot实例
     */
    private BotInstance botInstance;

    /**
     * 正在运行的jobName
     */
    private String runningJob;
}
package cn.com.vortexa.db_layer.service;

import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.util.ConditionBuildUtil;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.db_layer.mapper.IBaseMapper;
import cn.com.vortexa.db_layer.util.ConditionQueryUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.PageInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public abstract class AbstractBaseService<M extends IBaseMapper<T>, T> extends ServiceImpl<M, T> implements IBaseService<T> {

    private final Consumer<T> fillFunction;

    protected AbstractBaseService(Consumer<T> fillFunction) {
        this.fillFunction = fillFunction;
    }

    @Override
    public T queryById(Serializable id) {
        return getById(id);
    }

    /**
     * 插入或更新
     *
     * @param t t
     * @return Integer
     */
    @Override
    public Integer insertOrUpdate(T t) throws SQLException {
        fillFunction.accept(t);
        return getBaseMapper().insertOrUpdate(t);
    }


    /**
     * 批量插入或更新
     *
     * @param tList tList
     * @return Integer
     */
    @Override
    public Integer insertOrUpdateBatch(List<T> tList) throws SQLException {
        int successCount = 0;
        for (T t : tList) {
            try {
                Integer count = insertOrUpdate(t);
                successCount += count == null ? 0 : count;
            } catch (Exception e) {
                throw new SQLException("insert or update error", e);
            }
        }

        return successCount;
    }

    /**
     * 条件分页查询
     *
     * @param page page
     * @param limit limit
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            Map<String, Object> filterMap
    ) throws SQLException {
        return conditionPageQuery(page, limit, "params", filterMap);
    }


    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param paramsKey paramsKey
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            String paramsKey,
            Map<String, Object> filterMap
    ) throws SQLException {
        try {
            PageInfo<T> pageInfo = ConditionQueryUtil.conditionQuery(
                    page,
                    limit,
                    filterMap,
                    paramsKey,
                    condition -> getBaseMapper().multipleConditionQuery(condition),
                    entityClass
            );
            List<T> list = pageInfo.getList();
            PageResult<T> pageResult = new PageResult<>();
            pageResult.setPages(pageInfo.getPages());
            pageResult.setPageNum(pageInfo.getPageNum());
            pageResult.setPageSize(pageInfo.getPageSize());
            pageResult.setTotal(pageInfo.getTotal());
            pageResult.setList(list);
            return pageResult;
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException |
                 IllegalAccessException e
        ) {
            throw new SQLException("condition query error", e);
        }
    }

    @Override
    public List<T> conditionQuery(Map<String, Object> filterMap) throws SQLException {
        return conditionQuery("params", filterMap);
    }

    @Override
    public List<T> conditionQuery(String paramsKey, Map<String, Object> filterMap) throws SQLException {
        T condition = null;
        try {
            condition = ConditionBuildUtil.getMapContainsCondition(
                    filterMap,
                    paramsKey,
                    entityClass
            );
        } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                 IllegalAccessException e) {
            throw new SQLException(e);
        }

        return getBaseMapper().multipleConditionQuery(condition);
    }

    /**
     * 删除
     *
     * @param ids ids
     * @return Result
     */
    @Transactional
    public Boolean delete(List<Integer> ids) {
        return removeBatchByIds(ids);
    }


    protected <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }

    protected Integer toInteger(Object obj) {
        return obj == null ? null : Integer.valueOf(obj.toString());
    }
}
package cn.com.vortexa.bot_platform.controller;

import cn.com.vortexa.bot_platform.dto.BotJob;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.common.vo.PageQuery;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.control.anno.RPCReference;
import cn.com.vortexa.bot_platform.service.IBotInstanceService;
import cn.com.vortexa.rpc.api.bot.IScriptAgentRPC;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;
import java.util.List;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@RestController
@RequestMapping("/botInstance")
public class BotInstanceController {

    @Autowired
    private IBotInstanceService botInstanceService;

    @RPCReference
    private IScriptAgentRPC scriptAgentRPC;

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(botInstanceService.conditionPageQueryAllInfo(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @PostMapping("/onlineInstance")
    public Result onlineInstance() {
        List<RegisteredService> registeredServices = botInstanceService.queryOnLineInstance();
        return Result.ok(registeredServices);
    }

    @PostMapping("/startJob")
    public Result startJob(@RequestBody BotJob botJob) throws BotStartException {
        return botInstanceService.startJob(botJob);
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import cn.com.vortexa.bot_platform.dto.BotJob;
import cn.com.vortexa.bot_platform.script_control.BotPlatformControlServer;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.bot_platform.mapper.BotInfoMapper;
import cn.com.vortexa.control.constant.WSControlSystemConstants;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.bot_platform.mapper.BotInstanceMapper;
import cn.com.vortexa.bot_platform.service.IBotInstanceService;

import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import lombok.extern.slf4j.Slf4j;

import org.quartz.JobExecutionContext;
import org.quartz.Scheduler;
import org.quartz.Trigger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@Slf4j
@Service
public class BotInstanceServiceImpl extends AbstractBaseService<BotInstanceMapper, BotInstance>
        implements IBotInstanceRPC, IBotInstanceService {

    @Autowired
    private BotInfoMapper botInfoMapper;

    @Lazy
    @Autowired
    private BotPlatformControlServer botControlServer;

    @Autowired
    private Scheduler scheduler;

    public BotInstanceServiceImpl() {
        super(botInstance -> {
            botInstance.setInsertDatetime(LocalDateTime.now());
            botInstance.setUpdateDatetime(LocalDateTime.now());
            botInstance.setIsValid(1);
        });
    }


    @Override
    public PageResult<BotInstanceVO> conditionPageQueryAllInfo(Integer page, Integer limit,
        Map<String, Object> filterMap) throws SQLException {

        PageResult<BotInstance> result = super.conditionPageQuery(page, limit, filterMap);

        // 填充botInfo
        List<Integer> botIds = result.getList().stream().map(BotInstance::getBotId).toList();
        Map<Integer, BotInfo> idMapBotInfo = botInfoMapper.selectBatchIds(botIds)
            .stream().collect(Collectors.toMap(BotInfo::getId, botInfo -> botInfo));

        List<String> botKeys = result.getList().stream().map(BotInstance::getBotKey).toList();

        // 查询运行中的任务
        Map<String, List<Trigger>> groupByBotKey = scheduler.getCurrentlyExecutingJobs()
            .stream()
            .map(JobExecutionContext::getTrigger)
            .collect(Collectors.groupingBy(trigger -> trigger.getJobKey().getGroup()));

        ArrayList<BotInstanceVO> voList = new ArrayList<>();
        for (BotInstance instance : result.getList()) {
            BotInstanceVO vo = new BotInstanceVO();

            vo.setBotInstance(instance);
            vo.setBotInfo(idMapBotInfo.get(instance.getBotId()));
            vo.setRunningJob(JSONObject.toJSONString(groupByBotKey.get(instance.getBotKey())));

            instance.addParam(BotInstance.BOT_INSTANCE_STATUS_KEY, botControlServer.getBotInstanceStatus(
                WSControlSystemConstants.DEFAULT_GROUP, instance.getBotName(), instance.getBotKey()
            ));
        }

        return new PageResult<>(
            result.getTotal(),
            voList,
            result.getPages(),
            result.getPageNum(),
            result.getPageSize()
        );
    }

    @Override
    public Boolean existsBotInstance(BotInstance query) {
        return getBaseMapper().exists(new QueryWrapper<>(query));
    }

    @Override
    public List<RegisteredService> queryOnLineInstance() {
        List<RegisteredService> res = new ArrayList<>();
        List<String> keys = botControlServer.getConnectionService().queryOnlineInstanceKey();
        keys.forEach(key -> res.addAll(botControlServer.getRegistryService().queryServiceInstance(key)));
        res.forEach(service -> {
            BotInstanceMapper mapper = getBaseMapper();
            BotInstance botInstance = mapper.selectOne(
                    new QueryWrapper<>(BotInstance.builder().botKey(service.getAddress().getInstanceId()).build())
            );
            service.addProps("bot_info", botInstance);
        });
        return res;
    }

    @Override
    public Result startJob(BotJob botJob) throws BotStartException {
        try {
            return botControlServer.startJob(
                    botJob.getGroup(),
                    botJob.getBotName(),
                    botJob.getBotKey(),
                    botJob.getJobName()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("[{}] start job error", botJob, e);
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @Override
    public Boolean existsBotInstanceRPC(BotInstance query) {
        return existsBotInstance(query);
    }

    @Override
    public Integer insertOrUpdateRPC(BotInstance instance) throws SQLException {
        return insertOrUpdate(instance);
    }

    @Override
    public BotInstance selectOneRPC(BotInstance query) {
        return getOne(new QueryWrapper<>(query));
    }
}
package cn.com.vortexa.bot_platform.service;

import cn.com.vortexa.bot_platform.dto.BotJob;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.exception.BotStartException;
import cn.com.vortexa.common.vo.BotInstanceVO;
import cn.com.vortexa.db_layer.service.IBaseService;

import java.sql.SQLException;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
public interface IBotInstanceService extends IBaseService<BotInstance> {

    Boolean existsBotInstance(BotInstance query);

    /**
     * 查询正在运行的bot实例
     *
     * @return List<BotInfo>
     */
    List<RegisteredService> queryOnLineInstance();

    /**
     * 启动job
     *
     * @param botJob botJob
     * @return boolean
     */
    Result startJob(BotJob botJob) throws BotStartException;

    /**
     * 分页查询bot instance 的全信息
     *
     * @param page page
     * @param limit limit
     * @param filterMap filterMap
     * @return PageResult<BotInstanceVO>
     */
    PageResult<BotInstanceVO> conditionPageQueryAllInfo(Integer page, Integer limit, Map<String, Object> filterMap)
        throws SQLException;
}
package cn.com.vortexa.bot_platform;

import cn.com.vortexa.common.util.BannerUtil;
import cn.com.vortexa.db_layer.DBLayerAutoConfig;
import cn.com.vortexa.job.JobAutoConfig;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = "cn.com.vortexa.bot_platform.mapper")
@ImportAutoConfiguration(classes = {DBLayerAutoConfig.class, JobAutoConfig.class})
public class BotPlatformApplication {
    public static void main(String[] args) {
        BannerUtil.printBanner("");
        SpringApplication.run(BotPlatformApplication.class, args);
    }
}
package cn.com.vortexa.script_node.scriptagent;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.control.constant.ExtFieldsConstants;
import cn.com.vortexa.script_node.config.AutoBotConfig;
import cn.com.vortexa.common.constants.BotExtFieldConstants;
import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.util.DiscardingBlockingQueue;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.script_node.util.log.AppendLogger;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author helei
 * @since 2025/3/26 17:04
 */
@Slf4j
public class BotScriptAgentLogUploadService {

    public static final int LOG_SEND_MAX_INTERVAL = 30;

    private final BotScriptAgent botScriptAgent;

    private final DiscardingBlockingQueue<AppendLogger.LogContent> logCache = new DiscardingBlockingQueue<>(
            AutoBotConfig.LOG_CACHE_COUNT);

    private final AtomicBoolean upload = new AtomicBoolean(false);

    private volatile String bindUploadTXId;

    public BotScriptAgentLogUploadService(BotScriptAgent botScriptAgent) {
        this.botScriptAgent = botScriptAgent;
    }

    public void pushLog(AppendLogger.LogContent content) {
        try {
            logCache.put(content);
        } catch (InterruptedException e) {
            log.error("put script node log error", e);
        }
    }

    /**
     * 开始上传日志命令处理器
     *
     * @param channel channel
     * @param command command
     * @return RemotingCommand
     */
    public RemotingCommand startUploadLogRCHandler(Channel channel, RemotingCommand command) {
        // 开始上传日志
        String logUploadTXID = command.getExtFieldsValue(BotExtFieldConstants.LOG_UPLOAD_TX_ID);

        log.info("start upload log, logUploadTXID[{}]", logUploadTXID);
        RemotingCommand response = new RemotingCommand();
        response.setTransactionId(command.getTransactionId());
        response.setCode(RemotingCommandCodeConstants.FAIL);
        response.setFlag(BotRemotingCommandFlagConstants.START_UP_BOT_LOG_RESPONSE);

        // 开启日志上传任务
        if (startBotLogUploadTask(logUploadTXID)) {
            response.setCode(RemotingCommandCodeConstants.SUCCESS);
            log.info("start log upload task success, logUploadTXID[{}]", logUploadTXID);
        } else {
            log.error("start log upload task error, logUploadTXID[{}]", logUploadTXID);
            response.addExtField(ExtFieldsConstants.REQUEST_ERROR_MSG,
                    "script node log in uploading");
        }

        return response;
    }

    /**
     * 关闭上传日志命令处理器
     *
     * @param channel channel
     * @param command command
     * @return RemotingCommand
     */
    public RemotingCommand stopUploadLogRCHandler(Channel channel, RemotingCommand command) {
        upload.set(false);

        RemotingCommand response = new RemotingCommand();
        response.setTransactionId(command.getTransactionId());
        response.setCode(RemotingCommandCodeConstants.SUCCESS);
        response.setFlag(BotRemotingCommandFlagConstants.STOP_UP_BOT_LOG);

        return response;
    }

    /**
     * 开启bot日志上传任务
     *
     * @param logUploadTXID logUploadTXID
     * @return boolean
     */
    private boolean startBotLogUploadTask(String logUploadTXID) {

        if (judgeUploadAble(logUploadTXID)) {
            synchronized (this) {
                if (judgeUploadAble(logUploadTXID)) {
                    bindUploadTXId = logUploadTXID;
                    AppendLogger logger = botScriptAgent.getBot().logger;
                    logger.setBeforePrintHandler(this::pushLog);
                    AppendLogger.LogContent[] cachedLog = logger.getLogCache().toArray(new AppendLogger.LogContent[0]);

                    logCache.clear();
                    for (AppendLogger.LogContent logContent : cachedLog) {
                        try {
                            logCache.put(logContent);
                        } catch (InterruptedException e) {
                            log.error("put script node log error", e);
                            upload.set(false);
                            throw new RuntimeException(e);
                        }
                    }
                    upload.set(true);
                } else {
                    return false;
                }
            }

            botScriptAgent.getCallbackInvoker().execute(() -> {
                while (upload.get()) {
                    try {
                        String oriTxId = bindUploadTXId;
                        AppendLogger.LogContent logContent = logCache.poll(LOG_SEND_MAX_INTERVAL, TimeUnit.SECONDS);

                        // 线程醒后需判断当前要发的txId有没有变化
                        if (!bindUploadTXId.equals(oriTxId) || !upload.get()) {
                            upload.set(false);
                            continue;
                        }

                        RemotingCommand command = botScriptAgent.newRequestCommand(
                                BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG, true);
                        command.addExtField(BotExtFieldConstants.LOG_UPLOAD_TX_ID, logUploadTXID);
                        command.setPayLoad(JSONObject.toJSONString(logContent));

                        log.debug("upload log, logUploadTXID[{}]", logUploadTXID);
                        RemotingCommand response = botScriptAgent.sendRequest(command).get();
                        if (response == null || !response.isSuccess()) {
                            log.error("upload log response error, {}", response);
                            upload.set(false);
                        }
                    } catch (InterruptedException e) {
                        upload.set(false);
                        log.error("log upload task interrupted");
                    } catch (ExecutionException e) {
                        upload.set(false);
                        log.error("upload log error", e);
                    }
                }
                log.warn("stopped upload log upload task");
            });
            return true;
        }
        return false;
    }

    private boolean judgeUploadAble(String logUploadTXID) {
        return StrUtil.isNotBlank(logUploadTXID) && (!logUploadTXID.equals(bindUploadTXId)
                || upload.compareAndSet(false, true));
    }
}
package cn.com.vortexa.script_node.util.log;

import cn.com.vortexa.common.util.DiscardingBlockingQueue;
import cn.com.vortexa.script_node.config.AutoBotConfig;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.function.Consumer;

public class AppendLogger {

    private final Logger log;

    private final StringBuilder format = new StringBuilder();

    @Getter
    private final DiscardingBlockingQueue<LogContent> logCache = new DiscardingBlockingQueue<>(
        AutoBotConfig.LOG_CACHE_COUNT);

    @Setter
    private Consumer<LogContent> beforePrintHandler;

    public AppendLogger(Class<?> clazz) {
        log = LoggerFactory.getLogger(clazz);
    }

    public AppendLogger append(Object context) {
        if (!format.isEmpty()) {
            format.append(" ");
        }

        format.append(context);

        return this;
    }

    public void info(Object context) {
        log.info("\033[32m" + getPrefix(LogType.INFO, context) + "\033[0m");
    }

    public void debug(Object context) {
        log.info("\033[90m" + getPrefix(LogType.DEBUG, context) + "\033[0m");
    }

    public void warn(Object context) {
        log.warn("\033[33m" + getPrefix(LogType.WARNING, context) + "\033[0m");
    }

    public void error(Object context) {
        log.error("\033[31m" + getPrefix(LogType.ERROR, context) + "\033[0m");
    }

    public void error(Object context, Throwable e) {
        log.error("\033[31m" + getPrefix(LogType.ERROR, context) + "\033[0m", e);
    }

    private @NotNull String getPrefix(LogType type, Object context) {
        String logStr = format + " - " + context;
        LogContent logContent = new LogContent(System.currentTimeMillis(), type, logStr);

        try {
            logCache.put(logContent);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (beforePrintHandler != null) {
            beforePrintHandler.accept(logContent);
        }
        return logStr;
    }

    public enum LogType {
        DEBUG,
        SUCCESS,
        INFO,
        ERROR,
        WARNING
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class LogContent {
        private long datetime;

        private LogType type;

        private String content;
    }
}
