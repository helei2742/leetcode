package cn.com.vortexa.web3.constants;

import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import lombok.Data;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * @author h30069248
 * @since 2025/4/23 10:27
 */
@Data
public class Web3ChainDict {
    public static final String RESOURCE_FILE_NAME = "chain-info.yaml";
    public static final List<String> PREFIX = List.of("vortexa", "web3");
    public static final Web3ChainDict INSTANCE;

    static {
        try (InputStream is = Web3ChainDict.class.getClassLoader().getResourceAsStream(RESOURCE_FILE_NAME)){
            INSTANCE = YamlConfigLoadUtil.load(RESOURCE_FILE_NAME, is, PREFIX, Web3ChainDict.class);
            if (INSTANCE.chainInfo != null) {
                INSTANCE.name2ChainInfoMap = INSTANCE.chainInfo.stream().collect(Collectors.toMap(Web3ChainInfo::getName, w->w));
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static Web3ChainDict loadCustomConfigDict(String path) {
        return YamlConfigLoadUtil.load(new File(path), PREFIX, Web3ChainDict.class);
    }

    private List<Web3ChainInfo> chainInfo;

    private Map<String, Web3ChainInfo> name2ChainInfoMap;

    public Web3ChainInfo getChainInfo(String name) {
        return name2ChainInfoMap.get(name);
    }

    public static void main(String[] args) {
        System.out.println(INSTANCE);
    }

    public void marge(Web3ChainDict defaultChainDict) {
        List<Web3ChainInfo> list = defaultChainDict.getChainInfo();
        for (Web3ChainInfo web3ChainInfo : list) {
            String name = web3ChainInfo.getName();
            if (name2ChainInfoMap.containsKey(name)) {
                throw new IllegalArgumentException("chain [%s] already exist in default chain info dict".formatted(name));
            }
            name2ChainInfoMap.put(name, web3ChainInfo);
        }
    }
}
package cn.com.vortexa.web3.constants;

/**
 * @author h30069248
 * @since 2025/4/23 10:54
 */
public enum Web3jFunctionType {
    Uint256,
    Bool,
    Address
}
package cn.com.vortexa.web3.dto;

import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.hutool.core.lang.Pair;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


import java.io.Serializable;
import java.math.BigInteger;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/23 11:05
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SCInvokeParams implements Serializable {
    /**
     * 钱包id
     */
    private Integer walletId;

    /**
     * 钱包信息
     */
    private WalletInfo walletInfo;

    /**
     * 链信息
     */
    private Web3ChainInfo chainInfo;

    /**
     * 调用的合约地址
     */
    private String contractAddress;

    /**
     * gas limit
     */
    private BigInteger gasLimit;

    /**
     * 交易金额
     */
    private BigInteger value;

    /**
     * abi方法名
     */
    private String functionName;
    /**
     * 只读方法
     */
    private Boolean readFunction;
    /**
     * 参数类型
     */
    private List<Pair<Web3jFunctionType, Object>> paramsTypes;
    /**
     * 返回值类型
     */
    private List<Web3jFunctionType> resultTypes;
}
package cn.com.vortexa.web3.dto;


import cn.com.vortexa.common.constants.ChainType;
import cn.hutool.core.collection.CollUtil;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Web3ChainInfo implements Serializable {
    /**
     * 链类型
     */
    private ChainType chainType;

    private List<String> rpcUrls;

    private String name;

    private Integer chainId;

    private String originTokenSymbol;

    private String blockExploreUrl;

    public String getRpcUrl() {
        return CollUtil.isEmpty(rpcUrls) ? null : rpcUrls.getFirst();
    }
}
package cn.com.vortexa.web3.service;

import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.com.vortexa.web3.dto.SCInvokeParams;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import cn.hutool.core.lang.Pair;

import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/24 16:08
 */
public interface IWeb3WalletOPTRPC {
    /**
     * 对消息签名
     * 必须使用已注册的钱包，使用钱包id标识签名的钱包
     *
     * @param message message
     * @return Result
     */
    Result signatureMessageRPC(SignatureMessage message);

    /**
     * id批量查
     *
     * @param ids ids
     * @return TwitterAccount
     */
    List<Web3Wallet> batchQueryByIdsRPC(List<Serializable> ids);

    /**
     * 调用erc20 abi方法
     *
     * @param scInvokeParams abi调用参数
     * @return 调用结果
     */
    Result erc20ABIInvokeRPC(SCInvokeParams scInvokeParams) throws IOException;

    /**
     * 代币授权
     *
     * @param chainInfo chainInfo
     * @param walletId 钱包id
     * @param tokenContract 合约地址
     * @param amount 授权数量
     * @return Result
     * @throws IOException  IOException
     */
    default Boolean erc20ApproveRPC(Web3ChainInfo chainInfo, Integer walletId, String tokenContract, String spenderAddress, BigInteger amount)
        throws IOException {
        Result result = erc20ABIInvokeRPC(SCInvokeParams.builder()
            .walletId(walletId)
            .chainInfo(chainInfo)
            .functionName("approve")
            .contractAddress(tokenContract)
            .paramsTypes(List.of(
                Pair.of(Web3jFunctionType.Address, spenderAddress),
                Pair.of(Web3jFunctionType.Uint256, amount)
            ))
            .resultTypes(List.of(Web3jFunctionType.Bool))
            .build()
        );

        if (result.getSuccess()) {
            return (Boolean) result.getData();
        } else {
            throw new IOException("erc20 approve rpc error, " + result.getErrorMsg());
        }
    }

    /**
     * 查某token的数量
     *
     * @param chainInfo chainInfo
     * @param walletId 钱包id
     * @param tokenContract 合约地址
     * @param walletAddress 钱包地址
     * @return  Result
     * @throws IOException  IOException
     */
    default BigInteger erc20BalanceOfRPC(Web3ChainInfo chainInfo, Integer walletId, String tokenContract, String walletAddress)
        throws IOException {
        Result result = erc20ABIInvokeRPC(SCInvokeParams.builder()
            .walletId(walletId)
            .chainInfo(chainInfo)
            .readFunction(true)
            .functionName("balanceOf")
            .contractAddress(tokenContract)
            .paramsTypes(List.of(
                Pair.of(Web3jFunctionType.Address, walletAddress)
            ))
            .resultTypes(List.of(Web3jFunctionType.Uint256))
            .build()
        );

        if (result.getSuccess()) {
            return (BigInteger) result.getData();
        } else {
            throw new IOException("erc20 balanceOf rpc error, " + result.getErrorMsg());
        }
    }

    /**
     * 查看spenderAddress能够使用的tokenContract的数量
     *
     * @param chainInfo chainInfo
     * @param walletId 钱包id
     * @param tokenContract 合约地址
     * @param spenderAddress spenderAddress
     * @return  Result
     * @throws IOException  IOException
     */
    default BigInteger erc20AllowanceRPC(Web3ChainInfo chainInfo, Integer walletId, String tokenContract, String spenderAddress, String walletAddress)
        throws IOException {
        Result result = erc20ABIInvokeRPC(SCInvokeParams.builder()
            .walletId(walletId)
            .chainInfo(chainInfo)
            .functionName("allowance")
            .contractAddress(tokenContract)
            .paramsTypes(List.of(
                Pair.of(Web3jFunctionType.Address, walletAddress),
                Pair.of(Web3jFunctionType.Address, spenderAddress)
            ))
            .resultTypes(List.of(Web3jFunctionType.Uint256))
            .build()
        );

        if (result.getSuccess()) {
            return (BigInteger) result.getData();
        } else {
            throw new IOException("erc20 allowance rpc error, " + result.getErrorMsg());
        }
    }

    /**
     * 查看spenderAddress能够使用的tokenContract的数量
     *
     * @param chainInfo chainInfo
     * @param walletId 钱包id
     * @param tokenContract 合约地址
     * @return  Result
     * @throws IOException  IOException
     */
    default BigInteger erc20DecimalsRPC(Web3ChainInfo chainInfo, Integer walletId, String tokenContract)
        throws IOException {
        Result result = erc20ABIInvokeRPC(SCInvokeParams.builder()
            .walletId(walletId)
            .chainInfo(chainInfo)
            .functionName("decimals")
            .readFunction(true)
            .contractAddress(tokenContract)
            .paramsTypes(List.of())
            .resultTypes(List.of(Web3jFunctionType.Uint256))
            .build()
        );

        if (result.getSuccess()) {
            return (BigInteger) result.getData();
        } else {
            throw new IOException("erc20 decimals rpc error, " + result.getErrorMsg());
        }
    }
}
package cn.com.vortexa.web3.util;

import cn.com.vortexa.web3.constants.Web3jFunctionType;

import org.web3j.abi.TypeReference;
import org.web3j.abi.datatypes.Address;
import org.web3j.abi.datatypes.Bool;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.abi.datatypes.generated.Uint256;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/23 10:51
 */
public class ABIFunctionBuilder {
    private String functionName;
    private final List<Type> parameterTypes = new ArrayList<>();
    private final List<TypeReference<?>> returnTypes = new ArrayList<>();

    public static ABIFunctionBuilder builder() {
        return new ABIFunctionBuilder();
    }

    public ABIFunctionBuilder functionName(String functionName) {
        this.functionName = functionName;
        return this;
    }

    public ABIFunctionBuilder addParameterType(Web3jFunctionType type, Object value) {
        parameterTypes.add(switch (type) {
            case Uint256 -> new Uint256((BigInteger) value);
            case Bool -> new Bool((Boolean) value);
            case Address -> new Address(String.valueOf(value));
        });
        return this;
    }

    public ABIFunctionBuilder addReturnType(Web3jFunctionType type) {
        returnTypes.add(switch (type) {
            case Uint256 -> new TypeReference<Uint256>() {};
            case Bool -> new TypeReference<Bool>() {};
            case Address -> new TypeReference<Address>() {};
        });
        return this;
    }

    public Function build() {
        return new Function(functionName, parameterTypes, returnTypes);
    }
}
package cn.com.vortexa.web3;

import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.com.vortexa.web3.util.ABIFunctionBuilder;

import org.bitcoinj.crypto.*;
import org.jetbrains.annotations.NotNull;
import org.web3j.abi.FunctionEncoder;
import org.web3j.abi.FunctionReturnDecoder;
import org.web3j.abi.datatypes.Function;
import org.web3j.abi.datatypes.Type;
import org.web3j.crypto.*;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.DefaultBlockParameterName;
import org.web3j.protocol.core.methods.request.Transaction;
import org.web3j.protocol.core.methods.response.EthCall;
import org.web3j.protocol.core.methods.response.EthEstimateGas;
import org.web3j.protocol.core.methods.response.EthSendTransaction;
import org.web3j.protocol.http.HttpService;
import org.web3j.utils.Numeric;

import java.io.IOException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;

/**
 * @author helei
 * @since 2025/3/28 11:16
 */
public class EthWalletUtil {

    /**
     * 默认Gas limit
     */
    private static final BigInteger DEFAULT_GAS_LIMIT = BigInteger.valueOf(200_000);

    private static final SecureRandom secureRandom = new SecureRandom();

    /**
     * 生成eth钱包信息
     *
     * @return  WalletInfo
     */
    public static WalletInfo generateEthWallet() {
        return generateWalletInfoFromMnemonic(generateMnemonic());
    }

    /**
     * 生成助记词
     *
     * @return  String
     */
    public static String generateMnemonic() {
        // 1. 生成助记词
        SecureRandom secureRandom = new SecureRandom();
        byte[] entropy = new byte[16]; // 128 bits entropy
        secureRandom.nextBytes(entropy);

        // 使用 bitcoinj 生成助记词
        var mnemonicCode = MnemonicCode.INSTANCE;
        List<String> mnemonicWords = null;
        try {
            mnemonicWords = mnemonicCode.toMnemonic(entropy);
        } catch (MnemonicException.MnemonicLengthException e) {
            throw new RuntimeException(e);
        }
        return String.join(" ", mnemonicWords);
    }

    /**
     * 助记词生成钱包信息
     *
     * @param mnemonic  mnemonic
     * @return  WalletInfo
     */
    public static WalletInfo generateWalletInfoFromMnemonic(String mnemonic) {
        // 2. 生成 seed
        byte[] seed = MnemonicUtils.generateSeed(mnemonic, ""); // passphrase 可设置

        // 3. 创建 HD 钱包根节点 (BIP32 Root Key)
        DeterministicKey rootPrivateKey = HDKeyDerivation.createMasterPrivateKey(seed);

        // 4. 分步派生 BIP44 路径 m/44'/60'/0'/0/0
        DeterministicKey purposeKey = HDKeyDerivation.deriveChildKey(rootPrivateKey, new ChildNumber(44, true));
        DeterministicKey coinTypeKey = HDKeyDerivation.deriveChildKey(purposeKey, new ChildNumber(60, true));
        DeterministicKey accountKey = HDKeyDerivation.deriveChildKey(coinTypeKey, new ChildNumber(0, true));
        DeterministicKey externalKey = HDKeyDerivation.deriveChildKey(accountKey, ChildNumber.ZERO); // change = 0
        DeterministicKey addressKey = HDKeyDerivation.deriveChildKey(externalKey,
                ChildNumber.ZERO); // address index = 0

        byte[] privateKeyBytes = addressKey.getPrivKeyBytes();

        // 转为 web3j 的 ECKeyPair
        ECKeyPair keyPair = ECKeyPair.create(privateKeyBytes);
        Credentials credentials = Credentials.create(keyPair);

        // 6. 输出钱包信息
        return WalletInfo.builder()
                .mnemonic(mnemonic)
                .privateKey(keyPair.getPrivateKey().toString(16))
                .publicKey(keyPair.getPublicKey().toString(16))
                .address(credentials.getAddress())
                .build();
    }

    /**
     * 前面消息
     *
     * @param privateKey    privateKey
     * @param message   message
     * @return  Sign.SignatureData
     */
    public static Sign.SignatureData signatureMessage2Data(String privateKey, String message) {
        byte[] contentHashBytes = message.getBytes();
        // 根据私钥获取凭证对象
        Credentials credentials = Credentials.create(privateKey);
        return Sign.signPrefixedMessage(contentHashBytes, credentials.getEcKeyPair());
    }

    /**
     * 前签名消息成String
     *
     * @param privateKey    privateKey
     * @param message   message
     * @return  String
     */
    public static String signatureMessage2String(String privateKey, String message) {
        Sign.SignatureData signMessage = signatureMessage2Data(privateKey, message);

        byte[] r = signMessage.getR();
        byte[] s = signMessage.getS();
        byte[] v = signMessage.getV();

        byte[] signByte = Arrays.copyOf(r, v.length + r.length + s.length);
        System.arraycopy(s, 0, signByte, r.length, s.length);
        System.arraycopy(v, 0, signByte, r.length + s.length, v.length);

        return Numeric.toHexString(signByte);
    }

    /**
     * 私钥获取地址
     *
     * @param privateKeyHex privateKeyHex
     * @return  String
     */
    public static String getETHAddress(String privateKeyHex) {
        Credentials credentials = Credentials.create(privateKeyHex);

        // 获取原始地址（小写）
        String rawAddress = credentials.getAddress();

        // 将地址转换为区分大小写的 Checksum 地址
        return Keys.toChecksumAddress(rawAddress);
    }



    public static String getRandomNonce() {
        // 生成 32 字节的随机数
        byte[] randomBytes = new byte[32];
        secureRandom.nextBytes(randomBytes);

        // 将字节数组转换为十六进制字符串
        return toHex(randomBytes);
    }

    // 将字节数组转换为十六进制字符串
    public static String toHex(byte[] bytes) {
        return Numeric.toHexString(bytes);
    }

    /**
     * approve token
     *
     * @param rpcUrl    rpcUrl
     * @param tokenAddress 代币地址
     * @param spenderAddress 代币合约地址
     * @param walletPrimaryKey  钱包私钥
     * @param walletAddress 钱包公钥
     * @param amount    授权数量
     * @return  String
     * @throws IOException  IOException
     */
    public static String erc20ApproveToken(
        String rpcUrl, String tokenAddress, String spenderAddress, String walletPrimaryKey, String walletAddress, BigInteger amount
    ) throws IOException {
        return EthWalletUtil.smartContractTransactionInvoke(
            rpcUrl, tokenAddress, walletPrimaryKey, walletAddress, null, amount,
            ABIFunctionBuilder.builder()
                .functionName("approve")
                .addParameterType(Web3jFunctionType.Address, spenderAddress)
                .addParameterType(Web3jFunctionType.Uint256, amount)
        );
    }

    /**
     * 智能合约调用 只读
     *
     * @param rpcUrl          rpcUrl
     * @param contractAddress contractAddress
     * @param address         address
     * @param functionBuilder functionBuilder
     * @return List<Type>
     * @throws IOException IOException
     */
    public static List<Type> smartContractCallInvoke(
            String rpcUrl,
            String contractAddress,
            String address,
            ABIFunctionBuilder functionBuilder
    ) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        Function function = functionBuilder.build();
        Transaction transaction = Transaction.createEthCallTransaction(
                address,
                contractAddress,
                FunctionEncoder.encode(function)
        );

        EthCall response = web3j.ethCall(
                transaction,
                DefaultBlockParameterName.LATEST
        ).send();
        return FunctionReturnDecoder.decode(response.getValue(), function.getOutputParameters());
    }

    /**
     * 智能合约调用 上链
     *
     * @param rpcUrl          rpcUrl
     * @param contractAddress 合约地址
     * @param primaryKey    钱包私钥
     * @param address        钱包地址
     * @param gasLimit  gasLimit
     * @param value         发生金额
     * @param functionBuilder functionBuilder
     * @return transaction hash
     * @throws IOException 网络不通， 获取hash失败都会抛出次异常
     */
    public static String smartContractTransactionInvoke(
            String rpcUrl,
            String contractAddress,
            String primaryKey,
            String address,
            BigInteger gasLimit,
            BigInteger value,
            ABIFunctionBuilder functionBuilder
    ) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        // Step 1 构建transaction
        Function function = functionBuilder.build();
        String encodeFunction = FunctionEncoder.encode(function);
        BigInteger nonce = getNonce(web3j, address);
        BigInteger gasPrice = getGasPrice(web3j);
        if (gasLimit == null) {
            gasLimit = dynamicCalGasLimit(
                web3j, contractAddress, address, gasPrice, encodeFunction
            );
        }
        if (value == null) value = BigInteger.ZERO;

        // Step 2 构建交易信息
        RawTransaction rawTX = RawTransaction.createTransaction(
            nonce, gasPrice, gasLimit, contractAddress, value, encodeFunction
        );

        byte[] signedMessage = TransactionEncoder.signMessage(rawTX, Credentials.create(primaryKey));
        String hexString = Numeric.toHexString(signedMessage);

        // Step 3 发生交友
        EthSendTransaction send = web3j.ethSendRawTransaction(hexString).send();

        // Step 4 获取交易hash值
        if (send.hasError()) {
            throw new IOException("Transaction Error: " + send.getError().getMessage());
        }
        return send.getTransactionHash();
    }

    /**
     * 动态计算gasLimit
     * @return  BigInteger
     */
    public static BigInteger dynamicCalGasLimit(
        Web3j web3j,
        String contractAddress,
        String walletAddress,
        BigInteger gasPrice,
        String encodeFunction
    ) throws IOException {

        EthEstimateGas ethEstimateGas = web3j.ethEstimateGas(Transaction.createFunctionCallTransaction(
            contractAddress,
            null,
            gasPrice,
            null,
            walletAddress,
            BigInteger.ZERO,
            encodeFunction
        )).send();
        return ethEstimateGas.getAmountUsed();
    }

    /**
     * 获取地址nonce
     *
     * @param rpcUrl rpcUrl
     * @param address address
     * @return  nonce
     * @throws IOException IOException
     */
    public static BigInteger getNonce(String rpcUrl, String address) throws IOException {
        return getNonce(Web3j.build(new HttpService(rpcUrl)), address);
    }

    /**
     * 获取地址nonce
     *
     * @param web3j web3j
     * @param address address
     * @return  nonce
     * @throws IOException IOException
     */
    public static BigInteger getNonce(@NotNull Web3j web3j, String address) throws IOException {
        return web3j.ethGetTransactionCount(address, DefaultBlockParameterName.PENDING)
            .send().getTransactionCount();
    }

    /**
     * 获取rpc的gas
     *
     * @param rpcUrl rpcUrl
     * @return  nonce
     * @throws IOException IOException
     */
    public static BigInteger getGasPrice(String rpcUrl) throws IOException {
        return getGasPrice(Web3j.build(new HttpService(rpcUrl)));
    }

    /**
     * 获取rpc的gas
     *
     * @param web3j web3j
     * @return  nonce
     * @throws IOException IOException
     */
    public static BigInteger getGasPrice(@NotNull Web3j web3j) throws IOException {
        return web3j.ethGasPrice().send().getGasPrice();
    }
}
vortexa:
  web3:
    chain-info:
      - name: Sepolia
        rpcUrls:
          - https://ethereum-sepolia-rpc.publicnode.com
          - https://rpc.sepolia.org
        chainId: 11155111
        originTokenSymbol: ETH
        blockExploreUrl: https://sepolia.etherscan.io

package cn.com.vortexa.bot_platform.service.impl;

import static cn.com.vortexa.common.entity.Web3Wallet.PUBLIC_FIELDS;

import cn.com.vortexa.bot_platform.web3.SmartContractInvoker;
import cn.com.vortexa.control_server.service.IConnectionService;
import cn.com.vortexa.web3.dto.SCInvokeParams;
import cn.com.vortexa.web3.dto.SCInvokeResult;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import cn.com.vortexa.web3.service.IWeb3WalletOPTRPC;
import cn.hutool.core.collection.CollUtil;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.bot_platform.mapper.Web3WalletMapper;
import cn.com.vortexa.bot_platform.service.IWeb3WalletService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.excel.ExcelReadUtil;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.SolanaWalletUtil;
import cn.com.vortexa.common.constants.ChainType;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.math.BigInteger;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@Slf4j
@Service
public class Web3WalletServiceImpl extends AbstractBaseService<Web3WalletMapper, Web3Wallet>
        implements IWeb3WalletOPTRPC, IWeb3WalletService {

    private final Web3WalletMapper web3WalletMapper;

    public Web3WalletServiceImpl(Web3WalletMapper web3WalletMapper) {
        super();
        this.web3WalletMapper = web3WalletMapper;
    }

    @Override
    public Result signatureMessageRPC(SignatureMessage message) {
        return signatureMessage(message);
    }

    @Override
    public List<Web3Wallet> batchQueryByIdsRPC(List<Serializable> ids) {
        return batchQueryByIds(ids);
    }

    @Override
    public Result erc20ABIInvokeRPC(SCInvokeParams scInvokeParams) throws IOException {
        return smartContractInvoke(scInvokeParams);
    }

    @Override
    public List<Web3Wallet> batchQueryByIds(List<Serializable> ids) {
        if (CollUtil.isEmpty(ids)) {
            return List.of();
        }
        QueryWrapper<Web3Wallet> queryWrapper = new QueryWrapper<>();
        queryWrapper.select(PUBLIC_FIELDS);
        queryWrapper.in("id", ids);
        return baseMapper.selectList(queryWrapper);
    }

    @Override
    public Result signatureMessage(SignatureMessage signatureMessage) {
        Integer walletId;
        String message;
        if ((walletId = signatureMessage.getWalletId()) == null || walletId < 0 || StrUtil.isBlank(
                message = signatureMessage.getMessage())) {
            return Result.fail("params illegal");
        }

        Web3Wallet web3Wallet = baseMapper.selectOne(new QueryWrapper<>(Web3Wallet.builder().id(walletId).build()));
        if (web3Wallet == null) {
            return Result.fail("wallet %s not exist".formatted(walletId));
        }

        ChainType chainType = signatureMessage.getChainType();
        try {
            String signature = switch (chainType) {
                case ETH -> EthWalletUtil.signatureMessage2String(web3Wallet.getEthPrivateKey(), message);
                case SOL -> SolanaWalletUtil.signatureMessage2String(web3Wallet.getSolPrivateKey(), message);
                case null -> throw new IllegalArgumentException("chain type[%s] not support".formatted(chainType));
            };
            return Result.ok(signature);
        } catch (Exception e) {
            log.error("{} signature chain[{}] message[{}] fail", walletId, chainType, message, e);
            return Result.fail("signature failed");
        }
    }

    @Override
    public Result smartContractInvoke(SCInvokeParams invokeParams) throws IOException {
        if (invokeParams.getWalletId() == null && invokeParams.getWalletInfo() == null) {
            return Result.fail("walletId or walletInfo must be provided");
        }

        Web3ChainInfo chainInfo = invokeParams.getChainInfo();
        if (chainInfo == null) {
            return Result.fail("chainInfo must be provided");
        }

        WalletInfo wallet = invokeParams.getWalletInfo() == null
                ? new WalletInfo(chainInfo.getChainType(), web3WalletMapper.selectById(invokeParams.getWalletId()))
                : invokeParams.getWalletInfo();

        SCInvokeResult result = switch (chainInfo.getChainType()) {
            case ETH -> SmartContractInvoker.CHAIN.ETH.invokeSCFunction(wallet, chainInfo, invokeParams);
            default ->
                    throw new IllegalArgumentException("chain type[%s] not support".formatted(chainInfo.getChainType()));
        };

        return Result.ok(result);
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getAppResourceSystemConfigDir() + File.separator + fileBotConfigPath;
        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);
            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("read wallet file[{}] error", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<Web3Wallet> web3Wallets = new ArrayList<>();
        for (Map<String, Object> line : rawLines) {
            String mnemonic = String.valueOf(line.get("mnemonic"));
            Web3Wallet.Web3WalletBuilder builder = Web3Wallet.builder().mnemonic(mnemonic);

            WalletInfo ethWallet = EthWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.ethPrivateKey(ethWallet.getPrivateKey());
            builder.ethAddress(ethWallet.getAddress());

            WalletInfo solWallet = SolanaWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.solPrivateKey(solWallet.getPrivateKey());
            builder.solAddress(solWallet.getAddress());
        }
        return insertOrUpdateBatch(web3Wallets);
    }
}
package cn.com.vortexa.bot_platform.web3;

import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.com.vortexa.web3.dto.SCInvokeParams;
import cn.com.vortexa.web3.dto.SCInvokeResult;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.com.vortexa.web3.dto.Web3ChainInfo;
import cn.com.vortexa.web3.util.ABIFunctionBuilder;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.lang.Pair;

import org.web3j.abi.datatypes.Type;

import java.io.IOException;

import java.util.List;

/**
 * 智能合约调用器
 *
 * @author helei
 * @since 2025/4/23 10:11
 */
public interface SmartContractInvoker {
    /**
     * 执行智能合约交互
     *
     * @param walletInfo  钱包信息
     * @param chainInfo  链信息
     * @param scInvokeParams 调用参数
     * @return  SCInvokeResult
     * @throws IOException  IOException
     */
    SCInvokeResult invokeSCFunction(
            WalletInfo walletInfo,
            Web3ChainInfo chainInfo,
            SCInvokeParams scInvokeParams
    ) throws IOException;

    enum CHAIN implements SmartContractInvoker {
        ETH {
            @Override
            public  SCInvokeResult invokeSCFunction(
                    WalletInfo walletInfo,
                    Web3ChainInfo chainInfo,
                    SCInvokeParams scInvokeParams
            ) throws IOException {
                List<Web3jFunctionType> resultTypes = scInvokeParams.getResultTypes();

                // Step 1 构建合约调用方法
                ABIFunctionBuilder functionBuilder = ABIFunctionBuilder
                        .builder()
                        .functionName(scInvokeParams.getFunctionName());

                if (CollUtil.isNotEmpty(scInvokeParams.getParamsTypes())) {
                    for (Pair<Web3jFunctionType, Object> paramsType : scInvokeParams.getParamsTypes()) {
                        functionBuilder.addParameterType(paramsType.getKey(), paramsType.getValue());
                    }
                }
                if (CollUtil.isNotEmpty(resultTypes)) {
                    for (Web3jFunctionType resultType : resultTypes) {
                        functionBuilder.addReturnType(resultType);
                    }
                }

                // Step 3 调用合约
                SCInvokeResult result = new SCInvokeResult();
                if (scInvokeParams.getReadFunction()) {
                    List<Type> types = EthWalletUtil.smartContractCallInvoke(
                            chainInfo.getRpcUrl(),
                            scInvokeParams.getContractAddress(),
                            walletInfo.getAddress(),
                            functionBuilder
                    );
                    result.setResult(types.stream().map(Type::getValue).toList());
                } else {
                    String transactionHash = EthWalletUtil.smartContractTransactionInvoke(
                            chainInfo.getRpcUrl(),
                            scInvokeParams.getContractAddress(),
                            walletInfo.getPrivateKey(),
                            walletInfo.getAddress(),
                            scInvokeParams.getGasLimit(),
                            scInvokeParams.getValue(),
                            functionBuilder
                    );
                    result.setTransactionHash(transactionHash);
                }

                return result;
            }
        }
    }
}
package cn.com.vortexa.script_node.config;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.config.AutoBotAccountConfig;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.com.vortexa.common.dto.BotMetaInfo;
import cn.com.vortexa.web3.constants.Web3ChainDict;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Stream;

/**
 * @author helei
 * @since 2025-04-04
 */
@Slf4j
@Data
@Component
@ConfigurationProperties(prefix = "vortexa.script-node")
public class ScriptNodeConfiguration implements InitializingBean {
    public static final String CUSTOM_CHAIN_INFO_DICT = "custom-chain-info.yaml";
    public static final String BOT_META_INF_FILE_NAME = "bot-meta-info.yaml";
    public static final List<String> BOT_META_INFO_PREFIX = List.of("vortexa", "botMetaInfo");
    public static final List<String> BOT_INSTANCE_CONFIG_PREFIX = List.of("vortexa", "botInstance");

    /**
     * bot group（Script Node中运行的bot的group)
     * ）
     */
    private String scriptNodeName;

    /**
     * 远程REST接口的url
     */
    private String remoteRestUrl;

    /**
     * 链信息字典
     */
    private Web3ChainDict chainDict;

    /**
     * bot-instance jar包名字
     */
    private List<String> botInstanceJarNames;

    /**
     * Script node 基础路径
     */
    private String scriptNodeBasePath;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;

    /**
     * botNameMetaInfoMap, （解析配置文件自动填入）
     */
    private Map<String, BotMetaInfo> botNameMetaInfoMap;

    /**
     * botKeyConfigMap, （解析配置文件自动填入）
     */
    private Map<String, AutoBotConfig> botKeyConfigMap;

    /**
     * 自动时自动启动的botKey
     */
    private Set<String> autoLaunchBotKeys;

    /**
     * bot公共配置，会加载到每个bot的 customConfig下
     *
     * @see AutoBotConfig
     */
    private Map<String, Object> botCommonConfig;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 解析地址，
        scriptNodeBasePath = FileUtil.getAppResourceAppConfigDir() + File.separator + scriptNodeName;

        initChainDict();

        initBotMetaInfo();

        initBotInstance();
    }

    /**
     * 获取远程设置api
     *
     * @return  String
     */
    public String buildRemoteConfigRestApi() {
        return remoteRestUrl + "/script-node/remote-config";
    }

    /**
     * 链信息列表
     */
    private void initChainDict() {
        Web3ChainDict defaultChainDict = Web3ChainDict.INSTANCE;
        Web3ChainDict customChainDict = Web3ChainDict.loadCustomConfigDict(CUSTOM_CHAIN_INFO_DICT);
        if (customChainDict != null) {
            customChainDict.marge(defaultChainDict);
        }
        this.chainDict = customChainDict == null ? defaultChainDict : customChainDict;
    }

    /**
     * 初始化BotInstance
     */
    private void initBotInstance() {
        botKeyConfigMap = new HashMap<>();
        String botInstanceConfigDir = FileUtil.getBotInstanceConfigDir();

        try (Stream<Path> walk = Files.walk(Paths.get(botInstanceConfigDir), 5)) {
            walk.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(".yaml")).forEach(configFile -> {
                try {
                    AutoBotConfig botConfig = YamlConfigLoadUtil.load(configFile.toFile(), BOT_INSTANCE_CONFIG_PREFIX,
                        AutoBotConfig.class);

                    // 配置文件校验
                    if (botConfig == null) {
                        throw new IllegalArgumentException(
                            "bot instance config file [" + configFile.getFileName() + "] illegal");
                    }

                    BotMetaInfo botMetaInfo = botNameMetaInfoMap.get(botConfig.getBotName());

                    if (botMetaInfo == null) {
                        log.warn("botName[{}] didn't loaded in script node", botConfig.getBotName());
                        return;
                    }

                    botConfig.setMetaInfo(botMetaInfo);

                    // 相对路径转绝对路径
                    reactivePathConfigConvert(
                        botConfig,
                        botMetaInfo.getResourceDir()
                    );

                    // 合并bot公共配置
                    if (botCommonConfig != null) {
                        botConfig.setCustomConfig(botCommonConfig);
                    }

                    // 合并远程配置
                    AutoBotConfig remoteBotConfig = fetchRemoteBotConfig(
                        buildRemoteConfigRestApi(),
                        scriptNodeName,
                        botConfig.getBotKey()
                    );
                    if (remoteBotConfig != null) {
                        mergeRemoteAutoBotConfig(botConfig, remoteBotConfig);
                    }

                    botKeyConfigMap.put(botConfig.getBotKey(), botConfig);
                } catch (Exception e) {
                    log.error("bot instance config[{}] load error, {}",
                        configFile.getFileName(),
                        e.getCause() == null ? e.getMessage() : e.getCause().getMessage()
                    );
                }
            });
        } catch (IOException e) {
            log.error("load bot instance config error", e);
        }
    }

    /**
     * 初始化bot原信息
     *
     * @throws IOException IOException
     */
    private void initBotMetaInfo() throws IOException {
        botNameMetaInfoMap = new HashMap<>();
        if (CollUtil.isNotEmpty(botInstanceJarNames)) {
            for (String botInstanceJarName : botInstanceJarNames) {
                String jarLibraryPath = FileUtil.getLibraryPath(botInstanceJarName);
                String jarFilePath = FileUtil.getJarFilePath(botInstanceJarName);
                FileUtil.extractJar(
                    jarLibraryPath,
                    jarFilePath
                );

                // 解析文件夹
                log.info("start resolve bot meta info config from dir[{}]", jarFilePath);
                try (Stream<Path> walk = Files.walk(Paths.get(jarFilePath), 5)) {
                    walk.filter(Files::isDirectory).forEach(dir -> {
                        Path configFilePath = dir.resolve(BOT_META_INF_FILE_NAME);
                        if (Files.exists(configFilePath)) {
                            BotMetaInfo metaInfo = YamlConfigLoadUtil.load(configFilePath.toFile(),
                                BOT_META_INFO_PREFIX, BotMetaInfo.class);

                            // 配置文件校验
                            if (metaInfo == null) {
                                throw new IllegalArgumentException(
                                    "bot meta info file [" + BOT_META_INF_FILE_NAME + "] illegal");
                            }

                            // 设置bot资源目录
                            metaInfo.setResourceDir(dir.toString());
                            // 设置所在jar包路径
                            metaInfo.setClassJarPath(jarLibraryPath);

                            botNameMetaInfoMap.put(metaInfo.getBotName(), metaInfo);
                            log.info("botName [{}] meta info loaded", metaInfo.getBotName());
                        }
                    });
                }
            }
        }
    }

    /**
     * 获取远程配置
     *
     * @param configUrl configUrl
     * @param scriptNodeName scriptNodeName
     * @param botKey botKey
     * @return String
     */
    private AutoBotConfig fetchRemoteBotConfig(String configUrl, String scriptNodeName, String botKey) {
        if (StrUtil.isBlank(configUrl)) {
            return null;
        }

        try {
            JSONObject params = new JSONObject();
            params.put("scriptNodeName", scriptNodeName);
            params.put("botKey", botKey);
            String response = RestApiClientFactory.getClient().request(
                configUrl,
                HttpMethod.POST,
                new HashMap<>(),
                params,
                new JSONObject()
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                AutoBotConfig load = YamlConfigLoadUtil.load(String.valueOf(result.getData()),
                    BOT_META_INFO_PREFIX, AutoBotConfig.class);
                log.info("remote config fetch success, merge into [{}] bot config...", botKey);
                return load;
            } else {
                log.warn("script node[{}] botKey[{}] config not found in remote", scriptNodeName, botKey);
                return null;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("script node[{}] botKey[{}] remote fetch error", scriptNodeName, botKey, e);
            return null;
        }
    }

    /**
     * 合并远程配置
     *
     * @param local local
     * @param remote remote
     */
    private void mergeRemoteAutoBotConfig(AutoBotConfig local, AutoBotConfig remote) {
        if (remote.getAccountConfig() != null) {
            local.setAccountConfig(remote.getAccountConfig());
        }
        if (remote.getCustomConfig() != null) {
            local.setCustomConfig(remote.getCustomConfig());
        }
    }

    /**
     * 相对路径转换
     *
     * @param config config
     * @param botResourcePath botResourcePath
     */
    private void reactivePathConfigConvert(AutoBotConfig config, String botResourcePath) {
        AutoBotAccountConfig accountConfig = config.getAccountConfig();
        accountConfig.setConfigFilePath(
            FileUtil.generateAbsPath(accountConfig.getConfigFilePath(), botResourcePath)
        );

        Map<String, Object> customConfig = config.getCustomConfig();
        if (customConfig != null && !customConfig.isEmpty()) {
            for (Map.Entry<String, Object> entry : customConfig.entrySet()) {
                Object value = entry.getValue();
                if (value instanceof String) {
                    entry.setValue(FileUtil.generateAbsPath((String) value, botResourcePath));
                }
            }
        }
    }
}
package cn.com.vortexa.script_node.service.impl;

import cn.com.vortexa.script_node.service.BotApi;
import cn.com.vortexa.script_node.service.IBotAccountContextService;
import cn.com.vortexa.script_node.service.IRewordInfoService;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import cn.com.vortexa.rpc.api.bot.IScriptAgentRPC;
import cn.com.vortexa.rpc.api.platform.IAccountBaseInfoRPC;
import cn.com.vortexa.rpc.api.platform.IBotInfoRPC;
import cn.com.vortexa.job.service.BotJobService;
import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import cn.com.vortexa.rpc.api.platform.IBrowserEnvRPC;
import cn.com.vortexa.rpc.api.platform.IDiscordAccountRPC;
import cn.com.vortexa.rpc.api.platform.IProxyInfoRPC;
import cn.com.vortexa.rpc.api.platform.ITelegramAccountRPC;
import cn.com.vortexa.rpc.api.platform.ITwitterAccountRPC;
import cn.com.vortexa.control.anno.RPCReference;
import cn.com.vortexa.script_node.service.IWeb3WalletService;
import cn.com.vortexa.web3.service.IWeb3WalletOPTRPC;
import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;


@Getter
@Component
public class DBBotApi implements BotApi {

    @Autowired
    private BotJobService botJobService;

    @Autowired
    private IBotAccountContextService botAccountService;

    @Autowired
    private IRewordInfoService rewordInfoService;


    @RPCReference
    private IBotInfoRPC botInfoRPC;

    @RPCReference
    private IBotInstanceRPC botInstanceRPC;

    @RPCReference
    private IAccountBaseInfoRPC accountBaseInfoRPC;

    @RPCReference
    private ITwitterAccountRPC twitterAccountRPC;

    @RPCReference
    private ITelegramAccountRPC telegramAccountRPC;

    @RPCReference
    private IProxyInfoRPC proxyInfoRPC;

    @RPCReference
    private IBrowserEnvRPC browserEnvRPC;

    @RPCReference
    private IDiscordAccountRPC discordAccountRPC;

    @RPCReference
    private IWeb3WalletOPTRPC web3WalletRPC;

    @Autowired
    private IScriptAgentRPC scriptAgentRPC;

    @Autowired
    private ITableShardStrategy tableShardStrategy;

    @Autowired
    private IWeb3WalletService web3WalletService;
}
package cn.com.vortexa.script_node.service.impl;

import cn.com.vortexa.script_node.service.IWeb3WalletService;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.constants.Web3jFunctionType;
import cn.com.vortexa.web3.util.ABIFunctionBuilder;
import cn.hutool.core.collection.CollUtil;

import org.springframework.stereotype.Service;
import org.web3j.abi.datatypes.Type;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/24 10:21
 */
@Service
public class Web3WalletServiceImpl implements IWeb3WalletService {
    @Override
    public BigDecimal erc20BalanceCheck(String rpcUrl, String tokenContractAddress, String address) throws IOException {
        List<Type> result = EthWalletUtil.smartContractCallInvoke(
            rpcUrl,
            tokenContractAddress,
            address,
            ABIFunctionBuilder
                .builder()
                .functionName("balanceOf")
                .addParameterType(Web3jFunctionType.Address, address)
                .addReturnType(Web3jFunctionType.Uint256)
        );

        if (CollUtil.isEmpty(result)) {
            throw new RuntimeException("erc20 balance check error");
        } else {
            return (BigDecimal) result.getFirst().getValue();
        }
    }
}
package cn.com.vortexa.script_node.service;


import cn.com.vortexa.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import cn.com.vortexa.job.service.BotJobService;
import cn.com.vortexa.rpc.api.bot.IScriptAgentRPC;
import cn.com.vortexa.rpc.api.platform.IAccountBaseInfoRPC;
import cn.com.vortexa.rpc.api.platform.IBotInfoRPC;
import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import cn.com.vortexa.rpc.api.platform.IBrowserEnvRPC;
import cn.com.vortexa.rpc.api.platform.IDiscordAccountRPC;
import cn.com.vortexa.rpc.api.platform.IProxyInfoRPC;
import cn.com.vortexa.rpc.api.platform.ITelegramAccountRPC;
import cn.com.vortexa.rpc.api.platform.ITwitterAccountRPC;
import cn.com.vortexa.web3.service.IWeb3WalletOPTRPC;

public interface BotApi {

    IBotInfoRPC getBotInfoRPC();

    IBotInstanceRPC getBotInstanceRPC();

    IAccountBaseInfoRPC getAccountBaseInfoRPC();

    IBrowserEnvRPC getBrowserEnvRPC();

    IDiscordAccountRPC getDiscordAccountRPC();

    IProxyInfoRPC getProxyInfoRPC();

    ITwitterAccountRPC getTwitterAccountRPC();

    ITelegramAccountRPC getTelegramAccountRPC();

    ITableShardStrategy getTableShardStrategy();

    IRewordInfoService getRewordInfoService();

    IBotAccountContextService getBotAccountService();

    BotJobService getBotJobService();

    IScriptAgentRPC getScriptAgentRPC();

    IWeb3WalletOPTRPC getWeb3WalletRPC();

    IWeb3WalletService getWeb3WalletService();
}
package cn.com.vortexa.script_node.service;

import java.io.IOException;
import java.math.BigDecimal;

/**
 * @author h30069248
 * @since 2025/4/24 10:20
 */
public interface IWeb3WalletService {

    BigDecimal erc20BalanceCheck(String rpcUrl, String tokenContractAddress, String address) throws IOException;
}
vortexa:
  web3:
    chain-info:
      - name: Monad_Testnet
        rpcUrls:
          - https://testnet-rpc.monad.xyz/
        chainId: 10143
        originTokenSymbol: MON
        blockExploreUrl: https://testnet.monadexplorer.com
      - name: Plume_Testnet
        rpcUrls:
          - https://testnet-rpc.plumenetwork.xyz
          - https://testnet-explorer.plumenetwork.xyz/
        chainId: 98867
        originTokenSymbol:
        blockExploreUrl: https://testnet-explorer.plumenetwork.xyz
