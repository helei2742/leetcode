package cn.com.vortexa.websocket.netty.base;

import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.com.vortexa.websocket.netty.handler.AbstractWebSocketClientHandler;
import cn.hutool.core.util.StrUtil;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.HttpProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Websocket客户端
 */
@Slf4j
@Setter
@Getter
public abstract class AbstractWebsocketClient<T> extends AutoConnectWSService {
    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    private final AbstractWebSocketClientHandler<T> handler;   //netty pipeline 最后一个执行的handler
    private final ExecutorService callbackInvoker;  //执行回调的线程池
    private final String name;
    private boolean handshake = true;
    private int allIdleTimeSecond = 10; //空闲时间

    public AbstractWebsocketClient(
            String url,
            String name,
            AbstractWebSocketClientHandler<T> handler
    ) {
        super(url);
        this.name = name;
        this.handler = handler;
        this.callbackInvoker = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(name));
    }

    @Override
    protected void afterBoostrapConnected() throws InterruptedException {
        if (handshake && handler.handshakeFuture() != null) {
            handler.handshakeFuture().sync();
        }
    }

    @Override
    protected void init() throws SSLException, URISyntaxException {
        URI uri = new URI(getUrl());

        WebSocketClientHandshaker webSocketClientHandshaker = handshake ? WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, getHeaders(), MAX_FRAME_SIZE
        ) : null;

        handler.init(this, webSocketClientHandshaker, callbackInvoker);

        final SslContext sslCtx;
        if (isUseSSL()) {
            sslCtx = SslContextBuilder
                    .forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE)
                    .build();
        } else {
            sslCtx = null;
        }

        setBootstrap(new Bootstrap());
        getBootstrap().group(getEventLoopGroup())
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000) // 设置连接超时为10秒
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        ProxyInfo proxy = getProxy();

                        if (proxy != null) {
                            // 添加 HttpProxyHandler 作为代理
                            if (StrUtil.isNotBlank(proxy.getUsername())) {
                                p.addFirst(new HttpProxyHandler(proxy.generateAddress(), proxy.getUsername(),
                                        proxy.getPassword()));
                            } else {
                                p.addFirst(new HttpProxyHandler(proxy.generateAddress()));
                            }
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), uri.getPort()));
                        }

                        addPipeline(p);
                    }
                });
    }

    /**
     * 添加 pipeline
     *
     * @param p p
     */
    public abstract void addPipeline(ChannelPipeline p);

    /**
     * 从消息中获取id
     *
     * @param message message
     * @return Object
     */
    public abstract Object getIdFromMessage(T message);

    /**
     * 发送消息，没有回调
     *
     * @param message message
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> sendMessage(T message) {
        return CompletableFuture.runAsync(() -> {
            if (message == null) {
                throw new IllegalArgumentException("message is null");
            }

            doSendMessage(message, false);
        }, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(T request) {
        log.debug("send request [{}]", request);

        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = handler.registryRequest(request, response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                doSendMessage(request, true);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) {
                    return null;
                }

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送消息
     *
     * @param message   message
     * @param isRequest isRequest
     */
    protected void doSendMessage(T message, boolean isRequest) {
        try {
            getChannel().writeAndFlush(message);
            log.debug("send request [{}] success", message);
        } catch (Exception e) {
            throw new RuntimeException("send message [" + message + "] error");
        }
    }
}
package cn.com.vortexa.websocket.netty.base;

import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.com.vortexa.websocket.netty.constants.WebsocketClientStatus;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.Channel;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

import javax.net.ssl.SSLException;

/**
 * @author h30069248
 * @since 2025/3/18 10:52
 */
@Slf4j
@Setter
@Getter
public abstract class AutoConnectWSService implements IWSService {
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);  //重链接次数
    private final ReentrantLock reconnectLock = new ReentrantLock();    //重连锁
    private final Condition startingWaitCondition = reconnectLock.newCondition();   //启动中阻塞的condition
    private final EventLoopGroup eventLoopGroup;    //netty线程组
    private final String url; //websocket的url字符串
    private Bootstrap bootstrap; //netty bootstrap
    private Channel channel;    //连接channel
    private String host;    //连接host
    private int port;    //连接port
    private boolean useSSL; //是否ssl
    private HttpHeaders headers;    //请求头
    private ProxyInfo proxy = null; //代理
    private int reconnectCountDownSecond = 180; //重连次数减少的间隔
    private int reconnectLimit = 3; //重连次数限制
    private volatile WebsocketClientStatus clientStatus = WebsocketClientStatus.NEW;    //客户端当前状态
    private Consumer<WebsocketClientStatus> clientStatusChangeHandler = socketCloseStatus -> {
    };    //clientStatus更新的回调

    protected AutoConnectWSService(String url) {
        this.url = url;
        this.eventLoopGroup = new NioEventLoopGroup();
    }

    protected abstract void init() throws SSLException, URISyntaxException;

    public final CompletableFuture<Boolean> connect() {
        return switch (clientStatus) {
            case NEW, STOP -> reconnect();
            case STARTING -> waitForStarting();
            case RUNNING -> {
                log.warn("ws service [{}] in running, clientStatus[{}]", getName(), clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> throw new RuntimeException("");
        };
    }

    public CompletableFuture<Boolean> reconnect() {
        return switch (clientStatus) {
            case NEW, STOP -> reconnectLogic();
            case STARTING -> waitForStarting().thenApplyAsync(success -> {
                if (success) {
                    return true;
                }
                try {
                    return reconnectLogic().get();
                } catch (InterruptedException | ExecutionException e) {
                    throw new RuntimeException(e);
                }
            });
            case RUNNING -> {
                log.warn("ws service [{}] in running, can't reconnect. clientStatus[{}]", getName(), clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> CompletableFuture.supplyAsync(() -> {
                log.error("client[{}] already shutdown", getName());
                return false;
            });
        };
    }

    private CompletableFuture<Boolean> reconnectLogic() {
        updateClientStatus(WebsocketClientStatus.STARTING);

        String name = getName();

        return CompletableFuture.supplyAsync(() -> {
            //Step 1 重连次数超过限制，关闭
            if (reconnectTimes.get() >= reconnectLimit) {
                log.error("reconnect times out of limit [{}], close websocket client", reconnectLimit);
                close();
                return false;
            }

            AtomicBoolean isSuccess = new AtomicBoolean(false);

            //Step 2 重连逻辑
            //Step 2.1 加锁保证只要一个线程进行重连
            reconnectLock.lock();
            try {
                //Step 2.2 已经再running状态，直接返回true。变为shutdown、stop状态，直接返回false
                if (clientStatus.equals(WebsocketClientStatus.RUNNING)) {
                    log.info("client started by other thread");
                    return true;
                } else if (clientStatus.equals(WebsocketClientStatus.SHUTDOWN) || clientStatus.equals(
                        WebsocketClientStatus.STOP)) {
                    log.error("clint {} when client starting", clientStatus);
                    return false;
                }

                //Step 3 初始化
                log.info("开始初始化WS客户端");
                try {
                    resolveParamFromUrl();

                    init();
                } catch (SSLException | URISyntaxException e) {
                    throw new RuntimeException("初始化WS客户端发生错误", e);
                }
                log.info("初始化WS客户端完成，开始链接服务器 [{}]", url);

                //Step 4 链接服务器
                if (reconnectTimes.incrementAndGet() <= reconnectLimit) {

                    //Step 4.1 每进行重连都会先将次数加1并设置定时任务将重连次数减1
                    eventLoopGroup.schedule(() -> {
                        reconnectTimes.decrementAndGet();
                    }, reconnectCountDownSecond, TimeUnit.SECONDS);

                    log.info("start connect client [{}], url[{}], current times [{}]", name, url, reconnectTimes.get());

                    //Step 4.2 latch用于同步等等链接完成
                    CountDownLatch latch = new CountDownLatch(1);

                    //Step 4.3 延迟再进行连接
                    eventLoopGroup.schedule(() -> {
                        try {
                            channel = bootstrap.connect(host, port).sync().channel();

                            afterBoostrapConnected();

                            log.info("success connect to {}", url);
                            //Step 4.4 连接成功设置标识
                            isSuccess.set(true);
                        } catch (Exception e) {
                            log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                            isSuccess.set(false);
                        } finally {
                            latch.countDown();
                        }
                    }, reconnectTimes.get() == 0 ? 0 : NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                    //Step 4.5 等待链接完成
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        log.error("connect client [{}], url[{}] interrupted, times [{}]", name, url, reconnectTimes.get(), e);
                    }

                    //Step 6 未成功启动，关闭
                    if (!isSuccess.get()) {
                        log.info("connect client [{}], url[{}] fail, current times [{}]", name, url, reconnectTimes.get());

                        close();
                    } else {
                        log.info("connect client [{}], url[{}] success, current times [{}]", name, url, reconnectTimes.get());

                        updateClientStatus(WebsocketClientStatus.RUNNING);
                        reconnectTimes.set(0);
                    }
                }
            } catch (Exception e) {
                //exception 遇到未处理异常，直接关闭
                close();
                throw new RuntimeException(String.format("connect client [%s] appear unknown error", name), e);
            } finally {
                //Step 5 释放等待启动的线程
                startingWaitCondition.signalAll();
                reconnectLock.unlock();
            }

            return isSuccess.get();
        }, getCallbackInvoker());
    }

    public void close() {
        if (clientStatus.equals(WebsocketClientStatus.STOP)
                || clientStatus.equals(WebsocketClientStatus.SHUTDOWN)) {
            return;
        }

        updateClientStatus(WebsocketClientStatus.STOP);

        log.info("closing websocket client [{}], [{}]", getName(), channel == null ? "null" : getChannel().hashCode());
        if (channel != null) {
            channel.close();
            channel = null;
        }
        log.warn("web socket client [{}] closed", getName());
    }

    public final void shutdown() {
        updateClientStatus(WebsocketClientStatus.SHUTDOWN);

        if (channel != null) {
            channel.close();
            channel = null;
        }
        eventLoopGroup.shutdownGracefully();
        log.warn("web socket client [{}] already shutdown !", getName());
    }

    /**
     * 更新status
     *
     * @param newStatus newStatus
     */
    protected void updateClientStatus(WebsocketClientStatus newStatus) {
        synchronized ("CLIENT_STATUS_LOCK") {
            if (clientStatus.equals(newStatus)) {
                return;
            }

            if (clientStatus.equals(WebsocketClientStatus.SHUTDOWN)) {
                throw new IllegalArgumentException("client status is shutdown，new status can not be " + newStatus);
            }

            try {
                if (newStatus != clientStatus && clientStatusChangeHandler != null) {
                    clientStatusChangeHandler.accept(newStatus);
                }
            } finally {
                log.info("client status [{}] -> [{}]", clientStatus, newStatus);
                clientStatus = newStatus;
            }
        }
    }

    /**
     * 获取回调执行线程池
     *
     * @return ExecutorService
     */
    public abstract ExecutorService getCallbackInvoker();

    /**
     * 每次netty bootstrap 连接后调用
     *
     * @throws InterruptedException InterruptedException
     */
    protected abstract void afterBoostrapConnected() throws InterruptedException;

    /**
     * 等待启动完成
     *
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Boolean> waitForStarting() {
        return CompletableFuture.supplyAsync(() -> {
            log.warn("client [{}] is starting, waiting for complete", getName());
            reconnectLock.lock();
            try {
                while (clientStatus.equals(WebsocketClientStatus.STARTING)) {
                    startingWaitCondition.await();
                }

                if (clientStatus.equals(WebsocketClientStatus.STOP) || clientStatus.equals(
                        WebsocketClientStatus.SHUTDOWN)) {
                    log.error("启动WS客户端[{}]失败, ClientStatus [{}}", getName(), clientStatus);
                    return false;
                }
                return true;
            } catch (InterruptedException e) {
                log.error("waiting for start client [{}] error", getName());
                throw new RuntimeException(e);
            } finally {
                reconnectLock.unlock();
            }
        }, getCallbackInvoker());
    }

    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        URI uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }
}
package cn.com.vortexa.websocket.netty.handler;

import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.com.vortexa.websocket.netty.util.HandlerEntity;
import io.netty.channel.*;
import io.netty.handler.timeout.IdleStateEvent;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * WebSocket客户端处理器基础类
 * 处理连接握手
 */
@Slf4j
@Getter
@ChannelHandler.Sharable
public abstract class BaseWebSocketInboundHandler<T> extends SimpleChannelInboundHandler<T> {

    /**
     * 存放请求响应的回调
     */
    protected final ConcurrentMap<Object, HandlerEntity<T>> requestIdMap = new ConcurrentHashMap<>();

    /**
     * 执行回调的线程池
     */
    private ExecutorService callbackInvoker;

    protected void init(ExecutorService callbackInvoker) {
        this.callbackInvoker = callbackInvoker;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        super.channelActive(ctx);
    }

    @Override
    protected final void channelRead0(ChannelHandlerContext ctx, T message) throws Exception {
        Channel channel = ctx.channel();
        log.debug("{} -> {}  message: {}", channel.remoteAddress(), channel.localAddress(), message);
        // Step 1 尝试调用请求回调
        tryInvokeResponseCallback(message)
                .thenAccept(success -> {
                    // Step 2 返回false，说明不是是请求的响应, 往下处理
                    if (!success) {
                        handlerMessage(ctx, message);
                    }
                })
                .exceptionally(throwable -> {
                    if (throwable != null) {
                        log.error("request callback invoke error", throwable);
                    }
                    return null;
                });
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }


    /**
     * 注册request
     *
     * @param request request
     * @return 是否注册成功
     */
    public boolean registryRequest(T request, Consumer<T> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        Object requestId = getMessageId(request);

        if (requestId == null) {
            return false;
        }

        requestIdMap.compute(requestId, (k, v) -> {
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", requestId, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 调用响应的回调
     *
     * @param response response
     */
    public CompletableFuture<Boolean> tryInvokeResponseCallback(T response) {
        Object responseId = getMessageId(response);
        log.debug("responseId[{}], {}", responseId, response);

        if (responseId == null || !requestIdMap.containsKey(responseId)) {
            return CompletableFuture.completedFuture(false);
        }

        return CompletableFuture.supplyAsync(() -> {
            try {
                HandlerEntity<T> remove = requestIdMap.remove(responseId);
                if (remove != null) {
                    remove.getCallback().accept(response);
                }
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
            return true;
        }, callbackInvoker);
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 从消息中取id
     *
     * @param message message
     * @return id
     */
    protected abstract Object getMessageId(T message);

    /**
     * 处理消息
     *
     * @param ctx     ctx
     * @param message message
     */
    protected abstract void handlerMessage(ChannelHandlerContext ctx, T message);
}
package cn.com.vortexa.nameserver.dto;


import io.netty.channel.Channel;
import io.netty.util.HashedWheelTimer;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author helei
 * @since 2025-03-12
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ConnectEntry {
    private Channel channel;
    private boolean usable;
    private long lastActiveTimestamp;
    private String type;

    public void close() {
        if (channel != null && channel.isActive()) {
            channel.close();
        }
        usable = false;
    }
}
package cn.com.vortexa.nameserver.exception;

public class CustomCommandException extends Exception{

    // 默认构造函数
    public CustomCommandException() {
        super("custom command exception.");
    }

    // 传入错误信息的构造函数
    public CustomCommandException(String message) {
        super(message);
    }

    // 传入错误信息和异常原因的构造函数
    public CustomCommandException(String message, Throwable cause) {
        super(message, cause);
    }

    // 传入异常原因的构造函数
    public CustomCommandException(Throwable cause) {
        super(cause);
    }
}
package cn.com.vortexa.nameserver.handler;

import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.RequestHandleResult;

/**
 * @author h30069248
 * @since 2025/3/20 11:09
 */
public interface CustomRequestHandler {

    RequestHandleResult handlerRequest(RemotingCommand request);

}
package cn.com.vortexa.nameserver.service.impl;

import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.RequestHandleResult;
import cn.com.vortexa.nameserver.exception.CustomCommandException;
import cn.com.vortexa.nameserver.handler.CustomRequestHandler;
import cn.com.vortexa.nameserver.protocol.Serializer;
import cn.com.vortexa.nameserver.service.ICustomCommandService;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author h30069248
 * @since 2025/3/20 11:02
 */
@Slf4j
public class DefaultCustomCommandService implements ICustomCommandService {

    private final ConcurrentMap<Integer, CustomRequestHandler> customCMDHandlerMap = new ConcurrentHashMap<>();

    @Override
    public void addCustomCommandHandler(Integer commandFlag, CustomRequestHandler customRequestHandler)
        throws CustomCommandException {
        if (!checkCommandFlag(commandFlag)) {
            throw new CustomCommandException("illegal command flag " + commandFlag);
        }

        if (customCMDHandlerMap.putIfAbsent(commandFlag, customRequestHandler) != null) {
            throw new CustomCommandException("command [%s] exist".formatted(commandFlag));
        } else {
            log.info("custom command [{}] added", commandFlag);
        }
    }

    @Override
    public RemotingCommand tryInvokeCustomCommandHandler(RemotingCommand request) throws CustomCommandException {
        CustomRequestHandler handler = customCMDHandlerMap.get(request.getFlag());

        if (handler == null) {
            throw new CustomCommandException("custom request[%s] didn't exist".formatted(request.getFlag()));
        }

        RemotingCommand response = new RemotingCommand();
        response.setTransactionId(request.getTransactionId());
        response.setFlag(-1 * request.getFlag());

        // 执行注册的回调方法
        RequestHandleResult result = handler.handlerRequest(request);

        if (result == null || !result.getSuccess()) {
            response.setCode(RemotingCommandCodeConstants.FAIL);
        } else {
            response.setCode(RemotingCommandCodeConstants.SUCCESS);
            response.setBody(
                Serializer.Algorithm.Protostuff.serialize(result.getData())
            );
        }

        return response;
    }

    /**
     * 检查命令flag
     *
     * @param commandFlag commandFlag
     * @return boolean
     */
    private static boolean checkCommandFlag(Integer commandFlag) {
        if (commandFlag == null || commandFlag <= 0 || commandFlag < 300) {
            return false;
        }

        int start = commandFlag;
        while (commandFlag > 10) {
            commandFlag = commandFlag / 10;
            start = commandFlag;
        }

        return start == 3;
    }

    public static void main(String[] args) {
        System.out.println(checkCommandFlag(3001));
    }
}
package cn.com.vortexa.nameserver.service.impl;

import cn.com.vortexa.nameserver.constant.RegistryState;
import cn.com.vortexa.nameserver.dto.RegisteredService;
import cn.com.vortexa.nameserver.dto.ServiceInstance;
import cn.com.vortexa.nameserver.service.IRegistryService;
import cn.com.vortexa.nameserver.util.NameserverUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONObject;

import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author helei
 * @since 2025-03-17
 */
@Slf4j
public class FileRegistryService implements IRegistryService {

    private static final String FILE_NAME = "nameserver-registry.dat";

    private final ConcurrentHashMap<String, RegisteredService> registryServiceMap = new ConcurrentHashMap<>();

    @Override
    public RegistryState registryService(ServiceInstance serviceInstance, Map<String, Object> props) {
        String group = serviceInstance.getGroup();
        String serviceId = serviceInstance.getServiceId();
        String clientId = serviceInstance.getClientId();

        if (StrUtil.isBlank(group) && StrUtil.isBlank(serviceId) && StrUtil.isBlank(clientId)) {
            return RegistryState.PARAM_ERROR;
        }

        try {
            String key = NameserverUtil.generateServiceInstanceKey(group, serviceId, clientId);

            // 存内存
            registryServiceMap.put(key, new RegisteredService(serviceInstance, props));

            // 存磁盘
            Boolean b = null;
            try {
                b = saveRegistryInfo();
                return BooleanUtil.isTrue(b) ? RegistryState.OK : RegistryState.STORE_ERROR;
            } catch (Exception e) {
                log.error("store registry error", e);
                return RegistryState.STORE_ERROR;
            }
        } catch (Exception e) {
            log.error("registry config error", e);
            return RegistryState.UNKNOWN_ERROR;
        }
    }

    @Override
    public Boolean saveRegistryInfo() throws IOException {
        Path path = Paths.get(NameserverUtil.getStoreFileResourcePath(FILE_NAME));
        if (!Files.exists(path.getParent())) {
            Files.createDirectories(path.getParent());
        }

        try (BufferedWriter bw = new BufferedWriter(new FileWriter(path.toFile()))) {
            bw.write(JSONObject.toJSONString(registryServiceMap));
            bw.flush();
            return true;
        }
    }

    @Override
    public List<RegisteredService> queryServiceInstance(
        String groupId,
        String serviceId,
        String clientId
    ) {
        String keyPattern = NameserverUtil.generateServiceInstanceKey(
            StrUtil.isBlank(groupId) ? "*" : groupId,
            StrUtil.isBlank(serviceId) ? "*" : serviceId,
            StrUtil.isBlank(clientId) ? "*" : clientId
        );
        Pattern compile = Pattern.compile(keyPattern);

        return registryServiceMap.keySet().stream().filter(key -> {
            Matcher matcher = compile.matcher(key);
            return matcher.find();
        }).map(registryServiceMap::get).toList();
    }

    @Override
    public boolean existServiceInstance(String key) {
        return registryServiceMap.containsKey(key);
    }
}
package cn.com.vortexa.nameserver.service;

import cn.com.vortexa.nameserver.dto.ConnectEntry;
import io.netty.channel.Channel;

/**
 * @author h30069248
 * @since 2025/3/18 15:02
 */
public interface IConnectionService {

    /**
     * 添加服务连接
     *
     * @param key key
     * @param channel channel
     */
    void addServiceChannel(String key, Channel channel);

    /**
     * 添加服务连接
     *
     * @param group group
     * @param serviceId serviceId
     * @param instanceId instanceId
     * @param channel channel
     */
    void addServiceChannel(String group, String serviceId, String instanceId, Channel channel);

    /**
     * 关闭服务连接
     *
     * @param channel channel
     * @param key key
     */
    void closeServiceChannel(Channel channel, String key);

    /**
     * 获取连接
     *
     * @param key key
     * @return ConnectEntry
     */
    ConnectEntry getServiceInstanceChannel(String key);

    /**
     * 刷新服务实例连接
     *
     * @param key key
     * @param channel channel
     */
    void freshServiceInstanceConnection(String key, Channel channel);
}
package cn.com.vortexa.nameserver.service;

import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.exception.CustomCommandException;
import cn.com.vortexa.nameserver.handler.CustomRequestHandler;

/**
 * @author h30069248
 * @since 2025/3/20 11:02
 */
public interface ICustomCommandService {
    /**
     * 添加自定义命令处理器
     *
     * @param commandFlag commandFlag
     * @param customRequestHandler customRequestHandler
     * @throws CustomCommandException CustomCommandException
     */
    void addCustomCommandHandler(Integer commandFlag, CustomRequestHandler customRequestHandler)
        throws CustomCommandException;

    /**
     * 运行自定义命令处理器
     *
     * @param request request
     * @return RemotingCommand
     */
    RemotingCommand tryInvokeCustomCommandHandler(RemotingCommand request) throws CustomCommandException;
}
package cn.com.vortexa.nameserver.service;

import cn.com.vortexa.nameserver.constant.RegistryState;
import cn.com.vortexa.nameserver.dto.RegisteredService;
import cn.com.vortexa.nameserver.dto.ServiceInstance;

import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * @author helei
 * @since 2025-03-17
 */
public interface IRegistryService {

    /**
     * 注册服务
     *
     * @param serviceInstance serviceInstance
     * @return 注册状态
     */
    RegistryState registryService(ServiceInstance serviceInstance, Map<String, Object> props);

    /**
     * 保存注册信息
     *
     * @return Boolean
     */
    Boolean saveRegistryInfo() throws IOException;

    /**
     * 查找服务实例
     *
     * @param groupId groupId
     * @param serviceId serviceId
     * @param clientId clientId
     * @return List<ServiceInstance>
     */
    List<RegisteredService> queryServiceInstance(
            String groupId,
            String serviceId,
            String clientId
    );

    /**
     * 是否存在已注册的实例
     *
     * @param key key
     * @return  boolean
     */
    boolean existServiceInstance(String key);
}
package cn.com.vortexa.nameserver.service.impl;

import cn.com.vortexa.nameserver.dto.ConnectEntry;
import cn.com.vortexa.nameserver.service.IConnectionService;
import cn.com.vortexa.nameserver.util.NameserverUtil;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * @author h30069248
 * @since 2025/3/18 15:03
 */
@Slf4j
public class MemoryConnectionService implements IConnectionService {

    private final ConcurrentMap<String, ConnectEntry> connectionMap = new ConcurrentHashMap<>();

    @Override
    public void addServiceChannel(String key, Channel channel) {
        connectionMap.compute(key, (k,v)->{
            if (v == null) {
                channel.attr(NettyConstants.CLIENT_NAME).set(key);
                v = ConnectEntry.builder()
                    .channel(channel)
                    .build();
            }

            v.setUsable(true);
            v.setLastActiveTimestamp(System.currentTimeMillis());
            return v;
        });
    }

    @Override
    public void addServiceChannel(String group, String serviceId, String instanceId, Channel channel) {
        String key = NameserverUtil.generateServiceInstanceKey(
            group,
            serviceId,
            instanceId
        );
        addServiceChannel(key, channel);
    }

    @Override
    public void closeServiceChannel(Channel channel, String key) {
        ConnectEntry remove = connectionMap.remove(key);
        if (remove != null) {
            remove.close();
        }
        if (channel != null && channel.isActive()) {
            channel.close();
        }
        log.debug("close service instance [{}] channel", key);
    }

    @Override
    public ConnectEntry getServiceInstanceChannel(String key) {
        return connectionMap.get(key);
    }

    @Override
    public void freshServiceInstanceConnection(String key, Channel channel) {
        addServiceChannel(key, channel);
    }
}
package cn.com.vortexa.nameserver.processor;


import cn.com.vortexa.nameserver.NameserverClient;
import cn.com.vortexa.nameserver.config.NameserverClientConfig;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.websocket.netty.handler.AbstractWebSocketClientHandler;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

/**
 * @author helei
 * @since 2025-03-13
 */
@Slf4j
public class NameClientProcessorAdaptor extends AbstractWebSocketClientHandler<RemotingCommand> {

    @Setter
    private NameserverClient nameserverClient;

    @Getter
    private final NameserverClientConfig clientConfig;

    public NameClientProcessorAdaptor(NameserverClientConfig clientConfig) {
        this.clientConfig = clientConfig;
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        super.channelActive(ctx);
        ctx.channel().attr(NettyConstants.CLIENT_NAME).set(nameserverClient.getName());
        nameserverClient.sendRegistryCommand();
    }

    @Override
    protected void handlerMessage(ChannelHandlerContext ctx, RemotingCommand remotingCommand) {
        Integer opt = remotingCommand.getFlag();
        String txId = remotingCommand.getTransactionId();

        Channel channel = ctx.channel();
        String clientName = channel.attr(NettyConstants.CLIENT_NAME).get();
        log.debug("receive client[{}] command [{}]", clientName, remotingCommand);


    }

    @Override
    protected Object getMessageId(RemotingCommand message) {
        return message.getTransactionId();
    }

}
package cn.com.vortexa.nameserver;


import cn.com.vortexa.nameserver.config.NameserverClientConfig;
import cn.com.vortexa.nameserver.constant.NameserverSystemConstants;
import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.ServiceInstance;
import cn.com.vortexa.nameserver.processor.NameClientProcessorAdaptor;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import cn.com.vortexa.nameserver.util.RemotingCommandDecoder;
import cn.com.vortexa.nameserver.util.RemotingCommandEncoder;
import cn.com.vortexa.websocket.netty.base.AbstractWebsocketClient;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.*;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Optional;
import java.util.function.Consumer;

/**
 * @author helei
 * @since 2025-03-13
 */
@Slf4j
public class NameserverClient extends AbstractWebsocketClient<RemotingCommand> {

    private final NameserverClientConfig clientConfig;  // 配置
    private final String clientName;    // 客户端name
    @Setter
    private Consumer<RemotingCommand> afterRegistryHandler = null;  // 注册成功后回调


    public NameserverClient(NameserverClientConfig clientConfig) {
        this(clientConfig, new NameClientProcessorAdaptor(clientConfig));
    }

    public NameserverClient(NameserverClientConfig clientConfig, NameClientProcessorAdaptor nameClientProcessorAdaptor) {
        super(clientConfig.getRegistryCenterUrl(), clientConfig.getServiceInstance().toString(), nameClientProcessorAdaptor);
        super.setHandshake(false);
        this.clientConfig = clientConfig;
        this.clientName = clientConfig.getServiceInstance().toString();
        ((NameClientProcessorAdaptor) getHandler()).setNameserverClient(this);
    }

    @Override
    public void addPipeline(ChannelPipeline p) {
        p.addLast(new IdleStateHandler(0,
                0, clientConfig.getServiceOfflineTtl()));

        p.addLast(new LengthFieldBasedFrameDecoder(NameserverSystemConstants.MAX_FRAME_LENGTH,
                0, 4, 0, 4));
        p.addLast(new LengthFieldPrepender(4));

        p.addLast(new RemotingCommandDecoder());
        p.addLast(new RemotingCommandEncoder());
        p.addLast(getHandler());
    }

    @Override
    public Object getIdFromMessage(RemotingCommand message) {
        return message.getTransactionId();
    }

    @Override
    protected void doSendMessage(RemotingCommand message, boolean b) {
        log.debug("send message to nameserver: {}", message);

        ServiceInstance serviceInstance = clientConfig.getServiceInstance();

        if (b && StrUtil.isBlank(message.getTransactionId())) {
            message.setTransactionId(clientName);
        }

        message.setGroup(serviceInstance.getGroup());
        message.setServiceId(serviceInstance.getServiceId());
        message.setClientId(serviceInstance.getClientId());

        Optional.of(getChannel()).ifPresent(channel -> channel.writeAndFlush(message));
    }

    @Override
    public void sendPing() {
        sendRequest(RemotingCommand.generatePingCommand(clientName));
    }

    @Override
    public void sendPong() {
        sendRequest(RemotingCommand.generatePongCommand(clientName));
    }

    /**
     * 发送服务注册命令
     */
    public void sendRegistryCommand() {
        RemotingCommand remotingCommand = new RemotingCommand();
        remotingCommand.setFlag(RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE);
        remotingCommand.setTransactionId(
            DistributeIdMaker.DEFAULT.nextId(clientConfig.getServiceInstance().getServiceId())
        );

        remotingCommand.setBodyFromObject(new HashMap<>());

        sendRequest(remotingCommand).whenComplete((response, throwable) -> {
            if (throwable != null) {
                log.error("{} -> [{}] channel active error",
                    clientConfig.getServiceInstance(), clientConfig.getRegistryCenterUrl(), throwable);
            }

            // 注册成功
            if (response.getCode() == RemotingCommandCodeConstants.SUCCESS) {
                log.info("{} client registry success", clientConfig.getServiceInstance());
                if (afterRegistryHandler != null) {
                    afterRegistryHandler.accept(response);
                }
            } else {
                // 注册失败
                log.error("{} client registry failed, response: {}", clientConfig.getServiceInstance(), response);
                close();
            }
        });
    }
}
package cn.com.vortexa.nameserver;

import cn.com.vortexa.nameserver.config.NameserverClientConfig;
import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.protocol.Serializer;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import cn.com.vortexa.websocket.netty.constants.WebsocketClientStatus;
import lombok.extern.slf4j.Slf4j;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

@Slf4j
class NameserverClientTest {

    private static NameserverClient nameserverClient;

    static int command = 3001;

    @BeforeAll
    static void setUpBeforeClass() throws Exception {

        nameserverClient = new NameserverClient(NameserverClientConfig.DEFAULT);
    }

    @Test
    public void test() throws ExecutionException, InterruptedException {
        nameserverClient.setAfterRegistryHandler(response -> {
            log.info("send test command {}", command);

            RemotingCommand remotingCommand = new RemotingCommand();
            remotingCommand.setFlag(command);
            remotingCommand.setCode(RemotingCommandCodeConstants.SUCCESS);
            remotingCommand.setTransactionId(
                DistributeIdMaker.DEFAULT.nextId(nameserverClient.getName())
            );
            nameserverClient.sendRequest(remotingCommand).thenAccept(customResponse->{
                String deserialize = Serializer.Algorithm.Protostuff.deserialize(customResponse.getBody(),
                    String.class);
                System.out.println(deserialize);
            });
        });

        CompletableFuture<Boolean> connect = nameserverClient.connect();
        connect.get();

        TimeUnit.SECONDS.sleep(10000000);
    }
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.nameserver.constant.*;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.server.NameserverService;
import cn.com.vortexa.nameserver.service.IRegistryService;
import cn.com.vortexa.nameserver.util.NameserverUtil;
import cn.com.vortexa.websocket.netty.handler.BaseWebSocketInboundHandler;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;

/**
 * @author helei
 * @since 2025/03/11
 */
@Slf4j
@ChannelHandler.Sharable
public class NameserverProcessorAdaptor extends BaseWebSocketInboundHandler<RemotingCommand> {

    @Getter
    private final NameserverService nameserverService;
    private final PingCommandProcessor pingCommandProcessor;
    private final PongCommandProcessor pongCommandProcessor;
    private final ServiceRegistryProcessor serviceRegistryProcessor;
    private final ServiceDiscoverProcessor serviceDiscoverProcessor;

    public NameserverProcessorAdaptor(
        NameserverService nameServerService,
        IRegistryService registryService
    ) {
        super();
        this.nameserverService = nameServerService;
        this.pingCommandProcessor = new PingCommandProcessor(nameserverService);
        this.pongCommandProcessor = new PongCommandProcessor(nameserverService);
        this.serviceRegistryProcessor = new ServiceRegistryProcessor(registryService);
        this.serviceDiscoverProcessor = new ServiceDiscoverProcessor(registryService);

        init(this.nameserverService.getExecutorService());
    }

    @Override
    protected void handlerMessage(ChannelHandlerContext ctx, RemotingCommand remotingCommand) {
        Integer opt = remotingCommand.getFlag();
        String txId = remotingCommand.getTransactionId();

        Channel channel = ctx.channel();
        String clientName = channel.attr(NettyConstants.CLIENT_NAME).get();
        log.debug("receive client[{}] command [{}]", clientName, remotingCommand);

        CompletableFuture.supplyAsync(() -> switch (opt) {
                case RemotingCommandFlagConstants.PING ->
                    pingCommandProcessor.handlerPing(clientName, channel, remotingCommand);
                case RemotingCommandFlagConstants.PONG ->
                    pongCommandProcessor.handlerPong(clientName, channel, remotingCommand);
                case RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE -> {
                    RemotingCommand registryResult = serviceRegistryProcessor.handlerClientServiceRegistry(
                        channel, remotingCommand);
                    if (registryResult.getCode() == RemotingCommandCodeConstants.SUCCESS) {
                        // 给channel设置名字
                        String group = remotingCommand.getGroup();
                        String serviceId = remotingCommand.getServiceId();
                        String clientId = remotingCommand.getClientId();
                        String key = NameserverUtil.generateServiceInstanceKey(group, serviceId, clientId);

                        channel.attr(NettyConstants.CLIENT_NAME).set(key);

                        // 注册成功，添加channel连接
                        nameserverService.getConnectionService().addServiceChannel(key, channel);
                    }
                    yield registryResult;
                }
                case RemotingCommandFlagConstants.CLIENT_DISCOVER_SERVICE ->
                    serviceDiscoverProcessor.handlerDiscoverService(channel, remotingCommand);
                default -> {
                    // 判断是不是自定义命令
                    try {
                        yield nameserverService.tryInvokeCustomCommand(channel, remotingCommand);
                    }catch (Exception e) {
                        throw new IllegalStateException("Unexpected value: " + opt, e);
                    }
                }
            }, getCallbackInvoker())
            .whenCompleteAsync((response, ex) -> {
                if (ex != null) {
                    log.error("client[{}] command process failed", clientName, ex);
                }
                if (response != null) {
                    response.setTransactionId(txId);
                    ctx.channel().writeAndFlush(response);

                    //失败关闭连接
                    if (response.getCode() == RemotingCommandCodeConstants.FAIL) {
                        ctx.close();
                    }
                }
            });
    }

    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        log.debug("channel[{}][{}] not active long time, will close it",
            channel.id(), channel.attr(NettyConstants.CLIENT_NAME));

        nameserverService.closeChannel(channel);
    }

    @Override
    protected Object getMessageId(RemotingCommand message) {
        return message.getTransactionId();
    }
}
package cn.com.vortexa.nameserver.server;

import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.nameserver.config.NameserverServerConfig;
import cn.com.vortexa.nameserver.constant.NameServerState;
import cn.com.vortexa.nameserver.constant.NameserverSystemConstants;
import cn.com.vortexa.nameserver.dto.ConnectEntry;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.exception.CustomCommandException;
import cn.com.vortexa.nameserver.exception.NameserverException;
import cn.com.vortexa.nameserver.handler.CustomRequestHandler;
import cn.com.vortexa.nameserver.processor.NameserverProcessorAdaptor;
import cn.com.vortexa.nameserver.service.IConnectionService;
import cn.com.vortexa.nameserver.service.ICustomCommandService;
import cn.com.vortexa.nameserver.service.IRegistryService;
import cn.com.vortexa.nameserver.service.impl.DefaultCustomCommandService;
import cn.com.vortexa.nameserver.util.NameserverUtil;
import cn.com.vortexa.nameserver.util.RemotingCommandDecoder;
import cn.com.vortexa.nameserver.util.RemotingCommandEncoder;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import static cn.com.vortexa.nameserver.constant.NameServerState.*;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;

@Slf4j
@Getter
public class NameserverService {
    private final NameserverServerConfig nameserverServerConfig;    // nameServerConfig
    private final ICustomCommandService customCommandService;   // 自定义命令处理服务
    private final ExecutorService executorService;
    private final long startTime;   //启动时间

    private volatile NameServerState state; // name server state
    private ServerBootstrap serverBootstrap;    //serverBootstrap
    private ChannelFuture nameserverChannelFuture;  //nameserverChannelFuture

    private NameserverProcessorAdaptor processorAdaptor;  // 消息处理器
    private IRegistryService registryService;   // 注册服务
    private IConnectionService connectionService;   // 连接服务

    public NameserverService(NameserverServerConfig nameserverServerConfig) throws NameserverException {
        this.nameserverServerConfig = nameserverServerConfig;
        updateNameServerState(JUST_START);
        this.startTime = System.currentTimeMillis();
        this.executorService = Executors.newThreadPerTaskExecutor(
            new NamedThreadFactory(nameserverServerConfig.getServiceInstance().toString())
        );

        this.customCommandService = new DefaultCustomCommandService();
    }

    /**
     * 初始化
     *
     * @param registryService registryService
     */
    public void init(
        IRegistryService registryService,
        IConnectionService connectionService
    ) throws NameserverException {
        this.registryService = registryService;
        this.connectionService = connectionService;
        this.processorAdaptor = new NameserverProcessorAdaptor(
            this,
            registryService
        );

        serverBootstrap = new ServerBootstrap()
            .group(new NioEventLoopGroup(nameserverServerConfig.getNioThreadCount()), new NioEventLoopGroup())
            .channel(NioServerSocketChannel.class)
            .option(ChannelOption.SO_BACKLOG, 1024)
            .option(ChannelOption.SO_REUSEADDR, true)
            .childOption(ChannelOption.SO_KEEPALIVE, false)
            .childOption(ChannelOption.TCP_NODELAY, true)
            .childOption(ChannelOption.SO_SNDBUF, 65535)
            .childOption(ChannelOption.SO_RCVBUF, 65535)
            .childHandler(new ChannelInitializer<NioSocketChannel>() {
                @Override
                protected void initChannel(NioSocketChannel ch) throws Exception {
                    ch.pipeline().addLast(new IdleStateHandler(
                        0, 0, nameserverServerConfig.getServiceOfflineTtl()));

                    ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(
                        NameserverSystemConstants.MAX_FRAME_LENGTH, 0,
                        4, 0, 4));

                    ch.pipeline().addLast(new LengthFieldPrepender(4));

                    ch.pipeline().addLast(new RemotingCommandDecoder());
                    ch.pipeline().addLast(new RemotingCommandEncoder());
                    ch.pipeline().addLast(processorAdaptor);
                }
            });

        updateNameServerState(INIT_FINISH);
    }

    /**
     * 启动
     *
     * @throws NameserverException NameserverStartException
     */
    public void start() throws NameserverException {
        log.info("start nameserver [{}], configuration:\n {}",
            nameserverServerConfig.getServiceInstance(), nameserverServerConfig);

        try {
            nameserverChannelFuture = serverBootstrap.bind(
                nameserverServerConfig.getServiceInstance().getHost(),
                nameserverServerConfig.getServiceInstance().getPort()
            );

            nameserverChannelFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture channelFuture) throws Exception {
                    updateNameServerState(RUNNING);
                }
            });

        } catch (Exception e) {
            updateNameServerState(SHUT_DOWN);
            throw new NameserverException("start error", e);
        }
    }

    /**
     * 添加自定义命令处理器
     *
     * @param commandFlag commandFlag 命令标识
     * @param customRequestHandler customRequestHandler    处理器
     */
    public void addCustomCommandHandler(Integer commandFlag, CustomRequestHandler customRequestHandler)
        throws CustomCommandException {
        customCommandService.addCustomCommandHandler(commandFlag, customRequestHandler);
    }

    /**
     * 调用自定义命令handler
     *
     * @param channel channel
     * @param request request
     * @return response
     */
    public RemotingCommand tryInvokeCustomCommand(Channel channel, RemotingCommand request)
        throws CustomCommandException {
        // Step 1 校验是否注册服务
        String key = channel.attr(NettyConstants.CLIENT_NAME).get();

        if (!registryService.existServiceInstance(key)) {
            log.debug("channel[{}] didn't registry, drop request [{}]", key, request);
            closeChannel(channel);
            return null;
        }

        // Step 2 运行自定义命令
        RemotingCommand response = customCommandService.tryInvokeCustomCommandHandler(request);
        if (response.getTransactionId() == null) {
            response.setTransactionId(request.getTransactionId());
        }

        return response;
    }

    /**
     * 给服务实例发送命令
     *
     * @param group group
     * @param serviceId serviceId
     * @param instanceId instanceId
     * @param remotingCommand remotingCommand
     * @return CompletableFuture<RemotingCommand>
     */
    public CompletableFuture<RemotingCommand> sendCommandToServiceInstance(
        String group,
        String serviceId,
        String instanceId,
        RemotingCommand remotingCommand
    ) {
        // Step 1 获取连接
        String key = NameserverUtil.generateServiceInstanceKey(group, serviceId, instanceId);
        ConnectEntry connectEntry = connectionService.getServiceInstanceChannel(key);

        if (connectEntry == null || !connectEntry.isUsable()) {
            log.error("[{}] channel is unusable", key);
            return CompletableFuture.completedFuture(null);
        }

        return CompletableFuture.supplyAsync(() -> {
            try {
                CountDownLatch latch = new CountDownLatch(1);
                AtomicReference<RemotingCommand> result = new AtomicReference<>();

                // Step 2 注册请求
                boolean registry = processorAdaptor.registryRequest(remotingCommand, response -> {
                    result.set(response);
                    latch.countDown();
                });

                if (registry) {
                    connectEntry.getChannel().writeAndFlush(remotingCommand);
                }

                latch.await();
                return result.get();
            } catch (InterruptedException e) {
                throw new RuntimeException("send command %s error".formatted(remotingCommand), e);
            }
        }, executorService);
    }

    /**
     * 关闭连接某客户端的channel连接
     *
     * @param channel channel
     */
    public void closeChannel(Channel channel) {
        if (channel == null) {
            return;
        }

        String key = channel.attr(NettyConstants.CLIENT_NAME).get();

        if (registryService.existServiceInstance(key)) {
            connectionService.closeServiceChannel(channel, key);
        } else if (channel.isActive()) {
            channel.close();
        }
    }

    /**
     * 更新状态
     *
     * @param newState newState
     * @throws NameserverException NameserverException
     */
    private void updateNameServerState(NameServerState newState) throws NameserverException {
        synchronized (this) {
            boolean isUpdate = switch (newState) {
                case JUST_START: {
                    yield state == null || state == JUST_START;
                }
                case INIT_FINISH:
                    yield state == JUST_START || state == INIT_FINISH;
                case RUNNING:
                    yield state == INIT_FINISH;
                case SHUT_DOWN:
                    yield state != SHUT_DOWN;
            };

            if (isUpdate) {
                log.info("nameserver[{}] status updated [{}]->[{}]", nameserverServerConfig.getServiceInstance(), state,
                    newState);
                state = newState;
            } else {
                throw new NameserverException("state cannot from [%s] to [%s]".formatted(state, newState));
            }
        }
    }
}
package cn.com.vortexa.nameserver.server;

import cn.com.vortexa.nameserver.config.NameserverServerConfig;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.RequestHandleResult;
import cn.com.vortexa.nameserver.dto.ServiceInstance;
import cn.com.vortexa.nameserver.exception.CustomCommandException;
import cn.com.vortexa.nameserver.exception.NameserverException;
import cn.com.vortexa.nameserver.handler.CustomRequestHandler;
import cn.com.vortexa.nameserver.service.impl.FileRegistryService;
import cn.com.vortexa.nameserver.service.impl.MemoryConnectionService;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Random;
import java.util.concurrent.TimeUnit;

class NameserverServiceTest {

    private static final Logger log = LoggerFactory.getLogger(NameserverServiceTest.class);
    static NameserverServerConfig nameserverServerConfig;

    static NameserverService nameserverService;

    static Random random = new Random();

    @BeforeAll
    public static void setUp() throws NameserverException {
        nameserverServerConfig = new NameserverServerConfig();

        ServiceInstance address = ServiceInstance.builder()
            .group("default")
            .serviceId("sahara")
            .clientId("sahara_test")
            .host("127.0.0.1")
            .port(8080)
            .build();

        nameserverServerConfig.setServiceInstance(address);

        nameserverService = new NameserverService(NameserverServerConfig.DEFAULT);

        nameserverService.init(new FileRegistryService(), new MemoryConnectionService());
    }

    @Test
    public void test() throws NameserverException, InterruptedException, CustomCommandException {
        nameserverService.start();

        nameserverService.addCustomCommandHandler(3001, new CustomRequestHandler() {
            @Override
            public RequestHandleResult handlerRequest(RemotingCommand request) {
                log.warn("收到客户端自定义命令[{}]", request);

                return RequestHandleResult.success("test-" + random.nextInt());
            }
        });
        TimeUnit.SECONDS.sleep(10000);
    }
}
package cn.com.vortexa.nameserver.util;

import java.io.File;

/**
 * @author h30069248
 * @since 2025/3/20 9:44
 */
public class NameserverUtil {

    private static final String STORE_FILE_RESOURCE_PATH = System.getProperty("user.dir") + File.separator
        + "nameserver";

    private static final String SERVICE_INSTANCE_KEY_DISPATCHER = "#%&%#";

    /**
     * 生成服务实例的key
     *
     * @param group group
     * @param serviceId serviceId
     * @param instanceId instanceId
     * @return String
     */
    public static String generateServiceInstanceKey(String group, String serviceId, String instanceId) {
        return group + SERVICE_INSTANCE_KEY_DISPATCHER + serviceId + SERVICE_INSTANCE_KEY_DISPATCHER + instanceId;
    }

    /**
     * 存储文件路径
     *
     * @param fileName fileName
     * @return path
     */
    public static String getStoreFileResourcePath(String fileName) {
        return STORE_FILE_RESOURCE_PATH + File.separator + fileName;
    }
}
package cn.com.vortexa.websocket.netty.constants;

import io.netty.util.AttributeKey;

public class NettyConstants {

    /**
     * 一朕的最大长度
     */
    public final static int MAX_FRAME_LENGTH = 1024;


    /**
     * 放在netty channel 里的 client_name 的 key
     */
    public static final AttributeKey<String> CLIENT_NAME = AttributeKey.valueOf("client_name");

    /**
     * 请求等待时间
     */
    public static final long REQUEST_WAITE_SECONDS = 60;

    /**
     * netty客户端断线重连时间
     */
    public static final int RECONNECT_DELAY_SECONDS = 1;


    /**
     * netty客户端断线重连次数
     */
    public static final int RECONNECT_LIMIT = 3;
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.server.NameserverService;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

/**
 * @author h30069248
 * @since 2025/3/18 9:46
 */
@Slf4j
public class PingCommandProcessor {

    private final NameserverService nameserverService;

    public PingCommandProcessor(NameserverService nameserverService) {
        this.nameserverService = nameserverService;
    }

    public RemotingCommand handlerPing(String clientName, Channel channel, RemotingCommand remotingCommand) {
        log.debug("receive client[{}] ping", clientName);

        RemotingCommand pong = RemotingCommand.generatePongCommand(clientName);
        pong.setTransactionId(remotingCommand.getTransactionId());

        nameserverService.getConnectionService().freshServiceInstanceConnection(clientName, channel);

        return pong;
    }
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.server.NameserverService;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

/**
 * @author h30069248
 * @since 2025/3/18 9:46
 */
@Slf4j
public class PongCommandProcessor {
    private final NameserverService nameserverService;

    public PongCommandProcessor(NameserverService nameserverService) {
        this.nameserverService = nameserverService;
    }

    public RemotingCommand handlerPong(String clientName, Channel channel, RemotingCommand remotingCommand) {
        log.debug("receive client[{}] pong", clientName);

        return null;
    }
}
package cn.com.vortexa.nameserver.dto;

import cn.com.vortexa.nameserver.constant.LanguageCode;
import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.nameserver.protocol.Serializer;
import cn.com.vortexa.nameserver.util.DistributeIdMaker;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.HashMap;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class RemotingCommand {

    public static final RemotingCommand TIME_OUT_COMMAND;
    public static final RemotingCommand PARAMS_ERROR;

    public static final String TRANSACTION_ID_KEY = "transaction_id";
    public static final String GROUP_KEY = "group";
    public static final String SERVICE_ID_KEY = "service_id";
    public static final String CLIENT_ID_KEY = "client_id";

    static {
        TIME_OUT_COMMAND = new RemotingCommand();
        TIME_OUT_COMMAND.setFlag(RemotingCommandFlagConstants.TIME_OUT_EXCEPTION);
        TIME_OUT_COMMAND.setCode(RemotingCommandCodeConstants.FAIL);

        PARAMS_ERROR = new RemotingCommand();
        PARAMS_ERROR.setFlag(RemotingCommandFlagConstants.PARAMS_ERROR);
        PARAMS_ERROR.setCode(RemotingCommandCodeConstants.FAIL);
    }

    private Integer flag;
    private Integer code;
    private LanguageCode language = LanguageCode.JAVA;
    private Integer version = 0;
    private String remark;
    private HashMap<String, String> extFields;

    private byte[] body;

    private Object payLoad;

    @Override
    public RemotingCommand clone() {
        RemotingCommand remotingCommand = new RemotingCommand();
        remotingCommand.setFlag(this.flag);
        remotingCommand.setCode(this.code);
        remotingCommand.setLanguage(this.language);
        remotingCommand.setVersion(this.version);
        remotingCommand.setRemark(this.remark);
        remotingCommand.setExtFields(this.extFields);
        remotingCommand.setBody(this.body);
        remotingCommand.setPayLoad(this.payLoad);
        return remotingCommand;
    }

    public String getTransactionId() {
        return getExtFieldsValue(TRANSACTION_ID_KEY);
    }

    public void setTransactionId(String tsId) {
        addExtField(TRANSACTION_ID_KEY, tsId);
    }

    public String getGroup() {
        String value = getExtFieldsValue(GROUP_KEY);
        return (value == null || value.isEmpty()) ? "default" : value;
    }

    public void setGroup(String group) {
        addExtField(GROUP_KEY, group);
    }

    public String getServiceId() {
        return getExtFieldsValue(SERVICE_ID_KEY);
    }

    public void setServiceId(String serviceId) {
        addExtField(SERVICE_ID_KEY, serviceId);
    }

    public String getClientId() {
        return getExtFieldsValue(CLIENT_ID_KEY);
    }

    public void setClientId(String clientId) {
        addExtField(CLIENT_ID_KEY, clientId);
    }

    public String getExtFieldsValue(String extFieldsKey) {
        if (extFields == null) return null;
        return extFields.get(extFieldsKey);
    }

    public Integer getExtFieldsInt(String extFieldsKey) {
        String value = getExtFieldsValue(extFieldsKey);
        if (value == null || value.isEmpty()) return null;
        return Integer.parseInt(value);
    }

    public Long getExtFieldsLong(String extFieldsKey) {
        String value = getExtFieldsValue(extFieldsKey);
        if (value == null || value.isEmpty()) return null;
        return Long.parseLong(value);
    }

    public void addExtField(String key, String value) {
        if (this.extFields == null) {
            this.extFields = new HashMap<>();
        }
        this.extFields.put(key, value);
    }

    public void setBodyFromObject(Object body) {
        this.body = Serializer.Algorithm.Protostuff.serialize(body);
    }

    public void release() {
    }

    protected void clear() {
        this.flag = null;
        this.code = null;
        this.language = null;
        this.version = null;
        this.remark = null;
        if (extFields == null) extFields = new HashMap<>();
        else this.extFields.clear();
        this.body = null;
    }

    public static RemotingCommand generatePingCommand(String key) {
        String txId = DistributeIdMaker.DEFAULT.nextId(key);
        RemotingCommand ping = new RemotingCommand();
        ping.setFlag(RemotingCommandFlagConstants.PING);
        ping.setTransactionId(txId);
        ping.setCode(RemotingCommandCodeConstants.SUCCESS);
        return ping;
    }
    public static RemotingCommand generatePongCommand(String key) {
        String txId = DistributeIdMaker.DEFAULT.nextId(key);
        RemotingCommand pong = new RemotingCommand();
        pong.setFlag(RemotingCommandFlagConstants.PONG);
        pong.setTransactionId(txId);
        pong.setCode(RemotingCommandCodeConstants.SUCCESS);
        return pong;
    }

    @Override
    public String toString() {
        return "RemotingCommand{" +
                "flag=" + flag +
                ", code=" + code +
                ", language=" + language +
                ", version=" + version +
                ", remark='" + remark + '\'' +
                ", extFields=" + extFields +
                ", body=" + ((body == null || body.length == 0) ? "empty" : "not empty") +
                '}';
    }
}
package cn.com.vortexa.nameserver.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author h30069248
 * @since 2025/3/20 14:18
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class RequestHandleResult {

    private Boolean success;

    private Object data;

    public static RequestHandleResult success(Object data) {
        return new RequestHandleResult(true, data);
    }

    public static RequestHandleResult fail(Object data) {
        return new RequestHandleResult(false, data);
    }
}
package cn.com.vortexa.nameserver.processor;

import cn.com.vortexa.nameserver.constant.ExtFieldsConstants;
import cn.com.vortexa.nameserver.constant.RegistryState;
import cn.com.vortexa.nameserver.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.nameserver.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.nameserver.dto.RemotingCommand;
import cn.com.vortexa.nameserver.dto.ServiceInstance;
import cn.com.vortexa.nameserver.protocol.Serializer;
import cn.com.vortexa.nameserver.service.IRegistryService;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;

/**
 * @author helei
 * @since 2025-03-12
 */
@Slf4j
public class ServiceRegistryProcessor {

    private final IRegistryService registryService;

    public ServiceRegistryProcessor(IRegistryService registryService) {
        this.registryService = registryService;
    }

    /**
     * 注册客户端服务
     *
     * @param channel channel
     * @param remotingCommand remotingCommand
     * @return CompletableFuture<RegistryState>
     */
    public RemotingCommand handlerClientServiceRegistry(
        Channel channel,
        RemotingCommand remotingCommand
    ) {
        // Step 1 解析获取参数
        String group = remotingCommand.getGroup();
        String serviceId = remotingCommand.getServiceId();
        String clientId = remotingCommand.getClientId();

        String[] serviceAddress = channel.remoteAddress().toString().split(":");

        ServiceInstance serviceInstance = ServiceInstance.builder()
            .group(group)
            .serviceId(serviceId)
            .clientId(clientId)
            .host(serviceAddress[0])
            .port(Integer.parseInt(serviceAddress[1]))
            .build();

        Map<String, Object> serviceProps = null;
        if (remotingCommand.getBody() != null && remotingCommand.getBody().length > 0) {
            try {
                serviceProps = Serializer.Algorithm.Protostuff.deserialize(remotingCommand.getBody(), Map.class);
            } catch (Exception e) {
                log.warn("get service props from remoting command error, {}", e.getMessage());
            }
        }

        // Step 2 注册服务实例
        RemotingCommand response = new RemotingCommand();
        response.setFlag(RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE_RESPONSE);
        response.setTransactionId(remotingCommand.getTransactionId());
        RegistryState registryState;

        try {
            registryState = registryService.registryService(serviceInstance, serviceProps);

            if (registryState == RegistryState.OK) {
                response.setCode(RemotingCommandCodeConstants.SUCCESS);
            } else {
                response.setCode(RemotingCommandCodeConstants.FAIL);
            }

            log.info("client[{}] registry state [{}]", serviceInstance, registryState);
        } catch (Exception e) {
            log.error("[{}]-[{}] registry error", group, serviceId, e);
            registryState = RegistryState.UNKNOWN_ERROR;
            response.setCode(RemotingCommandCodeConstants.FAIL);
        }

        // Step 3 添加注册状态
        response.addExtField(ExtFieldsConstants.NAMESERVER_REGISTRY_STATUS, registryState.name());
        return response;
    }
}
