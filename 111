package cn.com.helei.bot.app.kaleido_finance;

import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.llm.OpenAIPrompt;
import cn.com.helei.bot.core.util.llm.QwenLLMAgent;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONArray;

import java.util.List;
import java.util.concurrent.CompletableFuture;

public class KaLeiDoFinanceBot extends AnnoDriveAutoBot<KaLeiDoFinanceBot> {

    private static final String REGISTER_API = "https://kaleidofinance.xyz/api/testnet/register";

    private static final String QUESTION_GENERATE_PROMPT = """
            帮我生成[%s]个简单的问题, 有一下几点要求：
            1.问题不能够重复, 需保证多样化。
            2.问题需涵盖各个领域，包括数学、常识、自然科学、历史、文化等。
            3.输出以JSON格式输出, 如： ["question1", "question2", "question3"...]。
            强调, 我需要[%s]个问题
            """;

    public KaLeiDoFinanceBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        OpenAIPrompt prompt = OpenAIPrompt
                .builder()
                .system(String.format(QUESTION_GENERATE_PROMPT, 24, 24))
                .model("text-davinci-002")
                .topP(0.7)
                .temperature(1)
                .build();

        CompletableFuture<List<String>> questionFuture = new QwenLLMAgent(autoBotConfig.getConfig("openai.api.key"))
                .request(prompt)
                .thenApplyAsync(response -> {

                    String lastAnswer = response.getLastAnswer();
                    if (StrUtil.isNotBlank(lastAnswer)) {
                        return JSONArray.parseArray(lastAnswer).stream().map(Object::toString).toList();
                    }

                    throw new RuntimeException("LLM 请求获取问题失败, " + response);
                });
    }

    @Override
    protected KaLeiDoFinanceBot getInstance() {
        return this;
    }

}
package cn.com.helei.bot.app.keitokun;

import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.anno.BotWSMethodConfig;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BotJsonWSClient;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.util.List;


@Slf4j
public class KeiToKunBot extends AnnoDriveAutoBot<KeiToKunBot> {

    public static final String UID_KEY = "uid";

    public static final String TODAY_KEY = "today";

    public static final String TODAY_REMAINING_TAP_KEY = "today_remaining_tap";

    private static final String TAP_BASE_URL_KEY = "tap_base_url";


    public KeiToKunBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);
    }


    @Override
    protected KeiToKunBot getInstance() {
        return this;
    }


    @Override
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
        String today = LocalDate.now().toString();

        accountContexts.forEach(accountContext -> {
            // 判断今日的有没有点击完成
            String remainingTapStr = accountContext.getParam(TODAY_REMAINING_TAP_KEY);
            String accountSaveDay = accountContext.getParam(TODAY_KEY);

            // 今天还有没点击的,或者就没点击
            if (accountSaveDay == null || remainingTapStr == null
                    || !accountSaveDay.equals(today) || Integer.parseInt(remainingTapStr) >= 0
            ) {
                accountContext.setParam(TODAY_KEY, LocalDate.now().toString());
                accountContext.setParam(TODAY_REMAINING_TAP_KEY, StrUtil.isBlank(remainingTapStr) ? "500" : remainingTapStr);
            } else {
                accountContext.setParam(TODAY_REMAINING_TAP_KEY, "0");
            }
        });
    }


    @BotMethod(
            jobType = BotJobType.WEB_SOCKET_CONNECT,
            jobName = "ws-keep-alive-task",
            bowWsConfig = @BotWSMethodConfig(
                    isRefreshWSConnection = true,
                    heartBeatIntervalSecond = 5,
                    wsConnectCount = 10
            )
    )
    public BotJsonWSClient tapConnection(AccountContext accountContext) {
        String prefix = accountContext.getSimpleInfo();

        // Step 1 检查是否有uid
        String uid = accountContext.getParam("uid");

        if (StrUtil.isBlank(uid)) {
            log.warn("{} uid不可用", prefix);
            return null;
        }

        // Step 2 判断今天的点击是否完成
        String today = LocalDate.now().toString();
        String remainingTapStr = accountContext.getParam(TODAY_REMAINING_TAP_KEY);
        String accountSaveDay = accountContext.getParam(TODAY_KEY);

        // 新的一天
        if (accountSaveDay == null || !accountSaveDay.equals(today) || StrUtil.isBlank(remainingTapStr)) {
            accountContext.setParam(TODAY_KEY, LocalDate.now().toString());
            accountContext.setParam(TODAY_REMAINING_TAP_KEY, "500");
        } else if (Integer.parseInt(remainingTapStr) > 0) { // 日内没点击完
            log.info("{} 没点击完，剩余: {}", prefix, remainingTapStr);
        } else {
            // 今天点击完的
            log.warn("{} 今日点击已完成", prefix);
            return null;
        }

        log.info("{}-uid[{}] 开始创建ws客户端", prefix, uid);

        String connectUrl = getAutoBotConfig().getConfig(TAP_BASE_URL_KEY) + "?uid=" + accountContext.getParam(UID_KEY);

        return new KeiToKunWSClient(accountContext, connectUrl);
    }
}
package cn.com.helei.bot.app.keitokun;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.supporter.netty.BotJsonWSClient;
import cn.com.helei.bot.core.supporter.netty.constants.WebsocketClientStatus;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;

import static cn.com.helei.bot.app.keitokun.KeiToKunBot.TODAY_KEY;
import static cn.com.helei.bot.app.keitokun.KeiToKunBot.TODAY_REMAINING_TAP_KEY;


@Slf4j
public class KeiToKunWSClient extends BotJsonWSClient {

    private final static Map<BaseBotWSClient<JSONObject, JSONObject>, Integer> clientNoResponsePingCount = new ConcurrentHashMap<>();

    private final static Map<BaseBotWSClient<JSONObject, JSONObject>, Integer> requestIdMap = new ConcurrentHashMap<>();

    private final static int noResponsePingLimit = 10;

    private final Random random = new Random();

    public KeiToKunWSClient(AccountContext accountContext, String connectUrl) {
        super(accountContext, connectUrl);
    }

    @Override
    public void whenAccountClientStatusChange(WebsocketClientStatus clientStatus) {
        AccountContext accountContext = this.getAccountContext();

        String printPrefix = accountContext.getSimpleInfo() + "-" + accountContext.getParam(KeiToKunBot.UID_KEY);

        switch (clientStatus) {
            case RUNNING -> {
                log.info("{} 连接ws服务器[{}]成功", printPrefix, url);

            }
            case STOP -> {
                log.info("{} 连接到ws服务器[{}]失败", printPrefix, url);

                accountContext.getConnectStatusInfo().getRestart().incrementAndGet();
            }
            case SHUTDOWN -> {
                log.info("{} ws连接已断开", printPrefix);
                requestIdMap.remove(this);
            }
        }
    }

    @Override
    public JSONObject getHeartbeatMessage() {
        Integer count = clientNoResponsePingCount.compute(this, (k, v) -> {
            if (v != null && v >= noResponsePingLimit) {
                return null;
            }
            return v == null ? 1 : v + 1;
        });

        if (count == null) {
            log.warn("{} 长时间未收到pong，关闭客户端", this.getAccountContext().getSimpleInfo());
            this.close();
            return null;
        }


        JSONObject frame = new JSONObject();
        frame.put("cmd", 1001);
        frame.put("id", requestIdMap.compute(this, (k, v) -> v == null ? 1 : v + 1));
        frame.put("uid", getAccountContext().getParam("uid"));

        JSONObject data = new JSONObject();
        int randomClickTimes = getRandomClickTimes();

        data.put("amount", randomClickTimes);
        data.put("collectNum", randomClickTimes);
        data.put("timestamp", System.currentTimeMillis());
        frame.put("data", data);

        log.info("[{}] 发送心跳[{}]", getAccountContext().getSimpleInfo(), frame);
        getAccountContext().getConnectStatusInfo().getHeartBeat().getAndIncrement();

        return frame;
    }

    @Override
    public void whenAccountReceiveResponse(
            Object id,
            JSONObject response
    ) {
        Integer cmd = response.getInteger("cmd");
        JSONObject data = response.getJSONObject("data");

        AccountContext accountContext = this.getAccountContext();
        ConnectStatusInfo connectStatusInfo = accountContext.getConnectStatusInfo();

        String prefix = accountContext.getSimpleInfo() + "-" + accountContext.getParam("uid");

        log.info("{} 收到消息 {}", prefix, response);
        if (cmd == 1001) {
            Integer totalNum = data.getInteger("totalNum");
            Integer collectNum = data.getInteger("collectNum");

            accountContext.setParam(TODAY_REMAINING_TAP_KEY,
                    String.valueOf(Math.max(0, totalNum - collectNum)));

            // 今日的领完了, 关闭
            if (totalNum <= collectNum) {
                log.info("{} 今日keitokun点击已完成，断开ws连接", prefix);
                accountContext.setParam(TODAY_KEY, LocalDate.now().toString());
                this.shutdown();
            }

            log.info("{} 收到响应,[{}/{}](已点击/剩余)", prefix,
                    collectNum, totalNum);

            accountContext.getRewordInfo().setTotalPoints(data.getInteger("keitoAmount") * 1.0);
            accountContext.getRewordInfo().setTotalPoints(collectNum * 1.0);

            connectStatusInfo.getHeartBeat().incrementAndGet();
        } else {
            log.warn("{} 收到未知响应[{}]", prefix, response);
            connectStatusInfo.getErrorHeartBeat().incrementAndGet();
        }

        connectStatusInfo.setUpdateDateTime(LocalDateTime.now());
    }

    @Override
    public void whenAccountReceiveMessage(
            JSONObject message
    ) {

    }


    private int getRandomClickTimes() {
        return random.nextInt(5) + 1;
    }
}
package cn.com.helei.bot.app.kile_ai;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.entity.RewordInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.FileUtil;
import cn.com.helei.bot.core.util.pool.IdMarkPool;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.extern.slf4j.Slf4j;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
@BotApplication(name = "Kile_AI_BOT")
public class KileAIBot extends AnnoDriveAutoBot<KileAIBot> {


    private static final List<String> AGENT_LIST = List.of(
            "deployment-uu9y1z4z85rapgwkss1muuiz",
            "deployment-ecz5o55dh0dbqagkut47kzyc",
            "deployment-sofftlsf9z4fya3qchykaanq"
    );

    private static final String QUESTION_ASK_URL_FORMAT = "https://%s.stag-vxzy.zettablock.com/main";

    private static final String QUESTION_CONFIRM_URL = "https://quests-usage-dev.prod.zettablock.com/api/report_usage";

    private static final String WALLET_KEY = "eth_address";

    private static final String TODAY_KEY = "today";

    private static final String TODAY_TOTAL_KEY = "today_total";

    private static final int QUESTION_CONFIRM_LIMIT = 3;

    private final Random random = new Random();

    private final IdMarkPool<String> questionPool;


    public KileAIBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        String botAppConfigPath = FileUtil.getBotAppConfigPath();

        try {
            List<String> questions = Files.readAllLines(Path.of(botAppConfigPath + File.separator + "kile_ai" + File.separator + "question.txt"));
            this.questionPool = IdMarkPool.create(questions, String.class);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    protected KileAIBot getInstance() {
        return this;
    }

    /**
     * 每日询问的定时任务
     *
     * @param accountContext accountContext
     * @return String
     */
    @BotMethod(
            jobType = BotJobType.TIMED_TASK,
            jobName = "每日询问 AI",
            intervalInSecond = 60 * 60 * 12
    )
    public String queryAgentClaim(AccountContext accountContext) {
        if (accountContext.getAccountBaseInfo().getId() != 1) return "";

        // Step 1 过滤完成的，或不能用的
        if (filterAccountContext(accountContext)) {
            return "account-%s claim error, account claimed or unusable".formatted(accountContext.getSimpleInfo());
        }

        // Step 2 获取需要查询的数量
        int queryCount = Integer.parseInt(accountContext.getParam(TODAY_TOTAL_KEY));

        int errorCount = 0;

        // Step 3 开始逐个查询
        for (int i = 0; i < queryCount; i++) {
            String agent = getRandomAgent();
            String question = questionPool.getLessUsedItem(1).getFirst();

            log.info("{} 开始询问Agent[{}], [{}/{}]", accountContext.getSimpleInfo(), agent, i + 1, queryCount);

            // Step 3.1 询问问题
            CompletableFuture<Boolean> future = askQuestion(accountContext, agent, question)
                    // Step 3.2 询问完成后，提交问题和答案
                    .thenApplyAsync(resultStr -> {
                        if (StrUtil.isNotBlank(resultStr)) {
                            log.info("{} 询问Agent成功 [{}] -> [{}]", accountContext.getSimpleInfo(), question, resultStr);
                            try {
                                return confirmQuestion(accountContext, agent, question, resultStr).get();
                            } catch (InterruptedException | ExecutionException e) {
                                log.error("{} 上报问答发生异常, {}", accountContext, e.getMessage());
                                return false;
                            }
                        } else {
                            log.error("{} 询问Agent失败, question.dat [{}]", accountContext, question);
                            return false;
                        }
                    });
            try {
                if (future.get()) {
                    log.info("{} - 问题提交成功, [{}/{}]", accountContext.getSimpleInfo(), i + 1, queryCount);

                    accountContext.setParam(TODAY_TOTAL_KEY, queryCount - i);

                    RewordInfo rewordInfo = accountContext.getRewordInfo();

                    rewordInfo.setDailyPoints(rewordInfo.getDailyPoints() + 10);
                }
            } catch (InterruptedException | ExecutionException e) {
                errorCount++;
                log.error("{} - 问题提交失败, [{}/{}]", accountContext.getSimpleInfo(), i + 1, queryCount, e);
            }
        }

        return "account-%s-claim-complete, [%d/%d]".formatted(accountContext.getSimpleInfo(), queryCount - errorCount, queryCount);
    }


    /**
     * 过滤不可用的账户
     *
     * @param accountContext accountContext
     * @return boolean 是否过滤
     */
    private boolean filterAccountContext(AccountContext accountContext) {
        if (StrUtil.isBlank(accountContext.getParam(WALLET_KEY))) {
            log.warn("{} 没有钱包参数", accountContext.getSimpleInfo());
            return true;
        }

        String today = LocalDate.now().toString();
        String acDay = accountContext.getParam(TODAY_KEY);

        // 今天没做过
        if (!today.equals(acDay)) {
            accountContext.setParam(TODAY_KEY, today);
            int dailyQueryCount = getDailyQueryCount();
            accountContext.setParam(TODAY_TOTAL_KEY, dailyQueryCount);

            log.info("{} 今日还未执行, 问题个数[{}]", accountContext.getSimpleInfo(), dailyQueryCount);
        } else {
            String todayTotalStr = accountContext.getParam(TODAY_TOTAL_KEY);
            Integer todayTotal = null;

            if (todayTotalStr == null) {
                accountContext.setParam(TODAY_TOTAL_KEY, getDailyQueryCount());
            } else if ((todayTotal = Integer.valueOf(todayTotalStr)) == 0) {
                log.warn("{} 今日已完成", accountContext.getSimpleInfo());
                return true;
            } else {
                log.info("{} 今日剩余[{}], 继续执行", accountContext.getSimpleInfo(), todayTotal);
            }
        }

        return false;
    }


    /**
     * 询问Agent
     *
     * @param accountContext accountContext
     * @param agent          agent
     * @param question       question
     * @return CompletableFuture<String>
     */
    private CompletableFuture<String> askQuestion(AccountContext accountContext, String agent, String question) {
        JSONObject body = new JSONObject();
        body.put("message", question);
        body.put("stream", true);

        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
        headers.put("Origin", "https://agents.testnet.gokite.ai");
        headers.put("Referer", "https://agents.testnet.gokite.ai/");
        headers.put("connection", "keep-alive");
        headers.put("Accept", "text/event-stream");

        String url = QUESTION_ASK_URL_FORMAT.formatted(agent);

        headers.put("Host", url.replace("/main", "")
                .replace("https://", ""));

        return syncStreamRequest(
                accountContext.getProxy(),
                url,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> "%s 询问Agent%s[{}], 问题: %s".formatted(accountContext.getSimpleInfo(), agent, question)
        ).thenApplyAsync(responseList -> {
            StringBuilder answer = new StringBuilder();

            for (String chunk : responseList) {
                String res = chunk.substring(5);

                if ("[DONE]".equals(res)) {
                    break;
                }

                JSONObject jsonObject = JSONObject.parseObject(res);
                String content = jsonObject.getJSONArray("choices").getJSONObject(0).getString("content");

                answer.append(content);
            }

            return answer.toString();
        });
    }


    /**
     * 确认问答，，只有确认了才有分
     *
     * @param accountContext accountContext
     * @param agent          agent
     * @param question       question.dat
     * @param answer         answer
     * @return 是否确认成功
     */
    private CompletableFuture<Boolean> confirmQuestion(
            AccountContext accountContext,
            String agent,
            String question,
            String answer
    ) {
        ProxyInfo proxy = accountContext.getProxy();

        String wallet = accountContext.getParam(WALLET_KEY);

        JSONObject body = new JSONObject();
        body.put("wallet_address", wallet);
        body.put("agent_id", agent);
        body.put("request_text", question);
        body.put("response_text", answer);
        body.put("request_metadata", new JSONObject());

        return CompletableFuture.supplyAsync(() -> {
            Exception lastException = null;

            for (int i = 0; i < QUESTION_CONFIRM_LIMIT; i++) {
                try {
                    String resultStr = syncRequest(
                            proxy,
                            QUESTION_CONFIRM_URL,
                            HttpMethod.POST,
                            accountContext.getBrowserEnv().getHeaders(),
                            null,
                            body,
                            () -> accountContext.getSimpleInfo() + " 上报问答 - " + question
                    ).get();

                    log.info("{} 上报问答成功, {}", accountContext.getSimpleInfo(), resultStr);
                    return true;
                } catch (InterruptedException | ExecutionException e) {
                    log.warn("{} 上报问答发生异常, [{}/{}]", accountContext.getSimpleInfo(), i + 1, QUESTION_CONFIRM_LIMIT);
                    lastException = e;
                }
            }
            throw new RuntimeException("上报问答超过次数限制，" + QUESTION_CONFIRM_LIMIT, lastException);
        });
    }

    /**
     * 获取每日运行多少次
     *
     * @return 数量
     */
    private int getDailyQueryCount() {
        return 20 + random.nextInt(3);
    }

    /**
     * 随机选取agent
     *
     * @return String
     */
    private String getRandomAgent() {
        return AGENT_LIST.get(random.nextInt(AGENT_LIST.size()));
    }
}
package cn.com.helei.bot.app.nodego;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.captcha.CloudFlareResolver;
import cn.com.helei.bot.core.util.exception.RegisterException;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
@BotApplication(name = "NodeGO", describe = "NodeGo自动机器人")
public class NodeGoBot extends AnnoDriveAutoBot<NodeGoBot> {

    private static final String PASSWORD_KEY = "password";

    private static final String ACCESS_TOKEN_KEY = "accessToken";

    private static final String REGISTER_WEBSITE_KEY = "0x4AAAAAAA4zgfgCoYChIZf4";

    private static final String REGISTER_WEBSITE_URL = "https://app.nodego.ai/register";

    private static final String REGISTER_API = "https://nodego.ai/api/auth/register";

    private static final String LOGIN_API = "https://nodego.ai/api/auth/login";

    private static final String CHECK_IN_API = "https://nodego.ai/api/user/checkin";

    private static final String KEEP_ALIVE_API = "https://nodego.ai/api/user/nodes/ping";

    private static final int KEEP_ALIVE_INTERVAL = 60;

    private static final int DAILY_CHECK_IN_INTERVAL = 60 * 60 * 6;

    private String twoCaptchaApiKey = "";

    public NodeGoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);
        this.twoCaptchaApiKey = autoBotConfig.getConfig("2_CAPTCHA_API_KEY");
    }

    @Override
    protected NodeGoBot getInstance() {
        return this;
    }

    @BotMethod(jobType = BotJobType.REGISTER)
    public Result autoRegister(AccountContext accountContext, String inviteCode) {
        String email = accountContext.getAccountBaseInfo().getEmail();
        String username = email.split("@")[0];
        String password = accountContext.getParam(PASSWORD_KEY);

        log.info("{} 开始打码获取token", username);
        CompletableFuture<Result> future = CloudFlareResolver.cloudFlareResolve(
                        accountContext.getProxy(),
                        REGISTER_WEBSITE_URL,
                        REGISTER_WEBSITE_KEY,
                        twoCaptchaApiKey
                )
                .thenApplyAsync(tokenAndUA -> {
                    log.info("{} 开始打码成功， result:[{}]", username, tokenAndUA);

                    String token = tokenAndUA.getString("token");
                    String userAgent = tokenAndUA.getString("userAgent");

                    JSONObject body = new JSONObject();

                    body.put("username", username);
                    body.put("email", email);
                    body.put("password", password);
                    body.put("refBy", inviteCode);
                    body.put("captcha", token);

                    // 请求注册
                    Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
                    headers.put("User-Agent", userAgent);
                    headers.put("Origin", "https://app.nodego.ai");
                    headers.put("Accept", "application/json");
                    headers.put("referer", "https://app.nodego.ai/");

                    try {
                        return syncRequest(
                                accountContext.getProxy(),
                                REGISTER_API,
                                HttpMethod.POST,
                                headers,
                                null,
                                body,
                                () -> accountContext.getSimpleInfo() + " 开始注册"
                        ).get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new RegisterException(accountContext.getSimpleInfo() + " 注册失败, " + e.getMessage());
                    }
                })
                .thenApplyAsync(registerResultStr -> {
                    JSONObject registerResult = JSONObject.parseObject(registerResultStr);

                    Integer statusCode = registerResult.getInteger("statusCode");
                    if (statusCode == 201) {
                        log.info("{} 注册成功, {}", accountContext.getSimpleInfo(), registerResultStr);

                        accountContext.setParam(ACCESS_TOKEN_KEY, registerResult
                                .getJSONObject("metadata").getString(ACCESS_TOKEN_KEY));

                        AccountContext.signUpSuccess(accountContext);

                        return Result.ok();
                    } else {
                        throw new RegisterException("注册失败, " + registerResultStr);
                    }
                })
                .exceptionallyAsync(throwable -> {
                    log.error("{} 注册发生异常", accountContext.getSimpleInfo(), throwable);

                    String exception = throwable.getMessage();
                    if (exception.contains("{\"message\":\"Email already exists\",\"error\":\"Bad Request\",\"statusCode\":400}")) {
                        log.warn("{} 已注册过", accountContext.getSimpleInfo());
                        AccountContext.signUpSuccess(accountContext);
                        return Result.ok();
                    }
                    return Result.fail("注册发生异常, " + exception);
                });

        try {
            return future.get();
        } catch (ExecutionException | InterruptedException e) {
            return Result.fail("未知错误, " + e.getMessage());
        }
    }


    @BotMethod(jobType = BotJobType.LOGIN)
    public Result login(AccountContext accountContext) {
        if (accountContext.getParams().containsKey(ACCESS_TOKEN_KEY)) {
            log.warn("{} 已存在token", accountContext.getSimpleInfo());
            return Result.ok();
        }

        String email = accountContext.getAccountBaseInfo().getEmail();
        String password = accountContext.getParam(PASSWORD_KEY);

        log.info("{} 开始打码获取token", email);
        CompletableFuture<Result> future = CloudFlareResolver.cloudFlareResolve(
                        accountContext.getProxy(),
                        REGISTER_WEBSITE_URL,
                        REGISTER_WEBSITE_KEY,
                        twoCaptchaApiKey
                )
                .thenApplyAsync(tokenAndUA -> {
                    log.info("{} 开始打码成功， result:[{}]", email, tokenAndUA);

                    String token = tokenAndUA.getString("token");
                    String userAgent = tokenAndUA.getString("userAgent");

                    // 请求注册
                    Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
                    headers.put("User-Agent", userAgent);
                    headers.put("Origin", "https://app.nodego.ai");
                    headers.put("Accept", "application/json");
                    headers.put("referer", "https://app.nodego.ai/");


                    JSONObject body = new JSONObject();
                    body.put("email", email);
                    body.put("password", password);
                    body.put("captcha", token);
                    try {
                        return syncRequest(
                                accountContext.getProxy(),
                                LOGIN_API,
                                HttpMethod.POST,
                                headers,
                                null,
                                body,
                                () -> accountContext.getSimpleInfo() + " 开始登录"
                        ).get();
                    } catch (InterruptedException | ExecutionException e) {
                        throw new RegisterException(accountContext.getSimpleInfo() + " 登录失败, " + e.getMessage());
                    }
                })
                .thenApplyAsync(registerResultStr -> {
                    JSONObject registerResult = JSONObject.parseObject(registerResultStr);

                    Integer statusCode = registerResult.getInteger("statusCode");
                    if (statusCode == 201) {
                        log.info("{} 登录成功, {}", accountContext.getSimpleInfo(), registerResultStr);

                        accountContext.setParam(ACCESS_TOKEN_KEY, registerResult
                                .getJSONObject("metadata").getString(ACCESS_TOKEN_KEY));

                        return Result.ok();
                    } else {
                        throw new RegisterException("登录失败, " + registerResultStr);
                    }
                })
                .exceptionallyAsync(throwable -> {
                    log.error("{} 登录发生异常, {}", accountContext.getSimpleInfo(), throwable.getMessage());
                    return Result.fail("登录发生异常," + throwable.getMessage());
                });

        try {
            return future.get();
        } catch (ExecutionException | InterruptedException e) {
            return Result.fail("未知错误, " + e.getMessage());
        }
    }


    @BotMethod(
            jobType = BotJobType.TIMED_TASK,
            intervalInSecond = KEEP_ALIVE_INTERVAL
    )
    public void keepAlivePing(AccountContext accountContext) {
        String token = accountContext.getParam(ACCESS_TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            log.error("{} 没有登录", accountContext.getSimpleInfo());
        }

        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
        headers.put("Origin", "");
        headers.put("Reffer", "");
        headers.put("Auth", " " + token);

        // 发送心跳
        syncRequest(
                accountContext.getProxy(),
                KEEP_ALIVE_API,
                HttpMethod.GET,
                headers,
                null,
                null,
                () -> accountContext.getSimpleInfo() + " send keep alive ping"
        ).exceptionallyAsync(throwable -> {
            log.error("{} send keep alive field", accountContext.getSimpleInfo());
            return null;
        });
    }

    @BotMethod(
            jobType = BotJobType.TIMED_TASK,
            intervalInSecond = DAILY_CHECK_IN_INTERVAL
    )
    public void checkIn(AccountContext accountContext) {
        String token = accountContext.getParam(ACCESS_TOKEN_KEY);
        if (StrUtil.isBlank(token)) {
            log.error("{} 没有登录", accountContext.getSimpleInfo());
        }

        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();
        headers.put("Origin", "");
        headers.put("Reffer", "");
        headers.put("Auth", " " + token);

        // 发送心跳
        syncRequest(
                accountContext.getProxy(),
                CHECK_IN_API,
                HttpMethod.GET,
                headers,
                null,
                null,
                () -> accountContext.getSimpleInfo() + " send keep alive ping"
        ).exceptionallyAsync(throwable -> {
            log.error("{} check in field", accountContext.getSimpleInfo());
            return null;
        });
    }
}

package cn.com.helei.bot.app.teneo;

import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.anno.BotWSMethodConfig;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.util.exception.LoginException;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpMethod;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@BotApplication(name = "Teneo_Bot")
public class TeneoBot extends AnnoDriveAutoBot<TeneoBot> {

    private static final String LOGIN_API = "https://auth.teneo.pro/api/login";

    private static final String TOKEN_KEY = "token";

    private static final Logger log = LoggerFactory.getLogger(TeneoBot.class);

    public TeneoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);
    }

    @Override
    protected TeneoBot getInstance() {
        return this;
    }


    @BotMethod(jobType = BotJobType.LOGIN)
    protected Result login(AccountContext accountContext) {

        ProxyInfo proxy = accountContext.getProxy();

        JSONObject body = new JSONObject();
        body.put("email", accountContext.getAccountBaseInfo().getEmail());
        body.put("password", accountContext.getAccountBaseInfo().getPassword());

        Map<String, String> headers = accountContext.getBrowserEnv().getHeaders();

        CompletableFuture<Result> future = syncRequest(
                proxy,
                LOGIN_API,
                HttpMethod.POST,
                headers,
                null,
                body,
                () -> accountContext.getSimpleInfo() + " 开始登录"
        ).thenApplyAsync(responseStr -> {
            JSONObject response = JSONObject.parseObject(responseStr);
            if (response != null && responseStr.contains("access_token")) {
                String token = response.getString("access_token");

                accountContext.setParam(TOKEN_KEY, token);

                return Result.ok(token);
            } else {
                throw new LoginException(accountContext.getSimpleInfo() + " 登录获取token失败, response: " + responseStr);
            }
        });

        try {
            return future.get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("{} 出现异常登录失败, {}", accountContext, e.getMessage());
            return Result.fail("%s 现异常登录失败".formatted(accountContext.getSimpleInfo()));
        }
    }

    @BotMethod(
            jobType = BotJobType.WEB_SOCKET_CONNECT,
            bowWsConfig = @BotWSMethodConfig(
                    heartBeatIntervalSecond = 10
            )
    )
    public BaseBotWSClient<JSONObject, JSONObject> buildAccountWSClient(AccountContext accountContext) {
        String connectUrl = "wss://secure.ws.teneo.pro/websocket?accessToken=" + accountContext.getParam("token") + "&version=v0.2";

        TeneoWSClient teneoWSClient = new TeneoWSClient(accountContext, connectUrl);

        DefaultHttpHeaders headers = new DefaultHttpHeaders();
        Map<String, String> originHeaders = accountContext.getBrowserEnv().getHeaders();
        originHeaders.forEach(headers::add);

        headers.add("Host", "secure.ws.teneo.pro");
        headers.add("Origin", "chrome-extension://emcclcoaglgcpoognfiggmhnhgabppkm");
        headers.add("Upgrade", "websocket");

        teneoWSClient.setHeaders(headers);

        return teneoWSClient;
    }
}
package cn.com.helei.bot.app.teneo;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.netty.BotJsonWSClient;
import cn.com.helei.bot.core.supporter.netty.constants.WebsocketClientStatus;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TeneoWSClient extends BotJsonWSClient {

    public TeneoWSClient(AccountContext accountContext, String connectUrl) {
        super(accountContext, connectUrl);
    }

    @Override
    public void whenAccountClientStatusChange(WebsocketClientStatus newClientStatus) {

        final AccountContext accountContext = this.getAccountContext();

        switch (newClientStatus) {
            case STARTING -> {
                log.info("账户[{}]-proxy[{}] 开始到ws服务器[{}]",
                        accountContext.getName(), accountContext.getProxy().getAddressStr(), url);
            }
            case RUNNING -> {
                log.info("账户[{}]-proxy[{}]已连接到ws服务器",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());
            }
            case STOP -> {
                log.warn("账户[{}]-proxy[{}]已断开连接",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());

                accountContext.getConnectStatusInfo().getRestart().incrementAndGet();
            }
            case SHUTDOWN ->{
                log.warn("账户[{}]-proxy[{}] 工作已停止",
                        accountContext.getName(), accountContext.getProxy().getAddressStr());
            }
        }
    }

    @Override
    public JSONObject getHeartbeatMessage() {
        ConnectStatusInfo connectStatusInfo = getAccountContext().getConnectStatusInfo();
        connectStatusInfo.getHeartBeat().incrementAndGet();

        // 错误心跳数提前加上
        connectStatusInfo.getErrorHeartBeat().incrementAndGet();

        JSONObject ping = new JSONObject();
        ping.put("type", "ping");
        return ping;
    }

    @Override
    public void whenAccountReceiveResponse(Object id, JSONObject response) {

    }

    @Override
    public void whenAccountReceiveMessage(JSONObject message) {
        String type = message.getString("message");
        AccountContext accountContext = getAccountContext();

        if ("Connected successfully".equals(type)) {
            Double pointsToday = message.getDouble("pointsToday");
            Double pointsTotal = message.getDouble("pointsTotal");

            accountContext.getRewordInfo().setDailyPoints(pointsToday);
            accountContext.getRewordInfo().setTotalPoints(pointsTotal);

            log.info("账户[{}]-proxy[{}] 连接成功. 今日积分: {}, 总积分: {}",
                    accountContext.getName(), accountContext.getProxy().getAddressStr(),
                    pointsToday, pointsTotal);

        } else if ("Pulse from server".equals(type)) {
            Double pointsToday = message.getDouble("pointsToday");
            Double pointsTotal = message.getDouble("pointsTotal");

            accountContext.getRewordInfo().setDailyPoints(pointsToday);
            accountContext.getRewordInfo().setTotalPoints(pointsTotal);

            int heartbeatToday = message.getInteger("heartbeats");

            //减去提前加上的错误心跳数
            accountContext.getConnectStatusInfo().getErrorHeartBeat().decrementAndGet();
            log.debug("账户[{}]-proxy[{}] 心跳发送成功. 今日心跳: {}",
                    accountContext.getName(), accountContext.getProxy().getAddressStr(),
                    heartbeatToday);
        }
    }
}
package cn.com.helei.bot.core.bot.anno;

import cn.com.helei.bot.core.bot.constants.BotJobType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotMethod {

    /**
     * job类型
     *
     * @return BotJobType
     */
    BotJobType jobType();

    /**
     * jobName
     *
     * @return string
     */
    String jobName() default "";

    /**
     * 描述
     *
     * @return String
     */
    String description() default "";

    /**
     * 时间表达式
     *
     * @return String
     */
    String cronExpression() default "";

    /**
     * 运行间隔
     *
     * @return int
     */
    int intervalInSecond() default 0;

    /**
     * 并发数
     *
     * @return int
     */
    int concurrentCount() default 20;


    BotWSMethodConfig bowWsConfig() default @BotWSMethodConfig();
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.bot.constants.BotStatus;
import cn.com.helei.bot.core.dto.AutoBotRuntimeInfo;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.util.exception.DepinBotStatusException;
import cn.com.helei.bot.core.util.FileUtil;
import cn.com.helei.bot.core.util.NamedThreadFactory;
import cn.com.helei.bot.core.util.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.function.Supplier;

@Slf4j
@Getter
public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 配置
     */
    private final AutoBotConfig autoBotConfig;

    /**
     * 状态
     */
    private BotStatus status = BotStatus.NEW;

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot运行时信息
     */
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * 请求并发数量
     */
    @Getter
    @Setter
    private int requestConcurrentCount = 5;

    /**
     * bot api
     */
    @Getter
    private final BotApi botApi;

    /**
     * bot信息
     */
    @Getter
    private final BotInfo botInfo;

    public AbstractAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        if (StrUtil.isBlank(autoBotConfig.getBotKey())) {
            throw new IllegalArgumentException("bot key不能为空");
        }

        this.autoBotConfig = autoBotConfig;
        this.botApi = botApi;
        this.botInfo = buildBotInfo();

        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();

        this.executorService = Executors.newThreadPerTaskExecutor(
                new NamedThreadFactory(botInfo.getName() + "-executor"));
    }


    public void init() {
        updateState(BotStatus.INIT);
        try {
            doInit();

            //更新状态
            updateState(BotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化Bot[{}]发生错误", botInfo.getName(), e);
            updateState(BotStatus.INIT_ERROR);
        }
    }


    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;


    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).request(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy   proxy
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<List<String>> syncStreamRequest(
            ProxyInfo proxy,
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body,
            Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).streamRequest(
                        url,
                        method,
                        headers,
                        params,
                        body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    public <R> CompletableFuture<R> syncCCHandler(
            ProxyInfo proxy,
            Supplier<String> requestStart,
            Supplier<R> request
    ) {

        Semaphore networkController = networkSyncControllerMap
                .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                    if (v == null) {
                        v = new Semaphore(requestConcurrentCount);
                    }
                    return v;
                });


        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "开始";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                log.info("同步器允许发送请求-{}", str);

                return request.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, botInfo.getName());
    }


    /**
     * 更新BotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(BotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(BotStatus.SHUTDOWN)) {
            status = BotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> BotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(BotStatus.INIT_FINISH)
                        || newStatus.equals(BotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(BotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(BotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(BotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }


    protected abstract BotInfo buildBotInfo();
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.persistence.impl.DBAccountPersistenceManager;
import cn.com.helei.bot.core.util.exception.DepinBotInitException;
import cn.com.helei.bot.core.supporter.persistence.AccountPersistenceManager;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.*;


@Slf4j
public abstract class AccountManageAutoBot extends AbstractAutoBot {

    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    /**
     * 持久化管理器
     */
    private final AccountPersistenceManager persistenceManager;


    public AccountManageAutoBot(AutoBotConfig autoBotConfig, BotApi botApi) {
        super(autoBotConfig, botApi);

        this.persistenceManager = new DBAccountPersistenceManager(botApi);
    }


    @Override
    protected void doInit() throws DepinBotInitException {
        // Step 1 初始化保存的线程
        persistenceManager.init();

        // Step 2 初始化账户
        initAccounts();
    }

    /**
     * 注册账户
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> registerAccount();

    /**
     * 登录并获取token
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> loginAndTakeTokenAccount();


    /**
     * 更新账户奖励信息
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> updateAccountRewordInfo();


    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> getBotJobNameList();

    /**
     * 运行指定job
     *
     * @param jobName jobName
     * @return CompletableFuture<Result>
     */
    public abstract BotACJobResult startBotJob(String jobName);


    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }

    /**
     * 初始化账号方法
     */
    private void initAccounts() throws DepinBotInitException {
        Integer botId = getBotInfo().getId();

        String name = getBotInfo().getName();

        try {
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                    .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                log.warn("bot[{}]没有账户数据", name);
            } else {
                log.info("bot[{}]使用历史账户数据, 共[{}]", name, accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }


    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }
}
package cn.com.helei.bot.core.bot.base;

import cn.com.helei.bot.core.bot.AccountWSClientBuilder;
import cn.com.helei.bot.core.bot.WebSocketClientLauncher;
import cn.com.helei.bot.core.bot.anno.BotApplication;
import cn.com.helei.bot.core.bot.anno.BotMethod;
import cn.com.helei.bot.core.bot.constants.BotJobType;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.constants.MapConfigKey;
import cn.com.helei.bot.core.dto.ACListOptResult;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.entity.BotInfo;
import cn.com.helei.bot.core.supporter.botapi.BotApi;
import cn.com.helei.bot.core.supporter.netty.BaseBotWSClient;
import cn.com.helei.bot.core.util.exception.BotMethodFormatException;
import cn.com.helei.bot.core.util.exception.BotMethodInvokeException;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;

import static cn.com.helei.bot.core.constants.MapConfigKey.INVITE_CODE_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T> extends AccountManageAutoBot {

    /**
     * jobName -> jobParam
     */
    private final Map<String, AutoBotJobParam> autoBotJobMap;

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher;

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap;

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;


    public AnnoDriveAutoBot(
            AutoBotConfig autoBotConfig,
            BotApi botApi
    ) {
        super(autoBotConfig, botApi);

        this.webSocketClientLauncher = new WebSocketClientLauncher(this);
        this.jobCCSemaphoreMap = new ConcurrentHashMap<>();

        this.autoBotJobMap = resolveBotMethodAnno();
    }

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() {
        return resolveAnnoBotInfo(getBotApi());
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.REGISTER.name(),
                    "未找到注册方法"
            ));
        }

        return asyncForACList(
                accountContext -> {
                    if (BooleanUtil.isTrue(accountContext.isSignUp())) {
                        // 账户注册过，
                        String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(), accountContext.getName(),
                                accountContext.getAccountBaseInfo().getEmail());

                        log.warn(errorMsg);

                        return CompletableFuture.completedFuture(Result.fail(errorMsg));
                    } else if (registerMethod != null) {
                        // 调用注册方法注册
                        return invokeBotMethod(registerMethod, accountContext, getAutoBotConfig().getConfig(INVITE_CODE_KEY));
                    } else {
                        return CompletableFuture.completedFuture(Result.fail("未知错误"));
                    }
                },
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        //注册成功
                        AccountContext.signUpSuccess(accountContext);
                    }
                    return result;
                },
                BotJobType.REGISTER.name()
        );
    }


    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.LOGIN.name(),
                    "未找到登录方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(loginMethod, accountContext),
                (accountContext, result) -> {
                    // 登录成功
                    if (BooleanUtil.isTrue(result.getSuccess())) {
                        String token = result.getData() == null ? null : (String) result.getData();

                        // token不为空，设置到accountContext里
                        if (StrUtil.isNotBlank(token)) {
                            accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                        } else {
                            log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                        }
                    }
                    return result;
                },
                BotJobType.LOGIN.name()
        );
    }


    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                    getBotInfo().getId(),
                    getBotInfo().getName(),
                    BotJobType.QUERY_REWARD.name(),
                    "未找到奖励查询方法"
            ));
        }

        return asyncForACList(
                accountContext -> invokeBotMethod(updateRewordMethod, accountContext),
                (accountContext, result) -> result,
                BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> getBotJobNameList() {
        return autoBotJobMap.keySet();
    }

    @Override
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().registerJob(autoBotJobMap.get(jobName));
    }

    protected abstract T getInstance();

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        List<AccountContext> accountContexts = getAccountContexts();

        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult;
                    CompletableFuture<Result> future;

                    try {
                        botACJobResult = new BotACJobResult(
                                getBotInfo().getId(),
                                getBotInfo().getName(),
                                jobName,
                                accountContext.getId()
                        );

                        future = buildResultFuture.apply(accountContext);

                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        throw new RuntimeException(e);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) success++;

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            log.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInfo().getId(),
                                            getBotInfo().getName(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInfo().getId())
                            .botName(getBotInfo().getName())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 解析注解，添加botInfo
     */
    private BotInfo resolveAnnoBotInfo(BotApi botApi) {
        BotApplication annotation = this.getClass().getAnnotation(BotApplication.class);

        if (annotation != null) {
            String botName = annotation.name();
            if (StrUtil.isBlank(botName)) throw new IllegalArgumentException("bot name 不能为空");

            BotInfo dbBotInfo = botApi.getBotInfoService().query().eq("name", botName).one();

            // 查询bot是否存在，不存在则创建
            if (dbBotInfo == null) {
                log.warn("不存在[{}]bot info, 自动创建...", botName);

                BotInfo botInfo = new BotInfo();
                botInfo.setDescribe(annotation.describe());
                botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
                botInfo.setName(botName);
                if (botApi.getBotInfoService().save(botInfo)) {
                    log.info("自动创建[{}]bot info成功", botName);
                    return botInfo;
                } else {
                    throw new RuntimeException("保存bot[" + botName + "]信息失败");
                }
            } else {
                return dbBotInfo;
            }
        } else {
            throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
        }
    }


    /**
     * 解析注解中的方法
     *
     * @return List<AutoBotJob>
     */
    private Map<String, AutoBotJobParam> resolveBotMethodAnno() {
        Map<String, AutoBotJobParam> jobMap = new HashMap<>();

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod, jobMap);
                    case TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod, jobMap);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod, jobMap);
                }
            }
        }

        return jobMap;
    }

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                    "应为 Result methodName(AccountContext ac, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param jobMap       jobMap
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> jobMap) {
        if (method.getReturnType() == Result.class
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            AutoBotJobParam queryRewardJob = buildAutoBotJobParam(method, botJobMethod);

            jobMap.put(BotJobType.QUERY_REWARD.name(), queryRewardJob);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     * @param jobMap       jobMap
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod, Map<String, AutoBotJobParam> jobMap) {
        if (method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {

            AutoBotJobParam autoBotJob = buildAutoBotJobParam(method, botJobMethod);
            String jobName = autoBotJob.getJobName();

            if (!jobMap.containsKey(jobName)) {
                jobMap.put(jobName, autoBotJob);
            } else {
                throw new BotMethodFormatException("任务名称重复, " + jobName);
            }
        } else {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 Result methodName(AccountContext ac)");
        }
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     * @param jobMap           jobMap
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno, Map<String, AutoBotJobParam> jobMap) {
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                AutoBotJobParam jobParam = buildAutoBotJobParam(WebSocketClientLauncher.lanuchMethod, botJobMethodAnno);

                // 更改执行target，添加额外参数
                jobParam.setTarget(webSocketClientLauncher);
                jobParam.setExtraParams(new Object[]{jobParam, new AccountWSClientBuilder() {
                    @Override
                    public BaseBotWSClient<?, ?> build(AccountContext accountContext) throws InvocationTargetException, IllegalAccessException {
                        Object invoke = method.invoke(getInstance(), accountContext);

                        return (BaseBotWSClient<?, ?>) invoke;
                    }
                }});

                // 添加到jobMap
                jobMap.put(jobParam.getJobName(), jobParam);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else {
            throw new BotMethodFormatException("websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 根据方法注解创建 AutoBotJob
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     * @return AutoBotJobParam
     */
    private @NotNull AutoBotJobParam buildAutoBotJobParam(Method method, BotMethod botJobMethodAnno) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
            } else {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            autoBotJobParam = new AutoBotJobParam(
                    this,
                    StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName(),
                    botJobMethodAnno.description(),
                    method,
                    cronExpression,
                    intervalInSecond,
                    botJobMethodAnno.concurrentCount(),
                    botJobMethodAnno.bowWsConfig(),
                    null,
                    null
            );
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format(
                            "[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInfo().getName(),
                            method.getName(),
                            botJobMethodAnno.cronExpression()
                    ),
                    e
            );
        }

        return autoBotJobParam;
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInfo().getName(),
                        registerMethod.getName()
                ), e);
            }
        }, getExecutorService());
    }


    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = autoBotJobMap.get(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }
}
package cn.com.helei.bot.core.bot.job;

import cn.com.helei.bot.core.bot.anno.BotWSMethodConfig;
import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import lombok.*;
import org.quartz.CronExpression;

import java.lang.reflect.Method;

@Data
@AllArgsConstructor
public class AutoBotJobParam {

    private final AnnoDriveAutoBot<?> bot;

    private final String jobName;

    @Getter
    private final String description;

    private final Method jobMethod;

    @Getter
    private final CronExpression cronExpression;

    @Getter
    private final Integer intervalInSecond;

    private final int concurrentCount;

    private final BotWSMethodConfig botWSMethodConfig;

    private Object target;

    private Object[] extraParams;

    public String getGroup() {
        return this.bot.getBotInfo().getName();
    }

    public Integer getBotId() {
        return bot.getBotInfo().getId();
    }
}
package cn.com.helei.bot.core.bot.view;


import cn.com.helei.bot.core.bot.base.AnnoDriveAutoBot;
import cn.com.helei.bot.core.dto.config.AutoBotConfig;
import cn.com.helei.bot.core.supporter.AccountInfoPrinter;
import cn.com.helei.bot.core.supporter.commandMenu.CommandMenuNode;
import cn.com.helei.bot.core.supporter.commandMenu.DefaultMenuType;
import cn.com.helei.bot.core.supporter.commandMenu.MenuNodeMethod;
import com.alibaba.fastjson.JSON;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
        import java.util.function.Consumer;

import static cn.com.helei.bot.core.constants.MapConfigKey.*;


@Slf4j
public class MenuCMDLineAutoBot<C extends AutoBotConfig> extends CommandLineAutoBot {
    /**
     * 刷新节点
     */
    public static final CommandMenuNode REFRESH_NODE = new CommandMenuNode(true, "刷新", "当前数据已刷新", null);


    private final List<DefaultMenuType> defaultMenuTypes;

    @Setter
    private Consumer<CommandMenuNode> addCustomMenuNode;

    public MenuCMDLineAutoBot(AnnoDriveAutoBot bot, List<DefaultMenuType> defaultMenuTypes) {
        super(bot);
        this.defaultMenuTypes = new ArrayList<>(defaultMenuTypes);

        this.defaultMenuTypes.add(DefaultMenuType.ACCOUNT_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.PROXY_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.BROWSER_ENV_LIST);

        if (bot.getRegisterMethod() != null) {
            this.defaultMenuTypes.add(DefaultMenuType.REGISTER);
        }
        if (bot.getLoginMethod() != null) {
            this.defaultMenuTypes.add(DefaultMenuType.LOGIN);
        }
        if (bot.getBotJobNameList() != null) {
            this.defaultMenuTypes.add(DefaultMenuType.START_ACCOUNT_CLAIM);
        }

        // 解析MenuNodeMethod注解添加菜单节点
        for (Method method : bot.getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            if (method.isAnnotationPresent(MenuNodeMethod.class)) {
                if (method.getParameterCount() > 0) {
                    throw new IllegalArgumentException("菜单方法参数数量必须为0");
                }

                MenuNodeMethod anno = method.getAnnotation(MenuNodeMethod.class);
                String title = anno.title();
                String description = anno.description();

                CommandMenuNode menuNode = new CommandMenuNode(title, description, () -> {
                    try {
                        return method.invoke(bot).toString();
                    } catch (IllegalAccessException | InvocationTargetException e) {
                        throw new RuntimeException(e);
                    }
                });

                getMainManu().addSubMenu(menuNode);
            }
        }
    }


    @Override
    public final void buildMenuNode(CommandMenuNode mainManu) {
        if (addCustomMenuNode != null) {
            addCustomMenuNode.accept(mainManu);
        }

        for (DefaultMenuType menuType : defaultMenuTypes) {
            mainManu.addSubMenu(switch (menuType) {
                case REGISTER -> buildRegisterMenuNode();
                case VERIFIER -> buildVerifierMenuNode();
                case LOGIN -> buildQueryTokenMenuNode();
                case ACCOUNT_LIST -> buildAccountListMenuNode();
                case PROXY_LIST -> buildProxyListMenuNode();
                case BROWSER_ENV_LIST -> buildBrowserListMenuNode();
                case START_ACCOUNT_CLAIM -> buildStartAccountConnectMenuNode();
                case IMPORT -> buildImportMenuNode();
            });
        }
    }


    /**
     * 构建注册菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildRegisterMenuNode() {
        CommandMenuNode registerMenu = new CommandMenuNode("注册",
                "请确认设置后运行", this::printCurrentRegisterConfig);

        CommandMenuNode interInvite = new CommandMenuNode(
                "填入邀请码",
                "请输入邀请码：",
                this::printCurrentRegisterConfig
        );
        interInvite.setResolveInput(input -> {
            log.info("邀请码修改[{}]->[{}]", getBotConfig().getConfig(INVITE_CODE_KEY), input);
            getBotConfig().setConfig(INVITE_CODE_KEY, input);
        });

        return registerMenu
                .addSubMenu(interInvite)
                .addSubMenu(new CommandMenuNode(
                        true,
                        "开始注册",
                        "开始注册所有账号...",
                        () -> getBot()
                                .registerAccount().toString()
                ));
    }

    private CommandMenuNode buildVerifierMenuNode() {

        return new CommandMenuNode("验证邮箱", "请选择验证的账户类型",
                () -> "当前的邮箱类型：" + getBotConfig().getConfig(EMAIL_VERIFIER_TYPE));
    }


    /**
     * 获取token
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildQueryTokenMenuNode() {
        return new CommandMenuNode("获取token", "开始获取token",()->{
            return JSON.toJSONString(getBot().loginAndTakeTokenAccount());
        });
    }

    /**
     * 构建查看代理列表的菜单节点
     *
     * @return 查看代理列表菜单节点
     */
    private CommandMenuNode buildProxyListMenuNode() {
        return new CommandMenuNode(
                "查看代理列表",
                "当前代理列表:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 构建查看浏览器环境列表的菜单节点
     *
     * @return 查看浏览器环境列表菜单节点
     */
    private CommandMenuNode buildBrowserListMenuNode() {
        return new CommandMenuNode(
                "查看浏览器环境列表",
                "当前浏览器环境:",
                null
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 账户列表菜单节点
     *
     * @return 账户列表节点
     */
    private CommandMenuNode buildAccountListMenuNode() {
        CommandMenuNode accountListMenuNode = new CommandMenuNode(
                "查看账号",
                "当前账户详情列表:",
                () -> AccountInfoPrinter.printAccountList(getBot().getAccountContexts())
        );

        return accountListMenuNode
                .addSubMenu(buildAccountRewardMenuNode())
                .addSubMenu(buildAccountConnectStatusMenuNode())
                .addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户收益菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountRewardMenuNode() {
        return new CommandMenuNode(
                "查看账号收益",
                "账号收益详情列表:",
                () -> AccountInfoPrinter.printAccountReward(getBot().getAccountContexts())
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户连接情况菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountConnectStatusMenuNode() {
        return new CommandMenuNode(
                "查看账号连接情况",
                "账号连接情况列表:",
                () -> AccountInfoPrinter.printAccountConnectStatusList(getBot().getAccountContexts())
        ).addSubMenu(REFRESH_NODE);
    }


    /**
     * 开始账户连接菜单节点
     *
     * @return 连接账户菜单节点
     */
    private CommandMenuNode buildStartAccountConnectMenuNode() {
        CommandMenuNode menuNode = new CommandMenuNode(
                "启动任务",
                "选择任务类型",
                null
        );

        Set<String> jobNameSet = getBot().getBotJobNameList();
        for (String jobName : jobNameSet) {
            CommandMenuNode typeInput = new CommandMenuNode(true, jobName + " 任务", "type",
                    () -> JSON.toJSONString(getBot().startBotJob(jobName))
            );

            menuNode.addSubMenu(typeInput);
        }

        return menuNode;
    }

    /**
     * 导入菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportMenuNode() {

        return new CommandMenuNode("导入", "请选择要导入的数据", null)
                .addSubMenu(buildImportBotAccountContextMenuNode())
                .addSubMenu(buildImportBaseAccountMenuNode())
                .addSubMenu(buildImportProxyMenuNode())
                .addSubMenu(buildImportBrowserEnvMenuNode())
                .addSubMenu(buildImportTwitterMenuNode())
                .addSubMenu(buildImportDiscordMenuNode())
                .addSubMenu(buildImportTelegramMenuNode())
                ;
    }

    /**
     * 导入浏览器环境菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBrowserEnvMenuNode() {

        return new CommandMenuNode(true, "导入浏览器环境", null, () -> {
            String filePath = getBotConfig().getFilePathConfig().getBrowserEnvFileBotConfigPath();

            getBot().getBotApi().getImportService().importBrowserEnvFromExcel(filePath);

            return "浏览器环境导入完成";
        });
    }

    /**
     * 导入代理信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportProxyMenuNode() {
        return new CommandMenuNode(true, "导入代理", null, () -> {

            getBot().getBotApi().getImportService()
                    .importProxyFromExcel(getBotConfig().getFilePathConfig().getProxyFileBotConfigPath());

            return "代理导入完成";
        });
    }

    /**
     * 导入账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBaseAccountMenuNode() {
        return new CommandMenuNode(true, "导入账号基本信息", null, () -> {

            Map<String, Integer> result = getBot().getBotApi().getImportService()
                    .importAccountBaseInfoFromExcel(getBotConfig().getFilePathConfig().getBaseAccountFileBotConfigPath());

            return "账号基本信息导入完成，" + result;
        });
    }


    /**
     * 导入twitter账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportTwitterMenuNode() {
        return new CommandMenuNode(true, "导入twitter账号", null, () -> {
            getBot().getBotApi().getImportService()
                    .importTwitterFromExcel(getBotConfig().getFilePathConfig().getTwitterFileBotConfigPath());
            return "twitter导入完成";
        });
    }


    /**
     * 导入discord账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportDiscordMenuNode() {
        return new CommandMenuNode(true, "导入discord账号", null, () -> {

            getBot().getBotApi().getImportService().importDiscordFromExcel(getBotConfig().getFilePathConfig().getDiscordFileBotConfigPath());

            return "discord导入完成";
        });
    }

    /**
     * 导入Telegram账号基本信息
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportTelegramMenuNode() {
        return new CommandMenuNode(true, "导入Telegram账号", null, () -> {

            getBot().getBotApi().getImportService().importTelegramFormExcel(getBotConfig().getFilePathConfig().getTelegramFileBotConfigPath());

            return "Telegram导入完成";
        });
    }


    /**
     * 导入bot使用的账号菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBotAccountContextMenuNode() {
        return new CommandMenuNode(true, "导入bot运行账号", null, () -> {

            getBot().getBotApi().getImportService().importBotAccountContextFromExcel(
                    getBot().getBotInfo().getId(),
                    getBotConfig().getBotKey(),
                    getBotConfig().getAccountConfig().getConfigFilePath()
            );

            return "bot运行账号导入完成";
        });
    }


    /**
     * 打印当前的邀请码
     *
     * @return 邀请码
     */
    private String printCurrentRegisterConfig() {
        String inviteCode = (String) getBotConfig().getCustomConfig().get(INVITE_CODE_KEY);
        String registerType = (String) getBotConfig().getCustomConfig().get(REGISTER_TYPE_KEY);

        return "(当前邀请码为:" + inviteCode + ")\n"
                + "(当前注册类型为:" + registerType + ")\n";
    }
}
package cn.com.helei.bot.core.dto.config;

import lombok.*;

@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class AutoBotAccountConfig {

    private String configFilePath;
}
