package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.constants.DepinBotStatus;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.pool.account.AccountPool;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnvPool;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.exception.DepinBotStartException;
import cn.com.helei.DepinBot.core.exception.DepinBotStatusException;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxyPool;
import cn.com.helei.DepinBot.core.util.NamedThreadFactory;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;
import java.util.concurrent.*;

@Slf4j
@Getter
public abstract class AbstractDepinBot<Req, Resp> {
    /**
     * 执行异步任务的线程池
     */
    private final ExecutorService executorService;

    /**
     * 执行定时任务的线程池
     */
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);

    /**
     * 代理池
     */
    private final NetworkProxyPool proxyPool;

    /**
     * 浏览器环境池
     */
    private final BrowserEnvPool browserEnvPool;

    /**
     * 账户池
     */
    private final AccountPool accountPool;

    /**
     * 配置
     */
    private final BaseDepinBotConfig baseDepinBotConfig;

    /**
     * 状态
     */
    private DepinBotStatus status = DepinBotStatus.NEW;

    public AbstractDepinBot(BaseDepinBotConfig baseDepinBotConfig) {
        this.baseDepinBotConfig = baseDepinBotConfig;
        this.executorService = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(baseDepinBotConfig.getName() + "-executor"));

        this.proxyPool = NetworkProxyPool.loadYamlPool(
                baseDepinBotConfig.getNetworkPoolConfig(),
                "bot.network.proxy",
                NetworkProxyPool.class
        );
        this.browserEnvPool = BrowserEnvPool.loadYamlPool(
                baseDepinBotConfig.getBrowserEnvPoolConfig(),
                "bot.browser.env",
                BrowserEnvPool.class
        );
        this.accountPool = AccountPool.loadYamlPool(
                baseDepinBotConfig.getAccountPoolConfig(),
                "bot.account",
                AccountPool.class
        );

    }

    public void init() {
        updateState(DepinBotStatus.INIT);
        try {
            doInit();

            //更新状态
            updateState(DepinBotStatus.INIT_FINISH);
        } catch (Exception e) {
            log.error("初始化DepinBot[{}}发生错误", getBaseDepinBotConfig().getName(), e);
            updateState(DepinBotStatus.INIT_ERROR);
        }
    }

    /**
     * 初始化方法
     */
    protected abstract void doInit() throws DepinBotInitException;


    protected abstract void doExecute() throws IOException;

    /**
     * 使用accountContext构建AbstractDepinWSClient
     *
     * @param accountContext accountContext
     * @return AbstractDepinWSClient
     */
    public abstract BaseDepinWSClient<Req, Resp> buildAccountWSClient(AccountContext accountContext);


    /**
     * 当账户链接时调用
     *
     * @param depinWSClient depinWSClient
     * @param success       是否成功
     */
    public abstract void whenAccountConnected(BaseDepinWSClient<Req, Resp> depinWSClient, Boolean success);

    /**
     * 当ws连接收到响应
     *
     * @param depinWSClient depinWSClient
     * @param id            id
     * @param response      response
     */
    public abstract void whenAccountReceiveResponse(BaseDepinWSClient<Req, Resp> depinWSClient, String id, Resp response);

    /**
     * 当ws连接收到消息
     *
     * @param depinWSClient depinWSClient
     * @param message       message
     */
    public abstract void whenAccountReceiveMessage(BaseDepinWSClient<Req, Resp> depinWSClient, Resp message);

    /**
     * 获取心跳消息
     *
     * @param depinWSClient depinWSClient
     * @return 消息体
     */
    public abstract Req getHeartbeatMessage(BaseDepinWSClient<Req, Resp> depinWSClient);


    /**
     * 启动bot
     *
     * @throws DepinBotStartException DepinBotStartException
     */
    public void start() throws DepinBotStartException {
        updateState(DepinBotStatus.STARTING);
        log.info("正在启动Depin Bot");
        try {
            CountDownLatch startLatch = new CountDownLatch(1);
            //启动命令行交互的线程
            asyncExecute(startLatch);

            log.info("Depin Bot启动完毕");

            updateState(DepinBotStatus.RUNNING);
            startLatch.await();

        } catch (Exception e) {
            updateState(DepinBotStatus.SHUTDOWN);
            throw new DepinBotStartException("启动CommandLineDepinBot发生错误", e);
        }
    }


    /**
     * 添加定时任务
     *
     * @param runnable runnable
     * @param delay    delay
     * @param timeUnit timeUnit
     */
    public void addTimer(Runnable runnable, long delay, TimeUnit timeUnit) {
        scheduler.scheduleAtFixedRate(runnable, 0, delay, timeUnit);
    }

    /**
     * 异步启动
     */
    private void asyncExecute(CountDownLatch startLatch) {
        Thread commandInputThread = new Thread(() -> {
            try {
                doExecute();
            } catch (IOException e) {
                log.error("启动bot发生错误", e);
            } finally {
                startLatch.countDown();
            }
        }, "depin-bot-main");
        commandInputThread.setDaemon(true);
        commandInputThread.start();
    }



    /**
     * 更新DepinBotStatus
     *
     * @param newStatus 新状态
     */
    private synchronized void updateState(DepinBotStatus newStatus) throws DepinBotStatusException {
        boolean b = true;
        if (newStatus.equals(DepinBotStatus.SHUTDOWN)) {
            status = DepinBotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> DepinBotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(DepinBotStatus.INIT_FINISH)
                        || newStatus.equals(DepinBotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(DepinBotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(DepinBotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(DepinBotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }


        if (b) {
            log.info("CommandLineDepinBot Status change [{}] => [{}]", status, newStatus);
            this.status = newStatus;
        } else {
            throw new DepinBotStatusException(String.format("Depin Bot Status不能从[%s]->[%s]", status, newStatus));
        }
    }
}
package cn.com.helei.DepinBot.core.bot;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.BaseDepinWSClient;
import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.dto.account.AccountPrintDto;
import cn.com.helei.DepinBot.core.dto.RewordInfo;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnv;
import cn.com.helei.DepinBot.core.exception.DepinBotInitException;
import cn.com.helei.DepinBot.core.exception.DepinBotStatusException;
import cn.com.helei.DepinBot.core.netty.constants.WebsocketClientStatus;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.supporter.persistence.AccountPersistenceManager;
import cn.com.helei.DepinBot.core.util.NamedThreadFactory;
import cn.com.helei.DepinBot.core.util.table.CommandLineTablePrintHelper;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
public abstract class AccountAutoManageDepinBot<Req, Resp> extends AbstractDepinBot<Req, Resp> {
    /**
     * 异步操作线程池
     */
    private final ExecutorService executorService;

    /**
     * 是否开始过链接所有账号
     */
    private final AtomicBoolean isStartAccountConnected = new AtomicBoolean(false);

    /**
     * 账户客户端
     */
    private final ConcurrentMap<AccountContext, BaseDepinWSClient<Req, Resp>> accountWSClientMap = new ConcurrentHashMap<>();


    private final AccountPersistenceManager persistenceManager = new AccountPersistenceManager();

    /**
     * 账号列表
     */
    @Getter
    private final List<AccountContext> accounts = new ArrayList<>();


    public AccountAutoManageDepinBot(BaseDepinBotConfig baseDepinBotConfig) {
        super(baseDepinBotConfig);


        this.executorService = Executors
                .newThreadPerTaskExecutor(new NamedThreadFactory(baseDepinBotConfig.getName() + "-account"));
    }

    @Override
    protected void doInit() throws DepinBotInitException {
        initAccounts();
    }


    /**
     * 初始化账号方法
     */
    public void initAccounts() throws DepinBotInitException {
        try {
            // Step 1 获取持久化的
            Map<Integer, AccountContext> accountContextMap = persistenceManager.loadAccountContexts();

            // Step 2 没有保存的数据，加载新的
            List<AccountContext> accountContexts;
            if (accountContextMap == null || accountContextMap.isEmpty()) {
                log.info("bot[{}]加载新账户数据", getBaseDepinBotConfig().getName());
                // Step 2.1 加载新的
                accountContexts = loadNewAccountContexts();

                // Step 2.2 持久化
                persistenceManager.persistenceAccountContexts(accountContexts);
            } else {
                log.info("bot[{}]使用历史账户数据", getBaseDepinBotConfig().getName());
                accountContexts = new ArrayList<>(accountContextMap.values());
            }

            // Step 3 加载到bot
            registerAccountsInBot(accountContexts);
        } catch (Exception e) {
            throw new DepinBotInitException("初始化账户发生错误", e);
        }
    }

    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }


    /**
     * 加载新的账户上下文列表，从配置文件中
     *
     * @return List<AccountContext>
     */
    private List<AccountContext> loadNewAccountContexts() {
        // Step 1 初始化账号

        List<AccountContext> newAccountContexts = new ArrayList<>();

        List<AccountContext> noProxyIds = new ArrayList<>();
        List<AccountContext> noBrowserEnvIds = new ArrayList<>();

        getAccountPool()
                .getAllItem()
                .forEach(depinClientAccount -> {
                    AccountContext accountContext = AccountContext.builder()
                            .clientAccount(depinClientAccount).build();

                    Integer id = depinClientAccount.getId();

                    // 账号没有配置代
                    if (depinClientAccount.getProxyId() == null) {
                        noProxyIds.add(accountContext);
                    } else {
                        accountContext.setProxy(getProxyPool().getItem(depinClientAccount.getProxyId()));
                    }

                    // 账号没有配置浏览器环境
                    if (depinClientAccount.getBrowserEnvId() == null) {
                        noBrowserEnvIds.add(accountContext);
                    } else {
                        accountContext.setBrowserEnv(getBrowserEnvPool().getItem(depinClientAccount.getBrowserEnvId()));
                    }

                    newAccountContexts.add(accountContext);
                });

        // Step 2 账号没代理的尝试给他设置代理
        if (!noProxyIds.isEmpty()) {
            log.warn("以下账号没有配置代理，将随机选择一个代理进行使用");
            List<NetworkProxy> lessUsedProxy = getProxyPool().getLessUsedItem(noProxyIds.size());
            for (int i = 0; i < noProxyIds.size(); i++) {
                AccountContext accountContext = noProxyIds.get(i);

                NetworkProxy proxy = lessUsedProxy.get(i);
                accountContext.setProxy(proxy);

                log.warn("账号:{},将使用代理:{}", accountContext.getName(), proxy);
            }
        }

        // Step 3 账号没浏览器环境的尝试给他设置浏览器环境
        if (!noBrowserEnvIds.isEmpty()) {
            log.warn("以下账号没有配置浏览器环境，将随机选择一个浏览器环境使用");
            List<BrowserEnv> lessUsedBrowserEnv = getBrowserEnvPool().getLessUsedItem(noBrowserEnvIds.size());
            for (int i = 0; i < noBrowserEnvIds.size(); i++) {
                AccountContext accountContext = noBrowserEnvIds.get(i);

                BrowserEnv browserEnv = lessUsedBrowserEnv.get(i);
                accountContext.setBrowserEnv(browserEnv);

                log.warn("账号:{},将使用浏览器环境:{}", accountContext.getName(), browserEnv);
            }
        }

        return newAccountContexts;
    }

    /**
     * 开始所有账户的连接
     *
     * @return String 打印的消息
     */
    public String startAccountDepinClient() {
        if (isStartAccountConnected.compareAndSet(false, true)) {
            allAccountConnectExecute()
                    .exceptionally(throwable -> {
                        log.error("开始所有账户连接时发生异常", throwable);
                        return null;
                    });
            return "已开始账号链接任务";
        }

        return "已提交过建立连接任务";
    }

    /**
     * 所有账户建立连接
     *
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> allAccountConnectExecute() {
        return CompletableFuture.runAsync(() -> {
            //Step 1 遍历账户
            List<CompletableFuture<Void>> connectFutures = accounts.stream()
                    .map(accountContext -> {
                        // Step 2 根据账户获取ws client
                        BaseDepinWSClient<Req, Resp> depinWSClient = accountWSClientMap.compute(accountContext, (k, v) -> {
                            // 没有创建过，或被关闭，创建新的
                            if (v == null || v.getClientStatus().equals(WebsocketClientStatus.SHUTDOWN)) {
                                v = buildAccountWSClient(accountContext);
                            }

                            return v;
                        });


                        String accountName = accountContext.getClientAccount().getName();

                        //Step 3 建立连接
                        WebsocketClientStatus clientStatus = depinWSClient.getClientStatus();
                        return switch (clientStatus) {
                            case NEW, STOP:  // 新创建，停止状态，需要建立连接
                                yield depinWSClient
                                        .connect()
                                        .thenAcceptAsync(success -> {
                                            try {
                                                whenAccountConnected(depinWSClient, success);
                                            } catch (Exception e) {
                                                log.error("账户[{}]-连接完成后执行回调发生错误", accountName, e);
                                            }
                                        }, executorService)
                                        .exceptionallyAsync(throwable -> {
                                            log.error("账户[{}]连接失败, ", accountName,
                                                    throwable);
                                            return null;
                                        }, executorService);
                            case STARTING, RUNNING: // 正在建立连接，直接返回
                                CompletableFuture.completedFuture(null);
                            case SHUTDOWN: // 被禁止使用，抛出异常
                                throw new DepinBotStatusException("cannot start ws client when it shutdown, " + accountName);
                        };
                    })
                    .toList();

            //Step 4 等所有账户连接建立完成
            try {
                CompletableFuture
                        .allOf(connectFutures.toArray(new CompletableFuture[0]))
                        .get();
            } catch (InterruptedException | ExecutionException e) {
                log.error("账户建立连接发生异常", e);
            }
        }, executorService);
    }


    /**
     * 打印账号列表
     *
     * @return String
     */
    public String printAccountList() {
        List<AccountPrintDto> list = accounts.stream().map(accountContext -> {
            NetworkProxy proxy = accountContext.getProxy();
            BrowserEnv browserEnv = accountContext.getBrowserEnv();
            return AccountPrintDto
                    .builder()
                    .name(accountContext.getClientAccount().getName())
                    .proxyInfo(proxy.getId() + "-" + proxy.getAddress())
                    .browserEnvInfo(String.valueOf(browserEnv == null ? "NO_ENV" : browserEnv.getId()))
                    .usable(accountContext.isUsable())
                    .startDateTime(accountContext.getConnectStatusInfo().getStartDateTime())
                    .updateDateTime(accountContext.getConnectStatusInfo().getUpdateDateTime())
                    .heartBeatCount(accountContext.getConnectStatusInfo().getHeartBeatCount().get())
                    .connectStatus(accountContext.getConnectStatusInfo().getConnectStatus())
                    .build();
        }).toList();

        return "账号列表:\n" +
                CommandLineTablePrintHelper.generateTableString(list, AccountPrintDto.class) +
                "\n";
    }

    /**
     * 打印账号收益
     *
     * @return String
     */
    public String printAccountReward() {
        StringBuilder sb = new StringBuilder();

        List<RewordInfo> list = accounts.stream().map(AccountContext::getRewordInfo).toList();

        sb.append("收益列表:\n")
                .append(CommandLineTablePrintHelper.generateTableString(list, RewordInfo.class))
                .append("\n");

        return sb.toString();
    }

}
package cn.com.helei.DepinBot.core.dto.account;

import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenField;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import cn.com.helei.DepinBot.core.pool.env.BrowserEnv;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxy;
import cn.com.helei.DepinBot.core.dto.RewordInfo;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
@PropertyChangeListenClass(isDeep = true)
public class AccountContext {

    /**
     * 账户是否可用
     */
    @PropertyChangeListenField
    private boolean usable = true;

    /**
     * client 账户
     */
    @PropertyChangeListenField
    private DepinClientAccount clientAccount;

    /**
     * 代理
     */
    @PropertyChangeListenField
    private NetworkProxy proxy;

    /**
     * 浏览器环境
     */
    @PropertyChangeListenField
    private BrowserEnv browserEnv;

    private LocalDateTime saveDatetime;


    /**
     * 连接状态
     */
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    /**
     * 分数信息
     */
    @PropertyChangeListenField
    private final RewordInfo rewordInfo = new RewordInfo();

    @PropertyChangeListenField
    private final Map<String, String> params = new HashMap<>();

    public String getParam(String key) {
        return params.get(key);
    }

    public void setParam(String key, String value) {
        params.put(key, value);
    }

    public HttpHeaders getWSHeaders() {
        return clientAccount.getWSHeaders();
    }

    public HttpHeaders getRestHeaders() {
        return clientAccount.getRestHeaders();
    }

    public String getName() {
        return clientAccount.getName() == null ? clientAccount.getEmail() : clientAccount.getName();
    }
}
package cn.com.helei.DepinBot.core.dto;

import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenClass;
import lombok.Data;

import java.time.LocalDateTime;

@Data
@PropertyChangeListenClass
public class RewordInfo {

    /**
     * 所有分数
     */
    private Double totalPoints = 0.0;

    private String sessionId;

    private Double sessionPoints = 0.0;

    /**
     * 今天的分数
     */
    private Double todayPoints = 0.0;

    private LocalDateTime updateTime;

    public void addTotalPoints(Double points) {
        if (points == null) return;
        this.totalPoints += points;
    }

    public void addSessionPoints(Double points) {
        if (points == null) return;
        this.sessionPoints += points;
    }

    public void addTodayPoints(Double points) {
        if (points == null) return;
        this.todayPoints += points;
    }
}
package cn.com.helei.DepinBot.core.pool.account;

import cn.com.helei.DepinBot.core.pool.AbstractYamlLinePool;

import java.util.List;

public class AccountPool extends AbstractYamlLinePool<DepinClientAccount> {

    public AccountPool() {
        super(DepinClientAccount.class);
    }


    public static AccountPool getDefault() {
        return loadYamlPool(
                "bot/account.yaml",
                "bot.account",
                AccountPool.class
        );
    }

    public static void main(String[] args) {
        AccountPool aDefault = getDefault();
        System.out.println(aDefault.printPool());
    }
}
package cn.com.helei.DepinBot.core.pool.account;


import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenField;
import cn.com.helei.DepinBot.core.pool.AbstractYamlLineItem;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.*;


@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@PropertyChangeListenClass
public class DepinClientAccount extends AbstractYamlLineItem {

    /**
     * 账户名
     */
    @PropertyChangeListenField
    private String name;

    /**
     * 邮箱
     */
    @PropertyChangeListenField
    private String email;

    /**
     * 密码
     */
    @PropertyChangeListenField
    private String password;


    /**
     * 代理id
     */
    @PropertyChangeListenField
    private Integer proxyId;


    /**
     * 浏览器环境id
     */
    @PropertyChangeListenField
    private Integer browserEnvId;


    public DepinClientAccount(Object originLine) {
        String emailAndPassword = (String) originLine;

        String[] split = emailAndPassword.split(", ");
        email = split[0];

        String[] emailSplit = email.split("@");
        if (emailSplit.length != 2) {
            throw new IllegalArgumentException("邮箱格式错误");
        }
        this.name = emailSplit[0];


        password = split[1];

        if (split.length == 3) {
            this.proxyId = Integer.valueOf(split[2]);
        }
        if (split.length == 4) {
            this.browserEnvId = Integer.valueOf(split[2]);
        }
    }

    public HttpHeaders getWSHeaders() {
        return new DefaultHttpHeaders();
    }

    public HttpHeaders getRestHeaders() {
        return new DefaultHttpHeaders();
    }

    public String getConnectUrl() {
        return "";
    }
}
package cn.com.helei.DepinBot.core.pool.env;

import cn.com.helei.DepinBot.core.pool.AbstractYamlLineItem;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;

import java.util.Map;

@Getter
@Setter
public class BrowserEnv extends AbstractYamlLineItem {

    private Map<String, String> headers;

    public BrowserEnv(Object originLine) {
        headers = (Map<String, String>) originLine;
    }
}
package cn.com.helei.DepinBot.core.pool.env;


import cn.com.helei.DepinBot.core.pool.AbstractYamlLinePool;
import cn.com.helei.DepinBot.core.pool.network.NetworkProxyPool;

public class BrowserEnvPool extends AbstractYamlLinePool<BrowserEnv> {

    public BrowserEnvPool() {
        super(BrowserEnv.class);
    }

    public static BrowserEnvPool getDefault() {
        return loadYamlPool(
                "bot/browser-env.yaml",
                "bot.browser.env",
                BrowserEnvPool.class
        );
    }


    public static void main(String[] args) {
        System.out.println(NetworkProxyPool.getDefault());
    }
}
package cn.com.helei.DepinBot.core.pool.network;

import cn.com.helei.DepinBot.core.pool.AbstractYamlLineItem;
import lombok.*;

import java.net.InetSocketAddress;
import java.net.SocketAddress;

@Getter
@Setter
@NoArgsConstructor
public class NetworkProxy extends AbstractYamlLineItem {

    private ProxyType proxyType;

    private String host;

    private int port;

    private String username;

    private String password;

    public NetworkProxy(Object originLine) {
        String proxyUrl = (String) originLine;

        String[] split = proxyUrl.split("://");
        String protocol = split[0];

        proxyType = switch (protocol) {
            case "http" -> ProxyType.HTTP;
            case "sockt5" -> ProxyType.SOCKT5;
            default -> throw new IllegalStateException("Unexpected value: " + protocol);
        };
        String[] upAndAddress = split[1].split("@");

        String[] up = upAndAddress[0].split(":");
        this.username = up[0];
        this.password = up[1];

        String[] address = upAndAddress[1].split(":");
        this.host = address[0];
        this.port = Integer.parseInt(address[1]);

    }

    public SocketAddress getAddress() {
        return new InetSocketAddress(host, port);
    }
}
package cn.com.helei.DepinBot.core.pool.network;

import cn.com.helei.DepinBot.core.pool.AbstractYamlLineItem;
import cn.com.helei.DepinBot.core.pool.AbstractYamlLinePool;
import cn.com.helei.DepinBot.core.util.table.CommandLineTablePrintHelper;

import java.util.ArrayList;
import java.util.Collection;


public class NetworkProxyPool extends AbstractYamlLinePool<NetworkProxy> {

    public NetworkProxyPool() {
        super(NetworkProxy.class);
    }


    public static NetworkProxyPool getDefault() {
        return loadYamlPool(
                "bot/network-proxy.yaml",
                "bot.network.proxy",
                NetworkProxyPool.class
        );
    }

    public static void main(String[] args) {
        System.out.println(getDefault().printPool());
    }
}
package cn.com.helei.DepinBot.core.pool.network;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
        import java.util.ArrayList;
import java.util.List;

public class TxtProxyConvert2YamlConfig {

    public static void main(String[] args) throws RuntimeException {

        String fileName = "/Users/helei/develop/ideaworkspace/depinbot/DepinBot/src/main/resources/proxy.txt";
        String fileName1 = "/Users/helei/develop/ideaworkspace/depinbot/DepinBot/src/main/resources/build-proxy.yaml";

        try (BufferedReader fr = new BufferedReader(new FileReader(fileName))){

            List<NetworkProxy> set = new ArrayList<>();
            String line;
            int id = 1;
            while ((line = fr.readLine()) != null) {
                String[] split = line.split(":");

                NetworkProxy networkProxy = new NetworkProxy();
                networkProxy.setHost(split[0]);
                networkProxy.setPort(Integer.parseInt(split[1]));
                networkProxy.setUsername(split[2]);
                networkProxy.setPassword(split[3]);
                set.add(networkProxy);
            }

            // 配置 YAML 输出选项
            DumperOptions options = new DumperOptions();
            options.setIndent(2);  // 设置缩进级别为 2
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); // 使用块风格

            Yaml yaml = new Yaml(options);

            // 写入 YAML 文件
            try (FileWriter writer = new FileWriter(fileName1)) {
                NetworkProxyPool data = new NetworkProxyPool();
                data.getList().addAll(set);
                yaml.dump(data, writer);  // 将对象写入 YAML 文件
                System.out.println("YAML 文件写入成功！");
            } catch (IOException e) {
                e.printStackTrace();
            }

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cn.com.helei.DepinBot.core.pool.network;

import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import java.io.*;
        import java.util.ArrayList;
import java.util.List;

public class TxtProxyConvert2YamlConfig {

    public static void main(String[] args) throws RuntimeException {

        String fileName = "/Users/helei/develop/ideaworkspace/depinbot/DepinBot/src/main/resources/proxy.txt";
        String fileName1 = "/Users/helei/develop/ideaworkspace/depinbot/DepinBot/src/main/resources/build-proxy.yaml";

        try (BufferedReader fr = new BufferedReader(new FileReader(fileName))){

            List<NetworkProxy> set = new ArrayList<>();
            String line;
            int id = 1;
            while ((line = fr.readLine()) != null) {
                String[] split = line.split(":");

                NetworkProxy networkProxy = new NetworkProxy();
                networkProxy.setHost(split[0]);
                networkProxy.setPort(Integer.parseInt(split[1]));
                networkProxy.setUsername(split[2]);
                networkProxy.setPassword(split[3]);
                set.add(networkProxy);
            }

            // 配置 YAML 输出选项
            DumperOptions options = new DumperOptions();
            options.setIndent(2);  // 设置缩进级别为 2
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); // 使用块风格

            Yaml yaml = new Yaml(options);

            // 写入 YAML 文件
            try (FileWriter writer = new FileWriter(fileName1)) {
                NetworkProxyPool data = new NetworkProxyPool();
                data.getList().addAll(set);
                yaml.dump(data, writer);  // 将对象写入 YAML 文件
                System.out.println("YAML 文件写入成功！");
            } catch (IOException e) {
                e.printStackTrace();
            }

        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
package cn.com.helei.DepinBot.core.pool;

import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenField;
import lombok.Data;
import lombok.NoArgsConstructor;


@NoArgsConstructor
@Data
public abstract class AbstractYamlLineItem {

    @PropertyChangeListenField
    private Integer id;

    private Object originLine;

    public AbstractYamlLineItem(Object originLine){
        this.originLine = originLine;
    }
}
package cn.com.helei.DepinBot.core.pool;


import cn.com.helei.DepinBot.core.util.YamlConfigLoadUtil;
import cn.com.helei.DepinBot.core.util.table.CommandLineTablePrintHelper;
import lombok.Getter;
import lombok.Setter;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

@Getter
public class AbstractYamlLinePool<T extends AbstractYamlLineItem> {

    private final Class<T> tClass;

    @Getter
    @Setter
    private List<Object> list;

    @Setter
    private String configClassPath;


    private final ConcurrentMap<Integer, AbstractYamlLineItem> idMapItem = new ConcurrentHashMap<>();

    /**
     * 使用次数
     */
    private final Map<Integer, Integer> useCountMap = new HashMap<>();

    public AbstractYamlLinePool(Class<T> tClass) {
        this.tClass = tClass;
    }

    public static <C extends AbstractYamlLinePool<?>> C loadYamlPool(
            String classpath, String path, Class<C> cClass) {

        C pool = YamlConfigLoadUtil.load(classpath, Arrays.stream(path.split("\\.")).toList(), cClass);

        AtomicInteger id = new AtomicInteger();
        List<Object> list1 = pool.getList();
        for (Object rawLine : list1) {
            AbstractYamlLineItem item;

            try {
                item = pool.buildTInstanceFromLineStr(rawLine);
            } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                     IllegalAccessException e) {
                throw new RuntimeException(e);
            }

            item.setId(id.getAndIncrement());
            pool.getIdMapItem().put(id.get(), item);
            pool.getUseCountMap().put(id.get(), 0);
        }

        pool.setConfigClassPath(classpath);

        return pool;
    }


    /**
     * 获取代理
     *
     * @param id id
     * @return NetworkProxy
     */
    public synchronized T getItem(Integer id) {
        AbstractYamlLineItem compute = idMapItem.compute(id, (k, v) -> {
            if (v == null) return null;

            useCountMap.compute(id, (k1, v1) -> {
                if (v1 == null) v1 = 0;

                return v1 + 1;
            });

            return v;
        });
        return (T) compute;
    }


    /**
     * 获取最少使用的
     *
     * @param count 数量
     * @return List<T>
     */
    public synchronized List<T> getLessUsedItem(int count) {
        int batchSize = Math.min(count, getUseCountMap().size());

        List<T> res = new ArrayList<>(count);

        int needCount = count;
        while (needCount > 0) {
            int currentSize = Math.min(needCount, batchSize);

            List<T> batch = getUseCountMap().entrySet().stream()
                    .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .limit(currentSize)
                    .map(e -> {
                        getUseCountMap().compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                        return (T) getIdMapItem().get(e.getKey());
                    }).toList();
            res.addAll(batch);

            needCount -= batch.size();
        }

        return res;
    }

    /**
     * 获取全部
     *
     * @return List<T>
     */
    public List<T> getAllItem() {
        return getIdMapItem().values().stream().map(e -> (T) e).toList();
    }


    /**
     * 打印池
     *
     * @return String
     */
    public String printPool() {
        return CommandLineTablePrintHelper.generateTableString(new ArrayList<>(idMapItem.values()), tClass);
    }


    public T buildTInstanceFromLineStr(Object originLine)
            throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Constructor<T> constructor = getTClass().getConstructor(Object.class);
        return constructor.newInstance(originLine);
    }

}
package cn.com.helei.DepinBot.core.supporter.persistence;

import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeListenField;
import cn.com.helei.DepinBot.core.supporter.propertylisten.PropertyChangeProxy;
import cn.com.helei.DepinBot.core.util.NamedThreadFactory;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Stream;


@Slf4j
public class AccountPersistenceManager {

    private static final String PERSISTENCE_PATH = "persistence/accounts";

    private static final String PERSISTENCE_ACCOUNT_PATTERN = "account-%d.json";

    private final ExecutorService executorService;

    private final ConcurrentMap<Object, Object> listenedObjRootMap = new ConcurrentHashMap<>();

    private final ConcurrentMap<Object, Long> rootTimestampMap = new ConcurrentHashMap<>();

    public AccountPersistenceManager() {
        this.executorService = Executors.newThreadPerTaskExecutor(new NamedThreadFactory("persistence-"));
    }

    /**
     * 持久化保存accountContexts
     *
     * @param accountContexts accountContexts
     */
    public synchronized void persistenceAccountContexts(List<AccountContext> accountContexts) throws IOException {
        Path path = Paths.get(getPersistencePath(PERSISTENCE_PATH));
        if (!Files.exists(path)) Files.createDirectories(path);

        for (AccountContext accountContext : accountContexts) {
            String fileName = String.format(PERSISTENCE_ACCOUNT_PATTERN, accountContext.getClientAccount().getId());

            saveAccountContext(accountContext, path, fileName);
        }
    }


    /**
     * 加载账户上下文
     *
     * @return PersistenceDto
     */
    public synchronized Map<Integer, AccountContext> loadAccountContexts() {
        Path path = Paths.get(getPersistencePath(PERSISTENCE_PATH));

        if (!Files.exists(path)) return null;

        Map<Integer, AccountContext> map = new HashMap<>();

        try (Stream<Path> walk = Files.walk(path);) {

            for (Path filePath : walk.filter(Files::isRegularFile)
                    .filter(p -> p.toString().contains("account-")).toList()) {

                Integer idx = Integer.valueOf(filePath.toString()
                        .split("account-")[1].split(".json")[0]);

                try (BufferedReader reader = new BufferedReader(new FileReader(filePath.toFile()));) {
                    String line = null;
                    StringBuilder sb = new StringBuilder();
                    while ((line = reader.readLine()) != null) {
                        sb.append(line);
                    }

                    map.put(idx, JSONObject.parseObject(sb.toString(), AccountContext.class));
                }
            }

            return map;
        } catch (Exception e) {
            throw new RuntimeException("读取账户文件失败", e);
        }
    }


    /**
     * 注册持久化监听
     *
     * @param targetList targetList
     * @param <T>        targetType
     */
    public <T> void registerPersistenceListener(List<T> targetList) {
        targetList.replaceAll(this::bindPersistenceAnnoListener);
    }

    /**
     * 对象属性添加变化监听
     *
     * @param target target 目标对象
     * @param <T>    T
     * @return 添加监听后被动态代理的对象
     */
    public <T> T bindPersistenceAnnoListener(T target) {
        return doBindPersistenceAnnoListener(target, target);
    }

    /**
     * 对象属性添加变化监听
     *
     * @param target target 目标对象
     * @param <T>    T
     * @return 添加监听后被动态代理的对象
     */
    private <T> T doBindPersistenceAnnoListener(T target, Object rootObj) {
        if (target == null) return null;

        Class<?> targetClass = target.getClass();

        PropertyChangeListenClass propertyChangeListenClass = targetClass.getAnnotation(PropertyChangeListenClass.class);

        // 类上带有PersistenceClass注解，表示可以的类
        if (propertyChangeListenClass == null) {
            return target;
        }

        T proxy = PropertyChangeProxy.createProxy(target, (propertyName, oldValue, newValue, timestamp) -> {
            propertyChangeHandler(target, propertyName, oldValue, newValue, timestamp);
        });

        // 深度监听，还要给监听的字段对象内的属性监听
        if (propertyChangeListenClass.isDeep()) {

            for (Field field : targetClass.getDeclaredFields()) {
                field.setAccessible(true);
                // 字段上带有PersistenceField注解，表示可以的字段， 字段类型上带有PersistenceClass，还要监听字段对象的属性
                if (field.isAnnotationPresent(PropertyChangeListenField.class)
                        && field.getType().isAnnotationPresent(PropertyChangeListenClass.class)) {
                    try {
                        Object fieldValue = field.get(target);
                        Object filedProxy = doBindPersistenceAnnoListener(fieldValue, rootObj);

                        field.set(target, filedProxy);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("访问字段失败", e);
                    }
                }
            }
        }

        listenedObjRootMap.put(target, rootObj);

        return proxy;
    }

    /**
     * 属性改变后触发
     *
     * @param target       target
     * @param propertyName propertyName
     * @param oldValue     oldValue
     * @param newValue     newValue
     * @param timestamp    timestamp
     */
    private void propertyChangeHandler(Object target, String propertyName, Object oldValue, Object newValue, long timestamp) {
        executorService.execute(() -> {
            Object root = listenedObjRootMap.get(target);

            Long newTimestamp = rootTimestampMap.compute(root, (k, v) -> {
                log.info("目标[{}] 属性改变了:{},{}->{} [{}]", root.hashCode(), propertyName, oldValue, newValue, timestamp);

                // 如果当前没有保存时间戳，或者新的时间戳小于当前保存时间戳，则更新保存时间戳.写入文件
                if (v == null || v < timestamp) {
                    log.info("最新值为[{}]", newValue);
                    return timestamp;
                }
                return v;
            });


        });
    }

    /**
     * 保存账户
     *
     * @param accountContext accountContext
     * @param path           accountContext
     * @param fileName       fileName
     */
    private static void saveAccountContext(AccountContext accountContext, Path path, String fileName) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(Path.of(path.toString(), fileName).toFile()))) {

            accountContext.setSaveDatetime(LocalDateTime.now());
            writer.write(JSONObject.toJSONString(accountContext));

            writer.flush();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }


    /**
     * 获取持久化路径， 项目根目录开始
     *
     * @param subPath subPath
     * @return String
     */
    private static String getPersistencePath(String subPath) {
        return System.getProperty("user.dir") + File.separator + subPath;
    }
}
package cn.com.helei.DepinBot.core.supporter.propertylisten;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface PropertyChangeListenClass {
    boolean isDeep() default false;
}
package cn.com.helei.DepinBot.core.supporter.propertylisten;

public interface PropertyChangeListener {

    void onPropertyChanged(String propertyName, Object oldValue, Object newValue, long updateTimestamp);

}
package cn.com.helei.DepinBot.core.supporter.propertylisten;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface PropertyChangeListenField {

    String name() default "";
}
package cn.com.helei.DepinBot.core.supporter.propertylisten;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;
import org.jetbrains.annotations.NotNull;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PropertyChangeProxy implements MethodInterceptor {

    private final Object target;

    private final PropertyChangeListener listener;

    private final Map<String, Object> fieldValues = new HashMap<>();

    public PropertyChangeProxy(Object target, PropertyChangeListener listener) {
        this.target = target;
        this.listener = listener;
        Class<?> targetClass = target.getClass();

        if (targetClass.isAnnotationPresent(PropertyChangeListenClass.class) || target instanceof Map<?, ?>) {
            List<Field> fields = new ArrayList<>();
            fields.addAll(List.of(targetClass.getDeclaredFields()));
            fields.addAll(List.of(targetClass.getSuperclass().getDeclaredFields()));

            for (Field field : fields) {
                field.setAccessible(true);
                if (field.isAnnotationPresent(PropertyChangeListenField.class)) {
                    String name = getFieldName(field);
                    try {
                        Object fieldValue = field.get(target);

                        if (fieldValue instanceof Map<?, ?>) {
                            fieldValue = createMapProxy((Map<?, ?>) fieldValue, name);
                            field.set(target, fieldValue);
                        }

                        fieldValues.put(name, fieldValue);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("无法访问字段值", e);
                    }
                }
            }
        }
    }

    public static <T> T createProxy(T target, PropertyChangeListener listener) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(target.getClass());
        enhancer.setCallback(new PropertyChangeProxy(target, listener));

        return (T) enhancer.create();
    }


    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        if (isSetter(method)) {
            String fieldName = getFieldNameFromMethod(method);

            if (fieldValues.containsKey(fieldName)) {
                Object oldValue = fieldValues.get(fieldName);
                Object newValue = args[0];

                if (newValue instanceof Map<?, ?>) {
                    newValue = createMapProxy((Map<?, ?>) newValue, fieldName);
                }

                //属性值发生变化
                if ((oldValue == null && newValue != null) || (oldValue != null && !oldValue.equals(newValue))) {
                    fieldValues.put(fieldName, newValue);
                    listener.onPropertyChanged(fieldName, oldValue, newValue, System.currentTimeMillis());
                }
            }
        }

        return methodProxy.invoke(target, args);
    }


    private Map<?, ?> createMapProxy(Map<?, ?> originalMap, String fieldName) {
        Object o = Enhancer.create(Map.class, (MethodInterceptor) (obj, method, args, methodProxy) -> {

            if (method.getName().equals("put")) {
                Object key = args[0];
                Object value = args[1];
                listener.onPropertyChanged(fieldName + "[" + key + "]", originalMap.get(key), value, System.currentTimeMillis());
            }

            if (method.getName().equals("remove")) {
                Object key = args[0];
                listener.onPropertyChanged(fieldName + "[" + key + "]", originalMap.get(key), null, System.currentTimeMillis());
            }

            return  method.invoke(originalMap, args);
        });

        return (Map<?, ?>) o;
    }

    private String getFieldNameFromMethod(Method method) {
        String name = method.getName().substring(3);

        return Character.toLowerCase(name.charAt(0)) + name.substring(1);
    }


    private boolean isSetter(Method method) {
        return method.getName().startsWith("set") && method.getParameters().length == 1;
    }

    private static @NotNull String getFieldName(Field field) {
        PropertyChangeListenField persistenceField = field.getAnnotation(PropertyChangeListenField.class);
        String name = persistenceField.name();
        if (name.isEmpty()) {
            name = field.getName();
        }
        return name;
    }

}
package cn.com.helei.DepinBot.core.util.table;

import cn.hutool.core.util.StrUtil;
import com.jakewharton.fliptables.FlipTable;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;

public class CommandLineTablePrintHelper {

    /**
     * 生成表格字符串
     *
     * @param list   list
     * @param tClass tClass
     * @return 表格字符串
     */
    public static  String generateTableString(List<?> list, Class<?> tClass) {
        List<String> tableHeader = new ArrayList<>();
        List<Field> tableFields = new ArrayList<>();

        for (Field field : tClass.getDeclaredFields()) {
            field.setAccessible(true);
            if (field.isAnnotationPresent(CommandTableField.class)) {
                String name = field.getAnnotation(CommandTableField.class).name();
                if (StrUtil.isBlank(name)) {
                    name = field.getName();
                }

                tableHeader.add(name);
                tableFields.add(field);
            }
        }

        if (tableHeader.isEmpty()) {
            List<Field> fieldList = List.of(tClass.getDeclaredFields());
            tableFields.addAll(fieldList);
            tableHeader.addAll(fieldList.stream().map(Field::getName).toList());
        }

        tableHeader.addFirst("row");
        String[][] table = new String[list.size()][tableHeader.size()];

        for (int i = 0; i < list.size(); i++) {
            Object obj =  list.get(i);

            table[i][0] = String.valueOf(i);
            for (int i1 = 1; i1 <= tableFields.size(); i1++) {
                Field field = tableFields.get(i1 - 1);
                field.setAccessible(true);
                Object o = null;
                try {
                    o = field.get(obj);
                } catch (IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
                table[i][i1] = String.valueOf(o == null ? "NO_DATA" : o);
            }
        }

        return FlipTable.of(tableHeader.toArray(new String[0]), table);
    }

}
package cn.com.helei.DepinBot.core;


import lombok.Data;

import java.util.List;

@Data
public abstract class BaseDepinBotConfig {

    /**
     * 名字
     */
    private String name = "Default Name";

    /**
     * 并发数量
     */
    private int concurrentCount = 5;


    /**
     * 账户奖励刷新间隔
     */
    private long accountRewardRefreshIntervalSeconds = 600;

    /**
     * 网络代理池配置文件名
     */
    private String networkPoolConfig = "bot/network-proxy.yaml";

    /**
     * 浏览器环境池配置文件名
     */
    private String browserEnvPoolConfig = "bot/browser-env.yaml";

    /**
     * 账户配置文件名
     */
    private String accountPoolConfig = "bot/account.yaml";

    /**
     * 连接url
     */
    private String wsBaseUrl;
}
package cn.com.helei.DepinBot.core;

import cn.com.helei.DepinBot.core.dto.account.ConnectStatusInfo;
import cn.com.helei.DepinBot.core.netty.base.AbstractWebSocketClientHandler;
import io.netty.channel.ChannelHandlerContext;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class BaseDepinWSClientHandler<Req, Resp> extends AbstractWebSocketClientHandler<Req, Resp> {

    /**
     * channel 空闲，向其发送心跳
     * @param ctx ctx
     */
    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        BaseDepinWSClient<Req, Resp> depinWSClient = getDepinWSClient();

        depinWSClient
                .sendMessage(depinWSClient.getHeartbeatMessage(depinWSClient))
                .whenCompleteAsync((unused, throwable) -> {
                    ConnectStatusInfo connectStatusInfo = depinWSClient
                            .getAccountContext()
                            .getConnectStatusInfo();

                    if (throwable != null) {
                        log.error("client[{}] 发送心跳异常", websocketClient.getName(), throwable);
                        // 发送心跳失败，记录次数
                        connectStatusInfo.getErrorHeartBeatCount().getAndIncrement();
                    }

                    // 心跳计数
                    connectStatusInfo.getHeartBeatCount()
                            .getAndIncrement();
                }, depinWSClient.getCallbackInvoker());
    }


    @Override
    public String getRequestId(Req request) {
        return "";
    }

    @Override
    public String getResponseId(Resp response) {
        return "";
    }


    @Override
    protected void handleResponseMessage(String id, Resp response) {
        BaseDepinWSClient<Req, Resp> depinWSClient = getDepinWSClient();

        depinWSClient.whenAccountReceiveResponse(depinWSClient, id, response);
    }

    @Override
    protected void handleOtherMessage(Resp message) {
        BaseDepinWSClient<Req, Resp> depinWSClient = getDepinWSClient();

        depinWSClient.whenAccountReceiveMessage(depinWSClient, message);
    }

    private BaseDepinWSClient<Req, Resp> getDepinWSClient() {
        return (BaseDepinWSClient<Req, Resp>) websocketClient;
    }
}
package cn.com.helei.DepinBot.depined;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import cn.com.helei.DepinBot.core.util.YamlConfigLoadUtil;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;

import java.util.List;

@EqualsAndHashCode(callSuper = true)
@Slf4j
@Data
public class DepinedConfig extends BaseDepinBotConfig {

    private String inviteCode;

    public static void main(String[] args) {
        System.out.println(loadYamlConfig("app/oasis.yaml"));
    }

    public static DepinedConfig loadYamlConfig(String classpath) {
        log.info("开始加载 OasisBot配置信息-file classpath:[{}}", classpath);
        DepinedConfig oasisBotConfig = YamlConfigLoadUtil
                .load(classpath, List.of("depin", "app", "oasis"), DepinedConfig.class);

        log.info("OasisBot配置信息加载完毕,{}", oasisBotConfig);
        return oasisBotConfig;
    }
}
package cn.com.helei.DepinBot.oasis;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.extern.slf4j.Slf4j;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Slf4j
@Data
public class OasisBotConfig extends BaseDepinBotConfig {

    private String inviteCode;

    public static void main(String[] args) {
        System.out.println(loadYamlConfig("app/oasis.yaml"));
    }

    public static OasisBotConfig loadYamlConfig(String classpath) {
        Yaml yaml = new Yaml();
        log.info("开始加载 OasisBot配置信息-file classpath:[{}}", classpath);
        try (InputStream inputStream = OasisBotConfig.class.getClassLoader().getResourceAsStream(classpath)) {
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
            Map<String, Object> app = (Map<String, Object>) depin.get("app");
            Map<String, Object> oasis = (Map<String, Object>) app.get("oasis");

            //Step 1 基础配置文件
            OasisBotConfig oasisBotConfig = yaml.loadAs(yaml.dump(oasis), OasisBotConfig.class);

            log.info("OasisBot配置信息加载完毕");

            return oasisBotConfig;
        } catch (IOException e) {
            throw new RuntimeException(String.format("加载配置文件[%s]发生错误", classpath));
        }
    }
}


package cn.com.helei.DepinBot.openLedger;

import cn.com.helei.DepinBot.core.BaseDepinBotConfig;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j
@ToString
public class OpenLedgerConfig extends BaseDepinBotConfig {


    /**
     * 浏览器标识
     */
    private String origin;

    /**
     * 账户列表
     */
    private List<OpenLedgerAccount> openLedgerAccounts;


    public static void main(String[] args) {
        OpenLedgerConfig openLedgerConfig = loadYamlConfig("app/openledger.yaml");
        System.out.println(openLedgerConfig);
    }

    public static OpenLedgerConfig loadYamlConfig(String classpath) {
        Yaml yaml = new Yaml();
        log.info("开始加载OpenLedger配置信息-file classpath:[{}}", classpath);
        try (InputStream inputStream = OpenLedgerConfig.class.getClassLoader().getResourceAsStream(classpath)) {
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
            Map<String, Object> openledger = (Map<String, Object>) depin.get("openledger");

            //Step 1 基础配置文件
            OpenLedgerConfig openLedgerConfig = yaml.loadAs(yaml.dump(openledger), OpenLedgerConfig.class);

            //Step 4 账户列表完善
            openLedgerConfig.getOpenLedgerAccounts().forEach(openLedgerAccount -> {
                openLedgerAccount.setOpenLedgerConfig(openLedgerConfig);
            });

            log.info("OpenLedger配置信息加载完毕: 共{}个账号", openLedgerConfig.getOpenLedgerAccounts().size());

            return openLedgerConfig;
        } catch (IOException e) {
            throw new RuntimeException(String.format("价值配置网络代理池文件[%s]发生错误", classpath));
        }
    }



    @EqualsAndHashCode(callSuper = true)
    @Data
    public static class OpenLedgerAccount extends DepinClientAccount {

        private final static String printTemplate = "%-25s\t%-25s\t%-5s";

        private transient OpenLedgerConfig openLedgerConfig;

        private String token;

        private String identity;

        private String ownerAddress;


        public static String printTittle() {
            return String.format(printTemplate, "账户名", "代理", "环境ID");
        }

        @Override
        public String getConnectUrl() {
            return openLedgerConfig.getWsBaseUrl() + "?authToken=" + token;
        }

        @Override
        public HttpHeaders getWSHeaders() {
            HttpHeaders headers = new DefaultHttpHeaders();

            headers.add("Upgrade", "websocket")
                    .add("Origin", openLedgerConfig.origin)
                    .add("Host", "apitn.openledger.xyz")
                    .add("Connection", "Upgrade")
            ;
            return headers;
        }

        @Override
        public HttpHeaders getRestHeaders() {
            HttpHeaders restHeaders = super.getRestHeaders();

            restHeaders.add("authorization", "Bearer " + token);

            return restHeaders;
        }

        @Override
        public String toString() {
            return "OpenLedgerAccount{" +
                    "token='" + token + '\'' +
                    ", identity='" + identity + '\'' +
                    ", ownerAddress='" + ownerAddress + '\'' +
                    "} " + super.toString();
        }
    }
}
package cn.com.helei.DepinBot.core.persistence;

import cn.com.helei.DepinBot.core.dto.account.AccountContext;
import cn.com.helei.DepinBot.core.pool.account.DepinClientAccount;
import cn.com.helei.DepinBot.core.supporter.persistence.AccountPersistenceManager;
import org.junit.jupiter.api.Test;


class AccountPersistenceManagerTest {

    @Test
    void bindPersistenceAnnoListener() {
        AccountPersistenceManager accountPersistenceManager = new AccountPersistenceManager();

        DepinClientAccount clientAccount = new DepinClientAccount();

        AccountContext accountContext = AccountContext.builder().clientAccount(clientAccount).build();

        AccountContext proxy = accountPersistenceManager.bindPersistenceAnnoListener(accountContext);

        proxy.getParams().put("1", "a");
        proxy.getParams().put("1", "b");
        proxy.getParams().put("1", "c");
        proxy.getParams().put("1", "d");
    }
}
