package cn.com.vortexa.common.constants;

import java.io.Serial;
import java.io.Serializable;

/**
 * @author helei
 * @since 2025/4/22 10:15
 */
public enum ChainType implements Serializable {
    ETH,
    SOL
    ;


    @Serial
    private static final long serialVersionUID = -5038754923875498237L;
}
package cn.com.vortexa.common.dto.config;

import cn.com.vortexa.common.dto.BotMetaInfo;
import lombok.Data;
import lombok.ToString;

import java.io.Serial;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

@Data
@ToString
public class AutoBotConfig implements Serializable {

    @Serial
    private static final long serialVersionUID = -3278263726328378273L;

    public static int LOG_CACHE_COUNT = 50; // 日志缓存数量

    /**
     * bot名
     */
    private String botName;

    /**
     * bot实例key， botKey是由用户定义的
     */
    private String botKey;

    /**
     * bot 元信息
     */
    private BotMetaInfo metaInfo;

    /**
     * 账户配置
     */
    private AutoBotAccountConfig accountConfig = new AutoBotAccountConfig();

    /**
     * 自定义配置
     */
    private Map<String, Object> customConfig = new HashMap<>();


    public String getConfig(String key) {
        return customConfig == null ? null : String.valueOf(customConfig.get(key));
    }

    public void setConfig(String key, String value) {
        this.customConfig.put(key, value);
    }
}
package cn.com.vortexa.common.dto.web3;

import cn.com.vortexa.common.constants.ChainType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serial;
import java.io.Serializable;

/**
 * @author helei
 * @since 2025/4/22 10:16
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class SignatureMessage implements Serializable {
    @Serial
    private static final long serialVersionUID = -2783964872364872364L;

    private Integer walletId;

    private ChainType chainType;

    private String message;
}
package cn.com.vortexa.common.dto;

import lombok.Data;

import java.io.Serial;
import java.io.Serializable;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/22 16:30
 */
@Data
public class BotMetaInfo implements Serializable {
    @Serial
    private static final long serialVersionUID = -3498562379865872387L;

    /**
     * bot name，需要与对应类的@BotApplication注解中的name一致
     */
    private String botName;
    /**
     * 资源文件dir, 运行时写入，为class文件所在目录(bot-instance-config所在目录)
     */
    private String resourceDir;

    /**
     * class文件所在的jar包路径，运行时写入
     */
    private String classJarPath;

    /**
     * 类名， 必填，还需包含包路径
     */
    private String className;

    /**
     * 其它需加载的类名
     */
    private List<String> extraClassNameList;

}
package cn.com.vortexa.common.entity;


import cn.com.vortexa.common.dto.ConnectStatusInfo;
import cn.com.vortexa.common.util.excel.IntegerStringConverter;
import cn.com.vortexa.common.util.propertylisten.PropertyChangeListenClass;
import cn.com.vortexa.common.util.propertylisten.PropertyChangeListenField;
import cn.com.vortexa.common.util.tableprinter.CommandTableField;
import cn.com.vortexa.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.vortexa.common.util.typehandler.MapTextTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
@PropertyChangeListenClass(isDeep = true)
public class AccountContext implements Serializable {

    @Serial
    private static final long serialVersionUID = 5648946541345416541L;

    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("bot_id")
    @CommandTableField
    private Integer botId;

    @TableField("bot_key")
    @ExcelProperty(value = "bot_key")
    @CommandTableField
    private String botKey;

    @TableField("account_base_info_id")
    @ExcelProperty(value = "account_base_info_id", converter = IntegerStringConverter.class)
    @CommandTableField
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty(value = "twitter_id", converter = IntegerStringConverter.class)
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty(value = "discord_id", converter = IntegerStringConverter.class)
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty(value = "proxy_id", converter = IntegerStringConverter.class)
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty(value = "browser_env_id", converter = IntegerStringConverter.class)
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty(value = "telegram_id", converter = IntegerStringConverter.class)
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty(value = "wallet_id", converter = IntegerStringConverter.class)
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    /**
     * 账号状态
     * 0 表示初始状态
     * 1 表示已注册
     */
    @TableField("status")
    @PropertyChangeListenField
    @CommandTableField
    private Integer status;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer valid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    @CommandTableField
    private ProxyInfo proxy;

    @TableField(exist = false)
    @CommandTableField
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private Web3Wallet wallet;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return params.get(key) == null ? "" : params.get(key).toString();
    }

    public <T> T getParam(String key, Supplier<T> build) {
        Object o = params.get(key);
        if (o == null) {
            o = build.get();
        }
        return o == null ? null : (T) o;
    }

    public void setParam(String key, Object value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        if (accountBaseInfo == null) return "";
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().generateAddressStr());
    }

    public Boolean isSignUp() {
        return status != null && status == 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }

    public static void signUpSuccess(AccountContext accountContext) {
        accountContext.setStatus(1);
    }
}
package cn.com.vortexa.common.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableLogic;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.List;

import cn.com.vortexa.common.util.typehandler.LocalDateTimeTypeHandler;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * <p>
 * 
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_web3_wallet")
public class Web3Wallet implements Serializable {
    public static final List<String> PUBLIC_FIELDS = List.of("id", "eth_address", "sol_address", "btc_address", "insert_datetime", "update_datetime", "valid");

    @Serial
    private static final long serialVersionUID = 938764872364829487L;

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("mnemonic")
    private String mnemonic;

    @TableField("eth_private_key")
    private String ethPrivateKey;

    @TableField("eth_address")
    private String ethAddress;

    @TableField("sol_private_key")
    private String solPrivateKey;
    @TableField("sol_address")
    private String solAddress;

    @TableField("btc_private_key")
    private String btcPrivateKey;
    @TableField("btc_address")
    private String btcAddress;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer valid;
}
package cn.com.vortexa.common.util;

import cn.com.vortexa.common.constants.FilePathType;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class FileUtil {

    public static final String BASE_DIR_NAME = "vortexa-data";

    public static final List<String> CONFIG_DIR_BOT_PATH = List.of("config", "bot");

    public static final List<String> CONFIG_DIR_APP_PATH = List.of("config", "app");

    public static final String USER_DIR = System.getProperty("user.dir");
    /**
     * app资源根目录
     */
    public static final String RESOURCE_ROOT_DIR = USER_DIR + File.separator + BASE_DIR_NAME;

    /**
     * class资源
     *
     * @return path
     * @throws IOException exception
     */
    public static String getCompileClassResourceDir() throws IOException {
        Path path = Paths.get(RESOURCE_ROOT_DIR + File.separator + "classes");
        if (Files.notExists(path)) {
            Files.createDirectories(path);
        }
        return path.toString();
    }

    /**
     * class资源
     *
     * @return path
     * @throws IOException exception
     */
    public static String getCompileClassResource(String subDir) throws IOException {
        String dir = getCompileClassResourceDir();
        Path path = Paths.get(dir + File.separator + subDir);
        if (Files.notExists(path)) {
            Files.createDirectories(path);
        }
        return path.toString();
    }

    /**
     * 获取数据库文件的dir
     *
     * @return String
     */
    public static String getDBResourceDir() {
        return RESOURCE_ROOT_DIR + File.separator + "db";
    }

    /**
     * 获取资源路径
     *
     * @param path     子路径
     * @param fileName 文件名
     * @return 绝对路径
     */
    public static String getAppResourcePath(List<String> path, String fileName) {
        StringBuilder sb = new StringBuilder(RESOURCE_ROOT_DIR);

        for (String p : path) {
            sb.append(File.separator).append(p);
        }
        return sb.append(File.separator).append(fileName).toString();
    }

    /**
     * 获取app配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceConfigDir() {
        return RESOURCE_ROOT_DIR + File.separator + "config";
    }

    /**
     * 获取app配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceAppConfigDir() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, CONFIG_DIR_APP_PATH);
    }

    /**
     * 获取系统配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceSystemConfigDir() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, CONFIG_DIR_BOT_PATH);
    }

    /**
     * 获取data目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceDataDir() {
        return RESOURCE_ROOT_DIR + File.separator + "data";
    }

    /**
     * 获取data目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceDataPath(String fileName) {
        return getAppResourceDataDir() + File.separator + fileName;
    }

    /**
     * 获取script node config目录
     *
     * @return 配置目录绝对路径
     */
    public static String getScriptNodeConfigDir() {
        return getAppResourceConfigDir() + File.separator + "script_node";
    }

    /**
     * 依赖目录
     *
     * @return String
     */
    public static String getLibraryDir() {
        return USER_DIR + File.separator + "lib";
    }

    /**
     * 依赖文件
     *
     * @return String
     */
    public static String getLibraryPath(String fileName) {
        return getLibraryDir() + File.separator + fileName + (fileName.endsWith(".jar") ? "" : ".jar");
    }

    /**
     * 依赖目录
     *
     * @return String
     */
    public static String getJarFileDir() {
        return RESOURCE_ROOT_DIR + File.separator + "jarFile";
    }

    /**
     * 依赖文件
     *
     * @return String
     */
    public static String getJarFilePath(String ...fileName) {
        return getJarFileDir() + File.separator + String.join(File.separator, fileName);
    }

    /**
     * bot实例配置目录
     *
     * @return String
     */
    public static String getBotInstanceConfigDir() {
        return USER_DIR + File.separator + "instance";
    }

    /**
     * 生成绝对路径
     *
     * @param patternPath             patternPath
     * @param botResourcePath        botResourcePath
     * @return 绝对路径
     */
    public static String generateAbsPath(String patternPath, String botResourcePath) {
        FilePathType filePathType = FilePathType.resolveFilePathType(patternPath);
        return switch (filePathType) {
            case absolute -> {
                if (patternPath.startsWith(filePathType.name())) {
                    yield patternPath.replace("absolute:", "");
                }
                yield patternPath;
            }
            case instance_resource ->
                    patternPath.replace("instance_resource:", botResourcePath + File.separator);
            case app_resource -> patternPath.replace("app_resource:", RESOURCE_ROOT_DIR + File.separator);
            case app_resource_config ->
                    patternPath.replace("app_resource_config:", getAppResourceAppConfigDir() + File.separator);
            case app_resource_data ->
                    patternPath.replace("app_resource_data:", getAppResourceDataDir() + File.separator);
        };
    }

    /**
     * 保存
     */
    public static void saveJSONStringContext(Path filePath, String jsonContext) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath.toFile()))) {
            writer.write(jsonContext);
            writer.flush();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 创建日志目录
     *
     * @param scriptNodeName scriptNodeName
     * @param botKey         botKey
     */
    public static String createLogsDir(String scriptNodeName, String botKey) throws IOException {
        Path path = Paths.get(RESOURCE_ROOT_DIR, "logs", scriptNodeName, botKey);
        if (Files.notExists(path)) {
            Files.createDirectories(path);
        }
        return path.toString();
    }


    /**
     * 解压 JAR 文件到指定目录
     *
     * @param jarFilePath jarFilePath
     * @param outputDir   outputDir
     * @throws IOException  IOException
     */
    public static void extractJar(String jarFilePath, String outputDir) throws IOException {
        // 打开 JAR 文件
        try (JarFile jarFile = new JarFile(jarFilePath);) {
            // 创建目标目录，如果不存在则创建
            File outputDirFile = new File(outputDir);
            if (!outputDirFile.exists()) {
                outputDirFile.mkdirs();
            }
            // 获取 JAR 文件中的所有条目
            Enumeration<JarEntry> entries = jarFile.entries();

            // 遍历所有条目
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();

                // 获取条目的名称（路径）
                String entryName = entry.getName();
                File entryFile = new File(outputDirFile, entryName);

                // 如果条目是目录，则创建该目录
                if (entry.isDirectory()) {
                    entryFile.mkdirs();
                } else if (!entryName.endsWith(".class")){
                    // 如果条目是文件，则解压文件内容
                    try (InputStream inputStream = jarFile.getInputStream(entry);
                         OutputStream outputStream = new FileOutputStream(entryFile)) {

                        // 缓冲区
                        byte[] buffer = new byte[1024];
                        int bytesRead;

                        // 读取 JAR 文件内容并写入目标文件
                        while ((bytesRead = inputStream.read(buffer)) != -1) {
                            outputStream.write(buffer, 0, bytesRead);
                        }
                    }
                }
            }
        }
    }
}
package cn.com.vortexa.common.util;

import org.yaml.snakeyaml.Yaml;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class YamlConfigLoadUtil {

    private static final ConcurrentHashMap<String, Object> LOADED_CONFIG_MAP = new ConcurrentHashMap<>();

    public static <T> T load(
            String path,
            String fileName,
            String prefix,
            Class<T> clazz
    ) {
        return load(
                Arrays.asList(path.split("\\.")),
                fileName,
                Arrays.asList(prefix.split("\\.")),
                clazz
        );
    }


    public static <T> T load(
            List<String> path,
            String fileName,
            List<String> prefixList,
            Class<T> clazz
    ) {
        String dirResourcePath = FileUtil.getAppResourcePath(path, fileName);

        Object compute = LOADED_CONFIG_MAP.compute(dirResourcePath, (k, config) -> {
            if (config == null) {
                Yaml yaml = new Yaml();
                try (InputStream inputStream = new FileInputStream(dirResourcePath)) {
                    Map<String, Object> yamlData = yaml.load(inputStream);

                    if (prefixList != null) {
                        for (String prefix : prefixList) {
                            yamlData = (Map<String, Object>) yamlData.get(prefix);
                            Map<String, Object> target = new HashMap<>();
                            for (Map.Entry<String, Object> entry : yamlData.entrySet()) {
                                target.put(toCamelCase(entry.getKey()), entry.getValue());
                            }
                            yamlData = target;
                        }
                    }

                    config = yaml.loadAs(yaml.dump(yamlData), clazz);
                } catch (IOException e) {
                    throw new RuntimeException(String.format("加载配置池文件[%s]发生错误", dirResourcePath), e);
                }
            }

            return config;
        });

        return (T) compute;
    }

    public static List<Object> load(List<String> configDirBotPath, String fileName, String prefix) {
        return load(configDirBotPath, fileName, List.of(prefix.split("\\.")));
    }

    public static List<Object> load(
            List<String> path,
            String fileName,
            List<String> prefixList
    ) {
        String dirResourcePath = FileUtil.getAppResourcePath(path, fileName);

        Object compute = LOADED_CONFIG_MAP.compute(dirResourcePath, (k, config) -> {
            if (config == null) {
                Yaml yaml = new Yaml();
                try (InputStream inputStream = new FileInputStream(dirResourcePath)) {
                    Map<String, Object> yamlData = yaml.load(inputStream);

                    if (prefixList != null) {
                        for (String prefix : prefixList) {
                            yamlData = (Map<String, Object>) yamlData.get(prefix);
                            Map<String, Object> target = new HashMap<>();
                            for (Map.Entry<String, Object> entry : yamlData.entrySet()) {
                                target.put(toCamelCase(entry.getKey()), entry.getValue());
                            }
                            yamlData = target;
                        }
                    }
                    return yamlData.get("list");
                } catch (IOException e) {
                    throw new RuntimeException(String.format("加载配置池文件[%s]发生错误", dirResourcePath), e);
                }
            }

            return config;
        });

        return (List<Object>) compute;
    }

    public static <T> T load(File path, List<String> prefixList, Class<T> tClass) {
        Object compute = LOADED_CONFIG_MAP.compute(path.getAbsolutePath(), (k, config) -> {
            if (config == null) {
                Yaml yaml = new Yaml();
                try (InputStream inputStream = new FileInputStream(path)) {
                    Map<String, Object> yamlData = yaml.load(inputStream);

                    if (prefixList != null) {
                        for (String prefix : prefixList) {
                            yamlData = (Map<String, Object>) yamlData.get(prefix);
                            Map<String, Object> target = new HashMap<>();
                            for (Map.Entry<String, Object> entry : yamlData.entrySet()) {
                                target.put(toCamelCase(entry.getKey()), entry.getValue());
                            }
                            yamlData = target;
                        }
                    }

                    return yaml.loadAs(yaml.dump(yamlData), tClass);
                } catch (IOException e) {
                    throw new RuntimeException(String.format("加载配置池文件[%s]发生错误", path), e);
                }
            }
            return config;
        });

        return (T) compute;
    }


    public static <T> T load(String name, InputStream inputStream, List<String> prefixList, Class<T> tClass) {
        Object compute = LOADED_CONFIG_MAP.compute(name, (k, config) -> {
            if (config == null) {
                Yaml yaml = new Yaml();
                Map<String, Object> yamlData = yaml.load(inputStream);
                if (prefixList != null) {
                    for (String prefix : prefixList) {
                        yamlData = (Map<String, Object>) yamlData.get(prefix);
                        Map<String, Object> target = new HashMap<>();
                        for (Map.Entry<String, Object> entry : yamlData.entrySet()) {
                            target.put(toCamelCase(entry.getKey()), entry.getValue());
                        }
                        yamlData = target;
                    }
                }
                return yaml.loadAs(yaml.dump(yamlData), tClass);
            }
            return config;
        });

        return (T) compute;
    }

    public static <T> T load(String content, List<String> prefixList, Class<T> tClass) {
        Yaml yaml = new Yaml();
        Map<String, Object> yamlData = yaml.load(String.valueOf(content));
        if (prefixList != null) {
            for (String prefix : prefixList) {
                yamlData = (Map<String, Object>) yamlData.get(prefix);
                Map<String, Object> target = new HashMap<>();
                for (Map.Entry<String, Object> entry : yamlData.entrySet()) {
                    target.put(toCamelCase(entry.getKey()), entry.getValue());
                }
                yamlData = target;
            }
        }
        return yaml.loadAs(yaml.dump(yamlData), tClass);
    }

    private static String toCamelCase(String name) {
        String[] parts = name.split("-");
        StringBuilder camelCase = new StringBuilder(parts[0]);
        for (int i = 1; i < parts.length; i++) {
            camelCase.append(parts[i].substring(0, 1).toUpperCase()).append(parts[i].substring(1));
        }
        return camelCase.toString();
    }

    public static Map<String, Object> flattenMap(Map<String, Object> source) {
        Map<String, Object> result = new LinkedHashMap<>();
        buildFlattenedMap(result, source, null);
        return result;
    }

    private static void buildFlattenedMap(Map<String, Object> result, Map<String, Object> source, String path) {
        source.forEach((key, value) -> {
            String newKey = (path != null) ? path + "." + key : key;
            if (value instanceof Map) {
                buildFlattenedMap(result, (Map<String, Object>) value, newKey);
            } else {
                result.put(newKey, value);
            }
        });
    }
}
package cn.com.vortexa.web3.exception;

public class SignatureException extends Exception{

    // 默认构造函数
    public SignatureException() {
        super("signature failed.");
    }

    // 传入错误信息的构造函数
    public SignatureException(String message) {
        super(message);
    }

    // 传入错误信息和异常原因的构造函数
    public SignatureException(String message, Throwable cause) {
        super(message, cause);
    }

    // 传入异常原因的构造函数
    public SignatureException(Throwable cause) {
        super(cause);
    }
}
package cn.com.vortexa.web3;

import cn.com.vortexa.web3.dto.WalletInfo;
import org.bitcoinj.crypto.*;
import org.web3j.crypto.*;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.EthGetTransactionCount;
import org.web3j.protocol.http.HttpService;
import org.web3j.utils.Numeric;

import java.io.IOException;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.List;

/**
 * @author helei
 * @since 2025/3/28 11:16
 */
public class EthWalletUtil {

    private static final SecureRandom secureRandom = new SecureRandom();

    public static WalletInfo generateEthWallet() {
        return generateWalletInfoFromMnemonic(generateMnemonic());
    }

    public static String generateMnemonic() {
        // 1. 生成助记词
        SecureRandom secureRandom = new SecureRandom();
        byte[] entropy = new byte[16]; // 128 bits entropy
        secureRandom.nextBytes(entropy);

        // 使用 bitcoinj 生成助记词
        var mnemonicCode = MnemonicCode.INSTANCE;
        List<String> mnemonicWords = null;
        try {
            mnemonicWords = mnemonicCode.toMnemonic(entropy);
        } catch (MnemonicException.MnemonicLengthException e) {
            throw new RuntimeException(e);
        }
        return String.join(" ", mnemonicWords);
    }

    public static WalletInfo generateWalletInfoFromMnemonic(String mnemonic) {
        // 2. 生成 seed
        byte[] seed = MnemonicUtils.generateSeed(mnemonic, ""); // passphrase 可设置

        // 3. 创建 HD 钱包根节点 (BIP32 Root Key)
        DeterministicKey rootPrivateKey = HDKeyDerivation.createMasterPrivateKey(seed);

        // 4. 分步派生 BIP44 路径 m/44'/60'/0'/0/0
        DeterministicKey purposeKey = HDKeyDerivation.deriveChildKey(rootPrivateKey, new ChildNumber(44, true));
        DeterministicKey coinTypeKey = HDKeyDerivation.deriveChildKey(purposeKey, new ChildNumber(60, true));
        DeterministicKey accountKey = HDKeyDerivation.deriveChildKey(coinTypeKey, new ChildNumber(0, true));
        DeterministicKey externalKey = HDKeyDerivation.deriveChildKey(accountKey, ChildNumber.ZERO); // change = 0
        DeterministicKey addressKey = HDKeyDerivation.deriveChildKey(externalKey, ChildNumber.ZERO); // address index = 0

        byte[] privateKeyBytes = addressKey.getPrivKeyBytes();

        // 转为 web3j 的 ECKeyPair
        ECKeyPair keyPair = ECKeyPair.create(privateKeyBytes);
        Credentials credentials = Credentials.create(keyPair);

        // 6. 输出钱包信息
        return WalletInfo.builder()
            .mnemonic(mnemonic)
            .privateKey(keyPair.getPrivateKey().toString(16))
            .publicKey(keyPair.getPublicKey().toString(16))
            .address(credentials.getAddress())
            .build();
    }

    public static Sign.SignatureData signatureMessage2Data(String privateKey, String message) {
        byte[] contentHashBytes = message.getBytes();
        // 根据私钥获取凭证对象
        Credentials credentials = Credentials.create(privateKey);
        return Sign.signPrefixedMessage(contentHashBytes, credentials.getEcKeyPair());
    }

    public static String signatureMessage2String(String privateKey, String message) {
        Sign.SignatureData signMessage = signatureMessage2Data(privateKey, message);

        byte[] r = signMessage.getR();
        byte[] s = signMessage.getS();
        byte[] v = signMessage.getV();

        byte[] signByte = Arrays.copyOf(r, v.length + r.length + s.length);
        System.arraycopy(s, 0, signByte, r.length, s.length);
        System.arraycopy(v, 0, signByte, r.length + s.length, v.length);


        return Numeric.toHexString(signByte);
    }

    public static String getETHAddress(String privateKeyHex) {
        Credentials credentials = Credentials.create(privateKeyHex);

        // 获取原始地址（小写）
        String rawAddress = credentials.getAddress();

        // 将地址转换为区分大小写的 Checksum 地址
        return Keys.toChecksumAddress(rawAddress);
    }


    public static BigInteger getNonce(String rpcUrl, String address) throws IOException {
        Web3j web3j = Web3j.build(new HttpService(rpcUrl));

        EthGetTransactionCount transactionCount = web3j.ethGetTransactionCount(
                        address, org.web3j.protocol.core.DefaultBlockParameterName.LATEST)
                .send();

        return transactionCount.getTransactionCount();
    }

    public static String getRandomNonce() {
        // 生成 32 字节的随机数
        byte[] randomBytes = new byte[32];
        secureRandom.nextBytes(randomBytes);

        // 将字节数组转换为十六进制字符串
        return toHex(randomBytes);
    }

    // 将字节数组转换为十六进制字符串
    public static String toHex(byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            hexString.append(String.format("%02x", b));  // 格式化为两位十六进制
        }
        return hexString.toString();
    }

    public static void main(String[] args) throws MnemonicException.MnemonicLengthException {


    }

}
package cn.com.vortexa.web3;

import com.portto.solana.web3.util.TweetNaclFast;
import com.portto.solana.web3.wallet.DerivableType;
import com.portto.solana.web3.wallet.SolanaBip44;

import cn.com.vortexa.web3.dto.WalletInfo;
import cn.com.vortexa.web3.exception.SignatureException;

import net.i2p.crypto.eddsa.EdDSAEngine;
import net.i2p.crypto.eddsa.EdDSAPrivateKey;
import net.i2p.crypto.eddsa.spec.EdDSANamedCurveTable;
import net.i2p.crypto.eddsa.spec.EdDSAPrivateKeySpec;

import org.bitcoinj.core.Base58;
import org.web3j.crypto.Bip39Wallet;
import org.web3j.crypto.Bip44WalletUtils;
import org.web3j.crypto.CipherException;
import org.web3j.crypto.ECKeyPair;
import org.web3j.crypto.MnemonicUtils;
import org.web3j.crypto.WalletUtils;

import java.io.File;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.Signature;

/**
 * @author helei
 * @since 2025/4/22 9:17
 */
public class SolanaWalletUtil {
    public static void main(String[] args) {
        String mnemonic = "replace fuel parent quarter lake pepper sweet gorilla bitter invest bike rude";
        System.out.println(generateWalletInfoFromMnemonic(mnemonic));
    }

    public static WalletInfo generateWalletInfoFromMnemonic(String mnemonic) {
        byte[] seed = MnemonicUtils.generateSeed(mnemonic, "");
        SolanaBip44 solanaBip44 = new SolanaBip44();
        //M/44H/501H/0H/0H
        byte[] privateKeyFromSeed = solanaBip44.getPrivateKeyFromSeed(seed, DerivableType.BIP44CHANGE);
        TweetNaclFast.Signature.KeyPair keyPair = TweetNaclFast.Signature.keyPair_fromSeed(privateKeyFromSeed);
        return WalletInfo.builder().mnemonic(mnemonic)
            .privateKey(Base58.encode(keyPair.getSecretKey()))
            .address(Base58.encode(keyPair.getPublicKey())).build();
    }

    public static Bip39Wallet generateBip44Wallet(String pwd, String dirPath) throws CipherException, IOException {
        File dir = new File(dirPath);
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                throw new RuntimeException("make wallet dir error");
            }
        }
        return Bip44WalletUtils.generateBip44Wallet(pwd, dir);
    }

    public static String generateMnemonicFile(String pwd, String mnemonic, String dirPath) throws CipherException, IOException {
        // make dir
        File dir = new File(dirPath);
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                throw new RuntimeException("make wallet dir error");
            }
        }
        // string to pk
        byte[] entBytes = MnemonicUtils.generateEntropy(mnemonic);
        BigInteger entBigInteger = new BigInteger(entBytes);
        ECKeyPair entEcKeyPair = ECKeyPair.create(entBigInteger);
        return WalletUtils.generateWalletFile(pwd, entEcKeyPair, dir, false);
    }


    public static String signatureMessage2String(String base58PrivateKey, String message) throws SignatureException {
        try {
            // 解码私钥
            byte[] privateKeyBytes = Base58.decode(base58PrivateKey);
            if (privateKeyBytes.length != 64) {
                throw new IllegalArgumentException("私钥长度必须是64字节，当前是 " + privateKeyBytes.length);
            }

            // 取前32字节作为种子
            byte[] seed = new byte[32];
            System.arraycopy(privateKeyBytes, 0, seed, 0, 32);

            // 构造 ed25519 私钥
            EdDSAPrivateKeySpec privateKeySpec = new EdDSAPrivateKeySpec(seed, EdDSANamedCurveTable.getByName("Ed25519"));
            EdDSAPrivateKey privateKey = new EdDSAPrivateKey(privateKeySpec);

            // 签名
            Signature signer = new EdDSAEngine();
            signer.initSign(privateKey);
            signer.update(message.getBytes(StandardCharsets.UTF_8));
            byte[] signature = signer.sign();

            // 返回 base58 编码签名
            return Base58.encode(signature);
        } catch (Exception e) {
            throw new SignatureException("签名失败: " + e.getMessage(), e);
        }
    }
}
package cn.com.vortexa.rpc.api.platform;

import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.common.entity.Web3Wallet;

import java.io.Serializable;
import java.util.List;

/**
 * @author helei
 * @since 2025/4/22 11:38
 */
public interface IWeb3WalletRPC {

    /**
     * 对消息签名
     * 必须使用已注册的钱包，使用钱包id标识签名的钱包
     *
     * @param message message
     * @return Result
     */
    Result signatureMessageRPC(SignatureMessage message);

    /**
     * id批量查
     *
     * @param ids   ids
     * @return  TwitterAccount
     */
    List<Web3Wallet> batchQueryByIdsRPC(List<Serializable> ids);
}
package cn.com.vortexa.bot_platform.controller;

import cn.com.vortexa.bot_platform.service.IScriptNodeService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.control.RegisteredScriptNode;
import cn.hutool.core.util.StrUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.io.IOException;
import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@RestController
@RequestMapping("/script-node")
public class ScriptNodeController {

    @Autowired
    private IScriptNodeService scriptNodeService;

    @PostMapping("/remote-config/{nodeId}")
    public Result remoteConfig(@PathVariable("nodeId") String nodeId) {
        String configStr = null;
        try {
            configStr = scriptNodeService.loadScriptNodeConfig(nodeId);
            if (StrUtil.isBlank(configStr)) {
                return Result.fail(nodeId + " config is empty");
            }
            return Result.ok(configStr);
        } catch (IOException e) {
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @PostMapping("/remote-config")
    public Result botRemoteConfig(
        @RequestParam("nodeId") String nodeId,
        @RequestParam("botKey") String botKey
    ) {
        String configStr = null;
        try {
            configStr = scriptNodeService.loadScriptNodeBotConfig(nodeId, botKey);
            if (StrUtil.isBlank(configStr)) {
                return Result.fail(" config is empty");
            }
            return Result.ok(configStr);
        } catch (IOException e) {
            return Result.fail(e.getCause() == null ? e.getMessage() : e.getCause().getMessage());
        }
    }

    @PostMapping("/all")
    public Result queryAllScriptNode() {
        List<RegisteredScriptNode> list = scriptNodeService.queryAllScriptNode();
        return Result.ok(list);
    }
}
package cn.com.vortexa.bot_platform.controller;

import cn.com.vortexa.bot_platform.service.IWeb3WalletService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@RestController
@RequestMapping("/web3")
public class Web3WalletController {
    @Autowired
    public IWeb3WalletService web3WalletService;

    @PostMapping("/signature")
    public Result signatureWalletMessage(SignatureMessage message) {
        return Result.ok(web3WalletService.signatureMessage(message));
    }
}
package cn.com.vortexa.bot_platform.mapper;


import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.db_layer.mapper.IBaseMapper;


/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
public interface Web3WalletMapper extends IBaseMapper<Web3Wallet> {

}
package cn.com.vortexa.bot_platform.script_control.config;


import cn.com.vortexa.rpc.api.platform.*;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author helei
 * @since 2025-03-22
 */
@Configuration
public class ExposeRPCMethodConfig {

    @Bean
    @ConditionalOnBean(IAccountBaseInfoRPC.class)
    public RPCServiceInfo<IAccountBaseInfoRPC> accountBaseInfoRPCServiceInfo(
            IAccountBaseInfoRPC accountBaseInfoRPC
    ) {
        return RPCServiceInfo
                .<IAccountBaseInfoRPC>builder()
                .interfaces(IAccountBaseInfoRPC.class)
                .ref(accountBaseInfoRPC)
                .build();
    }

    @Bean
    @ConditionalOnBean(IBotInfoRPC.class)
    public RPCServiceInfo<IBotInfoRPC> botInfoRPCRPCServiceInfo(
            IBotInfoRPC botInfoRPC
    ) {
        return RPCServiceInfo
                .<IBotInfoRPC>builder()
                .interfaces(IBotInfoRPC.class)
                .ref(botInfoRPC)
                .build();
    }

    @Bean
    @ConditionalOnBean(IBotInstanceRPC.class)
    public RPCServiceInfo<IBotInstanceRPC> botInstanceRPCRPCServiceInfo(
            IBotInstanceRPC botInstanceRPC
    ) {
        return RPCServiceInfo
                .<IBotInstanceRPC>builder()
                .interfaces(IBotInstanceRPC.class)
                .ref(botInstanceRPC)
                .build();
    }

    @Bean
    @ConditionalOnBean(IBrowserEnvRPC.class)
    public RPCServiceInfo<IBrowserEnvRPC> browserEnvRPCRPCServiceInfo(
            IBrowserEnvRPC browserEnvRPC
    ) {
        return RPCServiceInfo
                .<IBrowserEnvRPC>builder()
                .interfaces(IBrowserEnvRPC.class)
                .ref(browserEnvRPC)
                .build();
    }

    @Bean
    @ConditionalOnBean(IDiscordAccountRPC.class)
    public RPCServiceInfo<IDiscordAccountRPC> discordAccountRPCRPCServiceInfo(
            IDiscordAccountRPC discordAccountRPC
    ) {
        return RPCServiceInfo
                .<IDiscordAccountRPC>builder()
                .interfaces(IDiscordAccountRPC.class)
                .ref(discordAccountRPC)
                .build();
    }

    @Bean
    @ConditionalOnBean(IProxyInfoRPC.class)
    public RPCServiceInfo<IProxyInfoRPC> proxyInfoRPCRPCServiceInfo(
            IProxyInfoRPC ref
    ) {
        return RPCServiceInfo
                .<IProxyInfoRPC>builder()
                .interfaces(IProxyInfoRPC.class)
                .ref(ref)
                .build();
    }

    @Bean
    @ConditionalOnBean(ITelegramAccountRPC.class)
    public RPCServiceInfo<ITelegramAccountRPC> telegramAccountRPCRPCServiceInfo(
            ITelegramAccountRPC ref
    ) {
        return RPCServiceInfo
                .<ITelegramAccountRPC>builder()
                .interfaces(ITelegramAccountRPC.class)
                .ref(ref)
                .build();
    }

    @Bean
    @ConditionalOnBean(ITwitterAccountRPC.class)
    public RPCServiceInfo<ITwitterAccountRPC> twitterAccountRPCRPCServiceInfo(
            ITwitterAccountRPC ref
    ) {
        return RPCServiceInfo
                .<ITwitterAccountRPC>builder()
                .interfaces(ITwitterAccountRPC.class)
                .ref(ref)
                .build();
    }

    @Bean
    @ConditionalOnBean(IWeb3WalletRPC.class)
    public RPCServiceInfo<IWeb3WalletRPC> web3WalletRPCRPCServiceInfo(IWeb3WalletRPC ref) {
        return  RPCServiceInfo
            .<IWeb3WalletRPC>builder()
            .interfaces(IWeb3WalletRPC.class)
            .ref(ref)
            .build();
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import cn.com.vortexa.bot_platform.script_control.BotPlatformControlServer;
import cn.com.vortexa.common.dto.control.RegisteredScriptNode;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.control.util.ControlServerUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;

import cn.com.vortexa.bot_platform.service.IScriptNodeService;
import cn.com.vortexa.common.entity.ScriptNode;
import cn.com.vortexa.bot_platform.mapper.ScriptNodeMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@Service
public class ScriptNodeServiceImpl extends ServiceImpl<ScriptNodeMapper, ScriptNode> implements IScriptNodeService {

    @Lazy
    @Autowired
    private BotPlatformControlServer botControlServer;

    @Override
    public Boolean insertOrUpdate(ScriptNode scriptNode) {
        return getBaseMapper().insertOrUpdate(scriptNode) > 0;
    }

    @Override
    public List<RegisteredScriptNode> queryAllScriptNode() {
        List<ScriptNode> list = list();
        Set<String> onLines = new HashSet<>(botControlServer.getConnectionService().queryOnlineInstanceKey());
        return list.stream().map(scriptNode -> RegisteredScriptNode.builder()
                .scriptNode(scriptNode)
                .online(onLines.contains(ControlServerUtil.generateServiceInstanceKey(
                        scriptNode.getGroupId(), scriptNode.getServiceId(), scriptNode.getInstanceId()
                )))
                .build()
        ).toList();
    }

    @Override
    public String loadScriptNodeConfig(String nodeId) throws IOException {
        Path dir = Paths.get(FileUtil.getScriptNodeConfigDir(), nodeId);
        if (Files.notExists(dir)) {
            Files.createDirectories(dir);
        }
        Path applicationConfigFile = dir.resolve("application.yaml");
        if (Files.exists(applicationConfigFile)) {
            return Files.readString(applicationConfigFile, StandardCharsets.UTF_8);
        } else {
            return null;
        }
    }

    @Override
    public String loadScriptNodeBotConfig(String nodeId, String botKey) throws IOException {
        Path dir = Paths.get(FileUtil.getScriptNodeConfigDir(), nodeId, botKey);
        if (Files.notExists(dir)) {
            Files.createDirectories(dir);
        }
        Path applicationConfigFile = dir.resolve("bot-instance-config.yaml");
        if (Files.exists(applicationConfigFile)) {
            return Files.readString(applicationConfigFile, StandardCharsets.UTF_8);
        } else {
            return null;
        }
    }
}
package cn.com.vortexa.bot_platform.service.impl;

import static cn.com.vortexa.common.entity.Web3Wallet.PUBLIC_FIELDS;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;

import cn.com.vortexa.bot_platform.mapper.Web3WalletMapper;
import cn.com.vortexa.bot_platform.service.IWeb3WalletService;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.TwitterAccount;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.excel.ExcelReadUtil;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.rpc.api.platform.IWeb3WalletRPC;
import cn.com.vortexa.web3.EthWalletUtil;
import cn.com.vortexa.web3.SolanaWalletUtil;
import cn.com.vortexa.common.constants.ChainType;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.web3.dto.WalletInfo;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.stereotype.Service;

import java.io.File;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
@Slf4j
@Service
public class Web3WalletServiceImpl extends AbstractBaseService<Web3WalletMapper, Web3Wallet> implements IWeb3WalletRPC,IWeb3WalletService {


    @Override
    public Result signatureMessageRPC(SignatureMessage message) {
        return signatureMessage(message);
    }

    @Override
    public List<Web3Wallet> batchQueryByIdsRPC(List<Serializable> ids) {
        return batchQueryByIds(ids);
    }

    @Override
    public List<Web3Wallet> batchQueryByIds(List<Serializable> ids) {
        QueryWrapper<Web3Wallet> queryWrapper = new QueryWrapper<>();
        queryWrapper.select(PUBLIC_FIELDS);
        queryWrapper.in("id", ids);
        return baseMapper.selectList(queryWrapper);
    }

    @Override
    public Result signatureMessage(SignatureMessage signatureMessage) {
        Integer walletId;
        String message;
        if ((walletId = signatureMessage.getWalletId()) == null || walletId < 0 || StrUtil.isBlank(
            message = signatureMessage.getMessage())) {
            return Result.fail("params illegal");
        }

        Web3Wallet web3Wallet = baseMapper.selectOne(new QueryWrapper<>(Web3Wallet.builder().id(walletId).build()));
        if (web3Wallet == null) {
            return Result.fail("wallet %s not exist".formatted(walletId));
        }

        ChainType chainType = signatureMessage.getChainType();
        try {
            String signature = switch (chainType) {
                case ETH -> EthWalletUtil.signatureMessage2String(web3Wallet.getEthPrivateKey(), message);
                case SOL -> SolanaWalletUtil.signatureMessage2String(web3Wallet.getSolPrivateKey(), message);
                case null -> throw  new IllegalArgumentException("chain type[%s] not support".formatted(chainType));
            };
            return Result.ok(signature);
        } catch (Exception e) {
            log.error("{} signature chain[{}] message[{}] fail", walletId, chainType, message, e);
            return Result.fail("signature failed");
        }
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getAppResourceSystemConfigDir() + File.separator + fileBotConfigPath;
        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);
            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("read wallet file[{}] error", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<Web3Wallet> web3Wallets = new ArrayList<>();
        for (Map<String, Object> line : rawLines) {
            String mnemonic = String.valueOf(line.get("mnemonic"));
            Web3Wallet.Web3WalletBuilder builder = Web3Wallet.builder().mnemonic(mnemonic);

            WalletInfo ethWallet = EthWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.ethPrivateKey(ethWallet.getPrivateKey());
            builder.ethAddress(ethWallet.getAddress());

            WalletInfo solWallet = SolanaWalletUtil.generateWalletInfoFromMnemonic(mnemonic);
            builder.solPrivateKey(solWallet.getPrivateKey());
            builder.solAddress(solWallet.getAddress());
        }
        return insertOrUpdateBatch(web3Wallets);
    }
}
package cn.com.vortexa.bot_platform.service;

import cn.com.vortexa.common.dto.control.RegisteredScriptNode;

import com.baomidou.mybatisplus.extension.service.IService;

import cn.com.vortexa.common.entity.ScriptNode;

import java.io.IOException;
import java.util.List;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
public interface IScriptNodeService extends IService<ScriptNode> {

    Boolean insertOrUpdate(ScriptNode scriptNode);

    /**
     * 查询全部
     *
     * @return List<RegisteredScriptNode>
     */
    List<RegisteredScriptNode> queryAllScriptNode();

    /**
     * 加载script node 配置
     *
     * @param nodeId nodeId
     * @return String
     */
    String loadScriptNodeConfig(String nodeId) throws IOException;

    /**
     * 加载script node 下运行的bot配置
     *
     * @param scriptNodeName scriptNodeName
     * @param botKey botKey
     * @return String
     */
    String loadScriptNodeBotConfig(String scriptNodeName, String botKey) throws IOException;
}
package cn.com.vortexa.bot_platform.service;

import com.baomidou.mybatisplus.extension.service.IService;

import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.common.entity.Web3Wallet;
import cn.com.vortexa.db_layer.service.ImportService;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-21
 */
public interface IWeb3WalletService extends IService<Web3Wallet>, ImportService {

    Result signatureMessage(SignatureMessage signatureMessage);
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mapper.Web3WalletMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.Web3Wallet">
        <id column="id" property="id" />
        <result column="mnemonic" property="mnemonic" />

        <result column="eth_private_key" property="ethPrivateKey" />
        <result column="eth_address" property="ethAddress" />

        <result column="sol_private_key" property="solPrivateKey" />
        <result column="sol_address" property="solAddress" />

        <result column="btc_private_key" property="btcPrivateKey" />
        <result column="btc_address" property="btcAddress" />

        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="valid" property="valid" />
    </resultMap>

    <insert id="insertOrUpdate" parameterType="cn.com.vortexa.common.entity.Web3Wallet">
        INSERT INTO t_web3_wallet
        (mnemonic, eth_private_key, eth_address, sol_private_key, sol_address, btc_private_key, btc_address, update_datetime, valid)
        VALUES (#{mnemonic}, #{ethPrivateKey}, #{ethAddress}, #{solPrivateKey}, #{solAddress}, #{btcPrivateKey}, #{btcAddress}, current_timestamp, 1)
        ON DUPLICATE KEY
        UPDATE
        <trim suffixOverrides=",">
            <if test="ethPrivateKey != null">
                eth_private_key = values(eth_private_key),
            </if>
            <if test="ethAddress != null">
                eth_address = values(eth_address),
            </if>
            <if test="solPrivateKey != null">
                sol_private_key = values(sol_private_key),
            </if>
            <if test="solAddress != null">
                sol_address = values(sol_address),
            </if>
            <if test="btcPrivateKey != null">
                btc_private_key = values(btc_private_key),
            </if>
            <if test="btcAddress != null">
                btc_address = values(btc_address),
            </if>
            <if test="updateDatetime != null">
                update_datetime = values(update_datetime),
            </if>
            <if test="valid != null">
                valid = values(valid),
            </if>
        </trim>
    </insert>

    <insert id="insertOrUpdateBatch" parameterType="java.util.List">
        INSERT INTO t_twitter_account
        (mnemonic, eth_private_key, eth_address, sol_private_key, sol_address, btc_private_key, btc_address, update_datetime, valid)
        VALUES
        <foreach collection="list" item="item" separator=",">
            (#{mnemonic}, #{ethPrivateKey}, #{ethAddress}, #{solPrivateKey}, #{solAddress}, #{btcPrivateKey}, #{btcAddress}, current_timestamp, 1)
        </foreach>
        ON DUPLICATE KEY UPDATE
        eth_private_key = values (eth_private_key),
        eth_address =values (eth_address),
        sol_private_key = values (sol_private_key),
        sol_address =values (sol_address),
        btc_private_key = values (btc_private_key),
        btc_address = values (btc_address),
        update_datetime =values (update_datetime),
        valid =values (valid)
    </insert>

    <select id="multipleConditionQuery"
            parameterType="cn.com.vortexa.common.entity.Web3Wallet"
            resultType="cn.com.vortexa.common.entity.Web3Wallet">
        select
        t.id,
        t.mnemonic,
        t.eth_private_key as ethPrivateKey,
        t.eth_address as ethAddress,
        t.sol_private_key as solPrivateKey,
        t.sol_address as solAddress,
        t.btc_private_key as btcPrivateKey,
        t.btc_address as btcAddress,
        t.insert_datetime as insertDatetime,
        t.update_datetime as updateDatetime,
        t.valid as valid
        from
        t_twitter_account as t
        <where>
            valid = 1
            <if test="id != null">
                and t.id = #{id}
            </if>
            <if test="mnemonic != null">
                and t.mnemonic = #{mnemonic}
            </if>
            <if test="ethPrivateKey != null">
                and t.eth_private_key = #{ethPrivateKey}
            </if>
            <if test="ethAddress != null">
                and t.eth_address = #{ethAddress}
            </if>
            <if test="solPrivateKey != null">
                and t.sol_private_key = #{solPrivateKey}
            </if>
            <if test="solAddress != null">
                and t.sol_address = #{solAddress}
            </if>
            <if test="btcPrivateKey != null">
                and t.btc_private_key = #{btcPrivateKey}
            </if>
            <if test="btcAddress != null">
                and t.btc_address = #{btcAddress}
            </if>
        </where>
    </select>
</mapper>
CREATE TABLE `t_web3_wallet`
(
    `id`              bigint NOT NULL AUTO_INCREMENT,
    `mnemonic`        varchar(520)                                                  DEFAULT NULL,
    `eth_private_key` varchar(520) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
    `eth_address`     varchar(520)                                                  DEFAULT NULL,
    `sol_address`     varchar(520)                                                  DEFAULT NULL,
    `sol_private_key` varchar(520) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
    `btc_address`     varchar(520)                                                  DEFAULT NULL,
    `insert_datetime` datetime                                                      DEFAULT CURRENT_TIMESTAMP,
    `update_datetime` datetime                                                      DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    `valid`           tinyint(1) DEFAULT '1',
    `btc_private_key` varchar(520) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci DEFAULT NULL,
    PRIMARY KEY (`id`),
    UNIQUE KEY `mnemonic` (`mnemonic`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;

package cn.com.vortexa.script_node.bot;

import cn.com.vortexa.common.constants.ChainType;
import cn.com.vortexa.common.dto.web3.SignatureMessage;
import cn.com.vortexa.script_node.util.persistence.AccountPersistenceManager;
import cn.com.vortexa.script_node.util.persistence.impl.DBAccountPersistenceManager;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.web3.exception.SignatureException;
import cn.hutool.core.util.BooleanUtil;

import com.alibaba.fastjson.JSONArray;

import cn.hutool.core.util.StrUtil;
import lombok.Getter;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static cn.com.vortexa.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;

public abstract class AccountManageAutoBot extends AbstractAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();

    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    @Getter
    private final Map<Integer, List<AccountContext>> acMap = new HashMap<>();

    @Getter
    private final List<AccountContext> uniqueACList = new ArrayList<>();

    /**
     * 持久化管理器
     */
    @Getter
    private AccountPersistenceManager persistenceManager;

    @Override
    protected void doInit() throws BotInitException {
        // Step 1 初始化保存的线程
        this.persistenceManager = new DBAccountPersistenceManager(getBotApi(), getExecutorService());

        this.persistenceManager.init();

        // Step 2 初始化账户
        this.initAccounts();

        acMap.putAll(
                getAccountContexts()
                        .stream()
                        .collect(Collectors.groupingBy(ac ->
                                ac.getAccountBaseInfoId() == null ? -1 : ac.getAccountBaseInfoId())
                        )
        );

        uniqueACList.addAll(acMap.values().stream().map(List::getFirst).toList());
    }

    @Override
    protected void doStop() {
        accountContexts.clear();
        acMap.clear();
        uniqueACList.clear();
        jobCCSemaphoreMap.clear();
    }

    /**
     * 注册账户
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> registerAccount();

    /**
     * 登录并获取token
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> loginAndTakeTokenAccount();

    /**
     * 更新账户奖励信息
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> updateAccountRewordInfo();

    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> botJobNameList();

    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }

    protected CompletableFuture<ACListOptResult> uniqueAsyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {

        return asyncForACList(
                new ArrayList<>(uniqueACList),
                accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    protected CompletableFuture<ACListOptResult> uniqueSyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {

        return syncForACList(
                new ArrayList<>(uniqueACList),
                accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    /**
     * 遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> syncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return syncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 同步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> syncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return CompletableFuture.supplyAsync(() -> {
            List<BotACJobResult> results = new ArrayList<>();
            int successCount = 0;

            for (AccountContext accountContext : new HashSet<>(accountContexts)) {
                if (checkAccountContainsParams(accountContext)) {
                    BotACJobResult botACJobResult = new BotACJobResult(
                            getBotInstance().getBotId(),
                            getBotInstance().getBotName(),
                            jobName,
                            accountContext.getId()
                    );

                    CompletableFuture<Result> future = buildResultFuture.apply(accountContext);

                    try {
                        Result result = future.get();
                        if (result.getSuccess()) {
                            successCount++;
                        }
                        botACJobResult = resultHandler.apply(accountContext, botACJobResult.setResult(result));
                        results.add(botACJobResult);
                    } catch (InterruptedException | ExecutionException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

            return ACListOptResult.builder()
                    .botId(getBotInstance().getBotId())
                    .botName(getBotInstance().getBotName())
                    .jobName(jobName)
                    .successCount(successCount)
                    .success(true)
                    .results(results)
                    .build();
        }, getExecutorService());
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> asyncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .filter(this::checkAccountContainsParams)
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult = new BotACJobResult(
                            getBotInstance().getBotId(),
                            getBotInstance().getBotKey(),
                            jobName,
                            accountContext.getId()
                    );
                    CompletableFuture<Result> future;

                    try {
                        future = buildResultFuture.apply(accountContext);
                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        botACJobResult.setErrorMsg(e.getMessage());
                        return CompletableFuture.completedFuture(botACJobResult);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) {
                                success++;
                            }

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            logger.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInstance().getBotId(),
                                            getBotInstance().getBotKey(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInstance().getBotId())
                            .botName(getBotInstance().getBotKey())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 检查账户是否含有指定参数
     *
     * @param accountContext accountContext
     * @return boolean
     */
    protected boolean checkAccountContainsParams(AccountContext accountContext) {
        // 过滤掉没有账户需要参数的
        Object o = getBotInstance().getParams().get(ACCOUNT_PARAMS_KEY);
        // 使用的json序列化进db，反序列化得到的是JsonArray
        if (o instanceof JSONArray jsonArray) {
            for (Object obj : jsonArray) {
                String key = (String) obj;
                if (accountContext.getParam(key) == null) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 初始化账号方法
     */
    public void initAccounts() throws BotInitException {
        Integer botId = getBotInstance().getBotId();

        try {
            this.accountContexts.clear();

            logger.info("start load account data");
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                    .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                logger.warn("no account data...");
            } else {
                logger.info("use history account, total:" + accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new BotInitException("init account info error", e);
        }
    }

    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }

    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }

    /**
     * 账户消息签名
     * <p>账户的钱包是不包含私钥的，签名需通过script-node发送RPC请求</p>
     *
     * @param accountContext    accountContext
     * @param message   String
     * @return  String
     */
    public String signatureAccountMessage(
        AccountContext accountContext,
        ChainType chainType,
        String message
    ) throws SignatureException {
        if (accountContext.getWalletId() == null) {
            throw new SignatureException("account didn't have bind wallet");
        }
        if (StrUtil.isBlank(message)) {
            throw new SignatureException("signature message is empty");
        }

        try {
            Result result = getBotApi().getWeb3WalletRPC().signatureMessageRPC(
                new SignatureMessage(accountContext.getWalletId(), chainType, message)
            );
            if (result.getSuccess()) {
                return String.valueOf(result.getData());
            } else {
                throw new SignatureException("signature fail, " + result.getErrorMsg());
            }
        } catch (Exception e) {
            throw new SignatureException("signature fail", e);
        }
    }
}
package cn.com.vortexa.script_node.config;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.config.AutoBotAccountConfig;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.com.vortexa.script_node.constants.ScriptNodeConstants;
import cn.com.vortexa.common.dto.BotMetaInfo;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Stream;

/**
 * @author helei
 * @since 2025-04-04
 */
@Slf4j
@Data
@Component
@ConfigurationProperties(prefix = "vortexa.script-node")
public class ScriptNodeConfiguration implements InitializingBean {

    public static final String BOT_META_INF_FILE_NAME = "bot-meta-info.yaml";
    public static final List<String> BOT_META_INFO_PREFIX = List.of("vortexa", "botMetaInfo");
    public static final List<String> BOT_INSTANCE_CONFIG_PREFIX = List.of("vortexa", "botInstance");

    /**
     * bot group（Script Node中运行的bot的group)
     * ）
     */
    private String scriptNodeName;

    /**
     * 远程配置获取的url
     */
    private String remoteConfigUrl;

    /**
     * bot-instance jar包名字
     */
    private List<String> botInstanceJarNames;

    /**
     * Script node 基础路径
     */
    private String scriptNodeBasePath;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;

    /**
     * botNameMetaInfoMap, （解析配置文件自动填入）
     */
    private Map<String, BotMetaInfo> botNameMetaInfoMap;

    /**
     * botKeyConfigMap, （解析配置文件自动填入）
     */
    private Map<String, AutoBotConfig> botKeyConfigMap;

    /**
     * 自动时自动启动的botKey
     */
    private Set<String> autoLaunchBotKeys;

    /**
     * bot公共配置，会加载到每个bot的 customConfig下
     *
     * @see AutoBotConfig
     */
    private Map<String, Object> botCommonConfig;

    @Override
    public void afterPropertiesSet() throws Exception {
        String nodeId = System.getProperty(ScriptNodeConstants.NODE_ID_KEH);
        scriptNodeName = StrUtil.isBlank(nodeId) ? scriptNodeName : nodeId;

        String remoteConfigUrl = System.getProperty(ScriptNodeConstants.NODE_ID_KEH);
        this.remoteConfigUrl = StrUtil.isBlank(remoteConfigUrl) ? this.remoteConfigUrl : remoteConfigUrl;

        // 解析地址，
        scriptNodeBasePath = FileUtil.getAppResourceAppConfigDir() + File.separator + scriptNodeName;

        initBotMetaInfo();

        initBotInstance();
    }

    /**
     * 初始化BotInstance
     */
    private void initBotInstance() {
        botKeyConfigMap = new HashMap<>();
        String botInstanceConfigDir = FileUtil.getBotInstanceConfigDir();

        try (Stream<Path> walk = Files.walk(Paths.get(botInstanceConfigDir), 1)) {
            walk.filter(p->Files.isRegularFile(p) && p.toString().endsWith(".yaml")).forEach(configFile -> {
                try {
                    AutoBotConfig botConfig = YamlConfigLoadUtil.load(configFile.toFile(), BOT_INSTANCE_CONFIG_PREFIX, AutoBotConfig.class);

                    // 配置文件校验
                    if (botConfig == null) {
                        throw new IllegalArgumentException("bot instance config file [" + configFile.getFileName() + "] illegal");
                    }

                    // 相对路径转绝对路径
                    reactivePathConfigConvert(
                        botConfig,
                        botNameMetaInfoMap.get(botConfig.getBotName()).getResourceDir()
                    );

                    // 合并bot公共配置
                    if (botCommonConfig != null) {
                        botConfig.setCustomConfig(botCommonConfig);
                    }

                    // 合并远程配置
                    AutoBotConfig remoteBotConfig = fetchRemoteBotConfig(
                        remoteConfigUrl,
                        scriptNodeName,
                        botConfig.getBotKey()
                    );
                    if (remoteBotConfig != null) {
                        mergeRemoteAutoBotConfig(botConfig, remoteBotConfig);
                    }

                    botKeyConfigMap.put(botConfig.getBotKey(), botConfig);
                } catch (Exception e) {
                  log.error("bot instance config[{}] load error", configFile.getFileName(), e);
                }
            });
        } catch (IOException e) {
            log.error("load bot instance config error", e);
        }
    }

    /**
     * 初始化bot原信息
     *
     * @throws IOException IOException
     */
    private void initBotMetaInfo() throws IOException {
        botNameMetaInfoMap = new HashMap<>();
        if (CollUtil.isNotEmpty(botInstanceJarNames)) {
            for (String botInstanceJarName : botInstanceJarNames) {
                String jarLibraryPath = FileUtil.getLibraryPath(botInstanceJarName);
                String jarFilePath = FileUtil.getJarFilePath(botInstanceJarName);
                FileUtil.extractJar(
                    jarLibraryPath,
                    jarFilePath
                );

                // 解析文件夹
                log.info("start resolve bot meta info config from dir[{}]", jarFilePath);
                try (Stream<Path> walk = Files.walk(Paths.get(jarFilePath), 3)) {
                    walk.filter(Files::isDirectory).forEach(dir -> {
                        Path configFilePath = dir.resolve(BOT_META_INF_FILE_NAME);
                        if (Files.exists(configFilePath)) {
                            BotMetaInfo metaInfo = YamlConfigLoadUtil.load(configFilePath.toFile(),
                                BOT_META_INFO_PREFIX, BotMetaInfo.class);

                            // 配置文件校验
                            if (metaInfo == null) {
                                throw new IllegalArgumentException(
                                    "bot meta info file [" + BOT_META_INF_FILE_NAME + "] illegal");
                            }

                            // 设置bot资源目录
                            metaInfo.setResourceDir(dir.toString());
                            // 设置所在jar包路径
                            metaInfo.setClassJarPath(jarLibraryPath);

                            botNameMetaInfoMap.put(metaInfo.getBotName(), metaInfo);
                            log.info("botName [{}] meta info loaded", metaInfo.getBotName());
                        }
                    });
                }
            }
        }
    }

    /**
     * 获取远程配置
     *
     * @param configUrl configUrl
     * @param nodeId nodeId
     * @param botKey botKey
     * @return String
     */
    private AutoBotConfig fetchRemoteBotConfig(String configUrl, String nodeId, String botKey) {
        if (StrUtil.isBlank(configUrl)) return null;

        try {
            JSONObject params = new JSONObject();
            params.put("nodeId", nodeId);
            params.put("botKey", botKey);
            String response = RestApiClientFactory.getClient().request(
                configUrl,
                HttpMethod.POST,
                new HashMap<>(),
                params,
                null
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                AutoBotConfig load = YamlConfigLoadUtil.load(String.valueOf(result.getData()),
                    BOT_META_INFO_PREFIX, AutoBotConfig.class);
                log.info("remote config fetch success, merge into [{}] bot config...", botKey);
                return load;
            } else {
                log.warn("script node[{}] botKey[{}] config not found in remote", nodeId, botKey);
                return null;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("script node[{}] botKey[{}] remote fetch error", nodeId, botKey, e);
            return null;
        }
    }

    /**
     * 合并远程配置
     *
     * @param local local
     * @param remote remote
     */
    private void mergeRemoteAutoBotConfig(AutoBotConfig local, AutoBotConfig remote) {
        if (remote.getAccountConfig() != null) {
            local.setAccountConfig(remote.getAccountConfig());
        }
        if (remote.getCustomConfig() != null) {
            local.setCustomConfig(remote.getCustomConfig());
        }
    }

    /**
     * 相对路径转换
     *
     * @param config config
     * @param botResourcePath botResourcePath
     */
    private void reactivePathConfigConvert(AutoBotConfig config, String botResourcePath) {
        AutoBotAccountConfig accountConfig = config.getAccountConfig();
        accountConfig.setConfigFilePath(
            FileUtil.generateAbsPath(accountConfig.getConfigFilePath(), botResourcePath)
        );

        Map<String, Object> customConfig = config.getCustomConfig();
        if (customConfig != null && !customConfig.isEmpty()) {
            for (Map.Entry<String, Object> entry : customConfig.entrySet()) {
                Object value = entry.getValue();
                if (value instanceof String) {
                    entry.setValue(FileUtil.generateAbsPath((String) value, botResourcePath));
                }
            }
        }
    }
}
