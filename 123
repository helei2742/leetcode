package cn.com.vortexa.example.optimai;

import cn.com.vortexa.bot_father.anno.BotMethod;
import cn.com.vortexa.bot_father.anno.BotWSMethodConfig;
import cn.com.vortexa.bot_father.bot.AutoLaunchBot;
import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.bot_father.service.BotApi;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.AccountContext;

import java.util.List;

/**
 * @author h30069248
 * @since 2025/3/24 17:14
 */
public class OptimAIBot extends AutoLaunchBot<OptimAIBot> {

    private static final String WS_CONNECT_URL = "wss://ws.optimai.network";

    private final int WS_RECONNECT_INTERVAL_SECOND = 60 * 60 * 24;

    private OptimAIAPI optimAIAPI;

    @Override
    protected void botInitialized(AutoBotConfig botConfig, BotApi botApi) {
        this.optimAIAPI = new OptimAIAPI(this);
    }

    @Override
    protected OptimAIBot getInstance() {
        return this;
    }

    @BotMethod(
        jobType = BotJobType.REGISTER
    )
    public Result registry(AccountContext uniAC, List<AccountContext> sameIdACList, String inviteCode) {
        return optimAIAPI.registry(uniAC, inviteCode);
    }

    @BotMethod(
        jobType = BotJobType.WEB_SOCKET_CONNECT,
        intervalInSecond = WS_RECONNECT_INTERVAL_SECOND,
        bowWsConfig = @BotWSMethodConfig(
            isRefreshWSConnection = true,
            reconnectLimit = 4,
            heartBeatIntervalSecond = 15 * 60,
            nioEventLoopGroupThreads = 2,
            wsConnectCount = 20
        )
    )
    public OptimAIWSClient buildKeepAliveWSClient(AccountContext accountContext) {
        OptimAIWSClient client = new OptimAIWSClient(accountContext, WS_CONNECT_URL);
        client.set
        return client;
    }
}
package cn.com.vortexa.example.stork_bot;

import cn.com.vortexa.bot_father.BotLauncher;
import cn.com.vortexa.bot_father.anno.BotApplication;
import cn.com.vortexa.bot_father.anno.BotMethod;
import cn.com.vortexa.bot_father.bot.AutoLaunchBot;
import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.bot_father.service.BotApi;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStartException;

import java.util.ArrayList;
import java.util.List;

import static cn.com.vortexa.example.stork_bot.StorkBotAPI.PASSWORD_KEY;

@BotApplication(name = "stork_bot", accountParams = PASSWORD_KEY)
public class StorkBot extends AutoLaunchBot<StorkBot> {


    private StorkBotAPI storkBotAPI;

    @Override
    protected void botInitialized(AutoBotConfig botConfig, BotApi botApi) {
        storkBotAPI = new StorkBotAPI(this);
    }

    @Override
    protected StorkBot getInstance() {
        return this;
    }

    @BotMethod(jobType = BotJobType.REGISTER)
    public Result signUp(AccountContext exampleAC, List<AccountContext> sameABIList, String inviteCode) {
        return storkBotAPI.signup(exampleAC, sameABIList, inviteCode);
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 60 * 20)
    public void tokenRefresh(AccountContext accountContext) {
        storkBotAPI.refreshToken(accountContext);
    }

    @BotMethod(jobType = BotJobType.TIMED_TASK, intervalInSecond = 60 * 5)
    public void keepAlive(AccountContext accountContext) {
        storkBotAPI.keepAlive(accountContext);
    }

    public static void main(String[] args) throws BotStartException, BotInitException {
        List<String> list = new ArrayList<>(List.of(args));

        list.add("--vortexa.botKey=stork_test");
        list.add("--vortexa.customConfig.invite_code=WSJQRJD5CB");
        list.add("--vortexa.accountConfig.configFilePath=stork_google.xlsx");
        list.add("--add-opens java.base/java.lang=ALL-UNNAMED");

        BotLauncher.launch(StorkBot.class, list.toArray(new String[0]));
    }

}
spring:
  datasource:
    quartz:
      url: jdbc:mysql://localhost:3306/job_store
      username: root
      password: 123456
      driver-class-name: com.mysql.cj.jdbc.Driver
      type: com.zaxxer.hikari.HikariDataSource

  quartz:
    job-store-type: jdbc
    jdbc:
      table-prefix: QRTZ_
      driver-class: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/job_store
      user: root
      password: 123456
      scheduler:
        instance-name: QuartzScheduler

vortexa:
  botKey: stork_test

  script-agent:
    registryCenterUrl: ws://localhost:18848
    nio-thread-count: 1
    service-offline-ttl: 60
    service-instance:
      host: localhost
      port: 20001
package cn.com.vortexa.bot_father.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface BotWSMethodConfig {
    /**
     * 是否刷新ws连
     *
     * @return boolean
     */
    boolean isRefreshWSConnection() default false;


    boolean wsUnlimitedRetry() default false;

    /**
     * 重连次数
     */
    int reconnectLimit() default 3;

    /**
     * 心跳间隔
     */
    int heartBeatIntervalSecond() default  30;

    /**
     * nio 线程数
     */
    int nioEventLoopGroupThreads() default 1;

    /**
     * websocket 并发数量
     */
    int wsConnectCount() default 50;

    /**
     * 重连减少的间隔
     */
    int reconnectCountDownSecond() default 180;
}
package cn.com.vortexa.bot_father.bot;

import static cn.com.vortexa.bot_father.service.impl.BotAccountContextServiceImpl.BOT_ACCOUNT_CONTEXT_TABLE_PREFIX;
import static cn.com.vortexa.common.entity.BotInfo.BASIC_JOB_LIST_KEY;

import cn.com.vortexa.bot_father.service.BotApi;
import cn.com.vortexa.bot_father.constants.BotStatus;
import cn.com.vortexa.common.config.SystemConfig;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.bot_father.util.log.AppendLogger;
import cn.com.vortexa.common.dto.AutoBotRuntimeInfo;
import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStatusException;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.hutool.core.util.RandomUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;

import lombok.Getter;
import lombok.Setter;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;
import java.util.function.Supplier;

public abstract class AbstractAutoBot {

    private static final ProxyInfo DEFAULT_PROXY = new ProxyInfo();

    public final AppendLogger logger = new AppendLogger(getClass());

    /**
     * 代理并发控制
     */
    private final Map<ProxyInfo, Semaphore> networkSyncControllerMap;

    /**
     * bot api
     */
    @Getter
    private BotApi botApi;

    /**
     * bot运行时信息
     */
    @Getter
    private final AutoBotRuntimeInfo autoBotRuntimeInfo;

    /**
     * 请求并发数量
     */
    @Getter
    @Setter
    private int requestConcurrentCount = 5;

    /**
     * bot信息
     */
    @Getter
    private BotInfo botInfo;

    @Getter
    private BotInstance botInstance;

    /**
     * 配置
     */
    @Getter
    private AutoBotConfig autoBotConfig;

    /**
     * 执行异步任务的线程池
     */
    @Getter
    private ExecutorService executorService;

    /**
     * 状态
     */
    @Getter
    private BotStatus status = BotStatus.NEW;

    public AbstractAutoBot() {
        this.networkSyncControllerMap = new ConcurrentHashMap<>();
        this.autoBotRuntimeInfo = new AutoBotRuntimeInfo();
    }

    /**
     * 初始化方法
     *
     * @param autoBotConfig autoBotConfig
     * @throws BotInitException BotInitException
     */
    public final void init(BotApi botApi, AutoBotConfig autoBotConfig) throws BotInitException {
        this.botApi = botApi;

        // Step 1 参数校验
        if (StrUtil.isBlank(autoBotConfig.getBotKey())) {
            throw new IllegalArgumentException("bot key is empty!");
        }

        // Step 2 进入INIT状态，获取参数
        updateState(BotStatus.INIT);
        this.autoBotConfig = autoBotConfig;
        try {
            // Step 2.1 获取BotInfo,解析Bot Job
            botInfo = buildBotInfo();
            resolveBotJobMethod();
        } catch (Exception e) {
            throw new BotInitException("resolve bot job error", e);
        }

        // Step 2.2 保存bot info
        try {
            if (botApi.getBotInfoRPC().insertOrUpdateRPC(botInfo) == 1) {
                Map<String, Object> query = new HashMap<>();
                query.put("name", botInfo.getName());
                // 保存成还需查询botId
                Integer id = botApi.getBotInfoRPC().conditionQueryRPC(query).getFirst().getId();
                botInfo.setId(id);
                AutoBotConfig.BOT_ID = id;
                logger.info("save bot info success, id:" + botInfo.getId());
            }
        } catch (SQLException e) {
            throw new BotInitException("save bot info error", e);
        }

        this.botInstance = BotInstance.builder()
            .botId(botInfo.getId())
            .botName(botInfo.getName())
            .botKey(autoBotConfig.getBotKey())
            .build();

        // Step 2.3 设置logger前缀与线程池
        String botName = runtimeBotName();
        logger.append(botName);
        this.executorService = Executors.newThreadPerTaskExecutor(
            new NamedThreadFactory(botInfo.getName() + "-executor"));

        try {
            // Step 2.4 初始化存储的Table
            logger.info("start init database table");
            // 检查对应分表是否存在
            if (!botApi.getBotAccountService()
                .checkAndCreateShardedTable(botInfo.getId(), getAutoBotConfig().getBotKey(), true)) {
                throw new RuntimeException("bot account table create error");
            }
            logger.info("database table init finish");

            // Step 2.5 初始化BotInstance实例
            logger.info("start init bot instance");

            BotInstance dbInstance = getBotApi().getBotInstanceRPC().selectOneRPC(botInstance);

            // 数据库存在bot instance实例信息，用数据库的。 否则用BotInfo信息生成BotInstance信息写入库
            if (dbInstance != null) {
                this.botInstance = dbInstance;
                logger.info("exist botInstance, use exist instance config");
            } else {
                logger.info("no instance, create it...");

                String tableName = getBotApi().getTableShardStrategy().generateTableName(
                    BOT_ACCOUNT_CONTEXT_TABLE_PREFIX,
                    new Object[] {botInstance.getBotId(), botInstance.getBotKey()}
                );
                botInstance.setBotName(botInfo.getName());
                botInstance.setAccountTableName(tableName);
                botInstance.setJobParams(botInfo.getJobParams());
                botInstance.setParams(botInfo.getParams());

                if (botApi.getBotInstanceRPC().insertOrUpdateRPC(botInstance) > 0) {
                    logger.info("new bot instance create success");
                } else {
                    throw new BotInitException("new bot instance create error");
                }
            }

            // Step 2.5 子类初始化
            doInit();

            // Step 2。6 更新状态
            updateState(BotStatus.INIT_FINISH);
        } catch (Exception e) {
            logger.error("init error", e);
            updateState(BotStatus.INIT_ERROR);
        }
    }

    /**
     * 初始化方法
     */
    protected abstract void doInit() throws BotInitException;

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body
    ) {
        return syncRequest(proxy, url, method, headers, params, body, 1);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<String> response str
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        int retryTimes
    ) {
        return syncRequest(proxy, url, method, headers, params, body, null, retryTimes);
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart
    ) {
        return syncRequest(
            proxy,
            url,
            method,
            headers,
            params,
            body,
            requestStart,
            1
        );
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<String> syncRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart,
        int retryTimes
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).request(
                    url,
                    method,
                    headers,
                    params,
                    body,
                    retryTimes
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    /**
     * 同步请求，使用syncController控制并发
     *
     * @param proxy proxy
     * @param url url
     * @param method method
     * @param headers headers
     * @param params params
     * @param body body
     * @return CompletableFuture<Response> String
     */
    public CompletableFuture<List<String>> syncStreamRequest(
        ProxyInfo proxy,
        String url,
        HttpMethod method,
        Map<String, String> headers,
        JSONObject params,
        JSONObject body,
        Supplier<String> requestStart
    ) {
        return syncCCHandler(proxy, requestStart, () -> {
            try {
                return RestApiClientFactory.getClient(proxy).streamRequest(
                    url,
                    method,
                    headers,
                    params,
                    body
                ).get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        });
    }

    public <R> CompletableFuture<R> syncCCHandler(
        ProxyInfo proxy,
        Supplier<String> requestStart,
        Supplier<R> request
    ) {

        Semaphore networkController = networkSyncControllerMap
            .compute(proxy == null ? DEFAULT_PROXY : proxy, (k, v) -> {
                if (v == null) {
                    v = new Semaphore(requestConcurrentCount);
                }
                return v;
            });

        return CompletableFuture.supplyAsync(() -> {
            try {
                networkController.acquire();
                // 随机延迟
                TimeUnit.MILLISECONDS.sleep(RandomUtil.randomLong(1000, 3000));

                String str = "start network request";
                if (requestStart != null) {
                    str = requestStart.get();
                }
                logger.info("同步器允许发送请求 - " + str);

                return request.get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                networkController.release();
            }
        }, executorService);
    }

    /**
     * 打印BotRuntimeInfo
     *
     * @return string
     */
    public String printBotRuntimeInfo() {
        StringBuilder sb = new StringBuilder();
        getAutoBotRuntimeInfo().getKeyValueInfoMap().forEach((k, v) -> {
            sb.append(k).append(": ").append(v).append("\n");
        });
        return sb.toString();
    }

    /**
     * 获取app的配置目录
     *
     * @return String
     */
    public String getAppConfigDir() {
        return FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, getBotInstance().getBotKey());
    }

    /**
     * 更新BotStatus
     *
     * @param newStatus 新状态
     */
    public synchronized void updateState(BotStatus newStatus) throws BotStatusException {
        boolean b = true;
        if (newStatus.equals(BotStatus.SHUTDOWN)) {
            status = BotStatus.SHUTDOWN;
            b = false;
        } else {
            b = switch (status) {
                //当前为NEW，新状态才能为NEW,SHUTDOWN
                case NEW -> BotStatus.INIT.equals(newStatus);
                //当前为INIT，新状态只能为INIT_FINISH、INIT_ERROR,SHUTDOWN
                case INIT -> newStatus.equals(BotStatus.INIT_FINISH)
                    || newStatus.equals(BotStatus.INIT_ERROR);
                //当前为INIT_ERROR,新状态只能为ACCOUNT_LOADING, SHUTDOWN
                case INIT_ERROR -> newStatus.equals(BotStatus.INIT);
                //当前状态为INIT_FINISH，新状态只能为ACCOUNT_LIST_CONNECT, SHUTDOWN
                case INIT_FINISH -> newStatus.equals(BotStatus.STARTING);
                //当前状态为STARING，新状态只能为RUNNING,SHUTDOWN
                case STARTING -> newStatus.equals(BotStatus.RUNNING);
                //RUNNING，新状态只能为 SHUTDOWN
                case RUNNING -> false;
                case SHUTDOWN -> false;
            };
        }

        if (b) {
            logger.info("Status change [%s] => [%s]".formatted(status, newStatus));
            this.status = newStatus;
        } else {
            throw new BotStatusException(
                String.format("%s status can't from[%s] -> to[%s]", runtimeBotName(), status, newStatus));
        }
    }

    public String runtimeBotName() {
        return "Bot[%s]-[%s]".formatted(botInstance.getBotName(), autoBotConfig.getBotKey());
    }

    protected synchronized Map<String, AutoBotJobParam> getJobParams() {
        return this.botInstance.getJobParams();
    }

    protected synchronized AutoBotJobParam getJobParam(String jobName) {
        return this.botInstance.getJobParams() == null ? null : this.botInstance.getJobParams().get(jobName);
    }

    protected synchronized void setJobParam(String jobKey, AutoBotJobParam jobParam) {
        //        if (!this.botInfo.getJobParams().containsKey(jobKey)) {
        this.botInfo.getJobParams().put(jobKey, jobParam);
        //        }
    }

    protected synchronized void addBasicJob(BotJobType jobType) {
        if (this.botInfo.getJobParams() == null) {
            this.botInfo.setParams(new HashMap<>());
        }

        this.botInfo.getParams().compute(BASIC_JOB_LIST_KEY, (k, v) -> {
            if (v == null) {
                v = new HashSet<String>();
            }
            if (v instanceof JSONArray t) {
                v = new HashSet<String>();
                for (int i = 0; i < t.size(); i++) {
                    ((HashSet<String>) v).add(t.getString(i));
                }
            }
            Set<String> set = (HashSet<String>) v;
            set.add(jobType.name());
            return v;
        });
    }

    protected abstract BotInfo buildBotInfo() throws BotInitException;

    protected abstract void resolveBotJobMethod();
}
package cn.com.vortexa.bot_father.bot;

import cn.com.vortexa.bot_father.util.persistence.AccountPersistenceManager;
import cn.com.vortexa.bot_father.util.persistence.impl.DBAccountPersistenceManager;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.exception.BotInitException;
import cn.hutool.core.util.BooleanUtil;

import com.alibaba.fastjson.JSONArray;

import lombok.Getter;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static cn.com.vortexa.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;

public abstract class AccountManageAutoBot extends AbstractAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();

    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    @Getter
    private final Map<Integer, List<AccountContext>> acMap = new HashMap<>();

    @Getter
    private final List<AccountContext> uniqueACList = new ArrayList<>();

    /**
     * 持久化管理器
     */
    @Getter
    private AccountPersistenceManager persistenceManager;

    @Override
    protected void doInit() throws BotInitException {
        // Step 1 初始化保存的线程
        this.persistenceManager = new DBAccountPersistenceManager(getBotApi());

        this.persistenceManager.init();

        // Step 2 初始化账户
        this.initAccounts();

        acMap.putAll(
            getAccountContexts()
                .stream()
                .collect(Collectors.groupingBy(ac ->
                    ac.getAccountBaseInfoId() == null ? -1 : ac.getAccountBaseInfoId())
                )
        );

        uniqueACList.addAll(acMap.values().stream().map(List::getFirst).toList());
    }

    /**
     * 注册账户
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> registerAccount();

    /**
     * 登录并获取token
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> loginAndTakeTokenAccount();

    /**
     * 更新账户奖励信息
     *
     * @return CompletableFuture<Result>
     */
    public abstract CompletableFuture<ACListOptResult> updateAccountRewordInfo();

    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> botJobNameList();

    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }

    public CompletableFuture<ACListOptResult> uniqueAsyncForACList(
        BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {

        return asyncForACList(
            new ArrayList<>(uniqueACList),
            accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
            resultHandler,
            jobName
        );
    }

    public CompletableFuture<ACListOptResult> uniqueSyncForACList(
        BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {

        return syncForACList(
            new ArrayList<>(uniqueACList),
            accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
            resultHandler,
            jobName
        );
    }

    /**
     * 遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> syncForACList(
        Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {
        return syncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
        Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 同步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> syncForACList(
        List<AccountContext> accountContexts,
        Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {
        return CompletableFuture.supplyAsync(() -> {
            List<BotACJobResult> results = new ArrayList<>();
            int successCount = 0;

            for (AccountContext accountContext : new HashSet<>(accountContexts)) {
                if (checkAccountContainsParams(accountContext)) {
                    BotACJobResult botACJobResult = new BotACJobResult(
                        getBotInstance().getBotId(),
                        getBotInstance().getBotName(),
                        jobName,
                        accountContext.getId()
                    );

                    CompletableFuture<Result> future = buildResultFuture.apply(accountContext);

                    try {
                        Result result = future.get();
                        if (result.getSuccess()) {
                            successCount++;
                        }
                        botACJobResult = resultHandler.apply(accountContext, botACJobResult.setResult(result));
                        results.add(botACJobResult);
                    } catch (InterruptedException | ExecutionException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

            return ACListOptResult.builder()
                .botId(getBotInstance().getBotId())
                .botName(getBotInstance().getBotName())
                .jobName(jobName)
                .successCount(successCount)
                .success(true)
                .results(results)
                .build();
        }, getExecutorService());
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    public CompletableFuture<ACListOptResult> asyncForACList(
        List<AccountContext> accountContexts,
        Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
        BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
        String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
            .filter(this::checkAccountContainsParams)
            .map(accountContext -> {
                try {
                    // 获取信号量
                    getCcSemaphore(jobName).acquire();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }

                BotACJobResult botACJobResult = new BotACJobResult(
                    getBotInstance().getBotId(),
                    getBotInstance().getBotKey(),
                    jobName,
                    accountContext.getId()
                );
                CompletableFuture<Result> future;

                try {
                    future = buildResultFuture.apply(accountContext);
                } catch (Exception e) {
                    getCcSemaphore(jobName).release();
                    botACJobResult.setErrorMsg(e.getMessage());
                    return CompletableFuture.completedFuture(botACJobResult);
                }

                return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                    .whenComplete((result, throwable) -> {
                        // 释放信号量
                        getCcSemaphore(jobName).release();
                    });
            }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApplyAsync(unused -> {
                List<BotACJobResult> results = new ArrayList<>();

                int success = 0;
                for (int i = 0; i < futures.size(); i++) {
                    CompletableFuture<BotACJobResult> future = futures.get(i);
                    AccountContext accountContext = accountContexts.get(i);

                    try {
                        BotACJobResult result = future.get();
                        BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                        if (BooleanUtil.isTrue(botACJobResult.getSuccess())) {
                            success++;
                        }

                        results.add(botACJobResult);
                    } catch (InterruptedException | ExecutionException e) {
                        String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                            accountContext.getId(), accountContext.getSimpleInfo());

                        logger.error(errorMsg, e);

                        results.add(
                            new BotACJobResult(
                                getBotInstance().getBotId(),
                                getBotInstance().getBotKey(),
                                jobName,
                                accountContext.getId(),
                                false,
                                errorMsg,
                                null
                            )
                        );
                    }
                }

                return ACListOptResult.builder()
                    .botId(getBotInstance().getBotId())
                    .botName(getBotInstance().getBotKey())
                    .jobName(jobName)
                    .successCount(success)
                    .success(true)
                    .results(results)
                    .build();
            });
    }

    /**
     * 检查账户是否含有指定参数
     *
     * @param accountContext accountContext
     * @return boolean
     */
    private boolean checkAccountContainsParams(AccountContext accountContext) {
        // 过滤掉没有账户需要参数的
        Object o = getBotInstance().getParams().get(ACCOUNT_PARAMS_KEY);
        // 使用的json序列化进db，反序列化得到的是JsonArray
        if (o instanceof JSONArray jsonArray) {
            for (Object obj : jsonArray) {
                String key = (String) obj;
                if (accountContext.getParam(key) == null) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 初始化账号方法
     */
    private void initAccounts() throws BotInitException {
        Integer botId = getBotInstance().getBotId();

        try {
            logger.info("开始加载账户数据");
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                logger.warn("没有账户数据");
            } else {
                logger.info("使用历史账户数据, 共:" + accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new BotInitException("初始化账户发生错误", e);
        }
    }

    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }

    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }

}
package cn.com.vortexa.bot_father.bot;

import cn.com.vortexa.bot_father.anno.BotApplication;
import cn.com.vortexa.bot_father.anno.BotMethod;
import cn.com.vortexa.bot_father.websocket.AccountWSClientBuilder;
import cn.com.vortexa.bot_father.websocket.BaseBotWSClient;
import cn.com.vortexa.bot_father.websocket.WebSocketClientLauncher;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.bot_father.constants.MapConfigKey;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.exception.BotMethodFormatException;
import cn.com.vortexa.common.exception.BotMethodInvokeException;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.bot_father.dto.job.AutoBotJobRuntimeParam;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONArray;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import org.jetbrains.annotations.NotNull;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;

import static cn.com.vortexa.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;
import static cn.com.vortexa.common.entity.BotInfo.CONFIG_PARAMS_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T extends JobInvokeAutoBot> extends JobInvokeAutoBot {

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher = new WebSocketClientLauncher(this);

    /**
     * 注册方法
     */
    @Getter
    private Method registerMethod;

    /**
     * 登录方法
     */
    @Getter
    private Method loginMethod;

    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() throws BotInitException {
        // 解析bot 基本信息
        try {
            BotApplication annotation = getInstance().getClass().getAnnotation(BotApplication.class);

            if (annotation != null) {
                String botName = annotation.name();
                if (StrUtil.isBlank(botName)) {
                    throw new IllegalArgumentException("bot name 不能为空");
                }

                //  解析bot 自定义配置, 看是否有满足的
                AutoBotConfig botConfig = getAutoBotConfig();
                Map<String, Object> customConfig = botConfig.getCustomConfig();
                for (String key : annotation.configParams()) {
                    if (!customConfig.containsKey(key)) {
                        throw new IllegalArgumentException("缺乏Bot必要参数[%s]".formatted(key));
                    }
                }

                BotInfo botInfo = null;

                // 查询是否存在botKey的bot
                Map<String, Object> query = new HashMap<>();
                query.put("name", botName);
                List<BotInfo> dbBotInfoList = getBotApi().getBotInfoRPC().conditionQueryRPC(query);

                // 查询bot是否存在，不存在则创建
                if (dbBotInfoList == null || dbBotInfoList.isEmpty()) {
                    logger.warn("不存在bot info, 自动创建...");
                    botInfo = generateFromAnno(annotation);
                } else {
                    botInfo = dbBotInfoList.getFirst();
                    botInfo.fixMapValueType();
                }
                return botInfo;
            } else {
                throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
            }
        } catch (Exception e) {
            throw new BotInitException(e);
        }
    }

    @Override
    protected void resolveBotJobMethod() {
        // 解析bot job 参数

        // Step 1 遍历方法
        for (Method method : getClass().getDeclaredMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case REGISTER -> registerMethodHandler(method);
                    case LOGIN -> loginMethodHandler(method);
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod);
                    case ONCE_TASK, TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod);
                }
            }
        }
    }

    /**
     * 注册type账号
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> registerAccount() {
        if (registerMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                getBotInstance().getBotId(),
                getBotInstance().getBotName(),
                BotJobType.REGISTER.name(),
                "未找到注册方法"
            ));
        }
        return uniqueAsyncForACList(
            (accountContext, accountContexts) -> {
                if (BooleanUtil.isTrue(accountContext.isSignUp())) {
                    // 账户注册过，
                    String errorMsg = String.format("[%s]账户[%s]-email[%s]注册过", accountContext.getId(),
                        accountContext.getName(),
                        accountContext.getAccountBaseInfo().getEmail());

                    log.warn(errorMsg);

                    return CompletableFuture.completedFuture(Result.fail(errorMsg));
                } else if (registerMethod != null) {
                    // 调用注册方法注册
                    return invokeBotMethod(
                        registerMethod,
                        accountContext,
                        accountContexts,
                        getAutoBotConfig().getConfig(MapConfigKey.INVITE_CODE_KEY)
                    ).thenApplyAsync(result -> {
                        if (result.getSuccess()) {
                            for (AccountContext ac : accountContexts) {
                                AccountContext.signUpSuccess(ac);
                            }
                        }
                        return result;
                    });
                } else {
                    return CompletableFuture.completedFuture(Result.fail("未知错误"));
                }
            },
            (accountContext, result) -> {
                // 登录成功
                if (BooleanUtil.isTrue(result.getSuccess())) {
                    //注册成功
                    AccountContext.signUpSuccess(accountContext);
                }
                return result;
            },
            BotJobType.REGISTER.name()
        );
    }

    /**
     * 获取账号的token
     *
     * @return String
     */
    @Override
    public CompletableFuture<ACListOptResult> loginAndTakeTokenAccount() {
        if (loginMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                getBotInstance().getBotId(),
                getBotInstance().getBotName(),
                BotJobType.LOGIN.name(),
                "未找到登录方法"
            ));
        }

        return asyncForACList(
            accountContext -> invokeBotMethod(
                loginMethod,
                accountContext
            ),
            (accountContext, result) -> {
                // 登录成功
                if (BooleanUtil.isTrue(result.getSuccess())) {
                    String token = result.getData() == null ? null :
                        (result.getData() instanceof String ? (String) result.getData() : null);

                    // token不为空，设置到accountContext里
                    if (StrUtil.isNotBlank(token)) {
                        accountContext.setParam(MapConfigKey.TOKEN_KEY, token);
                    } else {
                        log.debug("账号[{}]-[{}]token为空", accountContext.getId(), accountContext.getName());
                    }
                }
                return result;
            },
            BotJobType.LOGIN.name()
        );
    }

    @Override
    public CompletableFuture<ACListOptResult> updateAccountRewordInfo() {
        if (updateRewordMethod == null) {
            return CompletableFuture.completedFuture(ACListOptResult.fail(
                getBotInstance().getBotId(),
                getBotInstance().getBotName(),
                BotJobType.QUERY_REWARD.name(),
                "未找到奖励查询方法"
            ));
        }

        return asyncForACList(
            getUniqueACList(),
            accountContext -> invokeBotMethod(
                updateRewordMethod,
                accountContext,
                getAcMap().get(accountContext.getAccountBaseInfoId())
            ),
            (accountContext, result) -> result,
            BotJobType.QUERY_REWARD.name()
        );
    }

    @Override
    public Set<String> botJobNameList() {
        return getJobParams().keySet();
    }

    protected abstract T getInstance();

    /**
     * 注册方法处理器
     *
     * @param method method
     */
    private void registerMethodHandler(Method method) {
        logger.debug("add register method");
        if (method.getReturnType() == Result.class
            && method.getParameterCount() == 3
            && method.getParameters()[0].getType() == AccountContext.class
            && method.getParameters()[1].getType() == List.class
            && method.getParameters()[2].getType() == String.class) {

            if (this.registerMethod == null) {
                this.registerMethod = method;
                this.addBasicJob(BotJobType.REGISTER);
            } else {
                throw new BotMethodFormatException("注册方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("注册方法错误, " +
                "应为 Result methodName(AccountContext accountContext, List<AccountContext> sameAccountBaseInfoIdLists, String inviteCode)");
        }
    }

    /**
     * 登录方法处理器
     *
     * @param method method
     */
    private void loginMethodHandler(Method method) {
        logger.debug("add login method");
        if (method.getReturnType() == Result.class
            && method.getParameterCount() == 1
            && method.getParameters()[0].getType() == AccountContext.class
        ) {

            if (this.loginMethod == null) {
                this.loginMethod = method;
                this.addBasicJob(BotJobType.LOGIN);
            } else {
                throw new BotMethodFormatException("登录方法只能有一个");
            }
        } else {
            throw new BotMethodFormatException("登录方法错误, " +
                "应为 Result methodName(AccountContext ac");
        }
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method method
     * @param botJobMethod botJobMethod
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod) {
        logger.debug("add reword query method");
        if (method.getReturnType() == Result.class
            && method.getParameterCount() == 2
            && method.getParameters()[0].getType() == AccountContext.class
            && method.getParameters()[1].getType() == List.class
        ) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            registryJobInBot(
                getInstance(),
                method,
                null,
                botJobMethod
            );
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                "应为 Result methodName(AccountContext ac, List<AccountContext> sameAccountBaseInfoIdLists)");
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method method
     * @param botJobMethod botJobMethod
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod) {
        logger.debug("add [%s] method".formatted(botJobMethod));

        if (method.getParameterCount() > 2
            || method.getParameterCount() < 1
            || method.getParameters()[0].getType() != AccountContext.class
            || (method.getParameterCount() == 2 && method.getParameters()[1].getType() != List.class)
        ) {
            throw new BotMethodFormatException("定时任务方法错误, " +
                "应为 void methodName(AccountContext ac) 或 " +
                "void methodName(AccountContext exampleAC, List<AccountContext> sameABIIdList) ");
        }

        registryJobInBot(
            getInstance(),
            method,
            null,
            botJobMethod
        );
    }

    /**
     * Web socket 方法处理器
     *
     * @param method method
     * @param botJobMethodAnno botJobMethodAnno
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno) {
        logger.debug("add ws [%s] method".formatted(botJobMethodAnno));
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (cn.com.vortexa.bot_father.websocket.BaseBotWSClient.class.isAssignableFrom(returnType)
            && method.getParameterCount() == 1
            && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                String jobName = registryJobInBot(
                    webSocketClientLauncher,
                    WebSocketClientLauncher.lanuchMethod,
                    null,
                    botJobMethodAnno
                );

                AutoBotJobRuntimeParam runtimeParam = getJobRuntimeParamMap().get(jobName);

                if (runtimeParam != null) {
                    // 添加额外参数
                    runtimeParam.setExtraParams(new Object[] {
                        getJobParam(jobName), (AccountWSClientBuilder) accountContext -> {
                        Object invoke = method.invoke(getInstance(), accountContext);
                        return (BaseBotWSClient<?>) invoke;
                    }
                    });
                }

            } catch (Exception e) {
                throw new BotMethodFormatException(e);
            }
        } else {
            throw new BotMethodFormatException(
                "websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                    "执行[%s]-[%s]方法发生异常",
                    getBotInstance().getBotKey(),
                    method.getName()
                ), e);
            }
        }, getExecutorService());
    }

    protected BotInfo generateFromAnno(BotApplication annotation) {
        BotInfo botInfo = new BotInfo();
        botInfo.setName(annotation.name());
        botInfo.setDescribe(annotation.describe());
        botInfo.setImage(annotation.image());
        botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
        botInfo.getParams()
            .put(CONFIG_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.configParams())));
        botInfo.getParams()
            .put(ACCOUNT_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.accountParams())));

        return botInfo;
    }
}
package cn.com.vortexa.bot_father.bot;

import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.bot_father.constants.BotStatus;
import cn.com.vortexa.bot_father.service.BotApi;
import cn.com.vortexa.bot_father.view.MenuCMDLineAutoBot;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.common.exception.BotStartException;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.function.BiFunction;
import java.util.function.Supplier;

/**
 * @param <T>
 */
public abstract class AutoLaunchBot<T extends AnnoDriveAutoBot<T>> extends AnnoDriveAutoBot<T> {

    private static final Logger log = LoggerFactory.getLogger(AutoLaunchBot.class);

    @Override
    protected final void doInit() throws BotInitException {
        super.doInit();
    }

    /**
     * 启动Bot
     *
     * @param botConfig botConfig
     * @param botApi    botApi
     * @throws BotStartException BotStartException
     * @throws BotInitException  BotInitException
     */
    public void launch(AutoBotConfig botConfig, BotApi botApi, Supplier<Boolean> initHandler) throws BotStartException, BotInitException {
        String botKey = botConfig.getBotKey();
        if (StrUtil.isBlank(botKey)) {
            throw new BotStartException("botKey is empty");
        }

        T instance = getInstance();

        // 初始化
        instance.init(botApi, botConfig);

        if (BooleanUtil.isTrue(initHandler.get())) {
            botInitialized(botConfig, botApi);

            if (botConfig.isCommandMenu()) {
                MenuCMDLineAutoBot<AutoBotConfig> menuCMDLineAutoBot
                    = new MenuCMDLineAutoBot<>(instance, List.of());

                // 启动
                menuCMDLineAutoBot.start();
                log.info("bot[{}] running as cli-ui mode", getBotInstance().getBotKey());
            } else {
                // 启动
                instance.updateState(BotStatus.RUNNING);
                log.info("bot[{}] running as headless mode", getBotInstance().getBotKey());
            }
        } else {
            log.error("bot start cancel by init");
        }
    }

    protected abstract void botInitialized(AutoBotConfig botConfig, BotApi botApi);
}
package cn.com.vortexa.bot_father.bot;

import cn.com.vortexa.bot_father.anno.BotMethod;
import cn.com.vortexa.bot_father.anno.BotWSMethodConfig;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.dto.job.AutoBotJobWSParam;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.job.core.AutoBotJobInvoker;
import cn.com.vortexa.bot_father.dto.job.AutoBotJobRuntimeParam;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;
import org.quartz.JobKey;

import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;


import static cn.com.vortexa.common.constants.BotJobType.ACCOUNT_SPLIT_JOB;
import static cn.com.vortexa.common.dto.job.AutoBotJobParam.START_AT;

@Getter
public abstract class JobInvokeAutoBot extends AccountManageAutoBot implements AutoBotJobInvoker {

    private final Map<String, AutoBotJobRuntimeParam> jobRuntimeParamMap = new ConcurrentHashMap<>();

    private final Random random = new Random();

    @Override
    public void invokeJob(JobKey jobKey, AutoBotJobParam jobParam) {
        String jobName = jobKey.getName();

        // Step 1 获取运行时参数
        AutoBotJobRuntimeParam runtimeParam = jobRuntimeParamMap.get(jobName);

        // 账户拆分任务,不需要遍历账户列表
        if (ACCOUNT_SPLIT_JOB.equals(jobParam.getJobType())) {
            runtimeParam = jobRuntimeParamMap.get(jobKey.getGroup());
            invokeAccountSplitJob(jobKey, jobParam, runtimeParam);
            return;
        }

        // 动态触发器
        // 遍历账户，生成新的一些一次性任务执行
        if (BooleanUtil.isTrue(jobParam.getDynamicTrigger())) {
            splitJobByAccount(jobParam, jobName);
            return;
        }

        // Step 2 调用执行方法
        logger.info("开始执行[%s]定时任务".formatted(jobName));

        CompletableFuture<ACListOptResult> future = null;
        if (BooleanUtil.isTrue(jobParam.getUniqueAccount())) {
            future = uniqueForEachAccount(runtimeParam, jobName, jobParam, this::uniqueInvoke);
        } else {
            future = normalForEachAccount(runtimeParam, jobName, jobParam, this::normalInvoke);
        }

        acListOptResultHandler(future);


        logger.info("[%s]定时任务执行完毕".formatted(jobName));
    }


    /**
     * 将Job注册到Bot中
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     */
    public String registryJobInBot(
            Object invokeObj,
            Method method,
            Object[] extraParams,
            BotMethod botJobMethodAnno
    ) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            String jobName = StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName();

            // Step 1 判断合法性
            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
                logger.info("%s cronExpression:[%s]".formatted(jobName, cronExpression.getCronExpression()));
            } else if (botJobMethodAnno.jobType() != BotJobType.ONCE_TASK) {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            // Step 2 设置job运行时参数
            getJobRuntimeParamMap().put(
                    jobName,
                    AutoBotJobRuntimeParam
                            .builder()
                            .target(invokeObj)
                            .method(method)
                            .extraParams(extraParams)
                            .build()
            );

            // Step 3 构建job task参数
            autoBotJobParam = AutoBotJobParam
                    .builder()
                    .jobName(jobName)
                    .jobType(botJobMethodAnno.jobType())
                    .description(botJobMethodAnno.description())
                    .cronExpression(botJobMethodAnno.cronExpression())
                    .intervalInSecond(intervalInSecond)
                    .concurrentCount(botJobMethodAnno.concurrentCount())
                    .autoBotJobWSParam(convertWSConfigParam(botJobMethodAnno.bowWsConfig()))
                    .uniqueAccount(botJobMethodAnno.uniqueAccount())
                    .dynamicTrigger(botJobMethodAnno.dynamicTrigger())
                    .dynamicTimeWindowMinute(botJobMethodAnno.dynamicTimeWindowMinute())
                    .syncExecute(botJobMethodAnno.syncExecute())
                    .build();

            // Step 4 设置
            setJobParam(jobName, autoBotJobParam);

            getBotApi().getBotJobService().registerJobInvoker(new JobKey(jobName, getAutoBotConfig().getBotKey()), this);

            return jobName;
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format("[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInstance().getBotKey(), method.getName(), botJobMethodAnno.cronExpression()),
                    e
            );
        }
    }

    /**
     * 开始任务
     *
     * @param jobName jobName
     * @return BotACJobResult
     */
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().startJob(
                getAutoBotConfig().getBotKey(),
                jobName,
                getJobParam(jobName),
                getInstance()
        );
    }


    /**
     * 根据账户拆分job
     *
     * @param param   param
     * @param jobName jobName
     */
    private void splitJobByAccount(AutoBotJobParam param, String jobName) {
        if (BooleanUtil.isTrue(param.getUniqueAccount())) {
            uniqueAsyncForACList(
                    (accountContext, accountContexts) -> buildNewJob(param, accountContext),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            asyncForACList(
                    (accountContext) -> buildNewJob(param, accountContext),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }

    /**
     * 运行拆分的job
     *
     * @param jobKey       jobKey
     * @param param        param
     * @param runtimeParam runtimeParam
     */
    private void invokeAccountSplitJob(JobKey jobKey, AutoBotJobParam param, AutoBotJobRuntimeParam runtimeParam) {
        Integer acId = Integer.parseInt(jobKey.getName());

        List<AccountContext> list = getAcMap().get(acId);

        if (list.isEmpty()) {
            throw new IllegalArgumentException("不存在bot account " + acId);
        } else {
            AccountContext accountContext = list.getFirst();

            if (BooleanUtil.isTrue(param.getUniqueAccount())) {
                uniqueInvoke(accountContext, list, runtimeParam.getExtraParams(), runtimeParam.getMethod(), runtimeParam.getTarget());
            } else {
                normalInvoke(accountContext, list, runtimeParam.getExtraParams(), runtimeParam.getMethod(), runtimeParam.getTarget());
            }
        }
    }

    /**
     * 普通账户遍历处理
     *
     * @param runtimeParam runtimeParam
     * @param jobName      jobName
     * @param jobParam jobParam
     * @return CompletableFuture<ACListOptResult>
     */
    private CompletableFuture<ACListOptResult> normalForEachAccount(
            AutoBotJobRuntimeParam runtimeParam,
            String jobName,
            AutoBotJobParam jobParam,
            AccountJobMethodInvokeHandler handler
    ) {
        Object[] extraParams = runtimeParam.getExtraParams();
        Method jobMethod = runtimeParam.getMethod();
        Object invokeObj = runtimeParam.getTarget();

        if (BooleanUtil.isTrue(jobParam.getSyncExecute())) {
            return syncForACList(
                    accountContext -> handler.invoke(accountContext, null, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            return asyncForACList(
                    accountContext -> handler.invoke(accountContext, null, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }

    /**
     * 独有账户遍历处理
     *
     * @param runtimeParam runtimeParam
     * @param jobName      jobName
     * @param jobParam  jobParam
     * @return CompletableFuture<ACListOptResult>
     */
    private CompletableFuture<ACListOptResult> uniqueForEachAccount(AutoBotJobRuntimeParam runtimeParam, String jobName, AutoBotJobParam jobParam, AccountJobMethodInvokeHandler handler) {
        Object[] extraParams = runtimeParam.getExtraParams();
        Method jobMethod = runtimeParam.getMethod();
        Object invokeObj = runtimeParam.getTarget();

        if (BooleanUtil.isTrue(jobParam.getSyncExecute())) {
            return uniqueSyncForACList(
                    (accountContext, accountContexts) -> handler.invoke(accountContext, accountContexts, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            return uniqueAsyncForACList(
                    (accountContext, accountContexts) -> handler.invoke(accountContext, accountContexts, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }


    private @NotNull CompletableFuture<Result> normalInvoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                // 封装参数
                Object[] params;
                if (extraParams == null) {
                    params = new Object[]{accountContext};
                } else {
                    params = new Object[1 + extraParams.length];
                    params[0] = accountContext;
                    System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                }

                // 调用执行的job method
                jobMethod.setAccessible(true);
                Object invoke = jobMethod.invoke(invokeObj, params);
                return Result.ok(invoke);
            } catch (Exception e) {
                logger.error("执行定时任务发生异常", e);
                return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
            }
        }, getExecutorService());
    }

    private @NotNull CompletableFuture<Result> uniqueInvoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 封装参数
                Object[] params;
                if (extraParams == null) {
                    params = new Object[]{accountContext, accountContexts};
                } else {
                    params = new Object[2 + extraParams.length];
                    params[0] = accountContext;
                    params[1] = accountContexts;
                    System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                }

                // 调用执行的job method
                jobMethod.setAccessible(true);
                Object invoke = jobMethod.invoke(invokeObj, params);
                return Result.ok(invoke);
            } catch (Exception e) {
                logger.error("执行定时任务发生异常", e);
                return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
            }
        });
    }


    /**
     * 根据account context构建新的job
     *
     * @param param          param
     * @param accountContext accountContext
     * @return CompletableFuture<Result>
     */
    private @NotNull CompletableFuture<Result> buildNewJob(
            AutoBotJobParam param,
            AccountContext accountContext
    ) {
        return CompletableFuture.supplyAsync(() -> {
            // Step 1 计算开始时间
            long startAt = System.currentTimeMillis()
                    + (Long.max(1, random.nextInt(param.getDynamicTimeWindowMinute())) * 60 * 1000);

            // Step 2 生成参数
            String newJobName = String.valueOf(accountContext.getId());
            AutoBotJobParam jobParam = AutoBotJobParam
                    .builder()
                    .jobType(ACCOUNT_SPLIT_JOB)
                    .jobName(newJobName)
                    .intervalInSecond(param.getIntervalInSecond())
                    .autoBotJobWSParam(param.getAutoBotJobWSParam())
                    .uniqueAccount(param.getUniqueAccount())
                    .build();

            jobParam.putParam(START_AT, startAt);

            // Step 3 开始job
            getBotApi().getBotJobService().startJob(
                    param.getJobName(),
                    newJobName,
                    jobParam,
                    getInstance(),
                    false
            );
            return Result.ok("job start at " + startAt);
        }, getExecutorService()).exceptionallyAsync(throwable -> {
            logger.error("split job by account, create new job error", throwable);
            return Result.fail("split job by account, create new job error" + throwable.getMessage());
        });
    }

    protected abstract AutoBotJobInvoker getInstance();

    /**
     * 账户列表操作结果处理
     *
     * @param future future
     */
    private void acListOptResultHandler(CompletableFuture<ACListOptResult> future) {
        future.thenAcceptAsync(acListOptResult -> {
            if (!acListOptResult.getSuccess()) {
                logger.info("botId[%s]-botName[%s]-jobName[%s] 定时任务执行失败, %s".formatted(
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                ));
            } else {
                logger.info("botId[%s]-botName[%s]-jobName[%s] 定时任务执行成功, %s".formatted(
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                ));
            }
        });
    }

    /**
     * 转换BotWSMethodConfig 为 AutoBotJobWSParam
     *
     * @param methodConfig methodConfig
     * @return AutoBotJobWSParam
     */
    private AutoBotJobWSParam convertWSConfigParam(BotWSMethodConfig methodConfig) {
        return new AutoBotJobWSParam(
                methodConfig.isRefreshWSConnection(),
                methodConfig.wsUnlimitedRetry(),
                methodConfig.nioEventLoopGroupThreads(),
                methodConfig.wsConnectCount(),
                methodConfig.reconnectLimit(),
                methodConfig.heartBeatIntervalSecond(),
                methodConfig.reconnectCountDownSecond()
        );
    }

    private interface AccountJobMethodInvokeHandler {

        CompletableFuture<Result> invoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj);

    }
}
package cn.com.vortexa.bot_father.config;


import cn.com.vortexa.bot_father.dto.AutoBotAccountConfig;
import cn.com.vortexa.bot_father.dto.AutoBotConfigFilePathConfig;
import lombok.Data;
import lombok.ToString;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Data
@ToString
@Component
@ConfigurationProperties(prefix = "vortexa")
public class AutoBotConfig {

    /**
     * bot id
     */
    public static Integer BOT_ID;


    /**
     * botName
     */
    public static String BOT_NAME;


    /**
     * 标识bot，不同于bot id， botKey是由用户定义的
     */
    private String botKey;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;

    /**
     * 配置文件配置
     */
    private AutoBotConfigFilePathConfig filePathConfig = new AutoBotConfigFilePathConfig();

    /**
     * 账户配置
     */
    private AutoBotAccountConfig accountConfig = new AutoBotAccountConfig();

    /**
     * 自定义配置
     */
    private Map<String, Object> customConfig = new HashMap<>();


    public String getConfig(String key) {
        return String.valueOf(customConfig.get(key));
    }

    public void setConfig(String key, String value) {
        this.customConfig.put(key, value);
    }

}
package cn.com.vortexa.bot_father.mapper;

import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.db_layer.mapper.IBaseMapper;
import cn.com.vortexa.db_layer.plugn.table_shard.TableShard;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;
import org.apache.ibatis.annotations.Param;

import java.util.List;

import static cn.com.vortexa.bot_father.service.impl.BotAccountContextServiceImpl.BOT_ACCOUNT_CONTEXT_TABLE_PREFIX;


/**
 * <p>
 * Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@TableShard(
        tableNamePrefix = BOT_ACCOUNT_CONTEXT_TABLE_PREFIX,
        values = {"botId", "botKey"},
        fieldFlag = true,
        shardStrategy = BotIdBasedTableShardStrategy.class,
        targetClass = AccountContext.class
)
public interface BotAccountContextMapper extends IBaseMapper<AccountContext> {

    Integer createIfTableNotExist(@Param("botId") Integer botId, @Param("botKey") String botKey);

    List<String> queryBotAccountTableNames(@Param("botId") Integer botId);
}
package cn.com.vortexa.bot_father.scriptagent;

import cn.com.vortexa.control.ScriptAgent;
import cn.com.vortexa.control.config.ScriptAgentConfig;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import cn.com.vortexa.control.util.RPCMethodUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.io.FileNotFoundException;
import java.lang.reflect.Method;
import java.util.List;

/**
 * @author helei
 * @since 2025/3/21 15:04
 */
@Slf4j
@Configuration
@ConditionalOnClass(ScriptAgent.class)
public class BotScriptAgentConfig {

    private static final String APPLICATION_FILE_NAME = "application.yaml";

    private static final String NAMESERVER_CONFIG_PREFIX = "vortexa.scriptAgent";

    @Autowired(required = false)
    private List<RPCServiceInfo<?>> rpcServiceInfos;

    @Bean
    public ScriptAgentConfig scriptAgentClientConfig() throws FileNotFoundException {
        return ScriptAgentConfig.loadConfig(APPLICATION_FILE_NAME, NAMESERVER_CONFIG_PREFIX);
    }

    @Bean
    public ScriptAgent scriptAgent() throws FileNotFoundException, CustomCommandException {
        ScriptAgentConfig scriptAgentConfig = scriptAgentClientConfig();
        ScriptAgent scriptAgent = new ScriptAgent(scriptAgentConfig);

        addCustomCommandHandler(scriptAgent);

        return scriptAgent;
    }

    private void addCustomCommandHandler(ScriptAgent scriptAgent) throws CustomCommandException {
        if (rpcServiceInfos == null) return;

        for (RPCServiceInfo<?> rpcServiceInfo : rpcServiceInfos) {
            Class<?> interfaces = rpcServiceInfo.getInterfaces();
            Object ref = rpcServiceInfo.getRef();

            for (Method method : interfaces.getDeclaredMethods()) {
                method.setAccessible(true);
                String key = RPCMethodUtil.buildRpcMethodKey(interfaces.getName(), method);

                scriptAgent.addCustomCommandHandler(key, request -> {
                    RequestHandleResult result = new RequestHandleResult();

                    log.debug("invoke rpc method[{}]", method.getName());
                    try {
                        byte[] body = request.getBody();
                        RPCArgsWrapper params = Serializer.Algorithm.JDK.deserialize(body, RPCArgsWrapper.class);
                        result.setData(method.invoke(ref, params.getArgs()));
                        result.setSuccess(true);
                        return result;
                    } catch (Exception e) {
                        log.error("invoke rpc method [{}] error", method.getName());
                        throw new CustomCommandInvokeException(e);
                    }
                });
            }
        }
    }
}
package cn.com.vortexa.bot_father.service.impl;

import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.bot_father.mapper.BotAccountContextMapper;
import cn.com.vortexa.bot_father.service.IBotAccountContextService;
import cn.com.vortexa.common.config.SystemConfig;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.entity.BrowserEnv;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.excel.ExcelReadUtil;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import cn.com.vortexa.db_layer.service.AbstractBaseService;
import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import cn.com.vortexa.rpc.api.platform.IBrowserEnvRPC;
import cn.com.vortexa.control.anno.RPCReference;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class BotAccountContextServiceImpl extends AbstractBaseService<BotAccountContextMapper, AccountContext> implements IBotAccountContextService {

    public static final String BOT_ACCOUNT_CONTEXT_TABLE_PREFIX = "t_bot_account_context";

    @Autowired
    private AutoBotConfig botConfig;

    @Autowired
    private ITableShardStrategy tableShardStrategy;

    @RPCReference
    private IBotInstanceRPC botInstanceRPC;

    @RPCReference
    private IBrowserEnvRPC browserEnvRPC;

    public BotAccountContextServiceImpl() {
        super(accountContext -> {
            accountContext.setInsertDatetime(LocalDateTime.now());
            accountContext.setUpdateDatetime(LocalDateTime.now());
            accountContext.setIsValid(1);
        });
    }


    @Override
    public Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> rawLines) {
        if (botId == null || StrUtil.isBlank(botKey)) {
            return Result.fail("botId或botKey不能为空");
        }

        try {
            importFromRaw(rawLines);

            return Result.ok();
        } catch (Exception e) {
            log.error("botId[{}]-botKey[{}] 报错账户信息失败", botId, botKey, e);
            return Result.fail("保存失败, " + e.getMessage());
        }
    }


    @Override
    @Transactional
    public Boolean checkAndCreateShardedTable(Integer botId, String botKey, boolean existUpdate) throws SQLException {
        if (botId == null || StrUtil.isBlank(botKey)) {
            log.error("botId/botKey为空");
            return false;
        }
        try {
            getBaseMapper().createIfTableNotExist(botId, botKey);
            return true;
        } catch (Exception e) {
            throw new SQLException("check and create sharded table[%s]-[%s] error".formatted(botId, botKey), e);
        }
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<AccountContext> accountContexts = rawLines.stream().map(map -> AccountContext.builder()
                .botId(AutoBotConfig.BOT_ID)
                .botKey(botConfig.getBotKey())
                .accountBaseInfoId(toInteger(map.remove("account_base_info_id")))
                .twitterId(toInteger(map.remove("twitter_id")))
                .discordId(toInteger(map.remove("discord_id")))
                .proxyId(toInteger((map.remove("proxy_id"))))
                .browserEnvId(toInteger(map.remove("browser_env_id")))
                .telegramId(toInteger(map.remove("telegram_id")))
                .walletId(toInteger(map.remove("wallet_id")))
                .params(map)
                .build()
        ).toList();

        // 没设置代理的根据配置填充代理
//            tryFillProxy(accountContexts, proxyRepeat, proxyType);

        // 没设置浏览器环境的根据设置填充环境
        tryFillBrowserEnv(accountContexts);

        return insertOrUpdateBatch(accountContexts);
    }

    /**
     * 填充浏览器环境
     *
     * @param accountContexts accountContexts
     */
    private void tryFillBrowserEnv(List<AccountContext> accountContexts) {
        // Step 1 RPC 请求获取浏览器环境
        List<BrowserEnv> allBrowser = null;
        try {
            PageResult<BrowserEnv> pageResult = browserEnvRPC.conditionPageQueryRPC(1, accountContexts.size(), null);
            if (pageResult != null) {
                allBrowser = pageResult.getList();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }

        if (allBrowser == null) {
            log.warn("no browser env, please check it");
            return;
        }

        // Step 2 按次数分配
        Map<Integer, Integer> useCount = new HashMap<>();
        Map<Integer, BrowserEnv> idMapEnv = allBrowser.stream().collect(Collectors.toMap(BrowserEnv::getId, p -> {
            useCount.put(p.getId(), 0);
            return p;
        }));


        Set<AccountContext> noUseAccounts = new HashSet<>();

        accountContexts.forEach(accountContext -> {
            Integer browserEnvId = accountContext.getBrowserEnvId();

            if (browserEnvId == null || !idMapEnv.containsKey(browserEnvId)) {
                // 配置无效，给他添上
                noUseAccounts.add(accountContext);
            } else {
                useCount.put(browserEnvId, useCount.getOrDefault(browserEnvId, 0) + 1);
            }
        });

        // 填充浏览器环境
        List<Integer> ids = getLessUsedItem(useCount, noUseAccounts.size());
        ArrayList<AccountContext> list = new ArrayList<>(noUseAccounts);
        for (int i = 0; i < ids.size(); i++) {
            list.get(i).setBrowserEnvId(ids.get(i));
        }
    }

    /**
     * 获取最少使用的
     *
     * @param count 数量
     * @return List<T>
     */
    private List<Integer> getLessUsedItem(Map<Integer, Integer> useCountMap, int count) {
        if (useCountMap == null || useCountMap.isEmpty()) return Collections.emptyList();
        int batchSize = Math.min(count, useCountMap.size());

        List<Integer> res = new ArrayList<>(count);

        int needCount = count;
        while (needCount > 0) {
            int currentSize = Math.min(needCount, batchSize);

            List<Integer> batch = useCountMap.entrySet().stream()
                    .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .limit(currentSize)
                    .map(e -> {
                        useCountMap.compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                        return e.getKey();
                    }).toList();
            res.addAll(batch);

            needCount -= batch.size();
        }

        return res;
    }
}
package cn.com.vortexa.bot_father.service.impl;

import cn.com.vortexa.bot_father.service.BotApi;
import cn.com.vortexa.bot_father.service.IBotAccountContextService;
import cn.com.vortexa.bot_father.service.IRewordInfoService;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import cn.com.vortexa.rpc.api.bot.IScriptAgentRPC;
import cn.com.vortexa.rpc.api.platform.IAccountBaseInfoRPC;
import cn.com.vortexa.rpc.api.platform.IBotInfoRPC;
import cn.com.vortexa.job.service.BotJobService;
import cn.com.vortexa.rpc.api.platform.IBotInstanceRPC;
import cn.com.vortexa.rpc.api.platform.IBrowserEnvRPC;
import cn.com.vortexa.rpc.api.platform.IDiscordAccountRPC;
import cn.com.vortexa.rpc.api.platform.IProxyInfoRPC;
import cn.com.vortexa.rpc.api.platform.ITelegramAccountRPC;
import cn.com.vortexa.rpc.api.platform.ITwitterAccountRPC;
import cn.com.vortexa.control.anno.RPCReference;
import lombok.Getter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;


@Getter
@Component
public class DBBotApi implements BotApi {

    @Autowired
    private BotJobService botJobService;

    @Autowired
    private IBotAccountContextService botAccountService;

    @Autowired
    private IRewordInfoService rewordInfoService;


    @RPCReference
    private IBotInfoRPC botInfoRPC;

    @RPCReference
    private IBotInstanceRPC botInstanceRPC;

    @RPCReference
    private IAccountBaseInfoRPC accountBaseInfoRPC;

    @RPCReference
    private ITwitterAccountRPC twitterAccountRPC;

    @RPCReference
    private ITelegramAccountRPC telegramAccountRPC;

    @RPCReference
    private IProxyInfoRPC proxyInfoRPC;

    @RPCReference
    private IBrowserEnvRPC browserEnvRPC;

    @RPCReference
    private IDiscordAccountRPC discordAccountRPC;

    @Autowired
    private IScriptAgentRPC scriptAgentRPC;

    @Autowired
    private ITableShardStrategy tableShardStrategy;
}
package cn.com.vortexa.bot_father.service.impl;


import cn.com.vortexa.bot_father.bot.AutoLaunchBot;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.rpc.api.bot.IScriptAgentRPC;
import lombok.Setter;

import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;

/**
 * @author helei
 * @since 2025-03-23
 */
@Setter
@Service
public class ScriptAgentRPCImpl implements IScriptAgentRPC {

    private AutoLaunchBot<?> bot;

    @Override
    public String testRPC(ServiceInstance targetServiceInstance, String testParam1) {
        return "";
    }

    @Override
    public Map<String, AutoBotJobParam> queryScriptAgentJobType() {
        if (bot == null) return new HashMap<>();
        return bot.getBotInstance().getJobParams();
    }

}
