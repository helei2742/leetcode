package cn.com.vortexa.bot_father.config;


import cn.com.vortexa.bot_father.dto.AutoBotAccountConfig;
import cn.com.vortexa.bot_father.dto.AutoBotConfigFilePathConfig;
import lombok.Data;
import lombok.ToString;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Data
@ToString
@Component
@ConfigurationProperties(prefix = "vortexa")
public class AutoBotConfig {

    public static int LOG_CACHE_COUNT = 50; // 日志缓存数量

    /**
     * bot id
     */
    public static Integer BOT_ID;

    /**
     * botName
     */
    public static String BOT_NAME;


    /**
     * 标识bot，不同于bot id， botKey是由用户定义的
     */
    private String botKey;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;

    /**
     * 配置文件配置
     */
    private AutoBotConfigFilePathConfig filePathConfig = new AutoBotConfigFilePathConfig();

    /**
     * 账户配置
     */
    private AutoBotAccountConfig accountConfig = new AutoBotAccountConfig();

    /**
     * 自定义配置
     */
    private Map<String, Object> customConfig = new HashMap<>();


    public String getConfig(String key) {
        return String.valueOf(customConfig.get(key));
    }

    public void setConfig(String key, String value) {
        this.customConfig.put(key, value);
    }

}
package cn.com.vortexa.bot_father.scriptagent;

import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.control.ScriptAgent;
import cn.com.vortexa.control.config.ScriptAgentConfig;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.util.RPCMethodUtil;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.net.URISyntaxException;
import java.util.List;

import javax.net.ssl.SSLException;

/**
 * @author h30069248
 * @since 2025/3/26 16:56
 */
@Slf4j
public class BotScriptAgent extends ScriptAgent {

    private final List<RPCServiceInfo<?>> rpcServiceInfos;

    private final BotScriptAgentLogUploadService logUploadService;

    public BotScriptAgent(ScriptAgentConfig clientConfig, List<RPCServiceInfo<?>> rpcServiceInfos) {
        super(clientConfig);
        this.rpcServiceInfos = rpcServiceInfos;
        this.logUploadService = new BotScriptAgentLogUploadService(this);
    }

    @Override
    protected void init() throws SSLException, URISyntaxException {
        super.init();

        // Step 1 RPC命令处理
        if (rpcServiceInfos == null) {
            return;
        }

        for (RPCServiceInfo<?> rpcServiceInfo : rpcServiceInfos) {
            Class<?> interfaces = rpcServiceInfo.getInterfaces();
            Object ref = rpcServiceInfo.getRef();

            for (Method method : interfaces.getDeclaredMethods()) {
                method.setAccessible(true);
                String key = RPCMethodUtil.buildRpcMethodKey(interfaces.getName(), method);

                try {
                    super.addCustomCommandHandler(key, request -> {
                        RequestHandleResult result = new RequestHandleResult();

                        log.debug("invoke rpc method[{}]", method.getName());
                        try {
                            byte[] body = request.getBody();
                            RPCArgsWrapper params = Serializer.Algorithm.JDK.deserialize(body, RPCArgsWrapper.class);
                            result.setData(method.invoke(ref, params.getArgs()));
                            result.setSuccess(true);
                            return result;
                        } catch (Exception e) {
                            log.error("invoke rpc method [{}] error", method.getName());
                            throw new CustomCommandInvokeException(e);
                        }
                    });
                } catch (CustomCommandException e) {
                    throw new RuntimeException(e);
                }
            }
        }

        // Step 2 其它命令处理
        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.START_UP_BOT_LOG,
            logUploadService::startUploadLogRCHandler
        );
        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.STOP_UP_BOT_LOG,
            logUploadService::stopUploadLogRCHandler
        );
    }
}
package cn.com.vortexa.bot_father.scriptagent;

import cn.com.vortexa.control.ScriptAgent;
import cn.com.vortexa.control.config.ScriptAgentConfig;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.io.FileNotFoundException;
import java.util.List;

/**
 * @author helei
 * @since 2025/3/21 15:04
 */
@Slf4j
@Configuration
@ConditionalOnClass(ScriptAgent.class)
public class BotScriptAgentConfig {

    private static final String APPLICATION_FILE_NAME = "application.yaml";

    private static final String NAMESERVER_CONFIG_PREFIX = "vortexa.scriptAgent";

    @Autowired(required = false)
    private List<RPCServiceInfo<?>> rpcServiceInfos;

    @Bean
    public ScriptAgentConfig scriptAgentClientConfig() throws FileNotFoundException {
        return ScriptAgentConfig.loadConfig(APPLICATION_FILE_NAME, NAMESERVER_CONFIG_PREFIX);
    }

    @Bean
    public ScriptAgent scriptAgent() throws FileNotFoundException, CustomCommandException {
        ScriptAgentConfig scriptAgentConfig = scriptAgentClientConfig();
        return new BotScriptAgent(scriptAgentConfig, rpcServiceInfos);
    }
}
package cn.com.vortexa.bot_father.scriptagent;

import cn.com.vortexa.bot_father.config.AutoBotConfig;
import cn.com.vortexa.common.constants.BotExtFieldConstants;
import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.util.DiscardingBlockingQueue;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.dto.RemotingCommand;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author h30069248
 * @since 2025/3/26 17:04
 */
@Slf4j
public class BotScriptAgentLogUploadService {

    private final BotScriptAgent botScriptAgent;

    private final DiscardingBlockingQueue<String> logCache = new DiscardingBlockingQueue<>(
        AutoBotConfig.LOG_CACHE_COUNT);

    private final AtomicBoolean upload = new AtomicBoolean(false);

    public BotScriptAgentLogUploadService(BotScriptAgent botScriptAgent) {
        this.botScriptAgent = botScriptAgent;
    }

    /**
     * 开始上传日志命令处理器
     *
     * @param channel channel
     * @param command command
     * @return RemotingCommand
     */
    public RemotingCommand startUploadLogRCHandler(Channel channel, RemotingCommand command) {
        // 开始上传日志
        String logUploadTXID = command.getExtFieldsValue(BotExtFieldConstants.LOG_UPLOAD_TX_ID);

        RemotingCommand response = new RemotingCommand();
        response.setTransactionId(command.getTransactionId());
        response.setCode(RemotingCommandCodeConstants.FAIL);
        response.setFlag(BotRemotingCommandFlagConstants.START_UP_BOT_LOG_RESPONSE);

        // 开启日志上传任务
        if (startBotLogUploadTask(logUploadTXID)) {
            response.setCode(RemotingCommandCodeConstants.SUCCESS);
        }

        return response;
    }

    /**
     * 关闭上传日志命令处理器
     *
     * @param channel channel
     * @param command command
     * @return RemotingCommand
     */
    public RemotingCommand stopUploadLogRCHandler(Channel channel, RemotingCommand command) {
        upload.set(false);

        RemotingCommand response = new RemotingCommand();
        response.setTransactionId(command.getTransactionId());
        response.setCode(RemotingCommandCodeConstants.SUCCESS);
        response.setFlag(BotRemotingCommandFlagConstants.STOP_UP_BOT_LOG);

        return response;
    }

    private boolean startBotLogUploadTask(String logUploadTXID) {
        if (upload.compareAndSet(false, true)) {
            botScriptAgent.getCallbackInvoker().execute(() -> {
                while (upload.get()) {
                    try {
                        String logContent = logCache.take();

                        RemotingCommand message = botScriptAgent.newRequestCommand(
                            BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG, false);
                        message.addExtField(BotExtFieldConstants.LOG_UPLOAD_TX_ID, logUploadTXID);
                        message.setPayLoad(logContent);

                        botScriptAgent.sendMessage(message).get();
                    } catch (InterruptedException e) {
                        upload.set(false);
                        log.error("log upload task interrupted");
                    } catch (ExecutionException e) {
                        log.error("upload log error", e);
                    }
                }
            });
            return true;
        }
        return false;
    }
}
package cn.com.vortexa.bot_platform.script_control;

import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.constants.BotExtFieldConstants;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.dto.ConnectEntry;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.util.NameserverUtil;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * @author h30069248
 * @since 2025/3/26 15:16
 */
@Slf4j
public class BotLogUploadService {

    private final BotControlServer botControlServer;

    private final Map<String, String> botLogTxIdToBrowserKeyMap = new HashMap<>();

    public BotLogUploadService(BotControlServer botControlServer) {
        this.botControlServer = botControlServer;
    }

    /**
     * 浏览器请求获取bot的日志命令处理器
     *
     * @param browserChannel browserChannel
     * @param request request
     * @return RemotingCommand
     */
    public RemotingCommand browserRequestBotLogRCHandler(Channel browserChannel, RemotingCommand request) {
        RemotingCommand response = new RemotingCommand();
        response.setFlag(BotRemotingCommandFlagConstants.START_UP_BOT_LOG_RESPONSE);
        response.setTransactionId(request.getTransactionId());

        // Step 0 参数校验
        String browserInstanceKey = browserChannel.attr(NettyConstants.CLIENT_NAME).get();
        if (StrUtil.isBlank(browserInstanceKey)) {
            log.error("browserInstanceKey is blank, browser channel[{}]", browserChannel.id());

            response.setCode(RemotingCommandCodeConstants.FAIL);
            response.setObjBody(Result.fail("browserInstanceKey is blank"));
            return response;
        }

        //.收到开始获取bot的日志命令
        String group = request.getExtFieldsValue(BotExtFieldConstants.TARGET_GROUP_KEY);
        String botName = request.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_NAME_KEY);
        String botKey = request.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_KEY_KEY);
        String botInstanceKey = NameserverUtil.generateServiceInstanceKey(group, botName, botKey);

        log.info("receive command[{}] to start get bot[{}] runtime log",
            BotRemotingCommandFlagConstants.START_UP_BOT_LOG,
            botInstanceKey
        );

        ConnectEntry connectEntry = botControlServer.getConnectionService().getServiceInstanceChannel(
            botInstanceKey
        );

        // Step 1 判断bot是否可用
        if (connectEntry == null || !connectEntry.isUsable()) {
            log.warn("bot [{}] not running, can't upload runtime log", botInstanceKey);

            response.setCode(RemotingCommandCodeConstants.FAIL);
            response.setObjBody(Result.fail("bot cannot use"));
            return response;
        }

        // Step 2 发送命令到该Bot，让它开始发
        try {
            RemotingCommand botStartResponse = botControlServer.sendCommandToServiceInstance(
                group, botName, botKey, request
            ).get();

            if (botStartResponse.getCode() == RemotingCommandCodeConstants.SUCCESS) {
                // Step 2.1 成功
                botLogTxIdToBrowserKeyMap.put(request.getTransactionId(), browserInstanceKey);
                response.setFlag(RemotingCommandCodeConstants.SUCCESS);

                log.info("bot [{}] start upload runtime log", botInstanceKey);
            } else {
                // Step 2.2 失败
                response.setFlag(RemotingCommandCodeConstants.FAIL);
                response.setBody(botStartResponse.getBody());
                log.error("bot [{}] start upload runtime log error, [{}]", botInstanceKey, botStartResponse);
            }

            return response;
        } catch (Exception e) {
            log.error("bot [{}] start upload runtime log error", botInstanceKey, e);

            response.setCode(RemotingCommandCodeConstants.FAIL);
            response.setObjBody(Result.fail("unknown error"));
            return response;
        }
    }

    /**
     * bot上传日志命令处理器
     *
     * @param channel channel
     * @param command command
     * @return RemotingCommand
     */
    public RemotingCommand botUploadLogRCHandler(Channel channel, RemotingCommand command) {
        String logUploadTxId = command.getExtFieldsValue(BotExtFieldConstants.LOG_UPLOAD_TX_ID);
        String browserInstanceKey = botLogTxIdToBrowserKeyMap.get(logUploadTxId);
        String botInstanceKey = channel.attr(NettyConstants.CLIENT_NAME).get();

        RemotingCommand response = botControlServer.newRemotingCommand(BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG_RESPONSE, false);
        response.addExtField(BotExtFieldConstants.LOG_UPLOAD_TX_ID, logUploadTxId);
        response.setCode(RemotingCommandCodeConstants.FAIL);

        // Step 1 浏览器实例请求不在map里，让bot取消上传
        if (StrUtil.isBlank(browserInstanceKey)) {
            log.warn("browser instance[{}] upload log request canceled, interrupt bot[{}] upload",
                browserInstanceKey, botInstanceKey);
            stopBotUploadLog(botInstanceKey, logUploadTxId);
            return response;
        }

        // Step 2 查找请求该txId的log的browser channel，推送给它
        ConnectEntry browserConnect = botControlServer.getConnectionService().getServiceInstanceChannel(browserInstanceKey);
        if (browserConnect != null && browserConnect.isUsable()) {
            try {
                // 发送给browser
                RemotingCommand message = botControlServer.newRemotingCommand(BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG, false);
                botControlServer.sendCommandToServiceInstance(browserInstanceKey, message).get();

                // 发送给browser成功后，返回响应
                response.setCode(RemotingCommandCodeConstants.SUCCESS);
            } catch (Exception e) {
                log.error("reword bot[{}] log to browser[{}] error", botInstanceKey, browserInstanceKey, e);
            }
        } else {
            // channel不可用，让bot不发送
            log.warn("browser instance[{}] channel cannot use", browserInstanceKey);
            stopBotUploadLog(botInstanceKey, logUploadTxId);
        }

        return response;
    }

    /**
     * 停止Bot上传日志
     *
     * @param botInstanceKey botInstanceKey
     * @return CompletableFuture<RemotingCommand>
     */
    public CompletableFuture<RemotingCommand> stopBotUploadLog(String botInstanceKey, String txId) {
        RemotingCommand command = botControlServer.newRemotingCommand(BotRemotingCommandFlagConstants.STOP_UP_BOT_LOG, true);

        // 不管是否成功都把map里的txId删掉
        botLogTxIdToBrowserKeyMap.remove(txId);

        return botControlServer.sendCommandToServiceInstance(
            botInstanceKey, command
        ).whenComplete((response, throwable) -> {
            if (throwable != null) {
                log.error("stop bot[{}] log upload error", botInstanceKey, throwable);
            } else if (response == null || response.getCode() == RemotingCommandCodeConstants.FAIL) {
                log.error("stop bot[{}] log upload fail, {}", botInstanceKey, response, throwable);
            } else {
                log.info("stop bot[{}] log upload success", botInstanceKey, throwable);
            }
        });
    }
}
package cn.com.vortexa.bot_platform.script_control;

import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.config.ControlServerConfig;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.control.exception.ControlServerException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.service.IConnectionService;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.util.RPCMethodUtil;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.util.List;

/**
 * @author h30069248
 * @since 2025/3/26 15:42
 */
@Slf4j
public class BotPlatformControlServer extends BotControlServer {

    private final List<RPCServiceInfo<?>> rpcServiceInfos;
    private final BotLogUploadService botLogUploadService;

    public BotPlatformControlServer(ControlServerConfig controlServerConfig, List<RPCServiceInfo<?>> rpcServiceInfos) throws ControlServerException {
        super(controlServerConfig);
        this.rpcServiceInfos = rpcServiceInfos;
        this.botLogUploadService = new BotLogUploadService(this);
    }

    @Override
    public void init(IRegistryService registryService, IConnectionService connectionService) throws Exception {
        super.init(registryService, connectionService);

        // 1 RPC 服务
        for (RPCServiceInfo<?> rpcServiceInfo : rpcServiceInfos) {
            Class<?> interfaces = rpcServiceInfo.getInterfaces();

            Object ref = rpcServiceInfo.getRef();

            for (Method method : interfaces.getDeclaredMethods()) {
                method.setAccessible(true);
                String key = RPCMethodUtil.buildRpcMethodKey(interfaces.getName(), method);

                log.info("add custom command handler [{}]", key);

                super.addCustomCommandHandler(key, request -> {
                    RequestHandleResult result = new RequestHandleResult();

                    log.debug("invoke rpc method[{}]", method.getName());
                    try {
                        byte[] body = request.getBody();
                        RPCArgsWrapper params = Serializer.Algorithm.JDK.deserialize(body, RPCArgsWrapper.class);

                        Object invoke = method.invoke(ref, params.getArgs());
                        log.info("invoke rpc[{}] method[{}] return [{}]", request.getTransactionId(), key, invoke);
                        result.setData(invoke);
                        result.setSuccess(true);
                        return result;
                    } catch (Exception e) {
                        log.error("invoke rpc method [{}] error", method.getName());
                        throw new CustomCommandInvokeException(e);
                    }
                });
            }
        }

        // 2 自定义的请求
        // 2.1 浏览器客户端请求获取某个bot日志的命令处理器
        getCustomRemotingCommandHandlerMap().put(
            BotRemotingCommandFlagConstants.START_UP_BOT_LOG,
            botLogUploadService::browserRequestBotLogRCHandler
        );
        // 2.2 bot上传日志命令的处理器
        getCustomRemotingCommandHandlerMap().put(BotRemotingCommandFlagConstants.BOT_RUNTIME_LOG,
            botLogUploadService::botUploadLogRCHandler);
    }

}
package cn.com.vortexa.bot_platform.script_control;

import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.control.config.ControlServerConfig;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.service.IConnectionService;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.service.impl.FileRegistryService;
import cn.com.vortexa.control.service.impl.MemoryConnectionService;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import cn.com.vortexa.control.util.RPCMethodUtil;
import io.netty.channel.Channel;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.io.FileNotFoundException;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.BiFunction;

/**
 * @author helei
 * @since 2025-03-21
 */
@Slf4j
@Configuration
public class BotPlatformControlServerConfig implements InitializingBean {

    private static final String APPLICATION_FILE_NAME = "application.yaml";

    private static final String NAMESERVER_CONFIG_PREFIX = "vortexa.controlServer";

    @Autowired
    private List<RPCServiceInfo<?>> rpcServiceInfos;

    @Bean
    public ControlServerConfig controlServerConfig() throws FileNotFoundException {
        return ControlServerConfig.loadConfig(APPLICATION_FILE_NAME, NAMESERVER_CONFIG_PREFIX);
    }

    @Bean
    public ExecutorService controlServerThreadPool() throws FileNotFoundException {
        return Executors.newThreadPerTaskExecutor(
            new NamedThreadFactory(controlServerConfig().getServiceInstance().toString())
        );
    }

    @Bean
    public IRegistryService registryService() throws FileNotFoundException {
        return new FileRegistryService(controlServerThreadPool());
    }

    @Bean
    public IConnectionService connectionService() {
        return new MemoryConnectionService();
    }

    @Bean
    public BotControlServer botControlServer() throws Exception {
        ControlServerConfig controlServerConfig = controlServerConfig();
        log.info("start launch BotPlatFormNameserver[{}]", controlServerConfig.getServiceInstance());
        return new BotPlatformControlServer(controlServerConfig, rpcServiceInfos);
    }


    @Override
    public void afterPropertiesSet() throws Exception {
        BotControlServer botControlServer = botControlServer();
        botControlServer.init(registryService(), connectionService());
        botControlServer.start().get();
        log.info("BotPlatFormNameserver[{}] launch finish", botControlServer.getControlServerConfig().getServiceInstance());
    }
}
package cn.com.vortexa.common.constants;

/**
 * @author h30069248
 * @since 2025/3/26 14:54
 */
public class BotExtFieldConstants {
    public static final String TARGET_GROUP_KEY = "target_group";   // 目标的group
    public static final String TARGET_BOT_NAME_KEY = "target_bot_name"; // 目标的bot name
    public static final String TARGET_BOT_KEY_KEY = "target_bot_key";   // 目标的bot key

    public static final String LOG_UPLOAD_TX_ID = "log_upload_tx_id";   // 日志上传的txId
}
package cn.com.vortexa.common.constants;

/**
 * @author h30069248
 * @since 2025/3/26 14:45
 */
public class BotRemotingCommandFlagConstants {

    public static final int START_UP_BOT_LOG = 6001;    // 开始上传Bot运行日志
    public static final int START_UP_BOT_LOG_RESPONSE = -6001;  // 开始上传Bot运行日志的响应
    public static final int STOP_UP_BOT_LOG = 6002;    // 停止上传Bot运行日志
    public static final int STOP_UP_BOT_LOG_RESPONSE = -6003;  // 停止上传Bot运行日志的响应

    public static final int BOT_RUNTIME_LOG =  6666;    // 上传日志
    public static final int BOT_RUNTIME_LOG_RESPONSE =  -6666;    // 上传日志
}
package cn.com.vortexa.common.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serial;
import java.io.Serializable;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result implements Serializable {
    @Serial
    private static final long serialVersionUID = -43978563748658346L;

    private Boolean success;
    private String errorMsg;
    private Object data;

    public static Result ok(){
        return new Result(true, null, null);
    }
    public static Result ok(Object data){
        return new Result(true, null, data);
    }
    public static Result fail(String errorMsg){
        return new Result(false, errorMsg, null);
    }
}
package cn.com.vortexa.websocket.netty.base;

import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.com.vortexa.websocket.netty.handler.AbstractWebSocketClientHandler;
import cn.hutool.core.util.StrUtil;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.HttpProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Websocket客户端
 */
@Slf4j
@Setter
@Getter
public abstract class AbstractWebsocketClient<T> extends AutoConnectWSService {
    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    private final AbstractWebSocketClientHandler<T> handler;   //netty pipeline 最后一个执行的handler
    private final ExecutorService callbackInvoker;  //执行回调的线程池
    private String name;
    private boolean handshake = true;
    private int allIdleTimeSecond = 10; //空闲时间

    public AbstractWebsocketClient(
            String url,
            String name,
            AbstractWebSocketClientHandler<T> handler
    ) {
        super(url);
        this.name = name;
        this.handler = handler;
        this.callbackInvoker = Executors.newThreadPerTaskExecutor(new NamedThreadFactory(name));
    }

    @Override
    protected void afterBoostrapConnected(Channel channel) throws InterruptedException {
        if (handshake && handler.handshakeFuture() != null) {
            handler.handshakeFuture().sync();
        }
    }

    @Override
    protected void init() throws SSLException, URISyntaxException {
        URI uri = new URI(getUrl());

        WebSocketClientHandshaker webSocketClientHandshaker = handshake ? WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, getHeaders(), MAX_FRAME_SIZE
        ) : null;

        handler.init(this, webSocketClientHandshaker, callbackInvoker);

        final SslContext sslCtx;
        if (isUseSSL()) {
            sslCtx = SslContextBuilder
                    .forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE)
                    .build();
        } else {
            sslCtx = null;
        }

        setBootstrap(new Bootstrap());
        getBootstrap().group(getEventLoopGroup())
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 10000) // 设置连接超时为10秒
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        ProxyInfo proxy = getProxy();

                        if (proxy != null) {
                            // 添加 HttpProxyHandler 作为代理
                            if (StrUtil.isNotBlank(proxy.getUsername())) {
                                p.addFirst(new HttpProxyHandler(proxy.generateAddress(), proxy.getUsername(),
                                        proxy.getPassword()));
                            } else {
                                p.addFirst(new HttpProxyHandler(proxy.generateAddress()));
                            }
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), uri.getPort()));
                        }

                        addPipeline(p);
                    }
                });
    }

    /**
     * 添加 pipeline
     *
     * @param p p
     */
    public abstract void addPipeline(ChannelPipeline p);

    /**
     * 发送消息，没有回调
     *
     * @param message message
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> sendMessage(T message) {
        return CompletableFuture.runAsync(() -> {
            if (message == null) {
                throw new IllegalArgumentException("message is null");
            }

            doSendMessage(message, false);
        }, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(T request) {
        log.debug("send request [{}]", request);

        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = handler.registryRequest(request, response -> {
                jb.set(response);
                latch.countDown();
            });

            if (flag) {
                doSendMessage(request, true);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) {
                    return null;
                }

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送消息
     *
     * @param message   message
     * @param isRequest isRequest
     */
    protected void doSendMessage(T message, boolean isRequest) {
        try {
            getChannel().writeAndFlush(message);
            log.debug("send request [{}] success", message);
        } catch (Exception e) {
            throw new RuntimeException("send message [" + message + "] error");
        }
    }
}
package cn.com.vortexa.control.service;

import com.sun.management.OperatingSystemMXBean;

import cn.com.vortexa.control.ScriptAgent;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.dto.ScriptAgentMetrics;
import lombok.extern.slf4j.Slf4j;

import java.lang.management.ManagementFactory;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

/**
 * Script agent 指标上传服务
 *
 * @author h30069248
 * @since 2025/3/24 15:09
 */
@Slf4j
public class ScriptAgentMetricsUploadService {
    private static final OperatingSystemMXBean osBean = (OperatingSystemMXBean)ManagementFactory.getOperatingSystemMXBean();
    private static final Runtime runtime = Runtime.getRuntime();

    private final ScriptAgent scriptAgent;
    private final ExecutorService executorService;

    public ScriptAgentMetricsUploadService(
            ScriptAgent scriptAgent
    ) {
        this(scriptAgent, Executors.newFixedThreadPool(1));
    }

    public ScriptAgentMetricsUploadService(
            ScriptAgent scriptAgent,
            ExecutorService executorService
    ) {
        this.scriptAgent = scriptAgent;
        this.executorService = executorService;
    }

    public void start() {
        executorService.execute(new MetricsUploadTask(
                scriptAgent.getClientConfig().getMetricUploadIntervalSeconds(),
                this::uploadMetricsLogic
        ));
    }

    /**
     * 上传指标逻辑
     *
     * @param times times
     */
    private CompletableFuture<RemotingCommand> uploadMetricsLogic(Long times) {
        // Step 1 构建请求
        RemotingCommand request = scriptAgent.newRequestCommand(
                RemotingCommandFlagConstants.SCRIPT_AGENT_METRICS_UPLOAD
        );

        // Step 2 设置指标数据 TODO
        ScriptAgentMetrics metrics = ScriptAgentMetrics.builder()
                .totalMemory(runtime.totalMemory())
                .freeMemory(runtime.freeMemory())
                .maxMemory(runtime.maxMemory())
                .processCpuLoad(osBean.getProcessCpuLoad())
                .processCpuLoad(osBean.getCpuLoad())
                .build();

        request.setObjBody(metrics);

        // Step 3 发送请求
        return scriptAgent.sendRequest(request);
    }

    private static class MetricsUploadTask implements Runnable {

        private final int intervalSeconds; // 间隔
        private final Function<Long, CompletableFuture<RemotingCommand>> uploadLogic;
        private final AtomicLong uploadTimes;
        private volatile boolean running = true;

        private MetricsUploadTask(int intervalSeconds, Function<Long, CompletableFuture<RemotingCommand>> uploadLogic) {
            this.intervalSeconds = intervalSeconds;
            this.uploadLogic = uploadLogic;
            this.uploadTimes = new AtomicLong(0);
        }

        @Override
        public void run() {
            while (running) {
                try {
                    TimeUnit.SECONDS.sleep(intervalSeconds);
                } catch (InterruptedException e) {
                    log.warn("script agent metrics upload task interrupted");
                    running = false;
                    continue;
                }
                try {
                    if (uploadLogic != null) {
                        RemotingCommand response = uploadLogic.apply(uploadTimes.incrementAndGet()).get();
                        if (response.getCode() == RemotingCommandCodeConstants.FAIL) {
                            log.error("script agent metrics upload fail, [{}]", response);
                        }
                    }
                } catch (Exception e) {
                    log.error("script agent metrics upload error", e);
                }
            }
        }
    }
}
package cn.com.vortexa.control;

import cn.com.vortexa.control.config.ScriptAgentConfig;
import cn.com.vortexa.control.constant.*;
import cn.com.vortexa.control.dto.RemoteControlServerStatus;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.handler.CustomRequestHandler;
import cn.com.vortexa.control.processor.CustomCommandProcessor;
import cn.com.vortexa.control.processor.ScriptAgentProcessorAdaptor;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.service.ScriptAgentMetricsUploadService;
import cn.com.vortexa.control.util.DistributeIdMaker;
import cn.com.vortexa.control.util.RemotingCommandDecoder;
import cn.com.vortexa.control.util.RemotingCommandEncoder;
import cn.com.vortexa.websocket.netty.base.AbstractWebsocketClient;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.*;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Supplier;

/**
 * @author helei
 * @since 2025-03-13
 */
@Slf4j
@Getter
public class ScriptAgent extends AbstractWebsocketClient<RemotingCommand> {

    private final ScriptAgentConfig clientConfig;  // 配置
    private final ServiceInstance serviceInstance;
    private final RemoteControlServerStatus remoteStatus; // 远程服务命名中心状态
    private final CustomCommandProcessor customCommandProcessor;    // 自定义命令处理器
    private final ScriptAgentMetricsUploadService metricsUploadService; // 指标上传服务
    private final Map<Integer, BiFunction<Channel, RemotingCommand, RemotingCommand>> customRemotingCommandHandlerMap = new HashMap<>();

    @Setter
    private Supplier<Object> registryBodySetter = null; // 注册时的body
    @Setter
    private Consumer<RemotingCommand> afterRegistryHandler = null;  // 注册成功后回调

    public ScriptAgent(ScriptAgentConfig clientConfig) {
        this(clientConfig, new ScriptAgentProcessorAdaptor(clientConfig));
    }

    public ScriptAgent(ScriptAgentConfig clientConfig, ScriptAgentProcessorAdaptor scriptAgentProcessorAdaptor) {
        super(clientConfig.getRegistryCenterUrl(), clientConfig.getServiceInstance().toString(),
                scriptAgentProcessorAdaptor);
        super.setHandshake(false);
        this.clientConfig = clientConfig;
        this.serviceInstance = clientConfig.getServiceInstance();
        super.setName(this.serviceInstance.toString());
        this.remoteStatus = new RemoteControlServerStatus();
        this.customCommandProcessor = new CustomCommandProcessor();

        this.metricsUploadService = new ScriptAgentMetricsUploadService(this, this.getCallbackInvoker());
        ((ScriptAgentProcessorAdaptor) getHandler()).setScriptAgent(this);
    }

    @Override
    protected void afterBoostrapConnected(Channel channel) {
        // 每次连接成功，都发送注册消息
        channel.attr(NettyConstants.CLIENT_NAME).set(getName());
        sendRegistryCommand();
    }

    @Override
    public void addPipeline(ChannelPipeline p) {
        p.addLast(new IdleStateHandler(0,
                0, clientConfig.getServiceOfflineTtl()));

        p.addLast(new LengthFieldBasedFrameDecoder(NameserverSystemConstants.MAX_FRAME_LENGTH,
                0, 4, 0, 4));
        p.addLast(new LengthFieldPrepender(4));

        p.addLast(new RemotingCommandDecoder());
        p.addLast(new RemotingCommandEncoder());
        p.addLast(getHandler());
    }

    @Override
    protected void doSendMessage(RemotingCommand message, boolean b) {
        log.debug("send message to nameserver: {}", message);

        ServiceInstance serviceInstance = clientConfig.getServiceInstance();

        if (b && StrUtil.isBlank(message.getTransactionId())) {
            message.setTransactionId(nextTxId());
        }

        message.setGroup(serviceInstance.getGroup());
        message.setServiceId(serviceInstance.getServiceId());
        message.setClientId(serviceInstance.getInstanceId());

        Channel channel;
        if ((channel = getChannel()) != null) {
            channel.writeAndFlush(message);
        } else {
            throw new RuntimeException("channel is null");
        }
    }

    /**
     * 发送服务注册命令
     */
    public void sendRegistryCommand() {
        RemotingCommand remotingCommand = newRequestCommand(RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE);
        Object body = null;
        if (registryBodySetter != null) {
            body = registryBodySetter.get();
        }
        remotingCommand.setBodyFromObject(body);

        sendRequest(remotingCommand).whenComplete((response, throwable) -> {
            if (throwable != null) {
                log.error("{} -> [{}] channel active error",
                        clientConfig.getServiceInstance(), clientConfig.getRegistryCenterUrl(), throwable);
            }

            // 注册成功
            if (response.getCode() == RemotingCommandCodeConstants.SUCCESS) {
                log.info("{} client registry success", clientConfig.getServiceInstance());
                if (afterRegistryHandler != null) {
                    afterRegistryHandler.accept(response);
                }

                ServiceInstance nameserviceInstance = Serializer.Algorithm.Protostuff
                        .deserialize(response.getBody(), ServiceInstance.class);

                remoteStatus.setNameserverInstance(nameserviceInstance);
            } else {
                // 注册失败
                log.error("{} client registry failed, response: {}", clientConfig.getServiceInstance(), response);
                close();
            }

            remoteStatus.setLastUpdateTimestamp(System.currentTimeMillis());
            remoteStatus.setNameserverState(NameserverState.valueOf(
                    response.getExtFieldsValue(ExtFieldsConstants.NAMESERVER_STATUS)
            ));
        });
    }

    /**
     * 添加自定义命令处理器
     *
     * @param commandFlag          commandFlag 命令标识
     * @param customRequestHandler customRequestHandler    处理器
     */
    public void addCustomCommandHandler(String commandFlag, CustomRequestHandler customRequestHandler)
            throws CustomCommandException {
        customCommandProcessor.addCustomCommandHandler(commandFlag, customRequestHandler);
    }

    /**
     * 处理自定义请求
     *
     * @param remotingCommand request
     * @return response
     */
    public RemotingCommand tryResolveCustomRequest(RemotingCommand remotingCommand) {
        RemotingCommand response = null;
        try {
            response = customCommandProcessor.tryInvokeCustomCommandHandler(getChannel(), remotingCommand);
        } catch (Exception e) {
            log.error("custom request[{}] execute error, ", remotingCommand, e);
            response = new RemotingCommand();
            response.setTransactionId(remotingCommand.getTransactionId());
            response.setCode(RemotingCommandCodeConstants.FAIL);
            response.setBody(
                    Serializer.Algorithm.Protostuff.serialize(e)
            );
        }
        return response;
    }

    /**
     * 构建命令
     *
     * @param commandFlag commandFlag
     * @return RemotingCommand
     */
    public RemotingCommand newRequestCommand(int commandFlag) {
        return newRequestCommand(commandFlag, true);
    }
    /**
     * 构建命令
     *
     * @param commandFlag commandFlag
     * @return RemotingCommand
     */
    public RemotingCommand newRequestCommand(int commandFlag, boolean needTxId) {
        RemotingCommand command = new RemotingCommand();
        command.setGroup(serviceInstance.getGroup());
        command.setServiceId(serviceInstance.getServiceId());
        command.setClientId(serviceInstance.getInstanceId());
        command.setTransactionId(needTxId ? nextTxId() : null);

        command.setFlag(commandFlag);
        return command;
    }

    /**
     * 获取下一个事务id
     *
     * @return String
     */
    public String nextTxId() {
        return DistributeIdMaker.DEFAULT.nextId(getName());
    }
}
package cn.com.vortexa.control.dto;


import io.netty.channel.Channel;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @author helei
 * @since 2025-03-12
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ConnectEntry {
    private Channel channel;
    private boolean usable;
    private long lastActiveTimestamp;

    public void close() {
        if (channel != null && channel.isActive()) {
            channel.close();
        }
        usable = false;
    }

    public boolean isUsable() {
        return usable && channel != null && channel.isActive();
    }
}
package cn.com.vortexa.control.processor;

import cn.com.vortexa.control.constant.*;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.util.NameserverUtil;
import cn.com.vortexa.websocket.netty.handler.BaseWebSocketInboundHandler;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.channel.Channel;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.function.BiFunction;

/**
 * @author helei
 * @since 2025/03/11
 */
@Slf4j
@ChannelHandler.Sharable
public class ControlServerProcessorAdaptor extends BaseWebSocketInboundHandler<RemotingCommand> {

    @Getter
    private final BotControlServer botControlServer;
    private final PingCommandProcessor pingCommandProcessor;
    private final PongCommandProcessor pongCommandProcessor;
    private final ServiceRegistryProcessor serviceRegistryProcessor;
    private final ServiceDiscoverProcessor serviceDiscoverProcessor;
    private final ScriptAgentMetricsCommandProcessor scriptAgentMetricsCommandProcessor;

    public ControlServerProcessorAdaptor(
            BotControlServer nameServerService,
            IRegistryService registryService
    ) {
        super();
        this.botControlServer = nameServerService;
        this.pingCommandProcessor = new PingCommandProcessor(botControlServer);
        this.pongCommandProcessor = new PongCommandProcessor(botControlServer);
        this.serviceRegistryProcessor = new ServiceRegistryProcessor(registryService);
        this.serviceDiscoverProcessor = new ServiceDiscoverProcessor(registryService);
        this.scriptAgentMetricsCommandProcessor = new ScriptAgentMetricsCommandProcessor(botControlServer);

        init(this.botControlServer.getExecutorService());
    }

    @Override
    protected void handlerMessage(ChannelHandlerContext ctx, RemotingCommand remotingCommand) {
        Integer opt = remotingCommand.getFlag();
        String txId = remotingCommand.getTransactionId();

        Channel channel = ctx.channel();
        String key = channel.attr(NettyConstants.CLIENT_NAME).get();
        log.debug("receive client[{}] command [{}]", key, remotingCommand);

        CompletableFuture.supplyAsync(() -> switch (opt) {
                    case RemotingCommandFlagConstants.PING -> pingCommandProcessor.handlerPing(key, channel, remotingCommand);
                    case RemotingCommandFlagConstants.PONG -> pongCommandProcessor.handlerPong(key, channel, remotingCommand);
                    case RemotingCommandFlagConstants.CLIENT_REGISTRY_SERVICE -> {
                        RemotingCommand registryResult = serviceRegistryProcessor.handlerClientServiceRegistry(
                                channel, remotingCommand);
                        if (registryResult.getCode() == RemotingCommandCodeConstants.SUCCESS) {
                            // 给channel设置名字
                            String group = remotingCommand.getGroup();
                            String serviceId = remotingCommand.getServiceId();
                            String clientId = remotingCommand.getClientId();
                            String newKey = NameserverUtil.generateServiceInstanceKey(group, serviceId, clientId);

                            channel.attr(NettyConstants.CLIENT_NAME).set(newKey);

                            // 注册成功，添加channel连接
                            botControlServer.getConnectionService().addServiceChannel(newKey, channel);
                        }

                        // 返回状态
                        registryResult.addExtField(
                                ExtFieldsConstants.NAMESERVER_STATUS,
                                botControlServer.getState().name()
                        );
                        yield registryResult;
                    }
                    case RemotingCommandFlagConstants.CLIENT_DISCOVER_SERVICE ->
                            serviceDiscoverProcessor.handlerDiscoverService(channel, remotingCommand);
                    case RemotingCommandFlagConstants.CUSTOM_COMMAND ->
                            botControlServer.tryInvokeCustomCommand(channel, remotingCommand);
                    case RemotingCommandFlagConstants.SCRIPT_AGENT_METRICS_UPLOAD ->
                            scriptAgentMetricsCommandProcessor.handlerScriptAgentMetricsUpload(key, remotingCommand);
                    default -> {
                        BiFunction<Channel, RemotingCommand, RemotingCommand> customProcessor = botControlServer.getCustomRemotingCommandHandlerMap().get(opt);
                        if (customProcessor != null) {
                            yield customProcessor.apply(channel, remotingCommand);
                        } else {
                            throw new IllegalStateException("Unexpected value: " + opt);
                        }
                    }
                }, getCallbackInvoker())
                .whenCompleteAsync((response, ex) -> {
                    if (ex != null) {
                        log.error("client[{}] command process failed", key, ex);

                        RemotingCommand errorResponse = new RemotingCommand();
                        errorResponse.setFlag(-1 * opt);
                        errorResponse.setCode(RemotingCommandCodeConstants.FAIL);
                        errorResponse.addExtField(
                                ExtFieldsConstants.REQUEST_ERROR_MSG,
                                ex.getMessage()
                        );

                        ctx.channel().writeAndFlush(errorResponse);
                    } else if (response != null) {
                        response.setTransactionId(txId);

                        log.debug("send response[{}]", response);
                        ctx.channel().writeAndFlush(response);
                    }
                });
    }

    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        log.debug("channel[{}][{}] not active long time, will close it",
                channel.id(), channel.attr(NettyConstants.CLIENT_NAME));

        botControlServer.closeChannel(channel);
    }

    @Override
    protected Object getMessageId(RemotingCommand message) {
        return message.getTransactionId();
    }
}
package cn.com.vortexa.control;

import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.common.util.NamedThreadFactory;
import cn.com.vortexa.control.config.ControlServerConfig;
import cn.com.vortexa.control.constant.NameserverState;
import cn.com.vortexa.control.constant.NameserverSystemConstants;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.constant.RemotingCommandFlagConstants;
import cn.com.vortexa.control.dto.ConnectEntry;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.dto.RPCResultWrapper;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.ControlServerException;
import cn.com.vortexa.control.handler.CustomRequestHandler;
import cn.com.vortexa.control.processor.ControlServerProcessorAdaptor;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.service.IConnectionService;
import cn.com.vortexa.control.service.IMetricsService;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.processor.CustomCommandProcessor;
import cn.com.vortexa.control.service.impl.InfluxDBMetricsService;
import cn.com.vortexa.control.util.DistributeIdMaker;
import cn.com.vortexa.control.util.NameserverUtil;
import cn.com.vortexa.control.util.RemotingCommandDecoder;
import cn.com.vortexa.control.util.RemotingCommandEncoder;
import cn.com.vortexa.websocket.netty.constants.NettyConstants;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.LengthFieldBasedFrameDecoder;
import io.netty.handler.codec.LengthFieldPrepender;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import static cn.com.vortexa.control.constant.NameserverState.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.BiFunction;
import java.util.function.Function;

@Slf4j
@Getter
public class BotControlServer {
    private final ControlServerConfig controlServerConfig;    // nameServerConfig
    private final CustomCommandProcessor customCommandProcessor;   // 自定义命令处理服务
    private final ExecutorService executorService;
    private final long startTime;   //启动时间
    private final Map<Integer, BiFunction<Channel, RemotingCommand, RemotingCommand>> customRemotingCommandHandlerMap = new HashMap<>();

    private volatile NameserverState state; // name server state
    private ServerBootstrap serverBootstrap;    //serverBootstrap
    private ChannelFuture nameserverChannelFuture;  //nameserverChannelFuture

    private ControlServerProcessorAdaptor processorAdaptor;  // 消息处理器
    private IRegistryService registryService;   // 注册服务
    private IConnectionService connectionService;   // 连接服务
    private IMetricsService metricsService; // 指标服务

    public BotControlServer(ControlServerConfig controlServerConfig) throws ControlServerException {
        this(controlServerConfig, Executors.newThreadPerTaskExecutor(
                new NamedThreadFactory(controlServerConfig.getServiceInstance().toString())
        ));
    }

    public BotControlServer(
            ControlServerConfig controlServerConfig,
            ExecutorService executorService
    ) throws ControlServerException {
        this.controlServerConfig = controlServerConfig;
        updateNameServerState(JUST_START);
        this.startTime = System.currentTimeMillis();
        this.executorService = executorService;

        this.customCommandProcessor = new CustomCommandProcessor();
    }

    /**
     * 初始化
     *
     * @param registryService registryService
     */
    public void init(
            IRegistryService registryService,
            IConnectionService connectionService
    ) throws Exception {
        this.registryService = registryService;
        this.connectionService = connectionService;
        this.processorAdaptor = new ControlServerProcessorAdaptor(
                this,
                registryService
        );
        this.metricsService = new InfluxDBMetricsService();

        serverBootstrap = new ServerBootstrap()
                .group(new NioEventLoopGroup(controlServerConfig.getNioThreadCount()), new NioEventLoopGroup())
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 1024)
                .option(ChannelOption.SO_REUSEADDR, true)
                .childOption(ChannelOption.SO_KEEPALIVE, false)
                .childOption(ChannelOption.TCP_NODELAY, true)
                .childOption(ChannelOption.SO_SNDBUF, 65535)
                .childOption(ChannelOption.SO_RCVBUF, 65535)
                .childHandler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) throws Exception {
                        ch.pipeline().addLast(new IdleStateHandler(
                                0, 0, controlServerConfig.getServiceOfflineTtl()));

                        ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(
                                NameserverSystemConstants.MAX_FRAME_LENGTH, 0,
                                4, 0, 4));

                        ch.pipeline().addLast(new LengthFieldPrepender(4));

                        ch.pipeline().addLast(new RemotingCommandDecoder());
                        ch.pipeline().addLast(new RemotingCommandEncoder());
                        ch.pipeline().addLast(processorAdaptor);
                    }
                });

        updateNameServerState(INIT_FINISH);
    }

    /**
     * 启动
     *
     * @throws ControlServerException NameserverStartException
     */
    public ChannelFuture start() throws ControlServerException {
        log.info("start nameserver [{}], configuration:\n {}",
                controlServerConfig.getServiceInstance(), controlServerConfig);

        try {
            nameserverChannelFuture = serverBootstrap.bind(
                    controlServerConfig.getServiceInstance().getHost(),
                    controlServerConfig.getServiceInstance().getPort()
            );

            nameserverChannelFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture channelFuture) throws Exception {
                    updateNameServerState(RUNNING);
                }
            });

            return nameserverChannelFuture;
        } catch (Exception e) {
            updateNameServerState(SHUT_DOWN);
            throw new ControlServerException("start error", e);
        }
    }

    /**
     * 添加自定义命令处理器
     *
     * @param commandKey           commandKey 命令标识
     * @param customRequestHandler customRequestHandler    处理器
     */
    public void addCustomCommandHandler(String commandKey, CustomRequestHandler customRequestHandler)
            throws CustomCommandException {
        customCommandProcessor.addCustomCommandHandler(commandKey, customRequestHandler);
    }

    /**
     * 调用自定义命令handler
     *
     * @param channel channel
     * @param request request
     * @return response
     */
    public RemotingCommand tryInvokeCustomCommand(Channel channel, RemotingCommand request) {
        RemotingCommand response = null;

        try {
            // Step 1 校验是否注册服务
            String key = channel.attr(NettyConstants.CLIENT_NAME).get();

            if (!registryService.existServiceInstance(key)) {
                log.debug("channel[{}] didn't registry, drop request [{}]", key, request);
                closeChannel(channel);
                return null;
            }

            // Step 2 运行自定义命令
            response = customCommandProcessor.tryInvokeCustomCommandHandler(channel, request);

            if (response.getTransactionId() == null) {
                response.setTransactionId(request.getTransactionId());
            }
        } catch (Exception e) {
            log.error("client custom command[{}] execute error", request, e);

            response = new RemotingCommand();
            response.setTransactionId(request.getTransactionId());
            response.setFlag(RemotingCommandFlagConstants.CUSTOM_COMMAND_RESPONSE);
            response.setCode(RemotingCommandCodeConstants.FAIL);
            response.setBody(Serializer.Algorithm.JDK.serialize(new RPCResultWrapper<>(null, e)));
        }

        return response;
    }
    /**
     * 给服务实例发送命令
     *
     * @param group           group
     * @param serviceId       serviceId
     * @param instanceId      instanceId
     * @param remotingCommand remotingCommand
     * @return CompletableFuture<RemotingCommand>
     */
    public CompletableFuture<RemotingCommand> sendCommandToServiceInstance(
        String group,
        String serviceId,
        String instanceId,
        RemotingCommand remotingCommand
    ) {
        String key = NameserverUtil.generateServiceInstanceKey(group, serviceId, instanceId);
        return sendCommandToServiceInstance(key, remotingCommand);
    }

    /**
     * 给服务实例发送命令
     *
     * @param key      key
     * @param remotingCommand remotingCommand
     * @return CompletableFuture<RemotingCommand>
     */
    public CompletableFuture<RemotingCommand> sendCommandToServiceInstance(
        String key, RemotingCommand remotingCommand
    ) {
        // Step 1 获取连接

        ConnectEntry connectEntry = connectionService.getServiceInstanceChannel(key);

        if (connectEntry == null || !connectEntry.isUsable()) {
            log.error("[{}] channel is unusable", key);
            return CompletableFuture.completedFuture(null);
        }

        return CompletableFuture.supplyAsync(() -> {
            try {
                CountDownLatch latch = new CountDownLatch(1);
                AtomicReference<RemotingCommand> result = new AtomicReference<>();

                // Step 2 注册请求
                boolean registry = processorAdaptor.registryRequest(remotingCommand, response -> {
                    result.set(response);
                    latch.countDown();
                });

                connectEntry.getChannel().writeAndFlush(remotingCommand);
                latch.await();

                // Step 3 没有注册到请求，说明只是发的消息，唤醒线程
                if (!registry) {
                    result.set(null);
                    latch.countDown();
                }
                return result.get();
            } catch (InterruptedException e) {
                throw new RuntimeException("send command %s error".formatted(remotingCommand), e);
            }
        }, executorService);
    }

    /**
     * 关闭连接某客户端的channel连接
     *
     * @param channel channel
     */
    public void closeChannel(Channel channel) {
        if (channel == null) {
            return;
        }

        String key = channel.attr(NettyConstants.CLIENT_NAME).get();

        if (registryService.existServiceInstance(key)) {
            connectionService.closeServiceChannel(channel, key);
        } else if (channel.isActive()) {
            channel.close();
        }
    }

    /**
     * 新建命令
     *
     * @param flag  flag
     * @return  RemotingCommand
     */
    public RemotingCommand newRemotingCommand(int flag, boolean needId) {
        RemotingCommand remotingCommand = new RemotingCommand();
        remotingCommand.setFlag(flag);
        ServiceInstance serviceInstance = controlServerConfig.getServiceInstance();
        remotingCommand.setGroup(serviceInstance.getGroup());
        remotingCommand.setServiceId(serviceInstance.getServiceId());
        remotingCommand.setClientId(serviceInstance.getInstanceId());
        remotingCommand.setTransactionId(needId ? nextTxId() : null);
        return remotingCommand;
    }

    public String nextTxId() {
        return DistributeIdMaker.DEFAULT.nextId(controlServerConfig.getServiceInstance().toString());
    }

    /**
     * 更新状态
     *
     * @param newState newState
     * @throws ControlServerException NameserverException
     */
    private void updateNameServerState(NameserverState newState) throws ControlServerException {
        synchronized (this) {
            boolean isUpdate = switch (newState) {
                case JUST_START: {
                    yield state == null || state == JUST_START;
                }
                case INIT_FINISH:
                    yield state == JUST_START || state == INIT_FINISH;
                case RUNNING:
                    yield state == INIT_FINISH;
                case SHUT_DOWN:
                    yield state != SHUT_DOWN;
            };

            if (isUpdate) {
                log.info("nameserver[{}] status updated [{}]->[{}]", controlServerConfig.getServiceInstance(), state,
                        newState);
                state = newState;
            } else {
                throw new ControlServerException("state cannot from [%s] to [%s]".formatted(state, newState));
            }
        }
    }
}
package cn.com.vortexa.control.server;

import cn.com.vortexa.control.BotControlServer;
import cn.com.vortexa.control.TestRpc;
import cn.com.vortexa.control.config.ControlServerConfig;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.ControlServerException;
import cn.com.vortexa.control.handler.CustomRequestHandler;
import cn.com.vortexa.control.protocol.Serializer;
import cn.com.vortexa.control.service.impl.FileRegistryService;
import cn.com.vortexa.control.service.impl.MemoryConnectionService;

import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.FileNotFoundException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Random;
import java.util.concurrent.ExecutionException;

class BotControlServerTest {

    private static final Logger log = LoggerFactory.getLogger(BotControlServerTest.class);
    static ControlServerConfig controlServerConfig;
    static BotControlServer botControlServer;
    static Random random = new Random();
    static ServiceInstance clientInstance = ServiceInstance
            .builder()
            .group("test1")
            .serviceId("client")
            .instanceId("client-1")
            .build();
    static int command_client = 3001;
    static int command_service = 3002;

    @BeforeAll
    public static void setUp() throws Exception {
        controlServerConfig = new ControlServerConfig();

        ServiceInstance address = ServiceInstance.builder()
                .group("default")
                .serviceId("sahara")
                .instanceId("sahara_test")
                .host("127.0.0.1")
                .port(8080)
                .build();


        controlServerConfig.setServiceInstance(address);
        botControlServer = new BotControlServer(ControlServerConfig.defaultConfig());
        botControlServer.init(new FileRegistryService(botControlServer.getExecutorService()), new MemoryConnectionService());
    }

    @Test
    public void test() throws ControlServerException, InterruptedException, CustomCommandException, ExecutionException, NoSuchMethodException {
        Class<TestRpc> rpcClass = TestRpc.class;
        String name = rpcClass.getName();
        Method testMethod = rpcClass.getMethod("test", String.class);
        TestRPCImpl testRPC = new TestRPCImpl();

        botControlServer.addCustomCommandHandler(name + "-" + testMethod.getName(), new CustomRequestHandler() {
            @Override
            public RequestHandleResult handlerRequest(RemotingCommand request) {
                log.warn("收到客户端自定义命令[{}]", request);
                byte[] body = request.getBody();
                RPCArgsWrapper params = Serializer.Algorithm.Protostuff.deserialize(body, RPCArgsWrapper.class);
                try {
                    return RequestHandleResult.success(testMethod.invoke(testRPC, params.getArgs()));
                } catch (IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(e);
                }
            }
        });

        botControlServer.start().get();

//        while (true) {
//            RemotingCommand remotingCommand = new RemotingCommand();
//            remotingCommand.setTransactionId(
//                    DistributeIdMaker.DEFAULT.nextId(nameserverServerConfig.getServiceInstance().toString())
//            );
//            remotingCommand.setFlag(command_service);
//            TimeUnit.SECONDS.sleep(5);
//
//            log.info("发送服务端自定义命令.{}", remotingCommand);
//            nameserverService.sendCommandToServiceInstance(
//                    clientInstance.getGroup(),
//                    clientInstance.getServiceId(),
//                    clientInstance.getInstanceId(),
//                    remotingCommand
//            ).thenAccept(response -> {
//                String deserialize = Serializer.Algorithm.Protostuff.deserialize(response.getBody(), String.class);
//                log.info("收到服务端自定义命令响应. {}\n{}", response, deserialize);
//            });
//        }

        Thread.sleep(10000000);
    }

    static class TestRPCImpl implements TestRpc {

        @Override
        public String test(String param) {
            return param + "-test-" + random.nextInt();
        }
    }
}
