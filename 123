package cn.com.vortexa.control.service.impl;

import cn.com.vortexa.common.dto.ScriptNodeRegisterInfo;
import cn.com.vortexa.control.constant.RegistryState;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.util.ControlServerUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONObject;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * @author helei
 * @since 2025-03-17
 */
@Slf4j
public class FileRegistryService implements IRegistryService {

    private static final String FILE_NAME = "nameserver-registry.json";
    private final ConcurrentHashMap<String, RegisteredService> registryServiceMap = new ConcurrentHashMap<>();
    private final AtomicBoolean updated = new AtomicBoolean(false);
    @Setter
    private int saveIntervalSecond = 60;
    private boolean running = true;

    public FileRegistryService(ExecutorService executorService) {
        executorService.execute(() -> {
            while (running) {
                try {
                    saveRegistryInfo();

                    TimeUnit.SECONDS.sleep(saveIntervalSecond);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                } catch (InterruptedException e) {
                    log.warn("registry file auto store task interrupted", e);
                    running = false;
                }
            }
        });
    }

    @Override
    public RegistryState registryService(ServiceInstance serviceInstance, ScriptNodeRegisterInfo scriptNodeRegisterInfo) {
        String group = serviceInstance.getGroup();
        String serviceId = serviceInstance.getServiceId();
        String clientId = serviceInstance.getInstanceId();

        if (StrUtil.isBlank(group) && StrUtil.isBlank(serviceId) && StrUtil.isBlank(clientId)) {
            return RegistryState.PARAM_ERROR;
        }

        try {
            String key = ControlServerUtil.generateServiceInstanceKey(group, serviceId, clientId);

            // 存内存
            registryServiceMap.put(key, new RegisteredService(serviceInstance, scriptNodeRegisterInfo, LocalDateTime.now()));
            updated.set(true);

            // 存磁盘
            Boolean b = null;
            try {
                b = saveRegistryInfo();
                return BooleanUtil.isTrue(b) ? RegistryState.OK : RegistryState.STORE_ERROR;
            } catch (Exception e) {
                log.error("store registry error", e);
                return RegistryState.STORE_ERROR;
            }
        } catch (Exception e) {
            log.error("registry config error", e);
            return RegistryState.UNKNOWN_ERROR;
        }
    }

    @Override
    public Boolean saveRegistryInfo() throws IOException {
        if (updated.compareAndSet(true, false)) {
            log.info("start save registry info - [{}]", registryServiceMap.keySet());

            Path path = Paths.get(ControlServerUtil.getStoreFileResourcePath(FILE_NAME));
            if (!Files.exists(path.getParent())) {
                Files.createDirectories(path.getParent());
            }

            try (BufferedWriter bw = new BufferedWriter(new FileWriter(path.toFile()))) {
                bw.write(JSONObject.toJSONString(registryServiceMap));
                bw.flush();
                return true;
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else {
            log.debug("no update cancel save registry info to file");
            return true;
        }
    }

    @Override
    public List<RegisteredService> queryServiceInstance(ServiceInstance query) {
        return queryServiceInstance(query.getGroup(), query.getServiceId(), query.getInstanceId());
    }

    @Override
    public List<RegisteredService> queryServiceInstance(String target) {
        return registryServiceMap.keySet().stream().filter(key -> key.contains(target)).map(registryServiceMap::get).toList();
    }

    @Override
    public List<RegisteredService> queryServiceInstance(
            String groupId,
            String serviceId,
            String clientId
    ) {
        String keyPattern = ControlServerUtil.generateServiceInstanceKey(
            groupId,
            serviceId,
            clientId
        );

        return queryServiceInstance(keyPattern);
    }

    @Override
    public boolean existServiceInstance(String key) {
        return registryServiceMap.containsKey(key);
    }
}
package cn.com.vortexa.control.service;

import cn.com.vortexa.common.dto.ScriptNodeRegisterInfo;
import cn.com.vortexa.control.constant.RegistryState;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.common.dto.control.ServiceInstance;

import java.io.IOException;
import java.util.List;

/**
 * @author helei
 * @since 2025-03-17
 */
public interface IRegistryService {

    /**
     * 注册服务
     *
     * @param serviceInstance serviceInstance
     * @return 注册状态
     */
    RegistryState registryService(ServiceInstance serviceInstance, ScriptNodeRegisterInfo scriptNodeRegisterInfo);

    /**
     * 保存注册信息
     *
     * @return Boolean
     */
    Boolean saveRegistryInfo() throws IOException;

    /**
     * 查询服务实例
     *
     * @param query query
     * @return List<RegisteredService>
     */
    List<RegisteredService> queryServiceInstance(ServiceInstance query);

    /**
     * 查找服务实例
     *
     * @param key key
     * @return List<ServiceInstance>
     */
    List<RegisteredService> queryServiceInstance(
        String key
    );

    /**
     * 查找服务实例
     *
     * @param groupId groupId
     * @param serviceId serviceId
     * @param clientId clientId
     * @return List<ServiceInstance>
     */
    List<RegisteredService> queryServiceInstance(
        String groupId,
        String serviceId,
        String clientId
    );

    /**
     * 是否存在已注册的实例
     *
     * @param key key
     * @return boolean
     */
    boolean existServiceInstance(String key);
}
package cn.com.vortexa.common.dto.control;


import cn.com.vortexa.common.dto.ScriptNodeRegisterInfo;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Objects;

/**
 * @author helei
 * @since 2025-03-12
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class RegisteredService {

    private ServiceInstance address;

    private ScriptNodeRegisterInfo scriptNodeRegisterInfo;

    private LocalDateTime registerDatetime;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RegisteredService that = (RegisteredService) o;
        return Objects.equals(address, that.address);
    }

    @Override
    public int hashCode() {
        return Objects.hash(address);
    }
}
package cn.com.vortexa.common.dto.control;

import lombok.*;

import java.io.Serial;
import java.io.Serializable;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class ServiceInstance implements Serializable {

    @Serial
    private static final long serialVersionUID = 189273891273821798L;

    private String group;

    private String serviceId;

    private String instanceId;

    private String host;

    private int port;

    @Override
    public String toString() {
        return "[%s][%s][%s]-[%s:%s]".formatted(group, serviceId, instanceId, host, port);
    }
}
vortexa:
  bot-instance:
    botKey: 'optim_ai_test'
    className: 'cn.com.vortexa.script_bot.depin.optimai.OptimAIBot'
    classFileName: 'OptimAIBot.java'
    accountConfig:
      configFilePath: "D://workspace//Vortexa-dev_3.0//botData//config//app//optim_ai_google.xlsx"
    customConfig:
      invite_code: "WSJQRJD5CB"
      two_captcha_api_key: "1231235"


package cn.com.vortexa.bot_platform.script_control.service;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.bot_platform.service.IScriptNodeService;
import cn.com.vortexa.common.dto.ScriptNodeRegisterInfo;
import cn.com.vortexa.common.dto.control.RegisteredService;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.control.constant.RegistryState;
import cn.com.vortexa.control.service.IRegistryService;
import cn.com.vortexa.control.util.ControlServerUtil;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * 数据库注册服务
 *
 * @author h30069248
 * @since 2025/4/8 17:37
 */
@Slf4j
public class DBRegistryService implements IRegistryService {

    private final IScriptNodeService scriptNodeService;
    private final ConcurrentHashMap<String, RegisteredService> registryServiceMap = new ConcurrentHashMap<>();
    private final AtomicBoolean updated = new AtomicBoolean(false);
    private int saveIntervalSecond = 60;
    private boolean running = true;

    public DBRegistryService(IScriptNodeService scriptNodeService, ExecutorService executorService) {
        this.scriptNodeService = scriptNodeService;

        executorService.execute(() -> {
            while (running) {
                try {
                    saveRegistryInfo();

                    TimeUnit.SECONDS.sleep(saveIntervalSecond);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                } catch (InterruptedException e) {
                    log.warn("registry file auto store task interrupted", e);
                    running = false;
                }
            }
        });
    }

    @Override
    public RegistryState registryService(ServiceInstance serviceInstance, ScriptNodeRegisterInfo scriptNodeRegisterInfo) {
        return null;
    }

    @Override
    public Boolean saveRegistryInfo() throws IOException {
        if (updated.compareAndSet(true, false)) {
            log.info("start save registry info - [{}]", registryServiceMap.keySet());

        } else {
            log.debug("no update cancel save registry info to file");
            return true;
        }
    }

    @Override
    public List<RegisteredService> queryServiceInstance(ServiceInstance query) {
        return List.of();
    }

    @Override
    public List<RegisteredService> queryServiceInstance(String key) {
        return List.of();
    }

    @Override
    public List<RegisteredService> queryServiceInstance(String groupId, String serviceId, String clientId) {
        return List.of();
    }

    @Override
    public boolean existServiceInstance(String key) {
        return false;
    }
}
package cn.com.vortexa.bot_platform.service;

import com.baomidou.mybatisplus.extension.service.IService;

import cn.com.vortexa.common.entity.ScriptNode;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
public interface IScriptNodeService extends IService<ScriptNode> {

}
package cn.com.vortexa.common.entity;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;

import lombok.Getter;
import lombok.Setter;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@Getter
@Setter
@TableName("t_script_node")
public class ScriptNode implements Serializable {
    @Serial
    private static final long serialVersionUID = -1023437865743897341L;

    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    @TableField("group")
    private String group;

    @TableField("service_id")
    private String serviceId;

    @TableField("instance_id")
    private String instanceId;

    @TableField("host")
    private String host;

    @TableField("port")
    private Integer port;

    @TableField("bot_group")
    private String botGroup;

    @TableField("description")
    private String description;

    @TableField("config")
    private String config;

    @TableField("insert_datetime")
    private LocalDateTime insertDatetime;

    @TableField("update_datetime")
    private LocalDateTime updateDatetime;

    @TableField("valid")
    private Boolean valid;
}
package cn.com.vortexa.bot_platform.controller;

import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@RestController
@RequestMapping("/core/scriptNode")
public class ScriptNodeController {

}
package cn.com.vortexa.bot_platform.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;

import cn.com.vortexa.common.entity.ScriptNode;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
public interface ScriptNodeMapper extends BaseMapper<ScriptNode> {

}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.helei.bot.core.mapper.ScriptNodeMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.helei.bot.core.entity.ScriptNode">
        <id column="id" property="id" />
        <result column="group" property="group" />
        <result column="service_id" property="serviceId" />
        <result column="instance_id" property="instanceId" />
        <result column="host" property="host" />
        <result column="port" property="port" />
        <result column="bot_group" property="botGroup" />
        <result column="description" property="description" />
        <result column="config" property="config" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="valid" property="valid" />
    </resultMap>

</mapper>
package cn.com.vortexa.bot_platform.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;

import cn.com.vortexa.bot_platform.service.IScriptNodeService;
import cn.com.vortexa.common.entity.ScriptNode;
import cn.com.vortexa.bot_platform.mapper.ScriptNodeMapper;
import org.springframework.stereotype.Service;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@Service
public class ScriptNodeServiceImpl extends ServiceImpl<ScriptNodeMapper, ScriptNode> implements IScriptNodeService {

}
