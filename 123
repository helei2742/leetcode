package cn.com.vortexa.script_node.scriptagent;

import cn.com.vortexa.common.constants.BotExtFieldConstants;
import cn.com.vortexa.common.constants.BotRemotingCommandFlagConstants;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.com.vortexa.common.entity.ScriptNode;
import cn.com.vortexa.control.ScriptAgent;
import cn.com.vortexa.control.config.ScriptAgentConfig;
import cn.com.vortexa.control.constant.RemotingCommandCodeConstants;
import cn.com.vortexa.control.dto.RPCArgsWrapper;
import cn.com.vortexa.control.dto.RPCServiceInfo;
import cn.com.vortexa.control.dto.RemotingCommand;
import cn.com.vortexa.control.dto.RequestHandleResult;
import cn.com.vortexa.control.exception.CustomCommandException;
import cn.com.vortexa.control.exception.CustomCommandInvokeException;
import cn.com.vortexa.common.util.protocol.Serializer;
import cn.com.vortexa.control.util.ControlServerUtil;
import cn.com.vortexa.control.util.RPCMethodUtil;
import cn.com.vortexa.script_node.bot.AutoLaunchBot;
import cn.com.vortexa.script_node.config.ScriptNodeConfiguration;
import cn.hutool.core.util.BooleanUtil;
import lombok.extern.slf4j.Slf4j;

import java.lang.reflect.Method;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicInteger;

import javax.net.ssl.SSLException;

/**
 * @author helei
 * @since 2025/3/26 16:56
 */
@Slf4j
public class BotScriptAgent extends ScriptAgent {

    private final AtomicInteger initCount = new AtomicInteger(0);   // 启动次数
    private final BotScriptAgentLogUploadService logUploadService = new BotScriptAgentLogUploadService(this);  // 日志上传服务
    private final Map<String, BotInstanceMetaInfo> runningBotMap = new HashMap<>(); // key map bot
    private final String scriptNodeName;
    private final List<RPCServiceInfo<?>> rpcServiceInfos;  // RPC方法信息

    public BotScriptAgent(
            ScriptAgentConfig clientConfig,
            ScriptNodeConfiguration scriptNodeConfiguration,
            List<RPCServiceInfo<?>> rpcServiceInfos
    ) {
        super(clientConfig);
        super.setName(clientConfig.getServiceInstance().toString());
        super.setRegistryBodySetter(() -> {
            ServiceInstance serviceInstance = clientConfig.getServiceInstance();

            ScriptNode scriptNode = ScriptNode.generateFromServiceInstance(serviceInstance);
            scriptNode.setScriptNodeName(scriptNodeConfiguration.getScriptNodeName());
            scriptNode.setBotConfigMap(scriptNodeConfiguration.getBotKeyConfigMap());

            return scriptNode;
        });

        this.scriptNodeName = scriptNodeConfiguration.getScriptNodeName();
        this.rpcServiceInfos = rpcServiceInfos;
    }

    @Override
    protected void init() throws SSLException, URISyntaxException {
        super.init();

        if (initCount.getAndIncrement() > 0) {
            return;
        }

        // Step 1 RPC命令处理
        if (initRPCMethod()) return;

        // Step 2 其它命令处理
        customCommandInit();
    }

    /**
     * 初始化自定义命令
     */
    private void customCommandInit() {
        addCustomRemotingCommandHandler(
                BotRemotingCommandFlagConstants.START_UP_BOT_LOG,
                logUploadService::startUploadLogRCHandler
        );
        addCustomRemotingCommandHandler(
                BotRemotingCommandFlagConstants.STOP_UP_BOT_LOG,
                logUploadService::stopUploadLogRCHandler
        );
        addCustomRemotingCommandHandler(
                BotRemotingCommandFlagConstants.START_BOT_JOB,
                (channel, remotingCommand) -> startOrParsedBotJob(remotingCommand)
        );
    }

    /**
     * 初始化rpc方法
     *
     * @return 是否初始化成功
     */
    private boolean initRPCMethod() {
        if (rpcServiceInfos == null) {
            return true;
        }
        log.info("start registry rpc services");
        for (RPCServiceInfo<?> rpcServiceInfo : rpcServiceInfos) {
            Class<?> interfaces = rpcServiceInfo.getInterfaces();
            Object ref = rpcServiceInfo.getRef();

            for (Method method : interfaces.getDeclaredMethods()) {
                method.setAccessible(true);
                String key = RPCMethodUtil.buildRpcMethodKey(interfaces.getName(), method);

                try {
                    super.addCustomCommandHandler(key, request -> {
                        RequestHandleResult result = new RequestHandleResult();

                        log.debug("invoke rpc method[{}]", method.getName());
                        try {
                            byte[] body = request.getBody();
                            RPCArgsWrapper params = Serializer.Algorithm.JDK.deserialize(body, RPCArgsWrapper.class);
                            result.setData(method.invoke(ref, params.getArgs()));
                            result.setSuccess(true);
                            return result;
                        } catch (Exception e) {
                            log.error("invoke rpc method [{}] error", method.getName());
                            throw new CustomCommandInvokeException(e);
                        }
                    });
                } catch (CustomCommandException e) {
                    log.error("registry custom method error", e);
                }
            }
        }
        return false;
    }

    /**
     * 添加运行的bot 到script agent中
     *
     * @param botName botName
     * @param botKey  botKey
     * @param bot     bot
     */
    public void addRunningBot(String botName, String botKey, AutoLaunchBot<?> bot) {
        String key = ControlServerUtil.generateServiceInstanceKey(scriptNodeName, botName, botKey);

        if (runningBotMap.containsKey(key)) {
            throw new IllegalArgumentException("bot[%s][%s] exist".formatted(botName, botKey));
        }
        runningBotMap.put(key, new BotInstanceMetaInfo(bot));

        // 上报bot上线
        reportScriptBotOnLine(scriptNodeName, botName, botKey)
                .exceptionally(throwable -> {
                    log.error("bot[{}][{}]expose error", botName, botKey, throwable);
                    return false;
                });
    }

    /**
     * 移除正在运行的bot
     *
     * @param botName botName
     * @param botKey  botKey
     */
    public void removeRunningBot(String botName, String botKey) {
        String key = ControlServerUtil.generateServiceInstanceKey(scriptNodeName, botName, botKey);
        runningBotMap.remove(key);

        // 上报bot下线
        reportScriptBotOffLine(scriptNodeName, botName, botKey)
                .exceptionally(throwable -> {
                    log.error("bot[{}][{}] ffLine error", botName, botKey, throwable);
                    return false;
                });
    }


    /**
     * 根据bot实例key获取bot
     */
    public BotInstanceMetaInfo getBotMetaInfo(String botInstanceKey) {
        return runningBotMap.get(botInstanceKey);
    }

    /**
     * 将bot 上线上报到ControlServer
     *
     * @param botGroup botGroup
     * @param botName  botName
     * @param botKey   botKey
     * @return boolean
     */
    private CompletableFuture<Boolean> reportScriptBotOnLine(String botGroup, String botName, String botKey) {
        log.info("send report bot[{}][{}] on line command", botGroup, botName);
        // Step 1 生成命令
        RemotingCommand command = newRequestCommand(BotRemotingCommandFlagConstants.SCRIPT_BOT_ON_LINE, true);
        command.addExtField(BotExtFieldConstants.TARGET_GROUP_KEY, botGroup);
        command.addExtField(BotExtFieldConstants.TARGET_BOT_NAME_KEY, botName);
        command.addExtField(BotExtFieldConstants.TARGET_BOT_KEY_KEY, botKey);

        return sendRequest(command)
                .thenApply(response -> {
                    if (response.isSuccess()) {
                        log.info("report bot[{}][{}] online success", botGroup, botName);
                        return true;
                    } else {
                        return false;
                    }
                });
    }

    /**
     * 上报bot下线
     *
     * @param botGroup botGroup
     * @param botName  botName
     * @param botKey   botKey
     * @return CompletableFuture<Boolean>
     */
    private CompletableFuture<Boolean> reportScriptBotOffLine(String botGroup, String botName, String botKey) {
        log.warn("send report bot[{}][{}] offline command", botGroup, botName);
        // Step 1 生成命令
        RemotingCommand command = newRequestCommand(BotRemotingCommandFlagConstants.SCRIPT_BOT_OFF_LINE, true);
        command.addExtField(BotExtFieldConstants.TARGET_GROUP_KEY, botGroup);
        command.addExtField(BotExtFieldConstants.TARGET_BOT_NAME_KEY, botName);
        command.addExtField(BotExtFieldConstants.TARGET_BOT_KEY_KEY, botKey);

        return sendRequest(command)
                .thenApply(response -> {
                    if (response.isSuccess()) {
                        log.warn("report bot[{}][{}] offline success", botGroup, botName);
                        return true;
                    } else {
                        return false;
                    }
                });
    }


    /**
     * 启动或暂停bot
     *
     * @param remotingCommand remotingCommand
     * @return RemotingCommand
     */
    private RemotingCommand startOrParsedBotJob(RemotingCommand remotingCommand) {
        String botName = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_NAME_KEY);
        String botKey = remotingCommand.getExtFieldsValue(BotExtFieldConstants.TARGET_BOT_KEY_KEY);
        String jobName = remotingCommand.getExtFieldsValue(BotExtFieldConstants.JOB_NAME);

        // Step 1 生成key，从map中查找存在的bot
        String key = ControlServerUtil.generateServiceInstanceKey(scriptNodeName, botName, botKey);

        RemotingCommand response = new RemotingCommand();
        response.setCode(RemotingCommandCodeConstants.FAIL);

        BotInstanceMetaInfo botMetaInfo = runningBotMap.get(key);

        // 不存在，返回
        if (botMetaInfo == null) {
            response.setErrorMessage(key + " not found in script node");
            return response;
        }

        AutoLaunchBot<?> bot = botMetaInfo.getBot();

        // 存在则尝试调用方法启动
        BotACJobResult botACJobResult = bot.startBotJob(jobName);
        if (BooleanUtil.isTrue(botACJobResult.getSuccess())) {
            response.setCode(RemotingCommandCodeConstants.SUCCESS);
            bot.logger.debug("start/parsed job[%s] success".formatted(jobName));
        } else {

            bot.logger.error("start/parsed job[%s] fail".formatted(jobName));
        }

        response.setBody(Serializer.Algorithm.JDK.serialize(botACJobResult));
        return response;
    }
}
create table t_script_node
(
    id              bigint auto_increment
        primary key,
    group_id        varchar(255)                         null,
    service_id      varchar(255)                         null,
    instance_id     varchar(255)                         null,
    host            varchar(255)                         null,
    port            int                                  null,
    script_node_name       varchar(255)                         null,
    description     text                                 null,
    bot_config_map  text                                 null,
    params          text                                 null,
    insert_datetime datetime   default CURRENT_TIMESTAMP null,
    update_datetime datetime   default CURRENT_TIMESTAMP null on update CURRENT_TIMESTAMP,
    valid           tinyint(1) default 1                 null,
    constraint `group`
        unique (group_id, service_id, instance_id)
);

package cn.com.vortexa.common.util;

import cn.com.vortexa.common.constants.FilePathType;

import java.io.*;
import java.nio.file.Path;
import java.util.List;

public class FileUtil {

    public static final List<String> CONFIG_DIR_BOT_PATH = List.of("config", "bot");

    public static final List<String> CONFIG_DIR_APP_PATH = List.of("config", "app");

    /**
     * app资源根目录
     */
    public static final String RESOURCE_ROOT_DIR = System.getProperty("user.dir") + File.separator + "botData";

    /**
     * 获取配置文件
     *
     * @param path     子路径
     * @param fileName 文件名
     * @return 绝对路径
     */
    public static String getAppResourcePath(List<String> path, String fileName) {
        StringBuilder sb = new StringBuilder(RESOURCE_ROOT_DIR);

        for (String p : path) {
            sb.append(File.separator).append(p);
        }
        return sb.append(File.separator).append(fileName).toString();
    }

    /**
     * 获取app配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + "config";
    }

    /**
     * 获取app配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceAppConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, CONFIG_DIR_APP_PATH);
    }

    /**
     * 获取系统配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceSystemConfigPath() {
        return RESOURCE_ROOT_DIR + File.separator + String.join(File.separator, CONFIG_DIR_BOT_PATH);
    }


    /**
     * 获取系统配置目录
     *
     * @return 配置目录绝对路径
     */
    public static String getAppResourceDataPath() {
        return RESOURCE_ROOT_DIR + File.separator + "data";
    }

    /**
     * 生成绝对路径
     *
     * @param patternPath             patternPath
     * @param botInstanceResourcePath botInstanceResourcePath
     * @return 绝对路径
     */
    public static String generateAbsPath(String patternPath, String botInstanceResourcePath) {
        FilePathType filePathType = FilePathType.resolveFilePathType(patternPath);
        return switch (filePathType) {
            case absolute -> {
                if (patternPath.startsWith(filePathType.name())) {
                    yield patternPath.replace("absolute:", "");
                }
                yield patternPath;
            }
            case instance_resource ->
                    patternPath.replace("instance_resource:", botInstanceResourcePath + File.separator);
            case app_resource -> patternPath.replace("app_resource:", RESOURCE_ROOT_DIR + File.separator);
            case app_resource_config ->
                    patternPath.replace("app_resource_config:", getAppResourceAppConfigPath() + File.separator);
            case app_resource_data ->
                    patternPath.replace("app_resource_data:", getAppResourceDataPath() + File.separator);
        };
    }

    /**
     * 保存
     */
    public static void saveJSONStringContext(Path filePath, String jsonContext) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath.toFile()))) {
            writer.write(jsonContext);
            writer.flush();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
package cn.com.vortexa.common.entity;

import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.dto.control.ServiceInstance;
import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-04-08
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_script_node")
@EqualsAndHashCode(callSuper = true)
public class ScriptNode extends ServiceInstance implements Serializable {
    @Serial
    private static final long serialVersionUID = -1023437865743897341L;

    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    @TableField("script_node_name")
    private String scriptNodeName;

    @TableField("description")
    private String description;

    @TableField("bot_config_map")
    private Map<String, AutoBotConfig> botConfigMap;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer valid;

    public boolean usable() {
       return StrUtil.isNotBlank(groupId) && StrUtil.isNotBlank(serviceId) && StrUtil.isNotBlank(instanceId)
               && StrUtil.isNotBlank(host) && port != null && StrUtil.isNotBlank(scriptNodeName);
    }

    public static ScriptNode generateFromServiceInstance(ServiceInstance serviceInstance) {
        ScriptNode scriptNode = new ScriptNode();
        scriptNode.setHost(serviceInstance.getHost());
        scriptNode.setPort(serviceInstance.getPort());
        scriptNode.setGroupId(serviceInstance.getGroupId());
        scriptNode.setServiceId(serviceInstance.getServiceId());
        scriptNode.setInstanceId(serviceInstance.getInstanceId());

        return scriptNode;
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.ScriptNodeMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="cn.com.vortexa.common.entity.ScriptNode">
        <id column="id" property="id" />
        <result column="group_id" property="groupId" />
        <result column="service_id" property="serviceId" />
        <result column="instance_id" property="instanceId" />
        <result column="host" property="host" />
        <result column="port" property="port" />
        <result column="script_node_name" property="scriptNodeName" />
        <result column="description" property="description" />
        <result column="bot_config_map" property="botConfigMap" />
        <result column="params" property="params" />
        <result column="insert_datetime" property="insertDatetime" />
        <result column="update_datetime" property="updateDatetime" />
        <result column="valid" property="valid" />
    </resultMap>

    <insert id="insertOrUpdate">
        INSERT INTO t_script_node
        (group_id, service_id, instance_id, host, port, script_node_name, description, bot_config_map, params, update_datetime,  valid)
        VALUES (
                #{groupId}, #{serviceId}, #{instanceId}, #{host}, #{port}, #{scriptNodeName}, #{description}, #{botConfigMap}, #{params},  current_timestamp, 1
        ) ON DUPLICATE KEY  UPDATE
        <trim suffixOverrides=",">
            <if test="groupId != null">
                group_id = values(group_id),
            </if>
            <if test="serviceId != null">
                service_id = values(service_id),
            </if>
            <if test="instanceId != null">
                instance_id = values(instance_id),
            </if>
            <if test="host != null">
                host = values(host),
            </if>
            <if test="port != null">
                port = values(port),
            </if>
            <if test="scriptNodeName != null">
                script_node_name = values(script_node_name),
            </if>
            <if test="description != null">
                description = values(description),
            </if>
            <if test="botConfigMap != null">
                bot_config_map = values(bot_config_map),
            </if>
            <if test="params != null">
                params = values(params),
            </if>
            update_datetime = values(update_datetime),
            valid = values(valid),
        </trim>
    </insert>
</mapper>
