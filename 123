config/vorexa-config.ts
export enum BotInstanceStatus {
  ALL = '',
  RUNNING = 'RUNNING',
  STOPPED = 'STOPPED',
  UN_USABLE = 'UN_USABLE'
}

export const WS_CONNECT_URL:string = 'ws://localhost:10110/websocket/test'
export const API_BASE_URL: string = 'http://localhost:10110'
export const API_TIME_OUT: number = 5000

export const API_DEFAULT_PAGE: number = 1
export const API_DEFAULT_PAGE_SIZE: number = 20

export const PAGINATION_PAGE_SIZES: number[] = [20, 50, 100, 200, 400];


vorexa-type.ts

/**
 * åŸºç¡€è´¦æˆ·ä¿¡æ¯
 */
export class AccountBaseInfo {
  id: number
  type: string
  name: string
  email: string
  password: string
  params: Map<string, object>
  insertDatetime: string
  updateDatetime: string

  public constructor({
                       id,
                       type,
                       name,
                       email,
                       password,
                       params,
                       insertDatetime,
                       updateDatetime
                     }: {
    id: number,
    type: string,
    name: string,
    email: string,
    password: string,
    params: Map<string, object>,
    insertDatetime: string,
    updateDatetime: string
  }) {
    this.id = id
    this.type = type
    this.name = name
    this.email = email
    this.password = password
    this.params = params
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}


/**
 * twitterä¿¡æ¯
 */
export class TwitterInfo {
  id: number
  username: string
  password: string
  email: string
  emailPassword: string
  token: string
  f2aKey: string
  params: Map<string, object>
  insertDatetime: string
  updateDatetime: string

  public constructor({
                       id,
                       username,
                       password,
                       email,
                       emailPassword,
                       params,
                       token,
                       f2aKey,
                       insertDatetime,
                       updateDatetime
                     }: {
    id: number,
    username: string,
    password: string,
    email: string,
    emailPassword: string,
    params: Map<string, object>,
    token: string,
    f2aKey: string,
    insertDatetime: string,
    updateDatetime: string
  }) {
    this.id = id
    this.username = username
    this.password = password
    this.email = email
    this.emailPassword = emailPassword
    this.params = params
    this.token = token
    this.f2aKey = f2aKey
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}

/**
 * discordä¿¡æ¯
 */
export class DiscordInfo {
  id: number
  username: string
  password: string
  bindEmail: string
  bindEmailPassword: string
  token: string
  f2aKey: string
  params: Map<string, object>
  insertDatetime: string
  updateDatetime: string

  public constructor({
                       id,
                       username,
                       password,
                       bindEmail,
                       bindEmailPassword,
                       params,
                       token,
                       f2aKey,
                       insertDatetime,
                       updateDatetime
                     }:{
    id:number,
    username:string,
    password:string,
    bindEmail:string,
    bindEmailPassword:string,
    params:Map<string, object>,
    token:string,
    f2aKey:string,
    insertDatetime:string,
    updateDatetime:string
  }) {
    this.id = id
    this.username = username
    this.password = password
    this.bindEmail = bindEmail
    this.bindEmailPassword = bindEmailPassword
    this.params = params
    this.token = token
    this.f2aKey = f2aKey
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}

/**
 * proxyä¿¡æ¯
 */
export class ProxyInfo {
  id: number
  username: string
  password: string
  proxyType: string
  proxyProtocol: string
  host: string
  port: number
  params: Map<string, object>
  insertDatetime: string
  updateDatetime: string

  public constructor({
                       id,
                       host,
                       port,
                       username,
                       password,
                       proxyType,
                       proxyProtocol,
                       params,
                       insertDatetime,
                       updateDatetime
                     }:{
    id:number,
    host:string,
    port:number,
    username:string,
    password:string,
    proxyType:string,
    proxyProtocol:string,
    params:Map<string, object>,
    insertDatetime:string,
    updateDatetime:string
  }) {
    this.id = id
    this.host = host
    this.port = port
    this.username = username
    this.password = password
    this.proxyType = proxyType
    this.proxyProtocol = proxyProtocol
    this.params = params
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}

/**
 * proxyä¿¡æ¯
 */
export class BrowserEnv {
  id: number
  userAgent: string
  otherHeader: Map<string, object>
  insertDatetime: string
  updateDatetime: string

  public constructor({
                       id,
                       userAgent,
                       otherHeader,
                       insertDatetime,
                       updateDatetime
                     }:{
    id:number, userAgent:string, otherHeader:Map<string, object>, insertDatetime:string, updateDatetime:string
  }) {
    this.id = id
    this.userAgent = userAgent
    this.otherHeader = otherHeader
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}


/**
 * Bot å®ä¾‹ä¿¡æ¯
 */
export class BotInstanceInfo {
  id?: number
  botId?: number
  botName: string
  botKey: string
  botStatus: number // 0 æœªè¿è¡Œ 1 æ­£åœ¨è¿è¡Œ -1 å‘Šè­¦
  runningTask: Array<string>
  accountTableName?: string
  jobParams: Map<string, object>
  params: Map<string, object>
  insertDatetime?: string
  updateDatetime?: string
  botInfo?: object

  public constructor({
                       id,
                       botId,
                       botName,
                       botKey,
                       botStatus,
                       runningTask,
                       accountTableName,
                       jobParams,
                       params,
                       insertDatetime,
                       updateDatetime,
                       botInfo
                     }
                       : {
                       id?: number,
                       botId?: number,
                       botName?: string,
                       botKey?: string,
                       botStatus?: number,
                       runningTask?: Array<string>,
                       accountTableName?: string,
                       jobParams?: Map<string, object>,
                       params?: Map<string, object>,
                       insertDatetime?: string,
                       updateDatetime?: string,
                       botInfo?: BotInfo
                     }
  ) {
    this.id = id
    this.botId = botId
    this.botName = botName ? botName : 'unknown_bot'
    this.botKey = botKey ? botKey : 'unknown_instance'
    this.botStatus = botStatus !== undefined ? botStatus : -1
    this.runningTask = runningTask ? runningTask : new Array<string>()
    this.accountTableName = accountTableName
    this.jobParams = jobParams ? jobParams : new Map<string, object>()
    this.params = params ? params : new Map<string, object>()
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
    this.botInfo = botInfo
  }
}

/**
 * Bot ä¿¡æ¯
 */
export class BotInfo {
  id?: number
  name: string
  describe: string
  image?: string
  jobParams: Map<string, object>
  params: Map<string, object>
  insertDatetime?: string
  updateDatetime?: string

  constructor({id, name, describe, image, jobParams, params, insertDatetime, updateDatetime}
                : {
                id?: number,
                name?: string,
                describe?: string,
                image?: string,
                jobParams?: Map<string, object>,
                params?: Map<string, object>,
                insertDatetime?: string,
                updateDatetime?: string
              }
  ) {
    this.id = id
    this.name = name ? name : 'unknown_bot'
    this.describe = describe ? describe : ''
    this.image = image
    this.jobParams = jobParams ? jobParams : new Map<string, object>()
    this.params = params ? params : new Map<string, object>()
    this.insertDatetime = insertDatetime
    this.updateDatetime = updateDatetime
  }
}


vortexa-type-common

import {API_DEFAULT_PAGE, API_DEFAULT_PAGE_SIZE} from "@/config/vortexa-config.ts";
import {util} from "protobufjs";
import codegen = util.codegen;

/**
 * ä¸Šä¼ å®ä½“
 */
export class UploadEntry {
  rawLines: Array<Map<string, object>>

  constructor(rawLines: Array<Map<string, object>>) {
    this.rawLines = rawLines
  }
}

/**
 * Http å“åº”å®ä½“
 */
export class Result<T> {
  success: boolean
  errorMsg: string
  data: T

  constructor({success, errorMsg, data}: { success: boolean, errorMsg: string, data: T }) {
    this.success = success
    this.errorMsg = errorMsg
    this.data = data
  }
}

export class PageQuery {
  page: number = API_DEFAULT_PAGE
  limit: number = API_DEFAULT_PAGE_SIZE
  filterMap?: Map<string, object>

  constructor({page, limit, filterMap}: {
    page?: number,
    limit?: number,
    filterMap?: Map<string, object>
  }) {
    this.page = page == undefined ? API_DEFAULT_PAGE : page
    this.limit = limit == undefined ? API_DEFAULT_PAGE_SIZE : limit
    this.filterMap = filterMap
  }
}

/**
 * åˆ†é¡µå“åº”å®ä½“
 */
export class PageResult<T> {
  total: number;
  list: Array<T>;
  pages: number;
  pageNum: number;
  pageSize: number;

  constructor({total, pages, pageNum, pageSize, list}: {
    total: number,
    pages: number,
    pageNum: number,
    pageSize: number,
    list: Array<T>
  }) {
    this.total = total
    this.pages = pages
    this.pageNum = pageNum
    this.pageSize = pageSize
    this.list = list
  }
}

/**
 * websocket å‘é€çš„æ¶ˆæ¯
 */
export class WebSocketMessage {
  code: number
  success: boolean
  content: string

  constructor({code, success, content}: {
    code: number,
    success: boolean,
    content: string
  }) {
    this.code = code
    this.success = success
    this.content = content
  }
}


import ReconnectingWebSocket from "reconnecting-websocket";
import {WebSocketMessage} from "@/types/vortexa-type-common.ts";
import * as Events from "reconnecting-websocket/events.ts";

export class WebSocketClient {
  url: string
  ws: ReconnectingWebSocket | undefined
  messageHandlers: WebsocketMessageHandler[]

  constructor(url: string) {
    this.url = url;
    this.ws = undefined
    this.messageHandlers = [];
  }

  // è¿æ¥ WebSocket
  connect():void {
    if (this.ws) this.ws.close();

    this.ws = new ReconnectingWebSocket(this.url, undefined, {
      debug: true
    });

    this.ws.onopen =this.onOpen
    this.ws.onmessage = this.handleMessage
    this.ws.onerror = this.onError
    this.ws.onclose = this.onClose
  }

  // å¤„ç†æ¥æ”¶æ¶ˆæ¯
  handleMessage(event:MessageEvent): void {
    if (event.data) {
      const data = event.data

      this.messageHandlers.forEach(
        handler =>
          handler.handle(new WebSocketMessage(JSON.parse(data)))
      );
    }
  }

  // æ³¨å†Œæ¶ˆæ¯å¤„ç†å‡½æ•°
  onMessage(handler: WebsocketMessageHandler):void {
    this.messageHandlers.push(handler);
  }

  // å‘é€æ¶ˆæ¯
  send(message: WebSocketMessage):void {
    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(message));
    } else {
      console.warn("ğŸš« WebSocket æœªè¿æ¥");
    }
  }

  onOpen(): void {
    console.log("âœ… WebSocket è¿æ¥æˆåŠŸ")
  }

  onError(event: Events.ErrorEvent): void {
    console.error("âŒ WebSocket é”™è¯¯:", event)
  }

  onClose(): void {
    console.log("ğŸ”Œ WebSocket å·²æ–­å¼€");
  }
}

export interface WebsocketMessageHandler {
  handle(message: WebSocketMessage): void
}
