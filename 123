package com.helei.binanceapi.constants;


/**
 * Binance WS 客户端的类型
 */
public enum BinanceWSClientType {
    /**
     * 请求、响应类型客户端
     */
    REQUEST_RESPONSE,
    /**
     * 市场行情推送流客户端
     */
    MARKET_STREAM,
    /**
     * 账户信息推送流客户端
     */
    ACCOUNT_STREAM,
}



package com.helei.binanceapi.supporter;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;


@Slf4j
public class BinanceWSStreamSupporter {


}




package com.helei.binanceapi;

import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


@Slf4j
public class BinanceWSAccountEventStreamClient extends AbstractBinanceWSApiClient {

    /**
     * baseUrl
     */
    private String baseUrl;

    /**
     * 账户消息流的listenKey
     */
    private String listenKey;


    public BinanceWSAccountEventStreamClient(
            String baseUrl,
            IpWeightSupporter ipWeightSupporter
    ) throws URISyntaxException {
        super(BinanceWSClientType.ACCOUNT_STREAM, baseUrl, ipWeightSupporter, new BinanceWSAccountStreamClientHandler());
        this.baseUrl = baseUrl;
    }

    @Override
    public CompletableFuture<Void> connect() {
        return CompletableFuture.runAsync(()->{
            log.info("账户事件推送流客户端, 调用connect()方法不会启动");
        });
    }

    public void startAccountEventStream(String listenKey) {
        this.listenKey = listenKey;
        super.url = baseUrl + "/" + listenKey;

        try {
            connect().get();

            log.info("币安账户信息流已开启，listenKey = [{}]", listenKey);
        } catch (Exception e) {
            log.error("连接币安服务器[{}}发生错误", url, e);
            throw new RuntimeException(String.format("连接币安服务器[%s]发生错误", url), e);
        }
    }
}


package com.helei.binanceapi;

import com.helei.binanceapi.api.ws.BinanceWSBaseApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.dto.ASKey;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

/**
 * 币安账户信息流推送客户端
 */
@Slf4j
public class BinanceWSAccountStreamClient extends AbstractBinanceWSApiClient {


    /**
     * stream url
     */
    private final String streamUrl;

    /**
     * 账户信息的asKey
     */
    @Getter
    private final ASKey asKey;

    /**
     * BaseApi，用来维护listenKey
     */
    private final BinanceWSBaseApi baseApi;

    /**
     * 当前的listenKey
     */
    @Getter
    private String listenKey;

    /**
     * 收到信息的回调
     */
    @Getter
    private final Consumer<AccountEvent> whenReceiveEvent;


    public BinanceWSAccountStreamClient(
            String streamUrl,
            IpWeightSupporter ipWeightSupporter,
            ASKey asKey,
            Consumer<AccountEvent> whenReceiveEvent,
            BinanceWSBaseApi baseApi
    ) throws URISyntaxException {
        super(BinanceWSClientType.ACCOUNT_STREAM, streamUrl, ipWeightSupporter, new BinanceWSAccountStreamClientHandler(whenReceiveEvent));
        this.streamUrl = streamUrl;
        this.whenReceiveEvent = whenReceiveEvent;
        this.asKey = asKey;
        this.baseApi = baseApi;

        setName("币安账户信息推送客户端-" + asKey.getApiKey().substring(0, 8));
    }

    /**
     * 开始获取账户信息流
     *
     * @return CompletableFuture<Boolean> 是否成功
     */
    public CompletableFuture<Boolean> startAccountInfoStream() {
        log.info("开始获取账户信息流， apiKey = [{}]", asKey.getApiKey());

        return baseApi
                .requestListenKey(asKey)//获取listenKey
                .thenApplyAsync(listenKey -> { //请求ws连接
                    log.info("listenKey = [{}]", listenKey);
                    if (listenKey == null) {
                        log.error("获取listenKey结果为null，");
                        return false;
                    }
                    this.listenKey = listenKey;
                    super.url = streamUrl + "/" + listenKey;
                    try {
                        connect().get();
                        log.info("账户信息流已开启，listenKey = [{}]", listenKey);
                        return true;
                    } catch (Exception e) {
                        log.error("连接服务器[{}}发生错误", url, e);
                    }
                    return false;
                });
    }


    /**
     * 延长listenKey的时间
     *
     * @return future
     */
    public CompletableFuture<String> lengthenListenKey() {
        return baseApi.lengthenListenKey(listenKey, asKey);
    }

}


package com.helei.binanceapi;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApiClientHandler;
import com.helei.binanceapi.constants.AccountEventType;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import java.util.function.Consumer;

/**
 * 币安账户信息流客户端处理消息的handler
 */
@Setter
@Slf4j
class BinanceWSAccountStreamClientHandler extends AbstractBinanceWSApiClientHandler {

    private Consumer<AccountEvent> whenReceiveEvent;

    @Override
    protected void handleResponseMessage(String id, JSONObject response) {
        log.warn("get an response, not stream message! [{}]", response);
    }

    @Override
    protected void handleStreamMessage(String streamName, JSONObject context) {
        if (whenReceiveEvent != null) {
            whenReceiveEvent.accept(AccountEventType.STATUS_MAP.get(context.getString("e")).getConverter().convertFromJsonObject(context));
        }
    }
}



package com.helei.binanceapi;

import com.helei.binanceapi.api.ws.*;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;


/**
 * 币安市场信息推送流客户端
 */
@Getter
@Slf4j
public class BinanceWSMarketStreamClient  extends AbstractBinanceWSApiClient {


    /**
     * stream流推送相关api
     */
    private final BinanceWSStreamApi streamApi;


    public BinanceWSMarketStreamClient(
            String url,
            IpWeightSupporter ipWeightSupporter
    ) throws URISyntaxException {
        super(BinanceWSClientType.MARKET_STREAM, url, ipWeightSupporter, new BinanceWSMarketStreamClientHandler());
        streamApi = new BinanceWSStreamApi(this);
    }
}


package com.helei.binanceapi;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApiClientHandler;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import lombok.extern.slf4j.Slf4j;

import java.util.Map;
import java.util.concurrent.ExecutorService;


@Slf4j
public class BinanceWSMarketStreamClientHandler extends AbstractBinanceWSApiClientHandler {



    @Override
    public void handleStreamMessage(String streamName, JSONObject context) {
        publishStreamResponse(streamName, context, websocketClient.getCallbackInvoker());
    }


    /**
     * 收到订阅的消息，执行相应的回调
     * 1.首先会优先使用 StreamSubscribeEntity中传入的线程池执行
     * 2.如果没有则会用AbstractBinanceWSApiClient中的线程池执行
     * 3.如果还没有，使用netty线程池执行
     *
     * @param streamName      streamName
     * @param message         message
     * @param callbackInvoker callbackInvoker
     */
    public void publishStreamResponse(String streamName, JSONObject message, ExecutorService callbackInvoker) {

        StreamSubscribeEntity subscribeEntity = subscribeMap.get(streamName);
        if (subscribeEntity == null) {
            log.error("No subscribe entity for stream type {}", streamName);
            return;
        }
        Map<String, Object> params = subscribeEntity.getParams();

        try {
            ExecutorService executor = subscribeEntity.getCallbackExecutor();
            if (executor != null) {
                executor.submit(() -> {
                    subscribeEntity.getInvocationHandler().invoke(streamName, params, message);
                });
            } else if (callbackInvoker != null) {
                callbackInvoker.submit(() -> {
                    subscribeEntity.getInvocationHandler().invoke(streamName, params, message);
                });
            } else {
                subscribeEntity.getInvocationHandler().invoke(streamName, params, message);
                log.warn("use netty thread pool execute, stream name [{}]", streamName);
            }
        } catch (Exception e) {
            log.error("publish stream response error, stream name[{}]", streamName, e);
        }
    }
}



package com.helei.binanceapi;

import com.helei.binanceapi.api.ws.*;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;

/**
 * 币安Websocket，请求-响应模式的api客户端
 */
@Getter
@Slf4j
public class BinanceWSReqRespApiClient extends AbstractBinanceWSApiClient {

    /**
     * 基础的api
     */
    private final BinanceWSBaseApi baseApi;

    /**
     * 行情相关的api
     */
    private final BinanceWSMarketApi marketApi;

    /**
     * 交易相关api
     */
    private final BinanceWSTradeApi tradeApi;

    /**
     * 现货账户api
     */
    private final BinanceWSSpotAccountApi spotAccountApi;

    /**
     * 合约账户api
     */
    private final BinanceWSContractAccountApi contractAccountApi;

    public BinanceWSReqRespApiClient(
            String url,
            IpWeightSupporter ipWeightSupporter
    ) throws URISyntaxException {
        super(BinanceWSClientType.REQUEST_RESPONSE, url, ipWeightSupporter, new BinanceWSReqRespApiClientHandler());
        baseApi = new BinanceWSBaseApi(this);
        marketApi = new BinanceWSMarketApi(this);
        tradeApi = new BinanceWSTradeApi(this);
        spotAccountApi = new BinanceWSSpotAccountApi(this);
        contractAccountApi = new BinanceWSContractAccountApi(this);
    }
}


package com.helei.binanceapi;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApiClientHandler;
import lombok.extern.slf4j.Slf4j;


@Slf4j
public class BinanceWSReqRespApiClientHandler extends AbstractBinanceWSApiClientHandler {

    @Override
    protected void handleStreamMessage(String streamName, JSONObject content) {
        log.warn("非流式客户端,收到了错误的消息, streamName[{}]-content[{}]", streamName, content);
    }
}

package com.helei.cexapi.client;

import cn.hutool.core.util.StrUtil;
import com.helei.binanceapi.BinanceWSAccountEventStreamClient;
import com.helei.binanceapi.BinanceWSMarketStreamClient;
import com.helei.binanceapi.BinanceWSReqRespApiClient;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.cexapi.manager.BinanceBaseWSClientManager;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import lombok.extern.slf4j.Slf4j;

import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

@Slf4j
public class BinanceWSEnvClient {

    private final static String DEFAULT_MARK = "default";

    private final RunEnv runEnv;

    private final TradeType tradeType;

    private final BinanceApiConfig.BinanceTypedUrl urlSet;

    private final ConcurrentMap<BinanceWSClientType, ConcurrentHashMap<String, AbstractBinanceWSApiClient>> typedApiClient;

    private final BinanceBaseWSClientManager clientManager;

    private final InetSocketAddress proxy;

    public BinanceWSEnvClient(RunEnv runEnv, TradeType tradeType, BinanceBaseWSClientManager clientManager) {
        this.runEnv = runEnv;
        this.tradeType = tradeType;
        this.clientManager = clientManager;

        BinanceApiConfig apiConfig = BinanceApiConfig.INSTANCE;
        this.urlSet = apiConfig.getEnvUrlSet(runEnv, tradeType);
        this.proxy = apiConfig.getProxy();

        this.typedApiClient = new ConcurrentHashMap<>();
    }

    /**
     * 获取或创建clientType类型的客户端
     *
     * @param clientType 客户端类型
     * @param mark       客户端标志，根据这个标志可以创建出多个同类型的客户端
     * @return 客户端
     */
    public AbstractBinanceWSApiClient getOrCreateTypedClient(BinanceWSClientType clientType, String mark) {
        if (StrUtil.isBlank(mark)) mark = DEFAULT_MARK;

        ConcurrentHashMap<String, AbstractBinanceWSApiClient> markMap = typedApiClient.compute(clientType, (k, v) -> {
            if (v == null) {
                v = new ConcurrentHashMap<>();
            }
            return v;
        });

        String finalMark = mark;

        AbstractBinanceWSApiClient apiClient = markMap.compute(mark, (k, v) -> {
            if (v == null) {
                try {
                    v = createClientByType(clientType, finalMark);
                } catch (URISyntaxException e) {
                    throw new RuntimeException(e);
                }
            }
            return v;
        });

        log.info("runEnv[{}]-tradeType[{}]获取到客户端[{}]-mark[{}]", runEnv, tradeType, clientType, mark);

        return apiClient;
    }

    /**
     * 根据类型创建客户端
     *
     * @param clientType 客户端类型
     * @param mark       标记
     * @return 客户端
     * @throws URISyntaxException 异常
     */
    private AbstractBinanceWSApiClient createClientByType(BinanceWSClientType clientType, String mark) throws URISyntaxException {
        AbstractBinanceWSApiClient client = switch (clientType) {
            case REQUEST_RESPONSE -> createReqRespApiClient();
            case MARKET_STREAM -> createMarketStreamApiClient();
            case ACCOUNT_STREAM -> createAccountStreamClient();
        };


        client.setName(mark);
        client.setProxy(proxy);

        return client;
    }

    /**
     * 创建账户事件流客户端
     *
     * @return BinanceWSAccountEventStreamClient
     */
    private BinanceWSAccountEventStreamClient createAccountStreamClient() throws URISyntaxException {
        String url = urlSet.getWs_account_info_stream_url();

        return new BinanceWSAccountEventStreamClient(url, clientManager.getIpWeightSupporter());
    }

    /**
     * 创建市场流数据客户端
     *
     * @return BinanceWSMarketStreamClient
     * @throws URISyntaxException URISyntaxException
     */
    private BinanceWSMarketStreamClient createMarketStreamApiClient() throws URISyntaxException {
        String url = urlSet.getWs_market_stream_url();
        return new BinanceWSMarketStreamClient(url, clientManager.getIpWeightSupporter());
    }

    /**
     * 创建请求、响应客户端
     *
     * @return BinanceWSReqRespApiClient
     * @throws URISyntaxException URISyntaxException
     */
    private BinanceWSReqRespApiClient createReqRespApiClient() throws URISyntaxException {
        String url = urlSet.getWs_market_url();
        return new BinanceWSReqRespApiClient(url, clientManager.getIpWeightSupporter());
    }
}


package com.helei.cexapi.manager;


import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceWSClientType;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.cexapi.client.BinanceWSEnvClient;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.base.KeyValue;
import com.helei.dto.config.RunTypeConfig;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;


@Slf4j
@Getter
public class BinanceBaseWSClientManager {

    /**
     * 运行设置a
     */
    private final RunTypeConfig runType;

    /**
     * 不同环境的客户端
     */
    private final ConcurrentMap<String, BinanceWSEnvClient> envClientMap;


    private final IpWeightSupporter ipWeightSupporter = new IpWeightSupporter("localIp");

    /**
     * 执行的线程池
     */
    private final ExecutorService executor;

    public BinanceBaseWSClientManager(
            RunTypeConfig runType,
            ExecutorService executor
    ) {

        this.runType = runType;
        this.executor = executor;
        this.envClientMap = new ConcurrentHashMap<>();

        for (KeyValue<RunEnv, TradeType> keyValue : runType.getRunTypeList()) {
            RunEnv env = keyValue.getKey();
            TradeType tradeType = keyValue.getValue();
            envClientMap.put(buildKey(env, tradeType), new BinanceWSEnvClient(env, tradeType, this));
        }
    }


    public CompletableFuture<AbstractBinanceWSApiClient> getEnvTypedApiClient(
            RunEnv runEnv,
            TradeType tradeType,
            BinanceWSClientType clientType,
            String mark
    ) {

        return CompletableFuture.supplyAsync(() -> {
            // 1 参数校验
            String key = buildKey(runEnv, tradeType);

            BinanceWSEnvClient binanceWSEnvClient = envClientMap.get(key);

            if (binanceWSEnvClient == null) {
                log.error("runEnv[{}]-tradeType[{}] 并未在环境注册, 不能创建此类api客户端, 请检查设置", runEnv, tradeType);
                return null;
            }

            // 2 获取或创建客户端
            AbstractBinanceWSApiClient client = null;
            try {
                client = binanceWSEnvClient.getOrCreateTypedClient(clientType, mark);
            } catch (Exception e) {
                throw new RuntimeException(String.format("创建runEnv[%s]-tradeType[%s]-type[%s]客户端发生错误", runEnv, tradeType, clientType.name()), e);
            }

            try {
                // 3 启动客户端
                client.connect().get();
            } catch (Exception e) {
                throw new RuntimeException(String.format("启动runEnv[%s]-tradeType[%s]-type[%s]客户端发生错误", runEnv, tradeType, clientType.name()), e);
            }

            return client;
        }, executor);
    }


    /**
     * 构建key
     *
     * @param runEnv    运行环境
     * @param tradeType 交易类型
     * @return key
     */
    private static String buildKey(RunEnv runEnv, TradeType tradeType) {
        return runEnv.name() + "-" + tradeType.name();
    }
}




package com.helei.cexapi;


import com.helei.binanceapi.api.rest.BinanceUContractMarketRestApi;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;

@Slf4j
public class CEXApiFactory {

    private static final String CLIENT_CONNECT_KEY_SPACER = "<@>?";
    //TODO 配置化
//    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7897);
    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7890);
//    private static InetSocketAddress proxy = null;

    private static IpWeightSupporter ipWeightSupporter = new IpWeightSupporter("localIp");

    private static final ConcurrentMap<String, BinanceWSApiClient> CLIENT_CONNECTION_MAP = new ConcurrentHashMap<>();

    public static BinanceWSApiClient binanceApiClient(
            String url,
            String name
    ) {
        String clientKey = buildClientConnectKey(url, name);

        BinanceWSApiClient binanceWSApiClient = CLIENT_CONNECTION_MAP.get(clientKey);
        if (binanceWSApiClient != null) {
            log.info("已存在链接客户端 [{}] - [{}]", name, url);
            return binanceWSApiClient;
        }

        BinanceWSApiClient client;
        synchronized (CEXApiFactory.class) {
            try {
                log.info("创建链接客户端 [{}] - [{}]", name, url);

                client = binanceApiClient(url);
                client.setName(name);
                CLIENT_CONNECTION_MAP.put(clientKey, client);

                log.info("创建链接客户端 [{}] - [{}] 成功", name, url);
            } catch (Exception e) {
                log.error("创建链接客户端 [{}] - [{}] 失败", name, url, e);
                throw new RuntimeException("创建连接客户端失败", e);
            }
        }
        return client;
    }

    public static BinanceWSApiClient binanceApiClient(
            String url
    ) throws URISyntaxException, SSLException {

        BinanceWSApiClientHandler handler = new BinanceWSApiClientHandler();

        BinanceWSApiClient client = new BinanceWSApiClient(
                url,
                ipWeightSupporter,
                handler
        );
        client.setProxy(proxy);
        client.setName("binance-api-client-" + UUID.randomUUID().toString().substring(0, 8));

        return client;
    }

    public static BinanceUContractMarketRestApi binanceUContractMarketRestApi(String baseUrl,
                                                                              ExecutorService executor) {
        return new BinanceUContractMarketRestApi(executor, baseUrl, ipWeightSupporter);
    }


    /**
     * 创建客户端链接的key，保证同一个名和url只有一个链接
     *
     * @param url  url
     * @param name name
     * @return String
     */
    private static String buildClientConnectKey(String url, String name) {
        return name + CLIENT_CONNECT_KEY_SPACER + url;
    }
}


package com.helei.cexapi;

import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.binanceapi.constants.WebSocketStreamType;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import com.helei.binanceapi.constants.BinanceApiUrl;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import java.util.concurrent.TimeUnit;


class BinanceWSApiClientTest {
    private static BinanceWSApiClient binanceWSApiClient = null;

    @BeforeAll
    public static void before() {
        try {
            binanceWSApiClient = CEXApiFactory.binanceApiClient(BinanceApiUrl.WS_SPOT_STREAM_URL);
            binanceWSApiClient.connect().get();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testAGG_TRADE() throws InterruptedException {
        binanceWSApiClient
                .getStreamApi()
                .builder()
                .symbol("btcusdt")
                .addSubscribeEntity(
                        WebSocketStreamType.AGG_TRADE,
                        (streamName, params, result) -> {
                            System.out.println(streamName);
                        }
                )
                .subscribe();

        TimeUnit.SECONDS.sleep(100);
    }

    @Test
    public void testKLine() throws InterruptedException {
        binanceWSApiClient
                .getStreamApi()
                .builder()
                .symbol("btcusdt")
                .addSubscribeEntity(
                        StreamSubscribeEntity
                                .builder()
                                .symbol("btcusdt")
                                .subscribeType(WebSocketStreamType.KLINE)
                                .invocationHandler((streamName, params, result) -> {
                                    System.out.println("<<<<<<======================");
                                    System.out.println(streamName);
                                    System.out.println(result);
                                    System.out.println("======================>>>>>>");
                                })
                                .build()
                                .addParam(WebSocketStreamParamKey.KLINE_INTERVAL, "1m")
                                .addParam(WebSocketStreamParamKey.SECRET_KEY, "123")
                                .addParam(WebSocketStreamParamKey.API_KEY, "123")
                )
                .subscribe();

        TimeUnit.SECONDS.sleep(100);
    }
}




package com.helei.reaktimedatacenter.manager;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.client.BinanceAccountMergeClient;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.ASKey;
import com.helei.dto.base.KeyValue;
import com.helei.dto.account.UserAccountInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.net.InetSocketAddress;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;


@Slf4j
@Component
public class BinanceAccountClientManager implements InitializingBean {

    private final static long REFRESH_TASK_SLEEP_TIME = 60000;

    private final static long REFRESH_INTERVAL = 1000 * 60 * 10;

    private final static int REFRESH_CONCURRENT_LIMIT = 10;

    private static final int ACCOUNT_STREAM_START_TIMES_LIMIT = 1;


    private final ExecutorService executor;


    private final static ConcurrentMap<String, BinanceAccountMergeClient> mergeClientMap = new ConcurrentHashMap<>();


    private final static ConcurrentMap<Long, KeyValue<BinanceWSAccountStreamClient, Long>> accountIdMapClientAndExpireMap = new ConcurrentHashMap<>();


    private final BinanceApiConfig binanceApiConfig = BinanceApiConfig.INSTANCE;


    private final AtomicBoolean streamRefreshTaskState = new AtomicBoolean(true);


    @Autowired
    public BinanceAccountClientManager(ExecutorServiceManager executorServiceManager) {
        this.executor = executorServiceManager.getAccountRTDataExecutor();
    }

    /**
     * 创建 BinanceWSAccountStreamClient，用来获取账户事件推送流
     *
     * @param accountInfo accountInfo
     * @return BinanceWSAccountStreamClient
     * @throws Exception Exception
     */
    public BinanceWSAccountStreamClient getAccountEventStreamClient(final UserAccountInfo accountInfo, BiConsumer<UserAccountInfo, AccountEvent> whenReceiveAccountEvent) throws Exception {

        RunEnv runEnv = accountInfo.getRunEnv();
        TradeType tradeType = accountInfo.getTradeType();
        ASKey asKey = accountInfo.getAsKey();


        BinanceApiConfig.BinanceTypedUrl envUrlSet = binanceApiConfig.getEnvUrlSet(runEnv, tradeType);


        // 1. 创建用于获取 listenKey 的客户端
        BinanceWSApiClient requestClient = CEXApiFactory.binanceApiClient(envUrlSet.getWs_market_url(), "账户事件请求链接");

        // 2, 获取 merge 客户端
        String key = generateMergeClientKey(runEnv, tradeType);
        String streamUrl = envUrlSet.getWs_account_info_stream_url();

        BinanceAccountMergeClient accountMergeClient = mergeClientMap.compute(key, (k, v) -> {
            if (v == null) {
                try {
                    v = new BinanceAccountMergeClient(requestClient, streamUrl, executor);

                    InetSocketAddress proxy = binanceApiConfig.getProxy();
                    if (proxy != null) {
                        v.setProxy(proxy);
                    }
                } catch (Exception e) {
                    log.error("创建BinanceAccountMergeClient发生错误, url[{}}", streamUrl, e);
                    throw new RuntimeException(e);
                }
            }

            return v;
        });


        // 3. 开始根据 merge 客户端，获取该账户的推送流链接
        KeyValue<BinanceWSAccountStreamClient, Long> clientLongKeyValue = accountIdMapClientAndExpireMap.compute(accountInfo.getId(), (k, v) -> {
            if (v == null) {
                try {
                    BinanceWSAccountStreamClient binanceWSAccountStreamClient = accountMergeClient.getAccountStream(asKey, accountEvent -> whenReceiveAccountEvent.accept(accountInfo, accountEvent));

                    //刷新时间ddl设置为特殊值0代表没有启动
                    v = new KeyValue<>(binanceWSAccountStreamClient, 0L);
                } catch (Exception e) {
                    throw new RuntimeException("创建币按账户推送流失", e);
                }
            }

            return v;
        });

        return clientLongKeyValue.getKey();
    }


    /**
     * 根据accountId删除accountIdMapClientAndExpireMap里缓存的client
     *
     * @param accountId accountId
     */
    public void removeAccountStreamClient(long accountId) {
        KeyValue<BinanceWSAccountStreamClient, Long> remove = accountIdMapClientAndExpireMap.remove(accountId);
        if (remove != null) {
            log.warn("已移除AccountStreamClient [{}]", remove.getKey().getName());
        }
    }

    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     * <p>带重试次数，未达到重试限制之前，都会一直重试</p>
     *
     * @param accountId accountId
     */
    public boolean startAccountEventStream(long accountId) {
        KeyValue<BinanceWSAccountStreamClient, Long> pair = accountIdMapClientAndExpireMap.get(accountId);

        if (pair == null) return false;

        return startAccountEventStream(accountId, pair.getKey());
    }


    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     * <p>带重试次数，未达到重试限制之前，都会一直重试</p>
     *
     * @param accountId                    accountId
     * @param binanceWSAccountStreamClient binanceWSAccountStreamClient
     */
    public boolean startAccountEventStream(long accountId,
                                           BinanceWSAccountStreamClient binanceWSAccountStreamClient) {

        for (int i = 0; i < ACCOUNT_STREAM_START_TIMES_LIMIT; i++) {
            try {
                Boolean success = binanceWSAccountStreamClient.startAccountInfoStream().get();

                if (success) {

                    //设置刷新时间
                    accountIdMapClientAndExpireMap.compute(accountId, (k, v) -> {
                        if (v == null)
                            v = new KeyValue<>(binanceWSAccountStreamClient, System.currentTimeMillis() + REFRESH_INTERVAL);
                        return v;
                    });

                    return true;
                } else {
                    log.error("开启账户事件流失败[{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("开启账户事件流发生错误[{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId, e);
            }

            log.warn("开始账户事件流重试 [{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId);

        }

        log.error("accountId[{}] 重试次数[{}]超过限制[{}],", accountId, ACCOUNT_STREAM_START_TIMES_LIMIT, ACCOUNT_STREAM_START_TIMES_LIMIT);
        return false;
    }


    /**
     * 定期刷新账户流的ListenKey
     */
    private void refreshAccountStreamListenKey() {
        while (streamRefreshTaskState.get()) {
            long startTime = System.currentTimeMillis();
            Semaphore semaphore = new Semaphore(REFRESH_CONCURRENT_LIMIT);
            try {


                // 1. 去除失效的
                List<Long> expireIdList = accountIdMapClientAndExpireMap.entrySet().stream().filter(e -> e.getValue().getValue() == -1L).map(Map.Entry::getKey).toList();

                if (!expireIdList.isEmpty()) {
                    log.warn("去除失效的客户端链接 accountIds [{}]", expireIdList);
                    expireIdList.forEach(accountIdMapClientAndExpireMap::remove);
                }

                // 2.尝试刷新listenKey
                for (Map.Entry<Long, KeyValue<BinanceWSAccountStreamClient, Long>> entry : accountIdMapClientAndExpireMap.entrySet()) {
                    Long accountId = entry.getKey();
                    KeyValue<BinanceWSAccountStreamClient, Long> keyValue = entry.getValue();
                    BinanceWSAccountStreamClient client = keyValue.getKey();
                    Long expireTime = keyValue.getValue();

                    //没启动的，特殊特殊处理，跳过刷新listenKey
                    if (expireTime == 0L) continue;

                    semaphore.acquire();

                    if (System.currentTimeMillis() <= expireTime) {
                        log.info("accountId[{}]的事件流到了刷新时间，开始延长listenKey[{}]", accountId, client.getListenKey());

                        client.lengthenListenKey().whenCompleteAsync((listenKey, e) -> {
                            try {
                                if (e != null) {
                                    log.error("延长accountId[{}]的listenKey[{}]发生错误, 重新启动account链接", accountId, client.getListenKey(), e);

                                    //重新获取listenKey启动
                                    boolean result = startAccountEventStream(accountId, client);
                                    if (!result) {
                                        // TODO 错误日志上传
                                        log.error("accountId[{}}重新获取推送链接失败", accountId);

                                        //特殊标记，下一次刷新时删掉
                                        keyValue.setValue(-1L);
                                    } else {
                                        log.info("accountId[{}]重新获取推送链接成功, listenKey[{}]", accountId, client.getListenKey());
                                        keyValue.setValue(System.currentTimeMillis() + REFRESH_INTERVAL);
                                    }
                                }
                            } finally {
                                semaphore.release();

                            }
                        }, executor);
                    }
                }
            } catch (InterruptedException e) {
                log.error("定时刷新账户流ListenKey失败");
            }

            try {
                TimeUnit.MILLISECONDS.sleep(REFRESH_TASK_SLEEP_TIME - System.currentTimeMillis() + startTime);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }


    /**
     * 初始化，开始刷新链接任务
     *
     * @throws Exception Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        executor.execute(this::refreshAccountStreamListenKey);
    }


    /**
     * 获取 MergeClientKey
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return key
     */
    private String generateMergeClientKey(RunEnv runEnv, TradeType tradeType) {
        return runEnv + "." + tradeType;
    }


    public void close() {
        streamRefreshTaskState.set(false);
        executor.shutdown();
    }
}


package com.helei.reaktimedatacenter.realtime.impl;

import cn.hutool.core.lang.Pair;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.api.ws.BinanceWSStreamApi;
import com.helei.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.binanceapi.constants.WebSocketStreamType;
import com.helei.binanceapi.dto.StreamSubscribeEntity;
import com.helei.cexapi.CEXApiFactory;
import com.helei.constants.trade.KLineInterval;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.reaktimedatacenter.realtime.KLineRTDataSyncTask;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.URISyntaxException;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;

@Slf4j
public class BinanceKLineRTDataSyncTask extends KLineRTDataSyncTask {

    /**
     * 流api 获取流实时数据
     */
    private final BinanceWSApiClient streamApiClient;

    /**
     * 订阅的url
     */
    private final String url;


    /**
     * 币安k线数据同步任务
     *
     * @param listenKLines 监听的k线列表
     * @param url          url
     */
    public BinanceKLineRTDataSyncTask(
            List<Pair<String, KLineInterval>> listenKLines,
            String url
    ) {
        super(listenKLines);
        this.url = url;
        streamApiClient = CEXApiFactory.binanceApiClient(url, "币安k线实时获取任务-" + UUID.randomUUID().toString().substring(0, 8));
    }


    /**
     * 开始同步
     *
     * @param whenReceiveKLineData 当websocket收到消息时的回调，
     * @param taskExecutor         执行的线程池，回调也会通过这个线程池执行
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> startSync(
            SubscribeResultInvocationHandler whenReceiveKLineData,
            ExecutorService taskExecutor
    ) {
        return CompletableFuture.runAsync(() -> {
            CompletableFuture<Void> connect = null;
            try {

                // 1 连接
                connect = streamApiClient.connect();
                connect.get();
                log.info("连接[{}]成功，开始获取请求实时k线数据", url);

                // 2 构建请求
                BinanceWSStreamApi.StreamCommandBuilder streamCommandBuilder = streamApiClient.getStreamApi().builder();
                for (Pair<String, KLineInterval> kLine : listenKLines) {
                    streamCommandBuilder.addSubscribeEntity(
                            StreamSubscribeEntity
                                    .builder()
                                    .symbol(kLine.getKey().toLowerCase())
                                    .subscribeType(WebSocketStreamType.KLINE)
                                    .invocationHandler(whenReceiveKLineData)
                                    .callbackExecutor(taskExecutor)
                                    .build()
                                    .addParam(WebSocketStreamParamKey.KLINE_INTERVAL, kLine.getValue().getDescribe())
                    );
                }

                // 3 请求订阅
                streamCommandBuilder.subscribe();

                log.info("已发送k线获取请求到api [{}] ", url);

            } catch (SSLException | URISyntaxException | ExecutionException | InterruptedException e) {
                log.error("开始同步k线数据发生错误，连接api[{}]错误", url);
                throw new RuntimeException(String.format("同步k线数据发生错误，连接api[%s]错误", url), e);
            }
        }, taskExecutor);
    }
}



package com.helei.reaktimedatacenter.service.impl.account;


import com.helei.binanceapi.dto.accountevent.*;
import com.helei.dto.trade.BalanceInfo;
import com.helei.dto.account.AccountBalanceInfo;
import com.helei.dto.account.AccountPositionInfo;
import com.helei.dto.account.PositionInfo;
import com.helei.dto.account.UserAccountInfo;
import com.helei.reaktimedatacenter.manager.BinanceAccountClientManager;
import com.helei.reaktimedatacenter.manager.ExecutorServiceManager;
import com.helei.reaktimedatacenter.mapper.BalanceInfoMapper;
import com.helei.reaktimedatacenter.mapper.PositionInfoMapper;
import com.helei.reaktimedatacenter.service.AccountEventResolveService;
import com.helei.reaktimedatacenter.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

@Slf4j
@Service
public class BinanceAccountEventResolveService implements AccountEventResolveService {


    private ExecutorService eventExecutor = null;

    @Autowired
    private BinanceAccountClientManager binanceAccountClientManager;

    @Autowired
    private UserService userService;


    @Autowired
    public BinanceAccountEventResolveService(ExecutorServiceManager executorServiceManager) {
        this.eventExecutor = executorServiceManager.getAccountEventExecutor();
    }


    @Override
    public void resolveAccountEvent(UserAccountInfo accountInfo, AccountEvent accountEvent) {
        CompletableFuture<Void> future = null;

        switch (accountEvent) {
            case ListenKeyExpireEvent listenKeyExpireEvent ->
                    future = resolveListenKeyExpireEvent(accountInfo, listenKeyExpireEvent);
            case BailNeedEvent bailNeedEvent -> future = resolveBailNeedEvent(accountInfo, bailNeedEvent);
            case BalancePositionUpdateEvent balancePositionUpdateEvent ->
                    future = resolveBalancePositionUpdateEvent(accountInfo, balancePositionUpdateEvent);
            case OrderTradeUpdateLiteEvent orderTradeUpdateEvent ->
                    future = resolveOrderTradeUpdateEvent(orderTradeUpdateEvent);
            case AccountConfigUpdateEvent accountConfigUpdateEvent ->
                    future = resolveAccountConfigUpdateEvent(accountConfigUpdateEvent);
            case StrategyUpdateEvent strategyUpdateEvent -> future = resolveStrategyUpdateEvent(strategyUpdateEvent);
            case GridUpdateEvent gridUpdateEvent -> future = resolveGridUpdateEvent(gridUpdateEvent);
            case ConditionalOrderTriggerRejectEvent conditionalOrderTriggerRejectEvent ->
                    future = resolveConditionalOrderTriggerRejectEvent(conditionalOrderTriggerRejectEvent);
            case null, default ->
                    log.warn("userId[{}]-accountId[{}]-未知事件 [{}]", accountInfo.getUserId(), accountInfo.getId(), accountEvent);
        }


        if (future == null) return;


        future.whenCompleteAsync((unused, throwable) -> {
            if (throwable != null) {
                log.error("处理accountId[{}]事件[{}}发生错误", accountInfo.getId(), accountEvent, throwable);
            }
        }, eventExecutor);
    }

    /**
     * 条件订单(TP/SL)触发后拒绝更新推送
     *
     * @param conditionalOrderTriggerRejectEvent conditionalOrderTriggerRejectEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveConditionalOrderTriggerRejectEvent(ConditionalOrderTriggerRejectEvent conditionalOrderTriggerRejectEvent) {
        return null;
    }


    /**
     * 网格更新推送
     *
     * @param gridUpdateEvent gridUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveGridUpdateEvent(GridUpdateEvent gridUpdateEvent) {
        return null;
    }

    /**
     * 策略交易更新推送
     *
     * @param strategyUpdateEvent strategyUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveStrategyUpdateEvent(StrategyUpdateEvent strategyUpdateEvent) {
        return null;
    }


    /**
     * 杠杆倍数等账户配置 更新推送
     *
     * @param accountConfigUpdateEvent accountConfigUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveAccountConfigUpdateEvent(AccountConfigUpdateEvent accountConfigUpdateEvent) {
        return CompletableFuture.runAsync(() -> {
            //TODO

        }, eventExecutor);
    }

    /**
     * 精简交易推送
     *
     * @param orderTradeUpdateLiteEvent orderTradeUpdateLiteEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveOrderTradeUpdateLiteEvent(OrderTradeUpdateLiteEvent orderTradeUpdateLiteEvent) {
        return CompletableFuture.runAsync(() -> {
            //TODO

        }, eventExecutor);
    }

    /**
     * 订单交易更新推送
     *
     * @param orderTradeUpdateEvent orderTradeUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveOrderTradeUpdateEvent(OrderTradeUpdateLiteEvent orderTradeUpdateEvent) {
        return CompletableFuture.runAsync(() -> {
            //TODO

        }, eventExecutor);
    }


    /**
     * 处理账户仓位更新事件
     *
     * @param accountInfo                accountInfo
     * @param balancePositionUpdateEvent balancePositionUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveBalancePositionUpdateEvent(UserAccountInfo accountInfo, BalancePositionUpdateEvent balancePositionUpdateEvent) {

        return CompletableFuture.runAsync(() -> {
            // 1.更新仓位信息
            AccountPositionInfo accountPositionInfo = accountInfo.getAccountPositionInfo();
            accountPositionInfo.lock();
            try {
                List<BalancePositionUpdateEvent.PositionChangeInfo> positionChangeInfos = balancePositionUpdateEvent.getPositionChangeInfos();
                List<PositionInfo> positionInfos = PositionInfoMapper.INSTANCE.convertFromPositionChangeInfoList(positionChangeInfos);

                accountPositionInfo.updatePositionInfos(positionInfos);
                accountPositionInfo.setUpdateTime(System.currentTimeMillis());
            } finally {
                accountPositionInfo.unlock();
            }


            // 2.更新资金信息
            AccountBalanceInfo accountBalanceInfo = accountInfo.getAccountBalanceInfo();
            accountBalanceInfo.lock();
            try {
                List<BalancePositionUpdateEvent.BalanceChangeInfo> balanceChangeInfos = balancePositionUpdateEvent.getBalanceChangeInfos();
                List<BalanceInfo> balanceInfos = BalanceInfoMapper.INSTANCE.convertFromBalanceChangeInfoList(balanceChangeInfos);

                accountBalanceInfo.updateBalanceInfos(balanceInfos);
                accountPositionInfo.setUpdateTime(System.currentTimeMillis());
            } finally {
                accountBalanceInfo.unlock();
            }

            // 3.更新数据库和redis中的信息
            userService.updateUserAccountInfo(accountInfo);

            log.info("accountId[{}]信息更新成功，[{}]", accountInfo.getId(), accountInfo);
        }, eventExecutor);
    }


    /**
     * 处理追加保证金事件
     *
     * @param accountInfo   accountInfo
     * @param bailNeedEvent bailNeedEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveBailNeedEvent(UserAccountInfo accountInfo, BailNeedEvent bailNeedEvent) {
        return CompletableFuture.runAsync(() -> {
            log.warn("账户userId[{}]-accountId[{}]追加保证金事件, 详情:[{}]", accountInfo.getUserId(), accountInfo.getId(), bailNeedEvent);

        }, eventExecutor);
    }


    /**
     * listenKey过期了，要重新获取
     *
     * @param listenKeyExpireEvent listenKeyExpireEvent
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> resolveListenKeyExpireEvent(UserAccountInfo userAccountInfo, ListenKeyExpireEvent listenKeyExpireEvent) {
        long accountId = userAccountInfo.getId();
        log.info("收到accountId[{}]的账户listenKey过期事件，尝试重新连接", accountId);

        return CompletableFuture.runAsync(() -> {
            boolean result = binanceAccountClientManager.startAccountEventStream(accountId);
            if (result) {
                log.info("accountId[{}]的账户重新获取listenKey成功", accountId);
            } else {
                // TODO 日志上传
                log.error("accountId[{}]的账户重新获取listenKey失败", accountId);
            }
        }, eventExecutor);
    }
}



package com.helei.reaktimedatacenter.service.impl.account;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.account.UserAccountInfo;
import com.helei.dto.account.UserInfo;
import com.helei.reaktimedatacenter.manager.BinanceAccountClientManager;
import com.helei.reaktimedatacenter.service.AccountEventResolveService;
import com.helei.reaktimedatacenter.service.AccountEventStreamService;
import com.helei.reaktimedatacenter.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * 币安账户事件流服务
 */
@Slf4j
@Service
public class BinanceAccountEventStreamService implements AccountEventStreamService {

    private static final ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

    private static final int ACCOUNT_STREAM_START_TIMES_LIMIT = 3;


    @Autowired
    private UserService userService;

    @Autowired
    private AccountEventResolveService accountEventResolveService;


    @Autowired
    private BinanceAccountClientManager binanceAccountClientManager;


    /**
     * 开启所有用户事件流
     */
    @Override
    public void startAllUserInfoEventStream() {
        log.info("开始获取所有用户的账户事件流");

        List<CompletableFuture<Void>> list = userService.queryAll().stream()
                .map(userInfo -> CompletableFuture.runAsync(() -> startUserInfoEventStream(userInfo), executor)).toList();

        CompletableFuture.allOf(list.toArray(new CompletableFuture[0]))
                .whenCompleteAsync((unused, throwable) -> {
                    if (throwable != null) {
                        log.error("获取账户事件流发送错误", throwable);
                    } else {
                        log.info("所有用户账户事件流获取完毕，共[{}]个用户", list.size());
                    }
                }, executor);
    }


    /**
     * 开启用户信息事件，会开启用户名下所有账户的事件流
     *
     * @param userInfo userInfo
     */
    @Override
    public void startUserInfoEventStream(UserInfo userInfo) {
        log.info("开始获取用户id[{}]-name[{}]拥有账户事件流", userInfo.getId(), userInfo.getUsername());

        List<UserAccountInfo> accountInfos = userInfo.getAccountInfos();

        if (accountInfos == null || accountInfos.isEmpty()) {
            log.warn("用户[{}]-id[{}]没有注册交易账户事件", userInfo.getUsername(), userInfo.getId());
            return;
        }

        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (UserAccountInfo accountInfo : accountInfos) {
            CompletableFuture<Void> future = buildAndStartAccountEventStream(accountInfo);
            futures.add(future);
        }

        try {
            CompletableFuture
                    .allOf(futures.toArray(new CompletableFuture[0]))
                    .whenCompleteAsync((unused, throwable) -> {
                        if (throwable != null) {
                            log.error("用户id[{}]-name[{}]所有账户事件流开启时发生错误", userInfo.getId(), userInfo.getUsername(), throwable);
                        } else {
                            log.info("用户id[{}]-name[{}]所有账户事件流[共{}个]开启成功", userInfo.getId(), userInfo.getUsername(), futures.size());
                        }
                    })
                    .get();
        } catch (InterruptedException | ExecutionException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 构建并启动账户事件流，
     *
     * @param accountInfo accountInfo
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> buildAndStartAccountEventStream(UserAccountInfo accountInfo) {
        long userId = accountInfo.getUserId();
        long accountId = accountInfo.getId();

        RunEnv runEnv = accountInfo.getRunEnv();
        TradeType tradeType = accountInfo.getTradeType();


        log.info("开始获取账户事件流, userId[{}], accountId[{}], runEvn[{}], tradeType[{}]", userId, accountId, runEnv, tradeType);

        CompletableFuture<Void> future = CompletableFuture
                //1 获取流客户端
                .supplyAsync(() -> {
                    BinanceWSAccountStreamClient binanceWSAccountStreamClient = null;

                    //1.1 带重试
                    for (int i = 0; i < ACCOUNT_STREAM_START_TIMES_LIMIT; i++) {
                        try {
                            log.info("第 [{}] 次获取账户事件流, userId[{}], accountId[{}]", i, userId, accountId);

                            //1.2 创建 binanceWSAccountStreamClient 用于开启事件流
                            binanceWSAccountStreamClient = binanceAccountClientManager.getAccountEventStreamClient(accountInfo, this::resolveAccountEvent);

                            log.info("第 [{}] 次获取账户事件流成功, userId[{}], accountId[{}], listenKey[{}]", i, userId, accountId, binanceWSAccountStreamClient.getListenKey());

                            return binanceWSAccountStreamClient;
                        } catch (Exception e) {
                            log.error("第 [{}] 次获取账户事件流失败， userId[{}], accountId[{}]", i, userId, accountId, e);

                            binanceAccountClientManager.removeAccountStreamClient(accountId);

                            if (i == ACCOUNT_STREAM_START_TIMES_LIMIT - 1) {
                                log.error("重试次数 [{}] 超过了限制[{}], 不再继续重试, userId[{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, userId, accountId);
                            }
                        }
                    }

                    return binanceWSAccountStreamClient;
                }, executor)
                //2 开启流客户端
                .thenAcceptAsync(binanceWSAccountStreamClient -> {
                    // 开启事件流
                    startAccountEventStream(accountInfo, binanceWSAccountStreamClient);
                }, executor);

        return future;
    }


    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     *
     * @param accountInfo                  accountInfo
     * @param binanceWSAccountStreamClient binanceWSAccountStreamClient
     */
    private void startAccountEventStream(UserAccountInfo accountInfo,
                                         BinanceWSAccountStreamClient binanceWSAccountStreamClient) {
        long accountId = accountInfo.getId();

        boolean success = binanceAccountClientManager.startAccountEventStream(accountId, binanceWSAccountStreamClient);

        if (success) {
            log.info("开启账户事件流成功, accountId[{}], listenKey [{}]", accountId, binanceWSAccountStreamClient.getListenKey());
        } else {
            // TODO 错误日志上传
            log.error("开启账户事件流失败, accountId[{}]", accountId);
            throw new RuntimeException(String.format("开启账户事件流失败，accountId[%s], listenKey [%s]", accountId, binanceWSAccountStreamClient.getListenKey()));
        }
    }


    @Override
    public void resolveAccountEvent(final UserAccountInfo accountInfo, AccountEvent accountEvent) {
        log.info("账户[{}]-[{}]收到事件 [{}]", accountInfo.getUserId(), accountInfo.getId(), accountEvent);
        accountEventResolveService.resolveAccountEvent(accountInfo, accountEvent);
    }

}




package com.helei.reaktimedatacenter.service.impl.market;

import cn.hutool.core.collection.ListUtil;
import cn.hutool.core.lang.Pair;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.constants.CEXType;
import com.helei.constants.RunEnv;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.constants.trade.KLineInterval;
import com.helei.constants.trade.TradeType;
import com.helei.dto.base.KeyValue;
import com.helei.reaktimedatacenter.config.RealtimeConfig;
import com.helei.reaktimedatacenter.dto.SymbolKLineInfo;
import com.helei.reaktimedatacenter.service.MarketRealtimeDataService;
import com.helei.reaktimedatacenter.service.impl.KafkaProducerService;
import com.helei.util.KafkaUtil;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;


/**
 * 市场实时数据服务的抽象类
 * <P>能够将市场数据推送至kafka，会根据配置文件中的run_type来加载需要使用的环境。只需关注实现registryKLineDataLoader(*)方法</P>
 */
@Slf4j
public abstract class AbstractKafkaMarketRTDataService implements MarketRealtimeDataService {
    protected final ExecutorService taskExecutor;

    public final KafkaProducerService kafkaProducerService;

    protected final RealtimeConfig realtimeConfig;

    protected final BinanceApiConfig binanceApiConfig;

    public AbstractKafkaMarketRTDataService(ExecutorService taskExecutor, KafkaProducerService kafkaProducerService) {
        this.taskExecutor = taskExecutor;
        this.kafkaProducerService = kafkaProducerService;
        this.realtimeConfig = RealtimeConfig.INSTANCE;
        this.binanceApiConfig = BinanceApiConfig.INSTANCE;
    }

    @Override
    public Integer startSyncRealTimeKLine() {
        int all = 0;
        List<CompletableFuture<Integer>> futures = new ArrayList<>();

        for (KeyValue<RunEnv, TradeType> keyValue : realtimeConfig.getRun_type().getRunTypeList()) {
            futures.add(CompletableFuture.supplyAsync(() -> startSyncRealTimeKLine(keyValue.getKey(), keyValue.getValue()), taskExecutor));
        }

        for (CompletableFuture<Integer> future : futures) {
            try {
                all += future.get();
            } catch (InterruptedException | ExecutionException e) {
                throw new RuntimeException(e);
            }
        }
        return all;
    }

    @Override
    public Integer startSyncRealTimeKLine(RunEnv runEnv, TradeType tradeType) {
        log.info("开始同步env[{}]-tradeType[{}]的实时k线", runEnv, tradeType);

        RealtimeConfig.RealtimeKLineDataConfig realtimeKLineDataConfig = realtimeConfig.getEnvKLineDataConfig(runEnv, tradeType);

        //Step 1: 解析k线
        List<SymbolKLineInfo> realtimeKLineList = realtimeKLineDataConfig.getRealtimeKLineList();

        if (realtimeKLineList == null || realtimeKLineList.isEmpty()) {
            log.warn("runEnv[{}]-tradeType[{}] 没有设置要实时获取的k线", runEnv, tradeType);
            return 0;
        }

        List<Pair<String, KLineInterval>> intervals = new ArrayList<>();

        for (SymbolKLineInfo symbolKLineInfo : realtimeKLineList) {
            symbolKLineInfo.getIntervals().forEach(interval -> {
                intervals.add(new Pair<>(symbolKLineInfo.getSymbol(), interval));
            });
        }

        //Step 2: 创建topic
        log.info("开始检查并创建所需topic");
        createTopic(intervals, runEnv, tradeType);
        log.info("topic创建完毕");


        //Step 3: 分片执行
        List<List<Pair<String, KLineInterval>>> partition = ListUtil.partition(intervals, realtimeKLineDataConfig.getClient_listen_kline_max_count());


        try {
            List<CompletableFuture<Void>> futures = new ArrayList<>();
            for (List<Pair<String, KLineInterval>> list : partition) {

                //Step 4: 创建task执行获取
                CompletableFuture<Void> future = registryKLineDataLoader(
                        runEnv,
                        tradeType,
                        list,
                        (s, p, k) -> klineDataSyncToKafka(s, (KLineInterval) p.get(WebSocketStreamParamKey.KLINE_INTERVAL), k, runEnv, tradeType),
                        taskExecutor);

                futures.add(future);
            }

            CompletableFuture
                    .allOf(futures.toArray(new CompletableFuture[0]))
                    .get();

            log.info("所有k线开始实时同步");
        } catch (Exception e) {
            throw new RuntimeException(e);
        }

        return realtimeKLineList.size();
    }


    /**
     * 注册k线数据加载器
     *
     * @param runEnv               运行环境
     * @param tradeType            交易类型
     * @param listenKLines         k线
     * @param whenReceiveKLineData 回调，需要在whenReceiveKLineData.invoke()时传入symbol、interval、json格式的k线数据
     * @param executorService      执行的线程池
     * @return CompletableFuture
     */
    protected abstract CompletableFuture<Void> registryKLineDataLoader(
            RunEnv runEnv,
            TradeType tradeType,
            List<Pair<String, KLineInterval>> listenKLines,
            SubscribeResultInvocationHandler whenReceiveKLineData,
            ExecutorService executorService
    );

    /**
     * 把k线发到kafka
     *
     * @param symbol symbol
     * @param data   data
     */
    public void klineDataSyncToKafka(String symbol, KLineInterval kLineInterval, JSONObject data, RunEnv runEnv, TradeType tradeType) {
        String topic = KafkaUtil.resolveKafkaTopic(CEXType.BINANCE, KafkaUtil.getKLineStreamName(symbol, kLineInterval), runEnv, tradeType);

        log.info("收到k线信息 - {}, - {} - {} - {} send to topic[{}]", symbol, data, runEnv, tradeType, topic);
        try {
            kafkaProducerService.sendMessage(
                    topic,
                    data.toJSONString()
            ).get();
        } catch (InterruptedException | ExecutionException e) {
            log.error("保持k线信息到kafka出错，symbol[{}]", symbol, e);
        }
    }

    /**
     * 创建topic
     *
     * @param kLines    k线list
     * @param runEnv    运行环境
     * @param tradeType 交易类型
     */
    private void createTopic(List<Pair<String, KLineInterval>> kLines, RunEnv runEnv, TradeType tradeType) {
        for (Pair<String, KLineInterval> kLine : kLines) {
            String topic = KafkaUtil.resolveKafkaTopic(CEXType.BINANCE, KafkaUtil.getKLineStreamName(kLine.getKey(), kLine.getValue()), runEnv, tradeType);

            kafkaProducerService.checkAndCreateTopic(
                    topic,
                    realtimeConfig.getKafka().getKafka_num_partitions(),
                    realtimeConfig.getKafka().getKafka_replication_factor()
            );
        }
    }
}


package com.helei.reaktimedatacenter.service.impl.market;

import cn.hutool.core.lang.Pair;
import com.helei.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.constants.trade.KLineInterval;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.reaktimedatacenter.manager.ExecutorServiceManager;
import com.helei.reaktimedatacenter.realtime.impl.BinanceKLineRTDataSyncTask;
import com.helei.reaktimedatacenter.service.impl.KafkaProducerService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;


/**
 * 币安市场数据服务
 */
@Slf4j
@Service
public class BinanceMarketRTDataService extends AbstractKafkaMarketRTDataService {


    @Autowired
    public BinanceMarketRTDataService(ExecutorServiceManager executorServiceManager, KafkaProducerService kafkaProducerService) {
        super(executorServiceManager.getKlineTaskExecutor(), kafkaProducerService);
    }

    @Override
    protected CompletableFuture<Void> registryKLineDataLoader(
            RunEnv runEnv,
            TradeType tradeType,
            List<Pair<String, KLineInterval>> listenKLines,
            SubscribeResultInvocationHandler whenReceiveKLineData,
            ExecutorService executorService
    ) {
        String url = binanceApiConfig.getEnvUrlSet(runEnv, tradeType).getWs_market_stream_url();
        return new BinanceKLineRTDataSyncTask(
                listenKLines,
                url
        ).startSync(whenReceiveKLineData, taskExecutor);
    }

}


package com.helei.reaktimedatacenter.service.impl.market;

import cn.hutool.core.lang.Pair;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.constants.RunEnv;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.constants.trade.KLineInterval;
import com.helei.constants.trade.TradeType;
import com.helei.reaktimedatacenter.manager.ExecutorServiceManager;
import com.helei.reaktimedatacenter.service.impl.KafkaProducerService;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.*;


/**
 * 随机市场数据服务
 */
@Service
public class RandomMarketRTDataService extends AbstractKafkaMarketRTDataService {

    private final Random random = new Random();

    private final Double maxPrice = 99999.09;

    private final Double minPrice = 111.229;

    private final ConcurrentHashMap<String, ConcurrentHashMap<KLineInterval, Long>> startTimeStampMap;

    private final ConcurrentHashMap<String, ConcurrentHashMap<KLineInterval, Long>> realTimerMap;

    private final LocalDateTime startTimeStamp = LocalDateTime.of(2022, 1, 1, 1, 1);

    private long epochMilli;


    public RandomMarketRTDataService(
            ExecutorServiceManager executorServiceManager, KafkaProducerService kafkaProducerService
    ) {
        super(executorServiceManager.getKlineTaskExecutor(), kafkaProducerService);

        epochMilli = startTimeStamp.toInstant(ZoneOffset.UTC).toEpochMilli();

        if (epochMilli > System.currentTimeMillis()) {
            epochMilli = System.currentTimeMillis();
        }
        this.startTimeStampMap = new ConcurrentHashMap<>();
        this.realTimerMap = new ConcurrentHashMap<>();
    }

    @Override
    protected CompletableFuture<Void> registryKLineDataLoader(
            RunEnv runEnv,
            TradeType tradeType,
            List<Pair<String, KLineInterval>> listenKLines,
            SubscribeResultInvocationHandler whenReceiveKLineData,
            ExecutorService executorService
    ) {
        return CompletableFuture.runAsync(() -> {
            String key = getKey(runEnv, tradeType);
            for (Pair<String, KLineInterval> listenKLine : listenKLines) {
                String symbol = listenKLine.getKey();
                KLineInterval interval = listenKLine.getValue();

                startTimeStampMap.putIfAbsent(key, new ConcurrentHashMap<>());
                realTimerMap.putIfAbsent(key, new ConcurrentHashMap<>());

                startTimeStampMap.get(key).putIfAbsent(interval, epochMilli);
                realTimerMap.get(key).putIfAbsent(interval, epochMilli);

                executorService.execute(() -> {
                    Map<String, Object> map = new HashMap<>();
                    map.put(WebSocketStreamParamKey.KLINE_INTERVAL, interval);
                    while (true) {
                        try {
                            JSONObject kLine = loadKLine(runEnv, tradeType, symbol, interval);
                            whenReceiveKLineData.invoke(symbol, map, kLine);
                            TimeUnit.SECONDS.sleep(10);
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                });
            }

        }, executorService);
    }


    protected JSONObject loadKLine(
            RunEnv runEnv,
            TradeType tradeType,
            String symbol,
            KLineInterval kLineInterval
    ) {

        double nextLow = minPrice + (maxPrice - minPrice) * random.nextDouble();
        double nextHigh = nextLow + (maxPrice - nextLow) * random.nextDouble();
        double nextOpen = nextLow + (nextHigh - nextLow) * random.nextDouble();
        double nextClose = nextLow + (nextHigh - nextLow) * random.nextDouble();

        double volume = 10 + (Double.MAX_VALUE / 2 - 10) * random.nextDouble();
        long plus = kLineInterval.getSecond() * 1000;
        String key = getKey(runEnv, tradeType);
        long openTime = startTimeStampMap.get(key).get(kLineInterval);

        realTimerMap.get(key).computeIfPresent(kLineInterval, (k, v) -> v + 200);
        long curTime = realTimerMap.get(key).get(kLineInterval);

        boolean isRealTime = curTime > System.currentTimeMillis() - kLineInterval.getSecond() * 1000;
        if (isRealTime) {
            if (curTime >= openTime + plus) {
                openTime += plus;
                startTimeStampMap.get(key).put(kLineInterval, openTime);
            }
        } else {
            openTime += plus;
            startTimeStampMap.get(key).put(kLineInterval, openTime);
        }

        JSONObject jb = new JSONObject();
        jb.put("t", openTime);
        jb.put("T", openTime + plus - 1000);
        jb.put("s", symbol);
        jb.put("h", nextHigh);
        jb.put("l", nextLow);
        jb.put("o", nextOpen);
        jb.put("c", nextClose);
        jb.put("v", volume);
        jb.put("x", !isRealTime);
        jb.put("i", kLineInterval.name());

        return jb;
    }

    private String getKey(RunEnv runEnv, TradeType tradeType) {
        return runEnv.name() + " - " + tradeType.name();
    }
}



package com.helei.reaktimedatacenter.service.impl;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.cexapi.CEXApiFactory;
import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.dto.ASKey;
import com.helei.dto.account.AccountPositionConfig;
import com.helei.dto.account.AccountRTData;
import com.helei.dto.account.UserAccountInfo;
import com.helei.dto.account.UserInfo;
import com.helei.dto.base.KeyValue;
import com.helei.reaktimedatacenter.config.RealtimeConfig;
import com.helei.reaktimedatacenter.service.UserService;
import com.helei.reaktimedatacenter.supporter.BatchWriteSupporter;
import com.helei.util.RedisKeyUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;


@Slf4j
@Service
public class UserServiceImpl implements UserService, InitializingBean {

    private final RealtimeConfig realtimeConfig = RealtimeConfig.INSTANCE;

    private final BinanceApiConfig binanceApiConfig = BinanceApiConfig.INSTANCE;

    @Autowired
    private BatchWriteSupporter batchWriteSupporter;


    @Override
    public List<UserInfo> queryAll() {

        for (KeyValue<RunEnv, TradeType> keyValue : realtimeConfig.getRun_type().getRunTypeList()) {
            //TODO 查数据库, 只取这些环境里的

        }
        List<UserInfo> list = new ArrayList<>();

        UserInfo u_contract_test_net_account = UserInfo.builder()
                .id(1)
                .username("合约测试网账号")
                .password("123456")
                .accountInfos(List.of(
                        UserAccountInfo
                                .builder()
                                .id(1)
                                .userId(1)
                                .accountPositionConfig(AccountPositionConfig
                                        .builder()
                                        .riskPercent(0.5)
                                        .leverage(10)
                                        .build()
                                )
                                .asKey(new ASKey("b252246c6c6e81b64b8ff52caf6b8f37471187b1b9086399e27f6911242cbc66", "a4ed1b1addad2a49d13e08644f0cc8fc02a5c14c3511d374eac4e37763cadf5f"))
                                .subscribeSymbol(List.of("btcusdt", "ethusdt", "solusdt"))
                                .runEnv(RunEnv.TEST_NET)
                                .tradeType(TradeType.CONTRACT)
                                .build()
                ))
                .build();
        UserInfo spot_test_net_account = UserInfo.builder()
                .id(2)
                .username("现货测试网账号")
                .password("123456")
                .accountInfos(List.of(
                        UserAccountInfo
                                .builder()
                                .id(1)
                                .userId(2)
                                .accountPositionConfig(AccountPositionConfig
                                        .builder()
                                        .riskPercent(0.5)
                                        .leverage(10)
                                        .build()
                                )
                                .subscribeSymbol(List.of("btcusdt", "ethusdt", "solusdt"))
                                .asKey(new ASKey("1JIhkPyK07xadG9x8hIwqitN95MgpypPzA4b6TLraTonRnJ8BBJQlaO2iL9tPH0Y", "t84TYFR1zieMGncbw3kYq4zAPLxIJHJeMdD8V0FMKxij9fApojV6bhbDpyyjNDWt"))
                                .runEnv(RunEnv.TEST_NET)
                                .tradeType(TradeType.SPOT)
                                .build()
                ))
                .build();

        UserInfo binance_account = UserInfo.builder()
                .id(3)
                .username("正式网账号")
                .password("123456")
                .accountInfos(List.of(
                        UserAccountInfo
                                .builder()
                                .id(1)
                                .userId(3)
                                .accountPositionConfig(AccountPositionConfig
                                        .builder()
                                        .riskPercent(0.5)
                                        .leverage(10)
                                        .build()
                                )
                                .subscribeSymbol(List.of("btcusdt", "ethusdt", "solusdt"))
                                .asKey(new ASKey("TUFsFL4YrBsR4fnBqgewxiGfL3Su5L9plcjZuyRO3cq6M1yuwV3eiNX1LcMamYxz", "YsLzVacYo8eOGlZZ7RjznyWVjPHltIXzZJz2BrggCmCUDcW75FyFEv0uKyLBVAuU"))
                                .runEnv(RunEnv.NORMAL)
                                .tradeType(TradeType.SPOT)
                                .build()
                ))
                .build();


        list.add(u_contract_test_net_account);
//        list.add(spot_test_net_account);
//        list.add(binance_account);
        return list;
    }


    /**
     * 更新用户账户信息
     *
     * @param userAccountInfo userAccountInfo
     */
    @Override
    public void updateUserAccountInfo(UserAccountInfo userAccountInfo) {

        long accountId = userAccountInfo.getId();
        long userId = userAccountInfo.getUserId();

        String key = RedisKeyUtil.getUserAccountEnvRTDataKey(userAccountInfo.getRunEnv(), userAccountInfo.getTradeType());
        String hashKey = String.valueOf(accountId);

        //只发实时的部分数据
        String value = JSONObject.toJSONString(new AccountRTData(userId, accountId, userAccountInfo.getAccountBalanceInfo(), userAccountInfo.getAccountPositionInfo()));

        log.info("更新账户信息，key[{}], value[{}]", key, value);
//        batchWriteSupporter.writeToRedis(key, value);
        batchWriteSupporter.writeToRedisHash(key, hashKey, value);
    }

    /**
     * 更新UserInfo到Redis，包括User名下的账户信息
     *
     * @param env       运行环境
     * @param tradeType 交易类型
     */
    public void updateUserInfoToRedis(RunEnv env, TradeType tradeType) {
        List<UserInfo> userInfos = queryAll();
        for (UserInfo userInfo : userInfos) {
            String url = binanceApiConfig.getEnvUrlSet(env, tradeType).getWs_market_url();
            CEXApiFactory.binanceApiClient(url, "");

            String key = RedisKeyUtil.getUserInfoKeyPrefix(env, tradeType) + userInfo.getId();
            batchWriteSupporter.writeToRedis(key, JSONObject.toJSONString(userInfo));
        }
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        for (KeyValue<RunEnv, TradeType> keyValue : realtimeConfig.getRun_type().getRunTypeList()) {
            updateUserInfoToRedis(keyValue.getKey(), keyValue.getValue());
        }
    }
}


package com.helei;

import com.helei.reaktimedatacenter.service.AccountEventStreamService;
import com.helei.reaktimedatacenter.service.MarketRealtimeDataService;
import com.helei.reaktimedatacenter.service.impl.market.RandomMarketRTDataService;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

/**
 * 实时数据中心
 */
@SpringBootApplication
public class RealtimeDataCenter {
    public static void main(String[] args) {
        ConfigurableApplicationContext applicationContext = SpringApplication.run(RealtimeDataCenter.class, args);


        startRTDataStream(applicationContext);

//        startAccountEventStream(applicationContext);
    }

    private static void startAccountEventStream(ConfigurableApplicationContext applicationContext) {
        AccountEventStreamService accountEventStreamService = applicationContext.getBean(AccountEventStreamService.class);
        accountEventStreamService.startAllUserInfoEventStream();
    }

    private static void startRTDataStream(ConfigurableApplicationContext applicationContext) {
        MarketRealtimeDataService marketRealtimeDataService = applicationContext.getBean(RandomMarketRTDataService.class);
        marketRealtimeDataService.startSyncRealTimeKLine();
    }
}





package com.helei.reaktimedatacenter.service.impl;

import com.helei.dto.account.UserInfo;
import com.helei.reaktimedatacenter.service.impl.account.BinanceAccountEventStreamService;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;
import java.util.concurrent.TimeUnit;

@SpringBootTest
class BinanceAccountEventStreamServiceTest {

    @Autowired
    private UserServiceImpl userService;

    @Autowired
    private BinanceAccountEventStreamService binanceAccountEventStreamService;

    @BeforeEach
    void setUp() {
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    void startAllUserInfoEventStream() {
        binanceAccountEventStreamService.startAllUserInfoEventStream();

    }

    @Test
    void startUserInfoEventStream() throws InterruptedException {

        List<UserInfo> userInfos = userService.queryAll();

        UserInfo first = userInfos.getFirst();
        UserInfo two = userInfos.get(1);
        UserInfo three = userInfos.get(2);

        binanceAccountEventStreamService.startUserInfoEventStream(three);

        TimeUnit.MINUTES.sleep(1000);
    }
}



package com.helei.service.impl;

import com.helei.constants.RunEnv;
import com.helei.constants.trade.TradeType;
import com.helei.reaktimedatacenter.service.impl.market.BinanceMarketRTDataService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.TimeUnit;

@SpringBootTest
class BinanceMarketRTDataServiceTest {

    @Autowired
    private BinanceMarketRTDataService binanceMarketRTDataService;



    @Test
    void startSyncRealTimeKLine() throws InterruptedException {
        binanceMarketRTDataService.startSyncRealTimeKLine(RunEnv.TEST_NET, TradeType.SPOT);

        TimeUnit.MINUTES.sleep(1000);
    }
}


