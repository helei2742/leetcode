package cn.com.vortexa.script_node.bot;

import cn.com.vortexa.script_node.util.persistence.AccountPersistenceManager;
import cn.com.vortexa.script_node.util.persistence.impl.DBAccountPersistenceManager;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.exception.BotInitException;
import cn.hutool.core.util.BooleanUtil;

import com.alibaba.fastjson.JSONArray;

import lombok.Getter;

import java.util.*;
import java.util.concurrent.*;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.stream.Collectors;

import static cn.com.vortexa.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;

public abstract class AccountManageAutoBot extends AbstractAutoBot {

    /**
     * job并发控制信号量， jobName -> semaphore
     */
    private final ConcurrentMap<String, Semaphore> jobCCSemaphoreMap = new ConcurrentHashMap<>();

    /**
     * 账户上下文列表
     */
    @Getter
    private final List<AccountContext> accountContexts = new ArrayList<>();

    /**
     * 根据accountBaseInfo.id分组的 账户上下文
     */
    @Getter
    private final Map<Integer, List<AccountContext>> acMap = new HashMap<>();

    /**
     * 去重的账户上下文
     */
    @Getter
    private final List<AccountContext> uniqueACList = new ArrayList<>();

    /**
     * 持久化管理器
     */
    @Getter
    private AccountPersistenceManager persistenceManager;

    @Override
    protected void doInit() throws BotInitException {
        // Step 1 初始化保存的线程
        this.persistenceManager = new DBAccountPersistenceManager(getBotApi(), getExecutorService());

        this.persistenceManager.init();

        // Step 2 初始化账户
        this.initAccounts();

        acMap.putAll(
                getAccountContexts()
                        .stream()
                        .collect(Collectors.groupingBy(ac ->
                                ac.getAccountBaseInfoId() == null ? -1 : ac.getAccountBaseInfoId())
                        )
        );

        uniqueACList.addAll(acMap.values().stream().map(List::getFirst).toList());
    }

    @Override
    protected void doStop() {
        accountContexts.clear();
        acMap.clear();
        uniqueACList.clear();
        jobCCSemaphoreMap.clear();
    }

    /**
     * 获取jb name列表
     *
     * @return List<String>
     */
    public abstract Set<String> botJobNameList();

    /**
     * 账号被加载后调用
     *
     * @param accountContexts accountContexts
     */
    protected void accountsLoadedHandler(List<AccountContext> accountContexts) {
    }

    /**
     * 异步账户去重遍历账户
     *
     * @param buildResultFuture buildResultFuture
     * @param resultHandler     resultHandler
     * @param jobName           jobName
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> uniqueAsyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {

        return asyncForACList(
                new ArrayList<>(uniqueACList),
                accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    /**
     * 同步账户去重遍历账户
     *
     * @param buildResultFuture buildResultFuture
     * @param resultHandler     resultHandler
     * @param jobName           jobName
     * @return  CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> uniqueSyncForACList(
            BiFunction<AccountContext, List<AccountContext>, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {

        return syncForACList(
                new ArrayList<>(uniqueACList),
                accountContext -> buildResultFuture.apply(accountContext, acMap.get(accountContext.getAccountBaseInfoId())),
                resultHandler,
                jobName
        );
    }

    /**
     * 遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> syncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return syncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> asyncForACList(
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return asyncForACList(getAccountContexts(), buildResultFuture, resultHandler, jobName);
    }

    /**
     * 同步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> syncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        return CompletableFuture.supplyAsync(() -> {
            List<BotACJobResult> results = new ArrayList<>();
            int successCount = 0;

            for (AccountContext accountContext : new HashSet<>(accountContexts)) {
                if (checkAccountContainsParams(accountContext)) {
                    BotACJobResult botACJobResult = new BotACJobResult(
                            getBotInstance().getBotId(),
                            getBotInstance().getBotName(),
                            jobName,
                            accountContext.getId()
                    );

                    CompletableFuture<Result> future = buildResultFuture.apply(accountContext);

                    try {
                        Result result = future.get();
                        if (result.getSuccess()) {
                            successCount++;
                        }
                        botACJobResult = resultHandler.apply(accountContext, botACJobResult.setResult(result));
                        results.add(botACJobResult);
                    } catch (InterruptedException | ExecutionException e) {
                        throw new RuntimeException(e);
                    }
                }
            }

            return ACListOptResult.builder()
                    .botId(getBotInstance().getBotId())
                    .botName(getBotInstance().getBotName())
                    .jobName(jobName)
                    .successCount(successCount)
                    .success(true)
                    .results(results)
                    .build();
        }, getExecutorService());
    }

    /**
     * 异步遍历账户
     *
     * @param buildResultFuture buildResultFuture   具体执行的方法
     * @param resultHandler     resultHandler   处理结果的方法
     * @return CompletableFuture<ACListOptResult>
     */
    protected CompletableFuture<ACListOptResult> asyncForACList(
            List<AccountContext> accountContexts,
            Function<AccountContext, CompletableFuture<Result>> buildResultFuture,
            BiFunction<AccountContext, BotACJobResult, BotACJobResult> resultHandler,
            String jobName
    ) {
        // Step 1 遍历账户，获取执行结果
        List<CompletableFuture<BotACJobResult>> futures = accountContexts.stream()
                .filter(this::checkAccountContainsParams)
                .map(accountContext -> {
                    try {
                        // 获取信号量
                        getCcSemaphore(jobName).acquire();
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }

                    BotACJobResult botACJobResult = new BotACJobResult(
                            getBotInstance().getBotId(),
                            getBotInstance().getBotKey(),
                            jobName,
                            accountContext.getId()
                    );
                    CompletableFuture<Result> future;

                    try {
                        future = buildResultFuture.apply(accountContext);
                    } catch (Exception e) {
                        getCcSemaphore(jobName).release();
                        botACJobResult.setErrorMsg(e.getMessage());
                        return CompletableFuture.completedFuture(botACJobResult);
                    }

                    return future.thenApplyAsync(botACJobResult::setResult, getExecutorService())
                            .whenComplete((result, throwable) -> {
                                // 释放信号量
                                getCcSemaphore(jobName).release();
                            });
                }).toList();

        // Step 2 等待执行完成，转换执行结果
        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApplyAsync(unused -> {
                    List<BotACJobResult> results = new ArrayList<>();

                    int success = 0;
                    for (int i = 0; i < futures.size(); i++) {
                        CompletableFuture<BotACJobResult> future = futures.get(i);
                        AccountContext accountContext = accountContexts.get(i);

                        try {
                            BotACJobResult result = future.get();
                            BotACJobResult botACJobResult = resultHandler.apply(accountContext, result);

                            if (BooleanUtil.isTrue(botACJobResult.getSuccess())) {
                                success++;
                            }

                            results.add(botACJobResult);
                        } catch (InterruptedException | ExecutionException e) {
                            String errorMsg = String.format("[%s] %s 获取异步结果发生错误",
                                    accountContext.getId(), accountContext.getSimpleInfo());

                            logger.error(errorMsg, e);

                            results.add(
                                    new BotACJobResult(
                                            getBotInstance().getBotId(),
                                            getBotInstance().getBotKey(),
                                            jobName,
                                            accountContext.getId(),
                                            false,
                                            errorMsg,
                                            null
                                    )
                            );
                        }
                    }

                    return ACListOptResult.builder()
                            .botId(getBotInstance().getBotId())
                            .botName(getBotInstance().getBotKey())
                            .jobName(jobName)
                            .successCount(success)
                            .success(true)
                            .results(results)
                            .build();
                });
    }

    /**
     * 检查账户是否含有指定参数
     *
     * @param accountContext accountContext
     * @return boolean
     */
    protected boolean checkAccountContainsParams(AccountContext accountContext) {
        // 过滤掉没有账户需要参数的
        Object o = getBotInstance().getParams().get(ACCOUNT_PARAMS_KEY);
        // 使用的json序列化进db，反序列化得到的是JsonArray
        if (o instanceof JSONArray jsonArray) {
            for (Object obj : jsonArray) {
                String key = (String) obj;
                if (accountContext.getParam(key) == null) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 初始化账号方法
     */
    public void initAccounts() throws BotInitException {
        Integer botId = getBotInstance().getBotId();

        try {
            this.accountContexts.clear();

            logger.info("start load account data");
            // Step 1 获取持久化的
            List<AccountContext> accountContexts = persistenceManager
                    .loadAccountContexts(botId, getAutoBotConfig().getBotKey());

            // Step 2 没有保存的数据
            if (accountContexts == null || accountContexts.isEmpty()) {
                logger.warn("no account data...");
            } else {
                logger.info("use history account, total:" + accountContexts.size());

                // Step 3 加载到bot (字段修改监听)
                registerAccountsInBot(accountContexts);

                accountsLoadedHandler(accountContexts);

                this.accountContexts.addAll(accountContexts);
            }
        } catch (Exception e) {
            throw new BotInitException("init account info error", e);
        }
    }

    /**
     * 将账户加载到bot， 会注册监听，当属性发生改变时自动刷入磁盘
     *
     * @param accountContexts accountContexts
     */
    private void registerAccountsInBot(List<AccountContext> accountContexts) {
        persistenceManager.registerPersistenceListener(accountContexts);
    }

    /**
     * 获取并发控制的信号量
     *
     * @param jobName jobName
     * @return Semaphore
     */
    private Semaphore getCcSemaphore(String jobName) {
        return jobCCSemaphoreMap.computeIfAbsent(jobName, key -> {
            AutoBotJobParam autoBotJobParam = getJobParam(key);
            if (autoBotJobParam == null) {
                return new Semaphore(getRequestConcurrentCount());
            }
            return new Semaphore(autoBotJobParam.getConcurrentCount());
        });
    }
}
package cn.com.vortexa.script_node.bot;

import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.entity.BotInstance;
import cn.com.vortexa.common.entity.RewordInfo;
import cn.com.vortexa.script_node.anno.BotApplication;
import cn.com.vortexa.script_node.anno.BotMethod;
import cn.com.vortexa.script_node.dto.AccountRewordSnapshot;
import cn.com.vortexa.script_node.websocket.AccountWSClientBuilder;
import cn.com.vortexa.script_node.websocket.BaseBotWSClient;
import cn.com.vortexa.script_node.websocket.WebSocketClientLauncher;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.BotInfo;
import cn.com.vortexa.common.exception.BotMethodFormatException;
import cn.com.vortexa.common.exception.BotMethodInvokeException;
import cn.com.vortexa.common.exception.BotInitException;
import cn.com.vortexa.script_node.dto.job.AutoBotJobRuntimeParam;
import cn.hutool.core.util.StrUtil;

import com.alibaba.fastjson.JSONArray;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import org.jetbrains.annotations.NotNull;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import java.util.concurrent.*;

import static cn.com.vortexa.common.entity.BotInfo.ACCOUNT_PARAMS_KEY;
import static cn.com.vortexa.common.entity.BotInfo.CONFIG_PARAMS_KEY;

@Slf4j
public abstract class AnnoDriveAutoBot<T extends JobInvokeAutoBot> extends JobInvokeAutoBot {

    /**
     * ws client 启动器
     */
    private final WebSocketClientLauncher webSocketClientLauncher = new WebSocketClientLauncher(this);

    private String updateRewordJobName;
    /**
     * 奖励更新方法
     */
    @Getter
    private Method updateRewordMethod;

    /**
     * 奖励更新的代理方法
     */
    private final Method updateRewordProxyMethod;

    public AnnoDriveAutoBot() {
        try {
            updateRewordProxyMethod = AnnoDriveAutoBot.class
                .getDeclaredMethod("rewardQueryProxyMethod", AccountContext.class, List.class);
            updateRewordProxyMethod.setAccessible(true);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("reward query proxy method id empty", e);
        }
    }

    /**
     * 构建bot info， 会解析注解查询db，给上层父类调用
     *
     * @return BotInfo
     */
    @Override
    protected BotInfo buildBotInfo() throws BotInitException {
        // 解析bot 基本信息
        try {
            BotApplication annotation = getInstance().getClass().getAnnotation(BotApplication.class);

            if (annotation != null) {
                String botName = annotation.name();
                if (StrUtil.isBlank(botName)) {
                    throw new IllegalArgumentException("bot name 不能为空");
                }

                //  解析bot 自定义配置, 看是否有满足的
                AutoBotConfig botConfig = getAutoBotConfig();
                Map<String, Object> customConfig = botConfig.getCustomConfig();
                for (String key : annotation.configParams()) {
                    if (!customConfig.containsKey(key)) {
                        throw new IllegalArgumentException("缺乏Bot必要参数[%s]".formatted(key));
                    }
                }

                BotInfo botInfo = null;

                // 查询是否存在botKey的bot
                Map<String, Object> query = new HashMap<>();
                query.put("name", botName);
                List<BotInfo> dbBotInfoList = getBotApi().getBotInfoRPC().conditionQueryRPC(query);

                // 查询bot是否存在，不存在则创建
                if (dbBotInfoList == null || dbBotInfoList.isEmpty()) {
                    logger.warn("不存在bot info, 自动创建...");
                    botInfo = generateFromAnno(annotation);
                } else {
                    botInfo = dbBotInfoList.getFirst();
                    botInfo.fixMapValueType();
                }
                return botInfo;
            } else {
                throw new IllegalArgumentException("bot 应该带有 @BotApplication注解");
            }
        } catch (Exception e) {
            throw new BotInitException(e);
        }
    }

    @Override
    protected void resolveBotJobMethod() {
        // 解析bot job 参数
        logger.debug("resole job method...");
        // Step 1 遍历方法
        for (Method method : allMethods()) {
            method.setAccessible(true);

            // Step 2 找到方法中带有BotMethod注解的
            if (method.isAnnotationPresent(BotMethod.class)) {
                BotMethod botJobMethod = method.getAnnotation(BotMethod.class);

                // Step 3 根据BotMethod注解 的jobType，方法分类
                switch (botJobMethod.jobType()) {
                    case QUERY_REWARD -> queryRewardMethodHandler(method, botJobMethod);
                    case ONCE_TASK, TIMED_TASK -> timedTaskMethodHandler(method, botJobMethod);
                    case WEB_SOCKET_CONNECT -> webSocketConnectMethodHandler(method, botJobMethod);
                }
            }
        }
    }

    @Override
    protected void doStop() {
        updateRewordMethod = null;
        webSocketClientLauncher.clear();
        super.doStop();
    }

    @Override
    public Set<String> botJobNameList() {
        return getJobParams().keySet();
    }

    protected abstract T getInstance();

    /**
     * 保存并上传奖励信息
     *
     * @param aCListOptResult   aCListOptResult
     */
    private void saveAndUploadRewordQueryResult(ACListOptResult aCListOptResult) {
        List<BotACJobResult> results = aCListOptResult.getResults();

        List<RewordInfo> rewordInfos = new ArrayList<>();
        for (BotACJobResult result : results) {
            if (result.getData() instanceof RewordInfo rewordInfo) {
                rewordInfos.add(rewordInfo);
            }
        }

        BotInstance botInstance = getBotInstance();
        getBotApi().getRewordInfoService().saveAndUploadRewordInfos(
            botInstance.getBotId(),
            botInstance.getBotKey(),
            rewordInfos
        );
    }

    /**
     * 奖励查询方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     */
    private void queryRewardMethodHandler(Method method, BotMethod botJobMethod) {
        logger.debug("add reword query method");
        if (method.getReturnType() == AccountRewordSnapshot.class
                && method.getParameterCount() == 2
                && method.getParameters()[0].getType() == AccountContext.class
                && method.getParameters()[1].getType() == List.class
        ) {

            if (this.updateRewordMethod == null) {
                this.updateRewordMethod = method;
            } else {
                throw new BotMethodFormatException("收益查询方法只能有一个");
            }

            updateRewordJobName = registryJobInBot(
                getInstance(),
                updateRewordProxyMethod,
                null,
                botJobMethod
            );

            addJobExecuteResultHandler(updateRewordJobName, this::saveAndUploadRewordQueryResult);
        } else {
            throw new BotMethodFormatException("收益查询方法错误, " +
                    "应为 AccountRewordSnapshot methodName(AccountContext ac, List<AccountContext> sameAccountBaseInfoIdLists)");
        }
    }

    /**
     * 奖励查询方法的代理方法，得到收益快照后存人数据库
     *
     * @param accountContext    accountContext
     * @param accountContexts   accountContexts
     * @return  AccountRewordSnapshot
     */
    private RewordInfo rewardQueryProxyMethod(AccountContext accountContext, List<AccountContext> accountContexts) {
        if (this.updateRewordMethod == null) {
            throw new BotMethodInvokeException("update reword into,,");
        } else {
            try {
                AccountRewordSnapshot rewordSnapshot = (AccountRewordSnapshot) this.updateRewordMethod.invoke(
                    this, accountContext, accountContexts
                );

                // 解析后存db
                return RewordInfo.builder()
                    .botId(getBotInfo().getId())
                    .botKey(getBotInstance().getBotKey())
                    .botAccountId(accountContext.getId())
                    .totalPoints(rewordSnapshot.getTotalPoints())
                    .dailyPoints(rewordSnapshot.getDailyPoints())
                    .build();
            } catch (Exception e) {
                throw new BotMethodInvokeException("reword query method invoke error", e);
            }
        }
    }

    /**
     * 定时任务方法处理器
     *
     * @param method       method
     * @param botJobMethod botJobMethod
     */
    private void timedTaskMethodHandler(Method method, BotMethod botJobMethod) {
        logger.debug("add [%s] method".formatted(botJobMethod));

        if (method.getParameterCount() > 2
                || method.getParameterCount() < 1
                || method.getParameters()[0].getType() != AccountContext.class
                || (method.getParameterCount() == 2 && method.getParameters()[1].getType() != List.class)
        ) {
            throw new BotMethodFormatException("定时任务方法错误, " +
                    "应为 void methodName(AccountContext ac) 或 " +
                    "void methodName(AccountContext exampleAC, List<AccountContext> sameABIIdList) ");
        }

        registryJobInBot(
                getInstance(),
                method,
                null,
                botJobMethod
        );
    }

    /**
     * Web socket 方法处理器
     *
     * @param method           method
     * @param botJobMethodAnno botJobMethodAnno
     */
    private void webSocketConnectMethodHandler(Method method, BotMethod botJobMethodAnno) {
        logger.debug("add ws [%s] method".formatted(botJobMethodAnno));
        Class<?> returnType = method.getReturnType();

        // 检查方法是否符合要求
        if (cn.com.vortexa.script_node.websocket.BaseBotWSClient.class.isAssignableFrom(returnType)
                && method.getParameterCount() == 1
                && method.getParameters()[0].getType() == AccountContext.class
        ) {
            try {
                // 符合要求，添加到jobMap
                String jobName = registryJobInBot(
                        webSocketClientLauncher,
                        WebSocketClientLauncher.lanuchMethod,
                        null,
                        botJobMethodAnno
                );

                AutoBotJobRuntimeParam runtimeParam = getJobRuntimeParamMap().get(jobName);

                if (runtimeParam != null) {
                    // 添加额外参数
                    runtimeParam.setExtraParams(new Object[]{getJobParam(jobName), (AccountWSClientBuilder) accountContext -> {
                        Object invoke = method.invoke(getInstance(), accountContext);
                        return (BaseBotWSClient<?>) invoke;
                    }});
                }

            } catch (Exception e) {
                throw new BotMethodFormatException(e);
            }
        } else {
            throw new BotMethodFormatException(
                    "websocket 方法错误, 应为 BotWebSocketContext<?,?> methodName(AccountContext)");
        }
    }

    /**
     * 运行bot method
     *
     * @param method method
     * @param args   args
     * @return CompletableFuture<R>
     */
    private @NotNull CompletableFuture<Result> invokeBotMethod(Method method, Object... args) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                return (Result) method.invoke(this, args);
            } catch (IllegalAccessException | InvocationTargetException e) {
                throw new BotMethodInvokeException(String.format(
                        "执行[%s]-[%s]方法发生异常",
                        getBotInstance().getBotKey(),
                        method.getName()
                ), e);
            }
        }, getExecutorService());
    }

    protected BotInfo generateFromAnno(BotApplication annotation) {
        BotInfo botInfo = new BotInfo();
        botInfo.setName(annotation.name());
        botInfo.setDescription(annotation.describe());
        botInfo.setImage(annotation.image());
        botInfo.setLimitProjectIds(Arrays.toString(annotation.limitProjectIds()));
        botInfo.getParams()
                .put(CONFIG_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.configParams())));
        botInfo.getParams()
                .put(ACCOUNT_PARAMS_KEY, JSONArray.parseArray(JSONArray.toJSONString(annotation.accountParams())));

        return botInfo;
    }

    public  List<Method> allMethods() {
        List<Method> list = new ArrayList<>();
        Class<?> clazz = getClass();

        while (clazz != null) {
            // 获取当前类的所有声明的方法，包括私有方法、保护方法和公共方法
            Method[] methods = clazz.getDeclaredMethods();
            list.addAll(Arrays.asList(methods));
            // 获取父类继续遍历
            clazz = clazz.getSuperclass();
        }
        return list;
    }
}
package cn.com.vortexa.script_node.bot;

import cn.com.vortexa.script_node.anno.BotMethod;
import cn.com.vortexa.script_node.anno.BotWSMethodConfig;
import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.BotACJobResult;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.job.AutoBotJobParam;
import cn.com.vortexa.common.dto.job.AutoBotJobWSParam;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.job.core.AutoBotJobInvoker;
import cn.com.vortexa.script_node.dto.job.AutoBotJobRuntimeParam;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Getter;
import org.jetbrains.annotations.NotNull;
import org.quartz.CronExpression;
import org.quartz.JobKey;

import java.lang.reflect.Method;
import java.text.ParseException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;


import static cn.com.vortexa.common.constants.BotJobType.ACCOUNT_SPLIT_JOB;
import static cn.com.vortexa.common.dto.job.AutoBotJobParam.START_AT;

@Getter
public abstract class JobInvokeAutoBot extends AccountManageAutoBot implements AutoBotJobInvoker {

    /**
     * job运行时参数
     */
    private final Map<String, AutoBotJobRuntimeParam> jobRuntimeParamMap = new ConcurrentHashMap<>();

    /**
     * job执行完成后的回调Map
     */
    private final Map<String, JobExecuteResultHandler> jobExecuteResultHandlerMap = new HashMap<>();

    private final Random random = new Random();

    @Override
    public void invokeJob(JobKey jobKey, AutoBotJobParam jobParam) {
        String jobName = jobKey.getName();

        // Step 1 获取运行时参数
        AutoBotJobRuntimeParam runtimeParam = jobRuntimeParamMap.get(jobName);

        // 账户拆分任务,不需要遍历账户列表
        if (ACCOUNT_SPLIT_JOB.equals(jobParam.getJobType())) {
            runtimeParam = jobRuntimeParamMap.get(jobKey.getGroup());
            invokeAccountSplitJob(jobKey, jobParam, runtimeParam);
            return;
        }

        // 动态触发器
        // 遍历账户，生成新的一些一次性任务执行
        if (BooleanUtil.isTrue(jobParam.getDynamicTrigger())) {
            splitJobByAccount(jobParam, jobName);
            return;
        }

        // Step 2 调用执行方法
        logger.info("开始执行[%s]定时任务".formatted(jobName));

        CompletableFuture<ACListOptResult> future = null;
        if (BooleanUtil.isTrue(jobParam.getUniqueAccount())) {
            future = uniqueForEachAccount(runtimeParam, jobName, jobParam, this::uniqueInvoke);
        } else {
            future = normalForEachAccount(runtimeParam, jobName, jobParam, this::normalInvoke);
        }

        // Step 3 结果处理
        acListOptResultHandler(jobName, future);
    }

    @Override
    protected void doStop() {
        jobRuntimeParamMap.clear();
        super.doStop();
    }

    /**
     * 将Job注册到Bot中
     *
     * @param method           方法
     * @param botJobMethodAnno 方法上的BotMethod注解
     */
    public String registryJobInBot(
            Object invokeObj,
            Method method,
            Object[] extraParams,
            BotMethod botJobMethodAnno
    ) {
        AutoBotJobParam autoBotJobParam = null;

        try {
            Integer intervalInSecond = null;
            CronExpression cronExpression = null;

            String jobName = StrUtil.isBlank(botJobMethodAnno.jobName()) ? method.getName() : botJobMethodAnno.jobName();

            // Step 1 判断合法性
            if (botJobMethodAnno.intervalInSecond() != 0) {
                intervalInSecond = botJobMethodAnno.intervalInSecond();
            } else if (StrUtil.isNotBlank(botJobMethodAnno.cronExpression())) {
                cronExpression = new CronExpression(botJobMethodAnno.cronExpression());
                logger.info("%s cronExpression:[%s]".formatted(jobName, cronExpression.getCronExpression()));
            } else if (botJobMethodAnno.jobType() != BotJobType.ONCE_TASK) {
                throw new IllegalArgumentException("定时任务需设置时间间隔或cron表达式");
            }

            // Step 2 设置job运行时参数
            getJobRuntimeParamMap().put(
                    jobName,
                    AutoBotJobRuntimeParam
                            .builder()
                            .target(invokeObj)
                            .method(method)
                            .extraParams(extraParams)
                            .build()
            );

            // Step 3 构建job task参数
            autoBotJobParam = AutoBotJobParam
                    .builder()
                    .jobName(jobName)
                    .jobType(botJobMethodAnno.jobType())
                    .description(botJobMethodAnno.description())
                    .cronExpression(botJobMethodAnno.cronExpression())
                    .intervalInSecond(intervalInSecond)
                    .concurrentCount(botJobMethodAnno.concurrentCount())
                    .autoBotJobWSParam(convertWSConfigParam(botJobMethodAnno.bowWsConfig()))
                    .uniqueAccount(botJobMethodAnno.uniqueAccount())
                    .dynamicTrigger(botJobMethodAnno.dynamicTrigger())
                    .dynamicTimeWindowMinute(botJobMethodAnno.dynamicTimeWindowMinute())
                    .syncExecute(botJobMethodAnno.syncExecute())
                    .build();
            if (botJobMethodAnno.jobType() == BotJobType.QUERY_REWARD) {
                autoBotJobParam.setUniqueAccount(true);
            }
            // Step 4 设置
            setJobParam(jobName, autoBotJobParam);

            getBotApi().getBotJobService().registerJobInvoker(
                    getScriptNodeName(),
                    getAutoBotConfig().getBotKey(),
                    jobName,
                    this
            );

            return jobName;
        } catch (ParseException e) {
            throw new IllegalArgumentException(
                    String.format("[%s]-[%s]BotJobMethod上错误的cron表达式[%s]",
                            getBotInstance().getBotKey(), method.getName(), botJobMethodAnno.cronExpression()),
                    e
            );
        }
    }

    /**
     * job执行完成后的结果处理
     *
     * @param jobName                 jobName
     * @param jobExecuteResultHandler jobExecuteResultHandler
     */
    public void addJobExecuteResultHandler(
            String jobName,
            JobExecuteResultHandler jobExecuteResultHandler
    ) {
        this.jobExecuteResultHandlerMap.put(jobName, jobExecuteResultHandler);
    }

    /**
     * 开始任务
     *
     * @param jobName jobName
     * @return BotACJobResult
     */
    public BotACJobResult startBotJob(String jobName) {
        return getBotApi().getBotJobService().startJob(
                getScriptNodeName(),
                getAutoBotConfig().getBotKey(),
                jobName,
                getJobParam(jobName),
                getInstance()
        );
    }


    /**
     * 根据账户拆分job
     *
     * @param param   param
     * @param jobName jobName
     */
    private void splitJobByAccount(AutoBotJobParam param, String jobName) {
        if (BooleanUtil.isTrue(param.getUniqueAccount())) {
            uniqueAsyncForACList(
                    (accountContext, accountContexts) -> buildNewJob(param, accountContext),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            asyncForACList(
                    (accountContext) -> buildNewJob(param, accountContext),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }

    /**
     * 运行拆分的job
     *
     * @param jobKey       jobKey
     * @param param        param
     * @param runtimeParam runtimeParam
     */
    private void invokeAccountSplitJob(JobKey jobKey, AutoBotJobParam param, AutoBotJobRuntimeParam runtimeParam) {
        Integer acId = Integer.parseInt(jobKey.getName());

        List<AccountContext> list = getAcMap().get(acId);

        if (list.isEmpty()) {
            throw new IllegalArgumentException("不存在bot account " + acId);
        } else {
            AccountContext accountContext = list.getFirst();

            if (BooleanUtil.isTrue(param.getUniqueAccount())) {
                uniqueInvoke(accountContext, list, runtimeParam.getExtraParams(), runtimeParam.getMethod(), runtimeParam.getTarget());
            } else {
                normalInvoke(accountContext, list, runtimeParam.getExtraParams(), runtimeParam.getMethod(), runtimeParam.getTarget());
            }
        }
    }

    /**
     * 普通账户遍历处理
     *
     * @param runtimeParam runtimeParam
     * @param jobName      jobName
     * @param jobParam     jobParam
     * @return CompletableFuture<ACListOptResult>
     */
    private CompletableFuture<ACListOptResult> normalForEachAccount(
            AutoBotJobRuntimeParam runtimeParam,
            String jobName,
            AutoBotJobParam jobParam,
            AccountJobMethodInvokeHandler handler
    ) {
        Object[] extraParams = runtimeParam.getExtraParams();
        Method jobMethod = runtimeParam.getMethod();
        Object invokeObj = runtimeParam.getTarget();

        if (BooleanUtil.isTrue(jobParam.getSyncExecute())) {
            return syncForACList(
                    accountContext -> handler.invoke(accountContext, null, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            return asyncForACList(
                    accountContext -> handler.invoke(accountContext, null, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }

    /**
     * 独有账户遍历处理
     *
     * @param runtimeParam runtimeParam
     * @param jobName      jobName
     * @param jobParam     jobParam
     * @return CompletableFuture<ACListOptResult>
     */
    private CompletableFuture<ACListOptResult> uniqueForEachAccount(AutoBotJobRuntimeParam runtimeParam, String jobName, AutoBotJobParam jobParam, AccountJobMethodInvokeHandler handler) {
        Object[] extraParams = runtimeParam.getExtraParams();
        Method jobMethod = runtimeParam.getMethod();
        Object invokeObj = runtimeParam.getTarget();

        if (BooleanUtil.isTrue(jobParam.getSyncExecute())) {
            return uniqueSyncForACList(
                    (accountContext, accountContexts) -> handler.invoke(accountContext, accountContexts, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        } else {
            return uniqueAsyncForACList(
                    (accountContext, accountContexts) -> handler.invoke(accountContext, accountContexts, extraParams, jobMethod, invokeObj),
                    (accountContext, result) -> result,
                    jobName
            );
        }
    }


    private @NotNull CompletableFuture<Result> normalInvoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj) {

        return CompletableFuture.supplyAsync(() -> {
            try {
                // 封装参数
                Object[] params;
                if (extraParams == null) {
                    params = new Object[]{accountContext};
                } else {
                    params = new Object[1 + extraParams.length];
                    params[0] = accountContext;
                    System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                }

                // 调用执行的job method
                jobMethod.setAccessible(true);
                Object invoke = jobMethod.invoke(invokeObj, params);
                return Result.ok(invoke);
            } catch (Exception e) {
                logger.error("执行定时任务发生异常", e);
                return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
            }
        }, getExecutorService());
    }

    private @NotNull CompletableFuture<Result> uniqueInvoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj) {
        return CompletableFuture.supplyAsync(() -> {
            try {
                // 封装参数
                Object[] params;
                if (extraParams == null) {
                    params = new Object[]{accountContext, accountContexts};
                } else {
                    params = new Object[2 + extraParams.length];
                    params[0] = accountContext;
                    params[1] = accountContexts;
                    System.arraycopy(extraParams, 0, params, 1, extraParams.length);
                }

                // 调用执行的job method
                jobMethod.setAccessible(true);
                Object invoke = jobMethod.invoke(invokeObj, params);
                return Result.ok(invoke);
            } catch (Exception e) {
                logger.error("执行定时任务发生异常", e);
                return Result.fail("执行定时任务发生异常" + e.getCause().getMessage());
            }
        });
    }


    /**
     * 根据account context构建新的job
     *
     * @param param          param
     * @param accountContext accountContext
     * @return CompletableFuture<Result>
     */
    private @NotNull CompletableFuture<Result> buildNewJob(
            AutoBotJobParam param,
            AccountContext accountContext
    ) {
        return CompletableFuture.supplyAsync(() -> {
            // Step 1 计算开始时间
            long startAt = System.currentTimeMillis()
                    + (Long.max(1, random.nextInt(param.getDynamicTimeWindowMinute())) * 60 * 1000);

            // Step 2 生成参数
            String newJobName = String.valueOf(accountContext.getId());
            AutoBotJobParam jobParam = AutoBotJobParam
                    .builder()
                    .jobType(ACCOUNT_SPLIT_JOB)
                    .jobName(newJobName)
                    .intervalInSecond(param.getIntervalInSecond())
                    .autoBotJobWSParam(param.getAutoBotJobWSParam())
                    .uniqueAccount(param.getUniqueAccount())
                    .build();

            jobParam.putParam(START_AT, startAt);

            // Step 3 开始job
            getBotApi().getBotJobService().startJob(
                    getScriptNodeName(),
                    param.getJobName(),
                    newJobName,
                    jobParam,
                    getInstance(),
                    false
            );
            return Result.ok("job start at " + startAt);
        }, getExecutorService()).exceptionallyAsync(throwable -> {
            logger.error("split job by account, create new job error", throwable);
            return Result.fail("split job by account, create new job error" + throwable.getMessage());
        });
    }

    /**
     * 获取子类实例
     *
     * @return AutoBotJobInvoker
     */
    protected abstract AutoBotJobInvoker getInstance();

    /**
     * 账户列表操作结果处理
     *
     * @param jobName jobName
     * @param future  future
     */
    private void acListOptResultHandler(String jobName, CompletableFuture<ACListOptResult> future) {
        future.thenAcceptAsync(acListOptResult -> {
            if (!acListOptResult.getSuccess()) {
                logger.info("botId[%s]-botName[%s]-jobName[%s] 定时任务执行失败, %s".formatted(
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                ));
            } else {
                logger.info("botId[%s]-botName[%s]-jobName[%s] 定时任务执行成功, %s".formatted(
                        acListOptResult.getBotId(), acListOptResult.getBotName(), acListOptResult.getJobName(), acListOptResult.getErrorMsg()
                ));
            }
            JobExecuteResultHandler resultHandler = this.jobExecuteResultHandlerMap.get(jobName);
            if (resultHandler != null) {
                resultHandler.handle(acListOptResult);
            }
        }, getExecutorService());
    }

    /**
     * 转换BotWSMethodConfig 为 AutoBotJobWSParam
     *
     * @param methodConfig methodConfig
     * @return AutoBotJobWSParam
     */
    private AutoBotJobWSParam convertWSConfigParam(BotWSMethodConfig methodConfig) {
        return new AutoBotJobWSParam(
                methodConfig.isRefreshWSConnection(),
                methodConfig.wsUnlimitedRetry(),
                methodConfig.nioEventLoopGroupThreads(),
                methodConfig.wsConnectCount(),
                methodConfig.reconnectLimit(),
                methodConfig.heartBeatIntervalSecond(),
                methodConfig.reconnectCountDownSecond()
        );
    }

    /**
     * 执行账户job逻辑
     */
    private interface AccountJobMethodInvokeHandler {
        CompletableFuture<Result> invoke(AccountContext accountContext, List<AccountContext> accountContexts, Object[] extraParams, Method jobMethod, Object invokeObj);
    }

    /**
     * 一个job的所有账户执行完毕后的回调
     */
    public interface JobExecuteResultHandler {
        void handle(ACListOptResult acListOptResult);
    }
}
package cn.com.vortexa.script_node.config;

import com.alibaba.fastjson.JSONObject;

import cn.com.vortexa.common.constants.HttpMethod;
import cn.com.vortexa.common.dto.Result;
import cn.com.vortexa.common.dto.config.AutoBotAccountConfig;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.util.FileUtil;
import cn.com.vortexa.common.util.YamlConfigLoadUtil;
import cn.com.vortexa.common.util.http.RestApiClientFactory;
import cn.com.vortexa.common.dto.BotMetaInfo;
import cn.com.vortexa.web3.constants.Web3ChainDict;
import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.util.StrUtil;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.stream.Stream;

/**
 * @author helei
 * @since 2025-04-04
 */
@Slf4j
@Data
@Component
@ConfigurationProperties(prefix = "vortexa.script-node")
public class ScriptNodeConfiguration implements InitializingBean {
    public static final String CUSTOM_CHAIN_INFO_DICT = "cn/com/vortexa/script_bot/wallet/r2money/custom-chain-info.yaml";
    public static final String BOT_META_INF_FILE_NAME = "bot-meta-info.yaml";
    public static final List<String> BOT_META_INFO_PREFIX = List.of("vortexa", "botMetaInfo");
    public static final List<String> BOT_INSTANCE_CONFIG_PREFIX = List.of("vortexa", "botInstance");

    /**
     * bot group（Script Node中运行的bot的group)
     * ）
     */
    private String scriptNodeName;

    /**
     * 远程REST接口的url
     */
    private String remoteRestUrl;

    /**
     * 链信息字典
     */
    private Web3ChainDict chainDict;

    /**
     * bot-instance jar包名字
     */
    private List<String> botInstanceJarNames;

    /**
     * Script node 基础路径
     */
    private String scriptNodeBasePath;

    /**
     * 是否开启命令行菜单
     */
    private boolean commandMenu = true;

    /**
     * botNameMetaInfoMap, （解析配置文件自动填入）
     */
    private Map<String, BotMetaInfo> botNameMetaInfoMap;

    /**
     * botKeyConfigMap, （解析配置文件自动填入）
     */
    private Map<String, AutoBotConfig> botKeyConfigMap;

    /**
     * 自动时自动启动的botKey
     */
    private Set<String> autoLaunchBotKeys;

    /**
     * bot公共配置，会加载到每个bot的 customConfig下
     *
     * @see AutoBotConfig
     */
    private Map<String, Object> botCommonConfig;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 解析地址，
        scriptNodeBasePath = FileUtil.getAppResourceAppConfigDir() + File.separator + scriptNodeName;

        initBotMetaInfo();

        initBotInstance();
    }

    /**
     * 获取远程设置api
     *
     * @return String
     */
    public String buildRemoteConfigRestApi() {
        return remoteRestUrl + "/script-node/remote-config";
    }

    /**
     * 初始化BotInstance
     */
    private void initBotInstance() {
        botKeyConfigMap = new HashMap<>();
        Path botInstanceConfigPath = Paths.get(FileUtil.getBotInstanceConfigDir());
        if (!Files.exists(botInstanceConfigPath) || !Files.isDirectory(botInstanceConfigPath))         {
            log.warn("no bot instance config dir [{}]", botInstanceConfigPath);
            return;
        }

        try (Stream<Path> walk = Files.walk(botInstanceConfigPath, 5)) {
            walk.filter(p -> Files.isRegularFile(p) && p.toString().endsWith(".yaml")).forEach(configFile -> {
                try {
                    AutoBotConfig botConfig = YamlConfigLoadUtil.load(configFile.toFile(), BOT_INSTANCE_CONFIG_PREFIX,
                            AutoBotConfig.class);
                    if (botConfig.getCustomConfig() == null) botConfig.setCustomConfig(new HashMap<>());
                    // 配置文件校验
                    if (botConfig == null) {
                        throw new IllegalArgumentException(
                                "bot instance config file [" + configFile.getFileName() + "] illegal");
                    }

                    BotMetaInfo botMetaInfo = botNameMetaInfoMap.get(botConfig.getBotName());

                    if (botMetaInfo == null) {
                        log.warn("botName[{}] didn't loaded in script node", botConfig.getBotName());
                        return;
                    }

                    botConfig.setMetaInfo(botMetaInfo);

                    // 相对路径转绝对路径
                    reactivePathConfigConvert(
                            botConfig,
                            botMetaInfo.getResourceDir()
                    );

                    // 合并bot公共配置
                    if (botCommonConfig != null) {
                        botConfig.getCustomConfig().putAll(botCommonConfig);
                    }

                    // 合并远程配置
                    AutoBotConfig remoteBotConfig = fetchRemoteBotConfig(
                            buildRemoteConfigRestApi(),
                            scriptNodeName,
                            botConfig.getBotKey()
                    );
                    if (remoteBotConfig != null) {
                        mergeRemoteAutoBotConfig(botConfig, remoteBotConfig);
                    }

                    botKeyConfigMap.put(botConfig.getBotKey(), botConfig);
                } catch (Exception e) {
                    log.error("bot instance config[{}] load error, {}",
                            configFile.getFileName(),
                            e.getCause() == null ? e.getMessage() : e.getCause().getMessage()
                    );
                }
            });
        } catch (IOException e) {
            log.error("load bot instance config error", e);
        }
    }

    /**
     * 初始化bot原信息
     *
     * @throws IOException IOException
     */
    private void initBotMetaInfo() throws IOException {
        botNameMetaInfoMap = new HashMap<>();
        if (CollUtil.isNotEmpty(botInstanceJarNames)) {
            for (String botInstanceJarName : botInstanceJarNames) {
                String jarLibraryPath = FileUtil.getLibraryPath(botInstanceJarName);
                String jarFilePath = FileUtil.getJarFilePath(botInstanceJarName);
                FileUtil.extractJar(
                        jarLibraryPath,
                        jarFilePath
                );

                // 解析文件夹
                log.info("start resolve bot meta info config from dir[{}]", jarFilePath);
                try (Stream<Path> walk = Files.walk(Paths.get(jarFilePath), 5)) {
                    walk.filter(Files::isDirectory).forEach(dir -> {
                        Path configFilePath = dir.resolve(BOT_META_INF_FILE_NAME);
                        if (Files.exists(configFilePath)) {
                            BotMetaInfo metaInfo = YamlConfigLoadUtil.load(configFilePath.toFile(),
                                    BOT_META_INFO_PREFIX, BotMetaInfo.class);

                            // 配置文件校验
                            if (metaInfo == null) {
                                throw new IllegalArgumentException(
                                        "bot meta info file [" + BOT_META_INF_FILE_NAME + "] illegal");
                            }

                            // 设置bot资源目录
                            metaInfo.setResourceDir(dir.toString());
                            // 设置所在jar包路径
                            metaInfo.setClassJarPath(jarLibraryPath);

                            botNameMetaInfoMap.put(metaInfo.getBotName(), metaInfo);
                            log.info("botName [{}] meta info loaded", metaInfo.getBotName());
                        }
                    });
                }
            }
        }
    }

    /**
     * 获取远程配置
     *
     * @param configUrl      configUrl
     * @param scriptNodeName scriptNodeName
     * @param botKey         botKey
     * @return String
     */
    private AutoBotConfig fetchRemoteBotConfig(String configUrl, String scriptNodeName, String botKey) {
        if (StrUtil.isBlank(configUrl)) {
            return null;
        }

        try {
            JSONObject params = new JSONObject();
            params.put("scriptNodeName", scriptNodeName);
            params.put("botKey", botKey);
            String response = RestApiClientFactory.getClient().request(
                    configUrl,
                    HttpMethod.POST,
                    new HashMap<>(),
                    params,
                    new JSONObject()
            ).get();
            Result result = JSONObject.parseObject(response, Result.class);
            if (result.getSuccess()) {
                AutoBotConfig load = YamlConfigLoadUtil.load(String.valueOf(result.getData()),
                        BOT_META_INFO_PREFIX, AutoBotConfig.class);
                log.info("remote config fetch success, merge into [{}] bot config...", botKey);
                return load;
            } else {
                log.warn("script node[{}] botKey[{}] config not found in remote", scriptNodeName, botKey);
                return null;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("script node[{}] botKey[{}] remote fetch error", scriptNodeName, botKey, e);
            return null;
        }
    }

    /**
     * 合并远程配置
     *
     * @param local  local
     * @param remote remote
     */
    private void mergeRemoteAutoBotConfig(AutoBotConfig local, AutoBotConfig remote) {
        if (remote.getAccountConfig() != null) {
            local.setAccountConfig(remote.getAccountConfig());
        }
        if (remote.getCustomConfig() != null) {
            local.setCustomConfig(remote.getCustomConfig());
        }
    }

    /**
     * 相对路径转换
     *
     * @param config          config
     * @param botResourcePath botResourcePath
     */
    private void reactivePathConfigConvert(AutoBotConfig config, String botResourcePath) {
        AutoBotAccountConfig accountConfig = config.getAccountConfig();
        accountConfig.setConfigFilePath(
                FileUtil.generateAbsPath(accountConfig.getConfigFilePath(), botResourcePath)
        );

        Map<String, Object> customConfig = config.getCustomConfig();
        if (customConfig != null && !customConfig.isEmpty()) {
            for (Map.Entry<String, Object> entry : customConfig.entrySet()) {
                Object value = entry.getValue();
                if (value instanceof String) {
                    entry.setValue(FileUtil.generateAbsPath((String) value, botResourcePath));
                }
            }
        }
    }
}
package cn.com.vortexa.script_node.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;

import cn.com.vortexa.common.entity.RewordInfo;
import cn.com.vortexa.db_layer.plugn.table_shard.TableShard;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;

import org.apache.ibatis.annotations.Param;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@TableShard(
    tableNamePrefix = RewordInfo.BOT_REWORD_INFO_TABLE_PREFIX,
    values = {"botId", "botKey"},
    fieldFlag = true,
    shardStrategy = BotIdBasedTableShardStrategy.class,
    targetClass = RewordInfo.class
)
public interface RewordInfoMapper extends BaseMapper<RewordInfo> {

    Integer createIfTableNotExist(@Param("botId") Integer botId, @Param("botKey") String botKey);

}
package cn.com.vortexa.script_node.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.PageInfo;

import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.control.anno.RPCReference;
import cn.com.vortexa.db_layer.util.ConditionQueryUtil;
import cn.com.vortexa.rpc.api.platform.IRewordInfoRPC;
import cn.com.vortexa.script_node.mapper.RewordInfoMapper;
import cn.com.vortexa.script_node.service.IRewordInfoService;
import cn.com.vortexa.common.entity.RewordInfo;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Service;

import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class RewordInfoServiceImpl extends ServiceImpl<RewordInfoMapper, RewordInfo> implements IRewordInfoService {

    @Lazy
    @Autowired
    private RewordInfoServiceImpl rewordInfoService;

    @RPCReference
    private IRewordInfoRPC rewordInfoRPC;

    @Override
    public boolean checkAndCreateShardedTable(Integer botId, String botKey) throws SQLException {
        if (botId == null || StrUtil.isBlank(botKey)) {
            log.error("botId/botKey is empty");
            return false;
        }
        try {
            getBaseMapper().createIfTableNotExist(botId, botKey);
            return true;
        } catch (Exception e) {
            throw new SQLException("check and create sharded table[%s]-[%s] error".formatted(botId, botKey), e);
        }
    }

    @Override
    public PageResult<RewordInfo> queryAccountReword(
        Integer pageNum, Integer pageSize, HashMap<String, Object> params
    ) {
        try {
            PageInfo<RewordInfo> pageInfo = ConditionQueryUtil.conditionQuery(pageNum, pageSize, params, null,
                t -> list(new QueryWrapper<>(t)),
                RewordInfo.class
            );

            return PageResult.<RewordInfo>builder()
                .pageNum(pageInfo.getPageNum())
                .pageSize(pageSize)
                .pages(pageInfo.getPages())
                .total(pageInfo.getTotal())
                .list(pageInfo.getList())
                .build();
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void saveAndUploadRewordInfos(Integer botId, String botKey, List<RewordInfo> rewordInfos) {
        // Step 1 保存本地
        rewordInfoService.saveBatch(rewordInfos);
        rewordInfos.forEach(r->r.setId(null));
        // Step 2 上传
        rewordInfoRPC.saveBatchRPC(botId, botKey, rewordInfos);
    }
}
package cn.com.vortexa.script_node.service;

import com.baomidou.mybatisplus.extension.service.IService;

import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.entity.RewordInfo;

import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;

public interface IRewordInfoService extends IService<RewordInfo> {

    /**
     * 查找并传几个分表
     *
     * @param id id
     * @param botKey botKey
     * @return boolean
     */
    boolean checkAndCreateShardedTable(Integer id, String botKey) throws SQLException;

    /**
     * 查询账户收益
     *
     * @param pageNum pageNum
     * @param pageSize pageSize
     * @param params params
     * @return String
     */
    PageResult<RewordInfo> queryAccountReword(Integer pageNum, Integer pageSize, HashMap<String, Object> params);

    /**
     * 保存收益进库，并上传
     *
     * @param botId botId
     * @param botKey botKey
     * @param rewordInfos rewordInfos
     */
    void saveAndUploadRewordInfos(Integer botId, String botKey, List<RewordInfo> rewordInfos);
}
package cn.com.vortexa.script_node.util.persistence.impl;

import cn.com.vortexa.common.entity.*;
import cn.com.vortexa.script_node.service.BotApi;
import cn.com.vortexa.script_node.util.persistence.AbstractPersistenceManager;
import cn.com.vortexa.common.util.propertylisten.PropertyChangeInvocation;
import lombok.extern.slf4j.Slf4j;

import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.stream.Collectors;

@Slf4j
public class DBAccountPersistenceManager extends AbstractPersistenceManager {

    private final ExecutorService executorService;

    private final BotApi botApi;

    public DBAccountPersistenceManager(BotApi botApi, ExecutorService executorService) {
        this.botApi = botApi;
        this.executorService = executorService;
    }

    @Override
    public void init() {

    }

    @Override
    public void persistenceAccountContexts(List<AccountContext> accountContexts) {
        try {
            botApi.getBotAccountService().insertOrUpdateBatch(accountContexts);
        } catch (SQLException e) {
            throw new RuntimeException("persistence bot account context error", e);
        }
    }

    @Override
    public List<AccountContext> loadAccountContexts(Integer botId, String botKey) {
        // Step 1 加载 projectId 对应的账号
        Map<String, Object> query = new HashMap<>();
        query.put("botId", botId);
        query.put("botKey", botKey);

        List<AccountContext> accountContexts = null;
        try {
            accountContexts = botApi
                    .getBotAccountService()
                    .conditionQuery(query);
        } catch (SQLException e) {
            throw new RuntimeException("query bot[%s][%s] account list error".formatted(botId, botKey), e);
        }


        // Step 2 遍历账号，补充对象
        try {
            fillAccountInfos(accountContexts);
        } catch (Exception e) {
            throw new RuntimeException("fill account info error", e);
        }

        // Step 4
        return accountContexts;
    }

    @Override
    protected void propertyChangeHandler(PropertyChangeInvocation invocation) {
        log.debug("object field{} changed {}->{}", invocation.getPropertyName(), invocation.getOldValue(), invocation.getNewValue());

        Object target = invocation.getTarget();
        if (target instanceof AccountContext) {
            try {
                botApi.getBotAccountService().insertOrUpdate((AccountContext) target);
            } catch (SQLException e) {
                log.error("更新Bot Account Context[{}] error", target, e);
            }
        } else if (target instanceof RewordInfo) {

        }
    }

    @Override
    public void fillAccountInfos(List<AccountContext> accountContexts) throws ExecutionException, InterruptedException {
        Set<Integer> baseAccountIds = new HashSet<>();
        Set<Integer> twitterIds = new HashSet<>();
        Set<Integer> discordIds = new HashSet<>();
        Set<Integer> proxyIds = new HashSet<>();
        Set<Integer> browserIds = new HashSet<>();
        Set<Integer> telegramIds = new HashSet<>();
        Set<Integer> rewordInfoIds = new HashSet<>();
        Set<Integer> walletIds = new HashSet<>();

        accountContexts.forEach(accountContext -> {
            baseAccountIds.add(accountContext.getAccountBaseInfoId());
            twitterIds.add(accountContext.getTwitterId());
            discordIds.add(accountContext.getDiscordId());
            proxyIds.add(accountContext.getProxyId());
            browserIds.add(accountContext.getBrowserEnvId());
            telegramIds.add(accountContext.getTelegramId());
            walletIds.add(accountContext.getWalletId());
            rewordInfoIds.add(accountContext.getId());
        });

        CompletableFuture<Map<Integer, AccountBaseInfo>> accountBaseInfoMapFuture = CompletableFuture.supplyAsync(() -> {
            baseAccountIds.remove(null);
            return botApi.getAccountBaseInfoRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(baseAccountIds))
                    .stream()
                    .collect(Collectors.toMap(AccountBaseInfo::getId, accountBaseInfo -> accountBaseInfo));
        }, executorService);

        CompletableFuture<Map<Integer, TwitterAccount>> twitterAccountMapFuture = CompletableFuture.supplyAsync(() -> {
            twitterIds.remove(null);
            return botApi.getTwitterAccountRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(twitterIds))
                    .stream()
                    .collect(Collectors.toMap(TwitterAccount::getId, twitterAccount -> twitterAccount));
        }, executorService);

        CompletableFuture<Map<Integer, DiscordAccount>> discordAccountMapFuture = CompletableFuture.supplyAsync(() -> {
            discordIds.remove(null);
            return botApi.getDiscordAccountRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(discordIds))
                    .stream()
                    .collect(Collectors.toMap(DiscordAccount::getId, discordAccount -> discordAccount));
        }, executorService);

        CompletableFuture<Map<Integer, ProxyInfo>> proxyInfoMapFuture = CompletableFuture.supplyAsync(() -> {
            proxyIds.remove(null);
            return botApi.getProxyInfoRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(proxyIds))
                    .stream()
                    .collect(Collectors.toMap(ProxyInfo::getId, proxyInfo -> proxyInfo));
        }, executorService);

        CompletableFuture<Map<Integer, BrowserEnv>> browserEnvMapFuture = CompletableFuture.supplyAsync(() -> {
            browserIds.remove(null);
            return botApi.getBrowserEnvRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(browserIds))
                    .stream()
                    .collect(Collectors.toMap(BrowserEnv::getId, browserEnv -> browserEnv));
        }, executorService);

        CompletableFuture<Map<Integer, TelegramAccount>> telegramAccountMapFuture = CompletableFuture.supplyAsync(() -> {
            telegramIds.remove(null);
            return botApi.getTelegramAccountRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(telegramIds))
                    .stream()
                    .collect(Collectors.toMap(TelegramAccount::getId, account -> account));
        }, executorService);

        CompletableFuture<Map<Integer, Web3Wallet>> walletMapFuture = CompletableFuture.supplyAsync(() -> {
            walletIds.remove(null);
            return botApi.getWeb3WalletRPC()
                    .batchQueryByIdsRPC(new ArrayList<>(walletIds))
                    .stream()
                    .collect(Collectors.toMap(Web3Wallet::getId, account -> account));
        }, executorService);

        Map<Integer, AccountBaseInfo> accountBaseInfoMap = accountBaseInfoMapFuture.get();
        Map<Integer, TwitterAccount> twitterAccountMap = twitterAccountMapFuture.get();
        Map<Integer, DiscordAccount> discordAccountMap = discordAccountMapFuture.get();
        Map<Integer, ProxyInfo> proxyInfoMap = proxyInfoMapFuture.get();
        Map<Integer, BrowserEnv> browserEnvMap = browserEnvMapFuture.get();
        Map<Integer, TelegramAccount> telegramAccountMap = telegramAccountMapFuture.get();
        Map<Integer, Web3Wallet> walletMap = walletMapFuture.get();

        accountContexts.forEach(accountContext -> {
            accountContext.setAccountBaseInfo(accountBaseInfoMap.get(accountContext.getAccountBaseInfoId()));
            accountContext.setTwitter(twitterAccountMap.get(accountContext.getTwitterId()));
            accountContext.setDiscord(discordAccountMap.get(accountContext.getDiscordId()));
            accountContext.setProxy(proxyInfoMap.get(accountContext.getProxyId()));
            accountContext.setBrowserEnv(browserEnvMap.get(accountContext.getBrowserEnvId()));
            accountContext.setTelegram(telegramAccountMap.get(accountContext.getTelegramId()));
            accountContext.setWallet(walletMap.get(accountContext.getWalletId()));
        });
    }
}
package cn.com.vortexa.script_node.view.commandMenu;

public enum DefaultMenuType {

    START_BOT_TASK, // 启动Bot任务
    ACCOUNT_LIST,  // 账户列表
    PROXY_LIST, // 代理列表
    BROWSER_ENV_LIST,  // 浏览器环境列表
    IMPORT, // 导入菜单
    LAUNCH_SCRIPT // 启动菜单
}
package cn.com.vortexa.script_node.view;

import cn.com.vortexa.common.util.AnsiColor;
import cn.com.vortexa.script_node.bot.AutoLaunchBot;
import cn.com.vortexa.script_node.constants.BotStatus;
import cn.com.vortexa.script_node.util.AccountInfoPrinter;
import cn.com.vortexa.script_node.util.ScriptBotLauncher;
import cn.com.vortexa.script_node.view.commandMenu.CommandMenuNode;
import cn.com.vortexa.script_node.view.commandMenu.DefaultMenuType;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.script_node.view.commandMenu.PageMenuNode;
import cn.com.vortexa.common.dto.ACListOptResult;
import cn.com.vortexa.common.dto.PageResult;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.common.entity.BrowserEnv;
import cn.com.vortexa.common.entity.ProxyInfo;
import cn.com.vortexa.common.entity.RewordInfo;
import cn.com.vortexa.job.constants.JobStatus;

import com.alibaba.fastjson.JSON;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import org.quartz.SchedulerException;

import java.sql.SQLException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.function.Consumer;
import java.util.stream.Collectors;

import static cn.com.vortexa.script_node.constants.MapConfigKey.*;

@Slf4j
public class ScriptNodeCMDLineMenu extends CommandLineMenu {
    /**
     * 刷新节点
     */
    public static final CommandMenuNode REFRESH_NODE = new CommandMenuNode(true, "刷新", "当前数据已刷新");

    private final List<DefaultMenuType> defaultMenuTypes;

    @Setter
    private Consumer<CommandMenuNode> addCustomMenuNode;

    public ScriptNodeCMDLineMenu(List<DefaultMenuType> defaultMenuTypes) {
        super();
        this.defaultMenuTypes = new ArrayList<>(defaultMenuTypes);

        this.defaultMenuTypes.add(DefaultMenuType.IMPORT);
        this.defaultMenuTypes.add(DefaultMenuType.ACCOUNT_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.PROXY_LIST);
        this.defaultMenuTypes.add(DefaultMenuType.BROWSER_ENV_LIST);
    }

    @Override
    public final void buildBotMenuNode(CommandMenuNode botMenuNode, String botKey) {
        if (addCustomMenuNode != null) {
            addCustomMenuNode.accept(botMenuNode);
        }

        for (DefaultMenuType menuType : defaultMenuTypes) {
            botMenuNode.addSubMenu(switch (menuType) {
                case ACCOUNT_LIST -> buildAccountListMenuNode();
                case PROXY_LIST -> buildProxyListMenuNode();
                case BROWSER_ENV_LIST -> buildBrowserListMenuNode();
                case START_BOT_TASK -> buildStartBotTaskMenuNode(botKey);
                case IMPORT -> buildImportMenuNode();
                case LAUNCH_SCRIPT -> buildLaunchScriptMenuNode(botKey);
            });
        }
    }

    /**
     * 启动bot菜单
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildLaunchScriptMenuNode(String botKey) {
        ScriptBotLauncher botLauncher = ScriptBotLauncher.INSTANCE;

        CommandMenuNode commandMenuNode = new CommandMenuNode("启动/关闭 Bot", "启动或关闭Bot",
                () -> "当前选择的Bot[%s]\n状态[%s]".formatted(
                        botKey,
                        botLauncher.getBotStatus(botKey)
                ));

        return commandMenuNode.addSubMenu(new CommandMenuNode(true, "启动", null, () -> {
            try {
                botLauncher.loadAndLaunchBot(botKey);
                return botKey + " launch finish...Current status: " + botLauncher.getBotStatus(botKey);
            } catch (Exception e) {
                log.error("start bot[{}] error", botKey, e);
                return "";
            }
        })).addSubMenu(new CommandMenuNode(true, "关闭", null, () -> {
            AutoLaunchBot<?> keyBot = botLauncher.getBotByBotKey(botKey);
            if (keyBot == null || keyBot.getStatus() != BotStatus.RUNNING) {
                return AnsiColor.colorize("bot当前状态不能关闭", AnsiColor.YELLOW);
            }
            keyBot.stop();
            return "";
        }));
    }

    /**
     * 构建查看代理列表的菜单节点
     *
     * @return 查看代理列表菜单节点
     */
    private CommandMenuNode buildProxyListMenuNode() {
        return new PageMenuNode<>("查看代理列表", "当前代理列表:", (pageNum, pageSize) -> {
            try {
                return getBot().getBotApi().getProxyInfoRPC().conditionPageQueryRPC(pageNum, pageSize, new HashMap<>());
            } catch (SQLException e) {
                getBot().logger.error(
                        "查询代理列表出错, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
                return null;
            }
        }, ProxyInfo.class);
    }

    /**
     * 构建查看浏览器环境列表的菜单节点
     *
     * @return 查看浏览器环境列表菜单节点
     */
    private CommandMenuNode buildBrowserListMenuNode() {
        return new PageMenuNode<>("查看浏览器环境列表", "当前浏览器环境:", (pageNum, pageSize) -> {
            try {
                return getBot().getBotApi()
                        .getBrowserEnvRPC()
                        .conditionPageQueryRPC(pageNum, pageSize, new HashMap<>());
            } catch (SQLException e) {
                getBot().logger.error(
                        "查询浏览器环境列表出错, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
                return null;
            }
        }, BrowserEnv.class);
    }

    /**
     * 账户列表菜单节点
     *
     * @return 账户列表节点
     */
    private CommandMenuNode buildAccountListMenuNode() {
        CommandMenuNode accountListMenuNode = new PageMenuNode<>("查看账号", "当前账户详情列表:",
                (pageNum, pageSize) -> {
                    try {
                        HashMap<String, Object> filter = new HashMap<>();
                        filter.put("botId", getBot().getBotInstance().getBotId());
                        filter.put("botKey", getBot().getAutoBotConfig().getBotKey());

                        PageResult<AccountContext> pageResult = getBot().getBotApi()
                                .getBotAccountService()
                                .conditionPageQuery(pageNum, pageSize, filter);
                        getBot().getPersistenceManager().fillAccountInfos(pageResult.getList());
                        return pageResult;
                    } catch (Exception e) {
                        getBot().logger.error(
                                "查询账号列表出错, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
                        return new PageResult<>();
                    }
                }, AccountContext.class);

        return accountListMenuNode
                .addSubMenu(buildAccountRewardMenuNode())
                .addSubMenu(buildAccountConnectStatusMenuNode())
                .addSubMenu(REFRESH_NODE);
    }

    /**
     * 查看账户收益菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountRewardMenuNode() {
        return new PageMenuNode<>("查看账号收益", "账号收益详情列表:", (pageNum, pageSize) -> {
            try {
                return getBot().getBotApi()
                        .getRewordInfoService()
                        .queryAccountReword(pageNum, pageSize, new HashMap<>());
            } catch (Exception e) {
                getBot().logger.error(
                        "查询账号收益列表出错, " + (e.getCause() == null ? e.getMessage() : e.getCause().getMessage()));
                return null;
            }
        }, RewordInfo.class);
    }

    /**
     * 查看账户连接情况菜单节点
     *
     * @return 账户收益节点
     */
    private CommandMenuNode buildAccountConnectStatusMenuNode() {
        return new CommandMenuNode(
                "查看账号连接情况",
                "账号连接情况列表:",
                () -> AccountInfoPrinter.printAccountConnectStatusList(getBot().getAccountContexts())
        ).addSubMenu(REFRESH_NODE);
    }

    /**
     * 开始账户连接菜单节点
     *
     * @return 连接账户菜单节点
     */
    private CommandMenuNode buildStartBotTaskMenuNode(String botKey) {
        return new CommandMenuNode(
                "启动任务",
                "选择任务类型",
                node -> {
                    AutoLaunchBot<?> bot = getLoadedBotMap().get(botKey);
                    if (bot == null) return null;

                    Set<String> existJobs = node.getSubNodeList()
                            .stream()
                            .map(CommandMenuNode::getDescribe)
                            .collect(Collectors.toSet());

                    for (String jobName : bot.botJobNameList()) {
                        if (existJobs.contains(jobName)) continue;
                        CommandMenuNode typeInput = new CommandMenuNode(true, null, jobName,
                                () -> JSON.toJSONString(bot.startBotJob(jobName))
                        );

                        typeInput.setTittleBuilder(() -> {
                            JobStatus status = null;
                            try {
                                status = getBot().getBotApi()
                                        .getBotJobService()
                                        .queryJobStatus(
                                                getBot().getScriptNodeName(),
                                                getBot().getAutoBotConfig().getBotKey(),
                                                jobName
                                        );
                                return "%s 任务 (%s)".formatted(jobName, status);
                            } catch (SchedulerException e) {
                                throw new RuntimeException(e);
                            }
                        });

                        node.addSubMenu(typeInput);
                    }
                    return "";
                }
        );
    }

    /**
     * 导入菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportMenuNode() {
        return new CommandMenuNode("导入", "请选择要导入的数据")
                .addSubMenu(buildImportBotAccountContextMenuNode());
    }

    /**
     * 导入bot使用的账号菜单节点
     *
     * @return CommandMenuNode
     */
    private CommandMenuNode buildImportBotAccountContextMenuNode() {
        return new CommandMenuNode(true, "导入bot运行账号", null, () -> {

            try {
                Integer i = getBot().getBotApi().getBotAccountService().importFromExcel(
                        getBot().getBotInfo().getId(),
                        getBot().getBotInstance().getBotKey(),
                        getBot().getAutoBotConfig().getAccountConfig().getConfigFilePath()
                );
                getBot().initAccounts();
                return "bot运行账号导入完成," + i;
            } catch (Exception e) {
                return "import bot account context error," + e.getMessage();
            }
        });
    }

    /**
     * 打印当前的邀请码
     *
     * @return 邀请码
     */
    private String printCurrentRegisterConfig() {
        String inviteCode = (String) getBot().getAutoBotConfig().getCustomConfig().get(INVITE_CODE_KEY);
        String registerType = (String) getBot().getAutoBotConfig().getCustomConfig().get(REGISTER_TYPE_KEY);

        return "(当前邀请码为:" + inviteCode + ")\n"
                + "(当前注册类型为:" + registerType + ")\n";
    }
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.script_node.mapper.RewordInfoMapper">
    <update id="createIfTableNotExist">
        CREATE TABLE IF NOT EXISTS t_reword_info
        (
            "id"                   INTEGER PRIMARY KEY AUTOINCREMENT,
            "bot_id"               INTEGER NOT NULL,
            "bot_key"              TEXT    NOT NULL,
            "bot_account_id"       INTEGER NOT NULL,
            "total_points"         REAL,
            "daily_points"         REAL,
            "insert_datetime"      TEXT DEFAULT (strftime('%Y-%m-%d %H:%M:%S', 'now')),
            "update_datetime"      TEXT,
            "valid"             INTEGER(1) default 1
        );
    </update>
</mapper>
package cn.com.vortexa.rpc.api.platform;

import cn.com.vortexa.common.entity.RewordInfo;

import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/27 15:37
 */
public interface IRewordInfoRPC {

    /**
     * 批量保存收益
     *
     * @param botId botId
     * @param botKey botKey
     * @param rewordInfos rewordInfos
     */
    void saveBatchRPC(Integer botId, String botKey, List<RewordInfo> rewordInfos);
}
package cn.com.vortexa.bot_platform.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;

import cn.com.vortexa.common.entity.RewordInfo;
import cn.com.vortexa.db_layer.plugn.table_shard.TableShard;
import cn.com.vortexa.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;

import org.apache.ibatis.annotations.Param;

import java.util.List;

/**
 * @author h30069248
 * @since 2025/4/27 15:41
 */
@TableShard(
    tableNamePrefix = RewordInfo.BOT_REWORD_INFO_TABLE_PREFIX,
    values = {"botId", "botKey"},
    fieldFlag = true,
    shardStrategy = BotIdBasedTableShardStrategy.class,
    targetClass = RewordInfo.class
)
public interface RewordInfoMapper extends BaseMapper<RewordInfo> {

    /**
     * 不存在分表则创建
     *
     * @param botId botId
     * @param botKey botKey
     * @return Integer
     */
    Integer createIfTableNotExist(@Param("botId") Integer botId, @Param("botKey") String botKey);

    /**
     * 批量保存
     *
     * @param botId botId
     * @param botKey botKey
     * @param rewordInfos rewordInfos
     * @return int
     */
    int saveBatch(@Param("botId") Integer botId, @Param("botKey") String botKey, List<RewordInfo> rewordInfos);
}
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="cn.com.vortexa.bot_platform.mapper.RewordInfoMapper">


    <update id="createIfTableNotExist">
        CREATE TABLE IF NOT EXISTS t_reword_info
        (
            id                   INT PRIMARY KEY AUTO_INCREMENT,
            bot_id               INT NOT NULL,
            bot_key              varchar(255)    NOT NULL,
            bot_account_id       INT NOT NULL,
            total_points         DOUBLE,
            daily_points         DOUBLE,
            insert_datetime      DATETIME DEFAULT CURRENT_TIMESTAMP,
            update_datetime      DATETIME,
            valid             TINYINT(1) default 1
        );
    </update>

    <insert id="saveBatch">
        insert into t_reword_info (
            bot_id, bot_key, bot_account_id, total_points, daily_points, , update_datetime
        )
        values
        <foreach collection="list" item="item" separator=",">
            (#{item.botId}, #{item.botKey}, #{item.botAccountId}, #{item.totalPoints}, current_timestamp)
        </foreach>
    </insert>
</mapper>
vortexa:
  bot-meta-info:
    botName: test_bot
    className: cn.com.vortexa.script_bot.test_bot.TestBot
package cn.com.vortexa.script_bot.test_bot;

import cn.com.vortexa.common.constants.BotJobType;
import cn.com.vortexa.common.dto.config.AutoBotConfig;
import cn.com.vortexa.common.entity.AccountContext;
import cn.com.vortexa.script_node.anno.BotApplication;
import cn.com.vortexa.script_node.anno.BotMethod;
import cn.com.vortexa.script_node.bot.AutoLaunchBot;
import cn.com.vortexa.script_node.dto.AccountRewordSnapshot;
import cn.com.vortexa.script_node.service.BotApi;

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author h30069248
 * @since 2025/4/27 17:12
 */
@BotApplication(name = "test_bot")
public class TestBot extends AutoLaunchBot<TestBot> {
    private final AtomicInteger point = new AtomicInteger(0);
    private final AtomicInteger totalPoint = new AtomicInteger(0);

    @Override
    protected void botInitialized(AutoBotConfig botConfig, BotApi botApi) {

    }

    @Override
    protected TestBot getInstance() {
        return this;
    }


    @BotMethod(jobType = BotJobType.QUERY_REWARD, intervalInSecond = 60)
    public AccountRewordSnapshot rewordUpdate(AccountContext accountContext, List<AccountContext> sameAC) {
        AccountRewordSnapshot rewordSnapshot = new AccountRewordSnapshot();
        double dailyPoints = point.incrementAndGet();
        double totalPoints = totalPoint.addAndGet((int) dailyPoints);
        rewordSnapshot.setDailyPoints(dailyPoints);
        rewordSnapshot.setTotalPoints(totalPoints);
        return rewordSnapshot;
    }
}
package cn.com.vortexa.script_node.dto;

import lombok.Data;

/**
 * @author h30069248
 * @since 2025/4/27 11:51
 */
@Data
public class AccountRewordSnapshot {

    private Double totalPoints;

    private Double dailyPoints;
}
