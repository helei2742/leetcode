package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IAccountBaseInfoRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/accountBaseInfo")
public class AccountBaseInfoController {

    @DubboReference
    private IAccountBaseInfoRPC accountBaseInfoRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return accountBaseInfoRPC.saveAccountBaseInfos(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(accountBaseInfoRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @GetMapping("/typedInfo")
    public Result queryTypedInfo() {
        return accountBaseInfoRPC.queryTypedInfo();
    }

    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = accountBaseInfoRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }
}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotBindVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IBotInfoRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@RestController
@RequestMapping("/bot")
public class BotInfoController {

    @DubboReference
    private IBotInfoRPC botInfoRPC;

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(botInfoRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @PostMapping("/create")
    public Result create(@RequestBody BotBindVO botBindVO) {
        return botInfoRPC.bindBotAccountBaseInfo(botBindVO.getBotId(), botBindVO.getBotKey(),
                botBindVO.getBindAccountBaseInfoList());
    }
}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IBotInstanceRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@RestController
@RequestMapping("/botInstance")
public class BotInstanceController {

    @DubboReference
    private IBotInstanceRPC botInstanceRPC;

    @PostMapping("/pageQuery")
    public Result pageQuery(PageQuery query) throws SQLException {
        return Result.ok(botInstanceRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }
}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IBrowserEnvRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/browserEnv")
public class BrowserEnvController {
    @DubboReference
    private IBrowserEnvRPC browserEnvRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return browserEnvRPC.saveBrowserEnvs(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(browserEnvRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = browserEnvRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }

}
package cn.com.helei.bot_platform.controller;


import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IDiscordAccountRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/discord")
public class DiscordAccountController {
    @DubboReference
    private IDiscordAccountRPC discordAccountRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return discordAccountRPC.saveDiscordAccounts(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(
                discordAccountRPC.conditionPageQuery(
                        query.getPage(),
                        query.getLimit(),
                        query.getFilterMap()
                )
        );
    }

    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = discordAccountRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }

}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.IProxyInfoRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/proxyInfo")
public class ProxyInfoController {

    @DubboReference
    private IProxyInfoRPC proxyInfoRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return proxyInfoRPC.saveProxyInfos(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(proxyInfoRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = proxyInfoRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }
}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.ITelegramAccountRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@RestController
@RequestMapping("/telegram")
public class TelegramAccountController {

    @DubboReference
    private ITelegramAccountRPC telegramAccountRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return telegramAccountRPC.saveTelegrams(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query) throws SQLException {
        return Result.ok(telegramAccountRPC.conditionPageQuery(
                query.getPage(),
                query.getLimit(),
                query.getFilterMap()
        ));
    }

    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = telegramAccountRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }
}
package cn.com.helei.bot_platform.controller;

import cn.com.helei.common.vo.BotImportVO;
import cn.com.helei.common.vo.DeleteVO;
import cn.com.helei.common.vo.PageQuery;
import cn.com.helei.common.dto.Result;
import cn.com.helei.rpc.ITwitterAccountRPC;
import org.apache.dubbo.config.annotation.DubboReference;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLException;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/twitter")
public class TwitterAccountController {

    @DubboReference
    private ITwitterAccountRPC twitterAccountRPC;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return twitterAccountRPC.saveTwitters(importVO.getRawLines());
    }

    @PostMapping("/pageQuery")
    public Result pageQuery(@RequestBody PageQuery query)  throws SQLException {
        return Result.ok(
                twitterAccountRPC.conditionPageQuery(
                        query.getPage(),
                        query.getLimit(),
                        query.getFilterMap()
                )
        );
    }


    @PostMapping("/delete")
    public Result delete(@RequestBody DeleteVO deleteVO) {
        Boolean delete = twitterAccountRPC.delete(deleteVO.getIds());
        if (delete) {
            return Result.ok();
        } else {
            return Result.fail("删除失败");
        }
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.AccountBaseInfoMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.entity.AccountBaseInfo;
import cn.com.helei.rpc.IAccountBaseInfoRPC;
import cn.hutool.core.lang.Pair;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.io.IOException;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@DubboService
public class AccountBaseInfoServiceImpl extends AbstractBaseService<AccountBaseInfoMapper, AccountBaseInfo> implements IAccountBaseInfoRPC {

    public static final String DEFAULT_ACCOUNT_TYPE = "default";


    public AccountBaseInfoServiceImpl() {
        super(accountBaseInfo -> {
            accountBaseInfo.setInsertDatetime(LocalDateTime.now());
            accountBaseInfo.setUpdateDatetime(LocalDateTime.now());
            accountBaseInfo.setIsValid(1);
        });
    }

    @Override
    public Result saveAccountBaseInfos(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            log.error("导入账户数据失败", e.getCause());
            return Result.fail("导入账户数据失败," + e.getMessage());
        }
    }


    @Override
    public Result queryTypedInfo() {
        try {
            List<Pair<String, Integer>> typedInfo = getBaseMapper().queryTypedInfo();
            return Result.ok(typedInfo);
        } catch (Exception e) {
            log.error("查询AccountBaseInfo分类信息失败,", e.getCause());
            return Result.fail(e.getCause().getMessage());
        }
    }

    @Override
    public Integer importFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);
        AtomicInteger total = new AtomicInteger();
        try {
            ExcelReadUtil.readExcelAsMap(
                    proxyFilePath,
                    (type, map) -> AccountBaseInfo.builder()
                            .type(type)
                            .name(autoCast(map.remove("name")))
                            .email(autoCast(map.remove("email")))
                            .password(autoCast(map.remove("password")))
                            .params(map)
                            .build(),
                    (type, accountBaseInfos) -> CompletableFuture.runAsync(() -> {
                        log.info("[{}] 账号基本信息读取完毕, 共[{}]", type, accountBaseInfos.size());
                        Integer insertCount = null;
                        try {
                            insertCount = insertOrUpdateBatch(accountBaseInfos);
                        } catch (SQLException e) {
                            throw new RuntimeException(e);
                        }

                        log.info("[{}] 账号基本信息保存成功, 新增[{}], 共[{}]", type, insertCount, accountBaseInfos.size());

                        total.addAndGet(accountBaseInfos.size());
                    })
            );

        } catch (IOException e) {
            log.error("从文件导入账号基本信息出错", e);
        }

        return total.get();
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        log.info("导入账户基本信息，共[{}]条", rawLines.size());
        List<AccountBaseInfo> list = rawLines.stream().map(map -> {
            String type = autoCast(map.remove("type"));

            return AccountBaseInfo.builder()
                    .type(StrUtil.isBlank(type) ? DEFAULT_ACCOUNT_TYPE : type)
                    .name(autoCast(map.remove("name")))
                    .email(autoCast(map.remove("email")))
                    .password(autoCast(map.remove("password")))
                    .params(map)
                    .build();
        }).toList();

        return insertOrUpdateBatch(list);
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.BotInfo;
import cn.com.helei.db_layer.mapper.BotInfoMapper;
import cn.com.helei.rpc.IBotInfoRPC;
import cn.hutool.core.util.StrUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.time.LocalDateTime;
import java.util.List;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Slf4j
@DubboService
public class BotInfoServiceImpl extends AbstractBaseService<BotInfoMapper, BotInfo> implements IBotInfoRPC {


    public BotInfoServiceImpl() {
        super(botInfo -> {
            botInfo.setInsertDatetime(LocalDateTime.now());
            botInfo.setUpdateDatetime(LocalDateTime.now());
            botInfo.setIsValid(1);
        });
    }


    @Override
    public Result bindBotAccountBaseInfo(Integer botId, String botKey, List<Integer> bindAccountBaseInfoList) {

        // Step 1 参数校验
        if (botId == null || StrUtil.isBlank(botKey)) {
            log.error("Bot[{}]-[{}]绑定账户时参数botId/botKey为空", botId, botKey);
            return Result.fail("参数botId/botKey不能为空");
        }

        BotInfo dbBotInfo = query().eq("id", botId).one();
        if (dbBotInfo == null) {
            log.error("Bot[{}]-[{}] 不存在该bot", botId, botKey);
            return Result.fail("不存在该bot");
        }

        if (bindAccountBaseInfoList == null) bindAccountBaseInfoList = List.of();

        return Result.ok(bindAccountBaseInfoList);
//        // Step 2 查看或创建对应的表
//        try {
//            botAccountContextService.checkAndCreateShardedTable(botId, botKey, false);
//        } catch (SQLException e) {
//            log.error("检查创建[{}]-[{}]对应表失败", botId, botKey);
//            return Result.fail("检查创建表失败, " + e.getMessage());
//        }

//        // Step 3 插入或更新数据
//        List<BrowserEnv> browserEnvs = browserEnvService.getUselessBrowserEnv(bindAccountBaseInfoList.size());
//        AtomicInteger idx = new AtomicInteger();
//
//        List<AccountContext> accountContexts = bindAccountBaseInfoList.stream().map(abId -> {
//            AccountContext accountContext = new AccountContext();
//            accountContext.setBotId(botId);
//            accountContext.setBotKey(botKey);
//            accountContext.setAccountBaseInfoId(abId);
//            accountContext.setBrowserEnvId(browserEnvs.get(idx.getAndIncrement()).getId());
//
//            return accountContext;
//        }).toList();
//
//        Integer i = null;
//        try {
//            i = botAccountContextService.insertOrUpdateBatch(accountContexts);
//
//            log.info("保存Bot[{}]-[{}]账户成功. [{}/{}]", botId, botKey, i, accountContexts.size());
//            return Result.ok("保存Bot账户成功");
//        } catch (SQLException e) {
//            log.error("保存Bot[{}]-[{}]账户失败", botId, botKey, e);
//            return Result.fail("保存Bot账户失败, " + e.getCause().getMessage());
//        }
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.dto.PageResult;
import cn.com.helei.db_layer.mapper.BotInfoMapper;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.entity.BotInfo;
import cn.com.helei.common.entity.BotInstance;
import cn.com.helei.db_layer.mapper.BotInstanceMapper;
import cn.com.helei.rpc.IBotInstanceRPC;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;
import org.springframework.beans.factory.annotation.Autowired;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-18
 */
@Slf4j
@DubboService
public class BotInstanceServiceImpl extends AbstractBaseService<BotInstanceMapper, BotInstance> implements IBotInstanceRPC {

    @Autowired
    private BotInfoMapper botInfoMapper;

    public BotInstanceServiceImpl() {
        super(botInstance -> {
            botInstance.setInsertDatetime(LocalDateTime.now());
            botInstance.setUpdateDatetime(LocalDateTime.now());
            botInstance.setIsValid(1);
        });
    }
    @Override
    public PageResult<BotInstance> conditionPageQuery(int page, int limit, Map<String, Object> filterMap) throws SQLException {

        PageResult<BotInstance> result = super.conditionPageQuery(page, limit, filterMap);

        // 填充botInfo
        List<Integer> botIds = result.getList().stream().map(BotInstance::getBotId).toList();
        Map<Integer, BotInfo> idMapBotInfo = botInfoMapper.selectBatchIds(botIds)
                .stream().collect(Collectors.toMap(BotInfo::getId, botInfo -> botInfo));

        for (BotInstance instance : result.getList()) {
            instance.setBotInfo(idMapBotInfo.get(instance.getBotId()));
        }

        return result;
    }


    @Override
    public Boolean existsBotInstance(BotInstance query) {
        return getBaseMapper().exists(new QueryWrapper<>(query));
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.BrowserEnv;
import cn.com.helei.common.util.pool.IdMarkPool;
import cn.com.helei.db_layer.mapper.BrowserEnvMapper;
import cn.com.helei.rpc.IBrowserEnvRPC;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import static cn.com.helei.common.entity.BrowserEnv.USER_AGENT_KEY;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@DubboService
public class BrowserEnvServiceImpl extends AbstractBaseService<BrowserEnvMapper, BrowserEnv> implements IBrowserEnvRPC {

    private IdMarkPool<BrowserEnv> pool;

    public BrowserEnvServiceImpl() {
        super(browserEnv -> {
            browserEnv.setInsertDatetime(LocalDateTime.now());
            browserEnv.setUpdateDatetime(LocalDateTime.now());
            browserEnv.setIsValid(1);
        });
    }


    @Override
    public Result saveBrowserEnvs(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入浏览器环境失败," + e.getMessage());
        }
    }


    @Override
    public synchronized List<BrowserEnv> getUselessBrowserEnv(int count) {
        if (pool == null) {
            log.info("loading Browser Env pool...");
            this.pool = IdMarkPool.create(list(), BrowserEnv.class);
            log.info("loading Browser Env pool success");
        }

        return pool.getLessUsedItem(count);
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        List<Map<String, Object>> headerList = ExcelReadUtil.readExcelToMap(proxyFilePath);

        log.info("文件解析成功, 共[{}]个", headerList.size());
        return importFromRaw(headerList);
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {

        List<BrowserEnv> list = rawLines.stream().map(map -> {
            Object userAgent = map.remove(USER_AGENT_KEY);
            if (userAgent == null) return null;

            BrowserEnv browserEnv = new BrowserEnv();
            browserEnv.setUserAgent((String) userAgent);
            browserEnv.setOtherHeader(map);
            return browserEnv;
        }).filter(Objects::nonNull).toList();

        return insertOrUpdateBatch(list);
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.DiscordAccount;
import cn.com.helei.db_layer.mapper.DiscordAccountMapper;
import cn.com.helei.rpc.IDiscordAccountRPC;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@DubboService
public class DiscordAccountServiceImpl extends AbstractBaseService<DiscordAccountMapper, DiscordAccount> implements IDiscordAccountRPC {

    public DiscordAccountServiceImpl() {
        super(discordAccount -> {
            discordAccount.setInsertDatetime(LocalDateTime.now());
            discordAccount.setUpdateDatetime(LocalDateTime.now());
            discordAccount.setIsValid(1);
        });
    }


    public Result saveDiscordAccounts(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入discord账号失败," + e.getMessage());
        }
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);

            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取discord account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<DiscordAccount> discordAccounts = rawLines.stream().map(map -> DiscordAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .bindEmail(autoCast(map.remove("bind_email")))
                .bindEmailPassword(autoCast(map.remove("bind_email_password")))
                .token(autoCast(map.remove("token")))
                .params(map)
                .build()
        ).toList();

        return insertOrUpdateBatch(discordAccounts);
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.entity.ProjectInfo;
import cn.com.helei.db_layer.mapper.ProjectInfoMapper;
import cn.com.helei.rpc.IProjectInfoRPC;
import org.apache.dubbo.config.annotation.DubboService;

import java.time.LocalDateTime;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@DubboService
public class ProjectInfoServiceImpl extends AbstractBaseService<ProjectInfoMapper, ProjectInfo> implements IProjectInfoRPC {

    public ProjectInfoServiceImpl() {
        super(projectInfo -> {
            projectInfo.setInsertDatetime(LocalDateTime.now());
            projectInfo.setUpdateDatetime(LocalDateTime.now());
            projectInfo.setIsValid(1);
        });
    }

}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.constants.ProxyProtocol;
import cn.com.helei.common.constants.ProxyType;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.ProxyInfo;
import cn.com.helei.db_layer.mapper.ProxyInfoMapper;
import cn.com.helei.rpc.IProxyInfoRPC;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@DubboService
public class ProxyInfoServiceImpl extends AbstractBaseService<ProxyInfoMapper, ProxyInfo> implements IProxyInfoRPC {


    public ProxyInfoServiceImpl() {
        super(proxyInfo -> {
            proxyInfo.setInsertDatetime(LocalDateTime.now());
            proxyInfo.setUpdateDatetime(LocalDateTime.now());
            proxyInfo.setIsValid(1);
        });

    }


    @Override
    public Result saveProxyInfos(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            log.error("saveProxyInfos error", e);
            return Result.fail("导入代理信息失败," + e.getMessage());
        }
    }

    @Override
    public Integer importFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);

        int total = 0;

        try {
            List<Map<String, Object>> staticProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "static");

            total += importFromRaw(staticProxies);

            List<Map<String, Object>> dynamicProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "dynamic");

            total += importFromRaw(dynamicProxies);

            log.info("代理配置文件解析成功，static-proxy:[{}], dynamic-proxy:[{}]", staticProxies.size(), dynamicProxies.size());

            return total;
        } catch (Exception e) {
            log.error("解析代理配置文件[{}]错误", proxyFilePath, e);

            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {

        List<ProxyInfo> list = rawLines.stream().map(map -> {
            String proxyProtocol = autoCast(map.remove("proxy_protocol"));
            if (proxyProtocol == null) proxyProtocol = autoCast(map.remove("proxyProtocol"));

            Object port = map.remove("port");
            return ProxyInfo.builder()
                    .proxyType(ProxyType.STATIC)
                    .host(autoCast(map.remove("host")))
                    .port(port instanceof Integer ? (Integer) port : Integer.parseInt(autoCast(port)))
                    .proxyProtocol(ProxyProtocol.valueOf(proxyProtocol.toUpperCase()))
                    .username(autoCast(map.remove("username")))
                    .password(autoCast(map.remove("password")))
                    .params(map)
                    .build();
        }).toList();

        return insertOrUpdateBatch(list);
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.TelegramAccount;
import cn.com.helei.db_layer.mapper.TelegramAccountMapper;
import cn.com.helei.rpc.ITelegramAccountRPC;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@Slf4j
@DubboService
public class TelegramAccountServiceImpl extends AbstractBaseService<TelegramAccountMapper, TelegramAccount> implements ITelegramAccountRPC {


    public TelegramAccountServiceImpl() {
        super(telegramAccount -> {
            telegramAccount.setInsertDatetime(LocalDateTime.now());
            telegramAccount.setUpdateDatetime(LocalDateTime.now());
            telegramAccount.setIsValid(1);
        });
    }

    @Override
    public Result saveTelegrams(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入telegram账号失败," + e.getMessage());
        }
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);

            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取telegram account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<TelegramAccount> telegramAccounts = rawLines.stream().map(map -> TelegramAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .phonePrefix(autoCast(map.remove("phone_prefix")))
                .phone(autoCast(map.remove("phone")))
                .token(autoCast(map.remove("token")))
                .params(map)
                .build()
        ).toList();


        return insertOrUpdateBatch(telegramAccounts);
    }
}
package cn.com.helei.bot_platform.service.impl;

import cn.com.helei.common.config.SystemConfig;
import cn.com.helei.common.util.FileUtil;
import cn.com.helei.common.util.excel.ExcelReadUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.service.AbstractBaseService;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.TwitterAccount;
import cn.com.helei.db_layer.mapper.TwitterAccountMapper;
import cn.com.helei.rpc.ITwitterAccountRPC;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.config.annotation.DubboService;

import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@DubboService
public class TwitterAccountServiceImpl extends AbstractBaseService<TwitterAccountMapper, TwitterAccount> implements ITwitterAccountRPC {


    public TwitterAccountServiceImpl() {
        super(twitterAccount -> {
            twitterAccount.setInsertDatetime(LocalDateTime.now());
            twitterAccount.setUpdateDatetime(LocalDateTime.now());
            twitterAccount.setIsValid(1);
        });
    }

    @Override
    public Result saveTwitters(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入twitter 账号失败," + e.getMessage());
        }
    }

    @Override
    public Integer importFromExcel(String fileBotConfigPath) throws SQLException {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            return importFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException {
        List<TwitterAccount> twitterAccounts = rawLines.stream().map(map -> TwitterAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .email(autoCast(map.remove("email")))
                .emailPassword(autoCast(map.remove("email_password")))
                .token(autoCast(map.remove("token")))
                .f2aKey(autoCast(map.remove("f2a_key")))
                .params(map)
                .build()).toList();

        return insertOrUpdateBatch(twitterAccounts);
    }
}
package cn.com.helei.bot_platform.service.rpc;

import cn.com.helei.bot_platform.service.DynamicDubboRPCService;
import cn.com.helei.common.dto.PageResult;
import cn.com.helei.common.dto.Result;
import cn.com.helei.common.entity.AccountContext;
import cn.com.helei.rpc.bot.IBotAccountRPC;
import org.springframework.stereotype.Service;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;


@Service
public class BotAccountContextServiceRPC extends DynamicDubboRPCService<IBotAccountRPC> {

    public BotAccountContextServiceRPC() {
        super(IBotAccountRPC.class);
    }

    public Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> acKVMap) {
        return getRPCInstance("", String.valueOf(botId), botKey).saveBotAccountContext(botId, botKey, acKVMap);
    }

    public Boolean checkAndCreateShardedTable(Integer botId, String botKey, boolean existUpdate) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).checkAndCreateShardedTable(botId, botKey, existUpdate);
    }

    public Integer insertOrUpdate(Integer botId, String botKey, AccountContext accountContext) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).insertOrUpdate(accountContext);
    }

    public Integer insertOrUpdateBatch(Integer botId, String botKey, List<AccountContext> accountContexts) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).insertOrUpdateBatch(accountContexts);
    }

    public PageResult<AccountContext> conditionPageQuery(
            Integer botId, String botKey, int page, int limit, String params, Map<String, Object> filterMap
    ) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).conditionPageQuery(page, limit, params, filterMap);
    }

    public PageResult<AccountContext> conditionPageQuery(
            Integer botId, String botKey, int page, int limit, Map<String, Object> filterMap
    ) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).conditionPageQuery(page, limit, filterMap);
    }

    public List<AccountContext> conditionQuery(Integer botId, String botKey, Map<String, Object> filterMap) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).conditionQuery(filterMap);
    }

    public List<AccountContext> conditionQuery(Integer botId, String botKey, String params, Map<String, Object> filterMap) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).conditionQuery(params, filterMap);
    }

    public AccountContext queryById(Integer botId, String botKey, Serializable id) {
        return getRPCInstance("", String.valueOf(botId), botKey).queryById(id);
    }

    public Boolean delete(Integer botId, String botKey, List<Integer> ids) {
        return getRPCInstance("", String.valueOf(botId), botKey).delete(ids);
    }

    public Integer importFromExcel(Integer botId, String botKey, String fileBotConfigPath) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).importFromExcel(fileBotConfigPath);
    }

    public Integer importFromRaw(Integer botId, String botKey, List<Map<String, Object>> rawLines) throws SQLException {
        return getRPCInstance("", String.valueOf(botId), botKey).importFromRaw(rawLines);
    }
}
package cn.com.helei.bot_platform.service.rpc;

import cn.com.helei.bot_platform.service.DynamicDubboRPCService;
import cn.com.helei.common.dto.PageResult;
import cn.com.helei.common.entity.RewordInfo;
import cn.com.helei.rpc.bot.IRewordInfoRPC;
import org.springframework.stereotype.Service;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

@Service
public class RewordInfoServiceRPC extends DynamicDubboRPCService<IRewordInfoRPC> {
    public RewordInfoServiceRPC() {
        super(IRewordInfoRPC.class);
    }

    public Integer insertOrUpdate(Integer botId, String botKey, RewordInfo rewordInfo) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).insertOrUpdate(rewordInfo);
    }

    public Integer insertOrUpdateBatch(Integer botId, String botKey, List<RewordInfo> rewordInfos) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).insertOrUpdateBatch(rewordInfos);
    }

    public PageResult<RewordInfo> conditionPageQuery(
            Integer botId, String botKey, int page, int limit, String params, Map<String, Object> filterMap
    ) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).conditionPageQuery(page, limit, params, filterMap);
    }

    public PageResult<RewordInfo> conditionPageQuery(
            Integer botId, String botKey, int page, int limit, Map<String, Object> filterMap
    ) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).conditionPageQuery(page, limit, filterMap);
    }

    public List<RewordInfo> conditionQuery(Integer botId, String botKey, Map<String, Object> filterMap) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).conditionQuery(filterMap);
    }

    public List<RewordInfo> conditionQuery(Integer botId, String botKey, String params, Map<String, Object> filterMap) throws SQLException {
        return getRPCInstance(String.valueOf(botId), botKey).conditionQuery(params, filterMap);
    }

    public RewordInfo queryById(Integer botId, String botKey, Serializable id) {
        return getRPCInstance(String.valueOf(botId), botKey).queryById(id);
    }

    public Boolean delete(Integer botId, String botKey, List<Integer> ids) {
        return getRPCInstance(String.valueOf(botId), botKey).delete(ids);
    }
}
package cn.com.helei.bot_platform.service;

import org.apache.dubbo.config.ReferenceConfig;
import org.apache.dubbo.config.RegistryConfig;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import static cn.com.helei.common.constants.DubboConstants.DEFAULT_VERSION;

/**
 * 动态DubboRPC调用service
 *
 * @param <T> 具体的RPC API
 */
public abstract class DynamicDubboRPCService<T> {

    private final Map<String, ReferenceConfig<T>> referenceCache = new ConcurrentHashMap<>();

    private final Map<String, RegistryConfig> registryConfigCache = new ConcurrentHashMap<>();

    private final Class<T> tClass;

    public DynamicDubboRPCService(Class<T> tClass) {
        this.tClass = tClass;
    }


    /**
     * 根据address、group、version获取RPC实例
     *
     * @param group   group
     * @param version version
     * @return T
     */
    public T getRPCInstance(String group, String version) {
        return getRPCInstance(null, group, version);
    }

    /**
     * 根据address、group、version获取RPC实例
     *
     * @param address address
     * @param group   group
     * @param version version
     * @return T
     */
    public T getRPCInstance(String address, String group, String version) {
        ReferenceConfig<T> reference = getReferenceConfig(address, group, version);
        if (null != reference) {
            return reference.get();
        }
        return null;
    }

    private ReferenceConfig<T> getReferenceConfig(String address, String group, String version) {

        return referenceCache.compute(group, (k, v) -> {
            if (v == null) {
                v = new ReferenceConfig<>();
                v.setRegistry(getRegistryConfig(address, group, version));
                v.setInterface(tClass);
                v.setGroup(group);
                v.setVersion(DEFAULT_VERSION);
            }
            return v;
        });
    }

    private RegistryConfig getRegistryConfig(String address, String group, String version) {
        String key = address + "-" + group + "-" + version;
        return registryConfigCache.compute(key, (k, v) -> {
            if (v == null) {
                v = new RegistryConfig();
                v.setAddress(address);
                registryConfigCache.put(key, v);
            }
            return v;
        });
    }
}
package cn.com.helei.bot_platform;

import cn.com.helei.db_layer.DBLayerAutoConfig;
import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@EnableDubbo(scanBasePackages = {"cn.com.helei.bot_platform.service.impl"})
@ImportAutoConfiguration(classes = DBLayerAutoConfig.class)
public class BotPlatformApplication {

    public static void main(String[] args) {
        SpringApplication.run(BotPlatformApplication.class, args);
    }
}
spring:
  datasource:
    url: "jdbc:sqlite://D:\\workspace\\DepinBot\\auto-bot-v_1.1\\botData\\config\\system\\auto_bot.db"

dubbo:
  application:
    name: bot-platform
    logger: slf4j
  registry:
    id: zk-registry
    address: zookeeper://127.0.0.1:2181


logging:
  level:
    org:
      apache:
        dubbo: WARN
        zookeeper: WARN
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>cn.com.helei</groupId>
        <artifactId>BotFramework</artifactId>
        <version>1.0-SNAPSHOT</version>
    </parent>

    <artifactId>bot-platform</artifactId>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>db-layer</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>cn.com.helei</groupId>
            <artifactId>rpc-api</artifactId>
            <version>1.0-SNAPSHOT</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!--dubbo集成springboot依赖-->
        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-spring-boot-starter</artifactId>
        </dependency>
        <dependency>
            <groupId>org.apache.dubbo</groupId>
            <artifactId>dubbo-zookeeper-spring-boot-starter</artifactId>
        </dependency>

    </dependencies>
</project>
package cn.com.helei.common.constants;

public class DubboConstants {
    public static final String DEFAULT_VERSION = "1.0";
}
package cn.com.helei.common.dto.job;

import cn.com.helei.common.constants.BotJobType;
import lombok.*;

import java.io.Serializable;


@Data
@NoArgsConstructor
@AllArgsConstructor
public class AutoBotJobParam implements Serializable {

    private BotJobType jobType;

    private String jobName;

    private String description;

    private String cronExpression;

    private Integer intervalInSecond;

    private Integer concurrentCount;

    private AutoBotJobWSParam autoBotJobWSParam;

    private Boolean uniqueAccount;
}
package cn.com.helei.common.dto.job;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AutoBotJobWSParam implements Serializable {

    private Boolean isRefreshWSConnection;

    private Boolean wsUnlimitedRetry;

    private Integer wsConnectCount;

    private Integer reconnectLimit;

    private Integer heartBeatIntervalSecond;

    private Integer reconnectCountDownSecond;


}
package cn.com.helei.common.dto;


import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PageResult<T> implements Serializable {

    private long total;

    private List<T> list;

    private int pages;

    private int pageNum;

    private int pageSize;

}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;
import lombok.*;


import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.*;


/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@Builder
@TableName("t_account_base_info")
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class AccountBaseInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 1000026515674412242L;

    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("type")
    @CommandTableField
    private String type;

    @TableField("name")
    @ExcelProperty("name")
    @CommandTableField
    private String name;

    @TableField("email")
    @ExcelProperty("email")
    @CommandTableField
    private String email;

    @TableField("password")
    @ExcelProperty("password")
    @CommandTableField
    private String password;

    @TableField("params")
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public AccountBaseInfo(Object originLine) {
        String emailAndPassword = (String) originLine;

        String[] split = emailAndPassword.split(", ");
        email = split[0];

        password = split[1];

        if (split.length == 3) {
            name = split[2];
        }
        if (split.length == 4) {
            type = split[3];
        }
    }
}
package cn.com.helei.common.entity;


import cn.com.helei.common.dto.ConnectStatusInfo;
import cn.com.helei.common.util.excel.IntegerStringConverter;
import cn.com.helei.common.util.propertylisten.PropertyChangeListenClass;
import cn.com.helei.common.util.propertylisten.PropertyChangeListenField;
import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.common.util.typehandler.MapTextTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
@PropertyChangeListenClass(isDeep = true)
public class AccountContext  implements Serializable {


    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("bot_id")
    @CommandTableField
    private Integer botId;

    @TableField("bot_key")
    @ExcelProperty(value = "bot_key")
    @CommandTableField
    private String botKey;

    @TableField("account_base_info_id")
    @ExcelProperty(value = "account_base_info_id", converter = IntegerStringConverter.class)
    @CommandTableField
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty(value = "twitter_id", converter = IntegerStringConverter.class)
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty(value = "discord_id", converter = IntegerStringConverter.class)
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty(value = "proxy_id", converter = IntegerStringConverter.class)
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty(value = "browser_env_id", converter = IntegerStringConverter.class)
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty(value = "telegram_id", converter = IntegerStringConverter.class)
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty(value = "wallet_id", converter = IntegerStringConverter.class)
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    /**
     * 账号状态
     * 0 表示初始状态
     * 1 表示已注册
     */
    @TableField("status")
    @PropertyChangeListenField
    @CommandTableField
    private Integer status;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    @CommandTableField
    private ProxyInfo proxy;

    @TableField(exist = false)
    @CommandTableField
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return params.get(key) == null ? "" : params.get(key).toString();
    }

    public void setParam(String key, Object value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        if (accountBaseInfo == null) return "";
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().generateAddressStr());
    }

    public Boolean isSignUp() {
        return status != null && status == 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }

    public static void signUpSuccess(AccountContext accountContext) {
        accountContext.setStatus(1);
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_info")
public class BotInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 1000026515674412242L;

    public static final String CONFIG_PARAMS_KEY = "config_params_key";

    public static final String ACCOUNT_PARAMS_KEY = "account_params_key";

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField("image")
    private String image;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField("job_params")
    private Map<String, AutoBotJobParam> jobParams = new HashMap<>();

    @TableField("params")
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

}
package cn.com.helei.common.entity;

import com.baomidou.mybatisplus.annotation.*;

        import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * @author com.helei
 * @since 2025-02-18
 */
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_instance")
public class BotInstance  implements Serializable {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("bot_key")
    private String botKey;

    @TableField("account_table_name")
    private String accountTableName;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

    public BotInfo botInfo;
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.hutool.core.util.StrUtil;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;


/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_browser_env")
public class BrowserEnv  implements Serializable {

    public static final String USER_AGENT_KEY = "User-Agent";

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("user_agent")
    @ExcelProperty("user_agent")
    private String userAgent;

    @TableField("other_header")
    @ExcelProperty("other_header")
    private Map<String, Object> otherHeader;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public Map<String, String> generateHeaders() {
        HashMap<String, String> map = new HashMap<>();
        map.put("User-Agent", userAgent);
        otherHeader.forEach((k, v) -> map.put(k, StrUtil.toString(v)));
        return map;
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@Builder
@TableName("t_discord_account")
@AllArgsConstructor
@NoArgsConstructor
public class DiscordAccount  implements Serializable {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("password")
    @ExcelProperty("password")
    private String password;

    @TableField("username")
    @ExcelProperty("username")
    private String username;

    @TableField("bind_email")
    @ExcelProperty("bind_email")
    private String bindEmail;

    @TableField("bind_email_password")
    @ExcelProperty("bind_email_password")
    private String bindEmailPassword;

    @TableField("token")
    @ExcelProperty("token")
    private String token;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;

import lombok.Getter;
import lombok.Setter;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@TableName("t_project_info")
public class ProjectInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 1654642415647348564L;

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;
}
package cn.com.helei.common.entity;

import cn.com.helei.common.constants.ProxyProtocol;
import cn.com.helei.common.constants.ProxyType;
import cn.com.helei.common.util.excel.IntegerStringConverter;
import cn.com.helei.common.util.excel.ProxyProtocolConverter;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;
import lombok.*;

import java.io.Serializable;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_proxy_info")
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ProxyInfo  implements Serializable {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField(value = "proxy_type")
    private ProxyType proxyType;

    @TableField(value = "proxy_protocol")
    @ExcelProperty(value = "proxy_protocol", converter = ProxyProtocolConverter.class)
    private ProxyProtocol proxyProtocol;

    @TableField("host")
    @ExcelProperty(value = "host")
    private String host;

    @TableField("port")
    @ExcelProperty(value = "port", converter = IntegerStringConverter.class)
    private Integer port;

    @TableField("username")
    @ExcelProperty(value = "username")
    private String username;

    @TableField("password")
    @ExcelProperty(value = "password")
    private String password;

    @TableField("params")
    private Map<String, Object> params;

    private Boolean usable;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public ProxyInfo(Object originLine) {
        String proxyUrl = (String) originLine;

        String[] split = proxyUrl.split("://");
        String protocol = split[0];

        proxyProtocol = switch (protocol.toLowerCase()) {
            case "http" -> ProxyProtocol.HTTP;
            case "socks5" -> ProxyProtocol.SOCKS5;
            default -> throw new IllegalStateException("Unexpected value: " + protocol);
        };
        String[] upAndAddress = split[1].split("@");

        if (upAndAddress.length == 1) {
            String[] address = upAndAddress[0].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        } else if (upAndAddress.length == 2) {
            String[] up = upAndAddress[0].split(":");
            this.username = up[0];
            this.password = up[1];

            String[] address = upAndAddress[1].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        }
    }


    public SocketAddress generateAddress() {
        return new InetSocketAddress(host, port);
    }

    public String generateAddressStr() {
        return host + ":" + port;
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.propertylisten.PropertyChangeListenClass;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;


import lombok.Getter;
import lombok.Setter;

import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_reword_info")
@PropertyChangeListenClass
public class RewordInfo  implements Serializable {

    @TableId(value = "project_account_id", type = IdType.INPUT)
    private Integer projectAccountId;

    @TableField("total_points")
    private Double totalPoints;

    @TableField("session")
    private String session;

    @TableField("session_points")
    private Double sessionPoints;

    @TableField("daily_points")
    private Double dailyPoints;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public RewordInfo newInstance() {
        RewordInfo rewordInfo = new RewordInfo();
        rewordInfo.totalPoints = this.totalPoints;
        rewordInfo.session = this.session;
        rewordInfo.sessionPoints = this.sessionPoints;
        rewordInfo.dailyPoints = this.dailyPoints;
        rewordInfo.insertDatetime = this.insertDatetime;
        rewordInfo.updateDatetime = this.updateDatetime;
        rewordInfo.isValid = this.isValid;

        return rewordInfo;
    }
}
package cn.com.helei.common.entity;

import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@Getter
@Setter
@Builder
@TableName("t_telegram_account")
@AllArgsConstructor
@NoArgsConstructor
public class TelegramAccount implements Serializable {


    @TableId(value = "id", type = IdType.INPUT)
    private Integer id;

    @TableField("username")
    @ExcelProperty("username")
    private String username;

    @TableField("password")
    @ExcelProperty("password")
    private String password;

    @TableField("phone_prefix")
    @ExcelProperty("phone_prefix")
    private String phonePrefix;

    @TableField("phone")
    @ExcelProperty("phone")
    private String phone;

    @TableField("token")
    @ExcelProperty("token")
    private String token;

    @TableField("params")
    private Map<String, Object> params;

    @TableField("insert_datetime")
    private LocalDateTime insertDatetime;

    @TableField("update_datetime")
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@Builder
@TableName("t_twitter_account")
@AllArgsConstructor
@NoArgsConstructor
public class TwitterAccount implements Serializable {

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("username")
    @ExcelProperty("username")
    private String username;

    @TableField("password")
    @ExcelProperty("password")
    private String password;

    @TableField("email")
    @ExcelProperty("email")
    private String email;

    @TableField("email_password")
    @ExcelProperty("email_password")
    private String emailPassword;

    @TableField("token")
    @ExcelProperty("token")
    private String token;

    @TableField("f2a_key")
    @ExcelProperty("f2a_key")
    private String f2aKey;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;
}
package cn.com.helei.common.service;


import cn.com.helei.common.dto.PageResult;

import java.io.Serializable;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

public interface IBaseService<T> {
    Integer insertOrUpdate(T t) throws SQLException;

    Integer insertOrUpdateBatch(List<T> tList) throws SQLException;

    PageResult<T> conditionPageQuery(int page, int limit, String params, Map<String, Object> filterMap) throws SQLException;

    PageResult<T> conditionPageQuery(int page, int limit, Map<String, Object> filterMap) throws SQLException;

    List<T> conditionQuery(Map<String, Object> filterMap) throws SQLException;

    List<T> conditionQuery(String params, Map<String, Object> filterMap) throws SQLException;

    T queryById(Serializable id);

    Boolean delete(List<Integer> ids);
}
package cn.com.helei.common.service;


import java.sql.SQLException;
import java.util.List;
import java.util.Map;

public interface ImportService {

    Integer importFromExcel(String fileBotConfigPath) throws SQLException;

    Integer importFromRaw(List<Map<String, Object>> rawLines) throws SQLException;
}
package cn.com.helei.db_layer.mapper;

import cn.com.helei.common.entity.ProjectInfo;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface ProjectInfoMapper extends IBaseMapper<ProjectInfo> {

}
package cn.com.helei.db_layer.mapper;

import cn.com.helei.common.entity.ProjectInfo;

/**
 * <p>
 *  Mapper 接口
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
public interface ProjectInfoMapper extends IBaseMapper<ProjectInfo> {

}
package cn.com.helei.db_layer.service;

import cn.com.helei.common.dto.PageResult;
import cn.com.helei.common.service.IBaseService;
import cn.com.helei.common.util.ConditionBuildUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.util.ConditionQueryUtil;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.PageInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public abstract class AbstractBaseService<M extends IBaseMapper<T>, T> extends ServiceImpl<M, T> implements IBaseService<T> {

    private final Consumer<T> fillFunction;

    protected AbstractBaseService(Consumer<T> fillFunction) {
        this.fillFunction = fillFunction;
    }

    @Override
    public T queryById(Serializable id) {
        return getById(id);
    }

    /**
     * 插入或更新
     *
     * @param t t
     * @return Integer
     */
    @Override
    public Integer insertOrUpdate(T t) throws SQLException {
        fillFunction.accept(t);
        return getBaseMapper().insertOrUpdate(t);
    }


    /**
     * 批量插入或更新
     *
     * @param tList tList
     * @return Integer
     */
    @Override
    public Integer insertOrUpdateBatch(List<T> tList) throws SQLException {
        int successCount = 0;
        for (T t : tList) {
            try {
                Integer count = insertOrUpdate(t);
                successCount += count == null ? 0 : count;
            } catch (Exception e) {
                throw new SQLException("insert or update error", e);
            }
        }

        return successCount;
    }

    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            Map<String, Object> filterMap
    ) throws SQLException {
        return conditionPageQuery(page, limit, "params", filterMap);
    }


    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param paramsKey paramsKey
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            String paramsKey,
            Map<String, Object> filterMap
    ) throws SQLException {
        try {
            PageInfo<T> pageInfo = ConditionQueryUtil.conditionQuery(
                    page,
                    limit,
                    filterMap,
                    paramsKey,
                    condition -> getBaseMapper().multipleConditionQuery(condition),
                    entityClass
            );
            List<T> list = pageInfo.getList();
            PageResult<T> pageResult = new PageResult<>();
            pageResult.setPages(pageInfo.getPages());
            pageResult.setPageNum(pageInfo.getPageNum());
            pageResult.setPageSize(pageInfo.getPageSize());
            pageResult.setTotal(pageInfo.getTotal());
            pageResult.setList(list);
            return pageResult;
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException |
                 IllegalAccessException e
        ) {
            throw new SQLException("condition query error", e);
        }
    }

    @Override
    public List<T> conditionQuery(Map<String, Object> filterMap) throws SQLException {
        return conditionQuery("params", filterMap);
    }

    @Override
    public List<T> conditionQuery(String paramsKey, Map<String, Object> filterMap) throws SQLException {
        T condition = null;
        try {
            condition = ConditionBuildUtil.getMapContainsCondition(
                    filterMap,
                    paramsKey,
                    entityClass
            );
        } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                 IllegalAccessException e) {
            throw new SQLException(e);
        }

        return getBaseMapper().multipleConditionQuery(condition);
    }

    /**
     * 删除
     *
     * @param ids ids
     * @return Result
     */
    @Transactional
    public Boolean delete(List<Integer> ids) {
        return removeBatchByIds(ids);
    }


    protected <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }

    protected Integer toInteger(Object obj) {
        return obj == null ? null : Integer.valueOf(obj.toString());
    }
}
package cn.com.helei.db_layer;

import cn.com.helei.db_layer.config.MybatisConfig;
import cn.com.helei.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@MapperScan(basePackages = "cn.com.helei.db_layer.mapper")
@Import(MybatisConfig.class)
public class DBLayerAutoConfig {

    @Bean
    public BotIdBasedTableShardStrategy botIdBasedTableShardStrategy() {
        return new BotIdBasedTableShardStrategy();
    }
}
# 应用程序名称
spring:
  datasource:
    driver-class-name: org.sqlite.JDBC
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      maximum-pool-size: 10
      auto-commit: true
      idle-timeout: 60000
      max-lifetime: 1800000
      pool-name: HikariPool
      connection-test-query: SELECT 1
      minimum-idle: 10
  output:
    ansi:
      enabled: always

mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
    cache-enabled: true
    map-underscore-to-camel-case: false
  global-config:
    db-config:
      logic-delete-field: isValid  # 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)
      logic-delete-value: 0    # 设置 1 为未删除
      logic-not-delete-value: 1 # 设置 0 为已删除
  mapper-locations: classpath:/mapper/*.xml


# 其他配置
logging:
  level:
    org.springframework: ERROR
#    cn.com.helei.bot.core: DEBUG
