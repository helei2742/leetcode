package com.helei.constants;

import lombok.Getter;

import java.util.HashMap;
import java.util.Map;

/**
 * 持仓方向
 */
@Getter
public enum PositionSide {

    BOTH("BOTH"),
    LONG("LONG"),
    SHORT("SHORT"),
    ;

    public static final Map<String, PositionSide> STATUS_MAP = new HashMap<>();

    static {
        for (PositionSide status : PositionSide.values()) {
            STATUS_MAP.put(status.getDescription(), status);
        }
    }

    private final String description;

    PositionSide(String description) {
        this.description = description;
    }
}


package com.helei.dto.account;

import com.helei.dto.AssetInfo;
import lombok.*;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@ToString
public class AccountBalanceInfo {

    /**
     * 账户id
     */
    private long accountId;

    /**
     * 更新时间
     */
    private Long updateTime;

    /**
     * 资金信息
     */
    private List<AssetInfo> balances;

}
package com.helei.dto.account;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 账户仓位设置
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class AccountPositionConfig {

    /**
     * 风险百分比
     */
    private double riskPercent;

    /**
     * 杠杠倍数
     */
    private int leverage;


    /**
     * 止损金额
     */
    private int stopLoss;

}


package com.helei.dto.account;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class AccountPositionInfo {


    /**
     * 账户id
     */
    private long accountId;

    /**
     * 更新时间
     */
    private long updateTime;

    /**
     * 仓位信息
     */
    private List<PositionInfo> positions;



    public void updatePositionInfos(List<PositionInfo> positionInfos) {

    }
}

package com.helei.dto.account;


import com.helei.constants.PositionSide;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class PositionInfo implements Serializable {


    /**
     * 交易对
     */
    private String symbol;

    /**
     * 仓位
     */
    private Double position;

    /**
     * 入仓价格
     */
    private Double enterPosition;

    /**
     * 盈亏平衡价
     */
    private Double balanceEqualPrice;

    /**
     * 总盈亏
     */
    private Double countProfitOrLoss;

    /**
     * 未实现盈亏
     */
    private Double unrealizedProfitOrLoss;

    /**
     * 保证金模式
     * TODO 切换枚举
     */
    private String  model;

    /**
     * 保证金
     */
    private Double bail;

    /**
     * 持仓方向
     */
    private PositionSide positionSide;


}


package com.helei.dto.account;


import com.helei.constants.RunEnv;
import com.helei.constants.TradeType;
import com.helei.dto.ASKey;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class UserAccountInfo {

    /**
     * 账户id
     */
    private long id;

    /**
     * 用户id
     */
    private long userId;

    /**
     * 验证key
     */
    private ASKey asKey;

    /**
     * 是否可用
     */
    private final AtomicBoolean usable = new AtomicBoolean(false);

    /**
     * 运行环境，测试网还是主网
     */
    private RunEnv runEnv;

    /**
     * 交易类型
     */
    private TradeType tradeType;

    /**
     * 订阅的交易对
     */
    private List<String> subscribeSymbol;

    /**
     * 账户仓位设置
     */
    private AccountPositionConfig accountPositionConfig;

    /**
     * 账户资金信息
     */
    private AccountBalanceInfo accountBalanceInfo;


    /**
     * 账户仓位信息
     */
    private AccountPositionInfo accountPositionInfo;


}


package com.helei.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class KeyValue<K, V> {

    private K key;

    private V value;
}



package com.helei.netty.base;


import com.alibaba.fastjson.JSON;
import com.helei.netty.NettyConstants;
import com.helei.netty.handler.RequestResponseHandler;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.Socks5ProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    protected String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    protected final ExecutorService callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected InetSocketAddress proxy = null;

    /**
     * 重链接次数
     */
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);

    /**
     * 当前是否在允许
     */
    @Getter
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    @Setter
    @Getter
    private String name;

    private Bootstrap bootstrap;

    private EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    private final RequestResponseHandler<T> requestResponseHandler;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        this.callbackInvoker = Executors.newVirtualThreadPerTaskExecutor();

        requestResponseHandler = new RequestResponseHandler<>();
    }

    private void init() throws SSLException, URISyntaxException {

        resolveParamFromUrl();

        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders()
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            p.addLast(new Socks5ProxyHandler(proxy));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }

    /**
     * 链接服务端
     * @throws SSLException Exception
     */
    public CompletableFuture<Void> connect() throws SSLException, URISyntaxException {
        if (isRunning.get()) {
            log.warn("WS客户端[{}}已链接", url);
            return CompletableFuture.runAsync(()->{});
        }

        log.info("开始初始化WS客户端");
        init();
        log.info("初始化WS客户端完成，开始链接服务器 [{}]", url);

        return reconnect();
    }


    /**
     * 重链接
     * @return  CompletableFuture<Void>
     */
    public CompletableFuture<Void> reconnect() {
        return CompletableFuture.runAsync(() -> {
            AtomicBoolean isSuccess = new AtomicBoolean(false);
            while (reconnectTimes.incrementAndGet() <= NettyConstants.RECONNECT_LIMIT) {
                eventLoopGroup.schedule(() -> {
                    reconnectTimes.decrementAndGet();
                }, 60, TimeUnit.SECONDS);

                log.info("start connect client [{}], url[{}], current times [{}]", name, url, reconnectTimes.get());
                CountDownLatch latch = new CountDownLatch(1);


                eventLoopGroup.schedule(() -> {
                    try {
                        channel = bootstrap.connect().sync().channel();
                        // 8. 等待 WebSocket 握手完成
                        handler.handshakeFuture().sync();

                        channel.attr(NettyConstants.CLIENT_NAME).set(name);

                        isSuccess.set(true);
                    } catch (Exception e) {
                        log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                    }
                    latch.countDown();
                }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                try {
                    latch.await();
                } catch (InterruptedException e) {
                    log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                }

                if (isSuccess.get()) {

                    log.info("connect client [{}], url[{}] success, current times [{}]", name, url, reconnectTimes.get());
                    isRunning.set(true);
                    break;
                }
            }
            if (!isSuccess.get()) {
                isRunning.set(false);
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
            }
        }, callbackInvoker);
    }


    /**
     * 关闭WebSocketClient
     */
    public void close() {
        log.info("start close websocket client [{}]", name);
        if (channel != null) {
            channel.close();
        }
        if (eventLoopGroup != null) {
            eventLoopGroup.shutdownGracefully();
        }

        reconnectTimes.set(0);
        isRunning.set(false);
        log.info("web socket client [{}] closed", name);
    }


    /**
     * 从request获取id
     *
     * @param request request
     * @return id
     */
    public abstract String getIdFromRequest(P request);

    /**
     * 发送请求, 注册响应监听
     *
     * @param request  请求体
     * @param callback 请求结果的回调
     */
    public void sendRequest(P request, Consumer<T> callback) {
        sendRequest(request, callback, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request         请求体
     * @param callback        请求结果的回调
     * @param executorService 执行回调的线程池，传入为空则会尝试使用本类的线程池以及netty线程池
     */
    public void sendRequest(P request, Consumer<T> callback, ExecutorService executorService) {
        boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
            if (executorService == null) {
                //此类线程处理
                callbackInvoker.submit(() -> {
                    callback.accept(response);
                });
            } else { //参数线程池处理
                executorService.submit(() -> {
                    callback.accept(response);
                });
            }

        });

        if (flag) {
            log.debug("send request [{}]", request);
            channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
        } else {
            throw new IllegalArgumentException("request id registered");
        }
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        log.debug("client [{}] send ping {}", name, url);
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        log.debug("client [{}] send pong {}", name, url);
        channel.writeAndFlush(new PongWebSocketFrame());
    }

    /**
     * 发送请求,不组册监听
     *
     * @param request 请求体
     */
    public void sendRequestNoListener(P request) {
        channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
    }


    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }


    /**
     * 提交请求的响应
     *
     * @param id       id
     * @param response response
     * @return 是否成功
     */
    public boolean submitResponse(String id, T response) {
        return requestResponseHandler.submitResponse(id, response);
    }

    /**
     * 提交stream流的响应
     *
     * @param streamName streamName, 通常由symbol和WebSocketStreamType组合成
     * @param message    message
     */
    public abstract void submitStreamResponse(String streamName, T message);
}





package com.helei.util;

import com.helei.dto.account.AccountPositionConfig;
import com.helei.dto.TrendLine;

import java.util.List;
import java.util.function.Function;

public class CalculatorUtil {


    /**
     *  EMA 计算公式
     * @param price 当前价格
     * @param previousMA 前一个ema值
     * @param period 间隔
     * @return 当前ma
     */
    public static double calculateMA(double price, double previousMA, int period) {
        return (previousMA * (period - 1) + price) / period;
    }


    /**
     *  EMA 计算公式
     * @param price 当前价格
     * @param previousEMA 前一个ema值
     * @param period 间隔
     * @return 当前ema
     */
    public static double calculateEMA(double price, double previousEMA, int period) {
        double alpha = 2.0 / (period + 1.0);
        return alpha * price + (1 - alpha) * previousEMA;
    }


    /**
     * 计算rsi
     * @param open 开盘价格
     * @param close 收盘价格
     * @param previousRSI   前一个rsi
     * @param interval  间隔
     * @return  rsi
     */
    public static double calculateRSI(double open, double close, double previousRSI, int interval) {
        double gain = Math.max(0, close - open);
        double loss = Math.max(0 , open - close);
        double avgGain = (gain + (interval - 2) * previousRSI) / (interval - 1);
        double avgLoss = (loss + (interval - 2) * (100 - previousRSI)) / (interval - 1);

        return 100 - (100/(1 + avgGain/avgLoss));
    }



    /**
     * 计算趋势线，采用最小二乘法
     * @param data data
     * @param getY getY
     * @param getX getX
     * @return TrendLine
     */
    public static<T> TrendLine calculateTrend(List<T> data, Function<T, Double> getX, Function<T, Double> getY) {
        if (data == null || data.isEmpty() || data.size() < 2) {
            return new TrendLine(0,0);
        }
        int n = data.size();
        double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
        for (T kLine : data) {
            double y =  getY.apply(kLine);
//            long x = kLine.getOpenTime().toInstant(ZoneOffset.UTC).getEpochSecond();
            double x = getX.apply(kLine);

            sumY += y;
            sumX += x;
            sumXY += x * y;
            sumX2 += x * x;
        }

        double k = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
        double m = (sumY - k * sumX) / n;

        return  new TrendLine(k, m);
    }


    /**
     * 计算list的单调性，从后往前取出具有单调性的部分
     * @param arr arr
     * @param calField 要计算单调性的字段
     * @param <T> 范型
     * @return 从后往前具有单调性的数组
     */
    public static <T> List<T> getLastMonotonicPart(List<T> arr, Function<T, Double> calField) {
        if (arr == null || arr.size() < 2) {
            return null;
        }

        int n = arr.size();
        int count = 1;

        // 从倒数第二个元素开始，比较相邻元素的大小
        boolean isIncreasing = calField.apply(arr.get(n - 2)) <= calField.apply(arr.get(n - 1));  // 判断单调性（递增或递减）

        // 从倒数第二个元素往前遍历
        for (int i = n - 2; i >= 0; i--) {
            if (isIncreasing) {
                // 如果是递增序列
                if (calField.apply(arr.get(i)) > calField.apply(arr.get(i + 1))) {
                    break;
                }

            } else {
                // 如果是递减序列
                if (calField.apply(arr.get(i)) > calField.apply(arr.get(i + 1))) {
                    break;
                }
            }
            count++;
        }

        // 返回最后具有单调性的部分
        return arr.subList(n - Math.max(2, count), n);
    }



    /**
     * 计算仓位大小
     * @param totalCapital  总可用金额
     * @param locationConfig    仓位设置
     * @param currentPrice  当前价格
     * @return 仓位大小
     */
    public static double calculatePositionSize(
            double totalCapital,
            AccountPositionConfig locationConfig,
            double currentPrice

    ) {
        double riskPercent = locationConfig.getRiskPercent();
        double leverage = locationConfig.getLeverage();
        double stopLoss = locationConfig.getStopLoss();
        // Calculate the maximum amount of capital to risk in this trade
        double maxRiskAmount = totalCapital * riskPercent;

        // Calculate the risk per contract (difference between current price and stop loss)
        double perContractRisk = currentPrice - stopLoss;

        // If stop loss is greater than or equal to current price, return 0 as position size is invalid
        if (perContractRisk <= 0) {
            System.out.println("Invalid stop loss: Stop loss must be less than current price.");
            return 0;
        }

        // Calculate the position size (number of contracts) taking leverage into account

        return (maxRiskAmount / perContractRisk) * leverage;
    }

}





package com.helei.binanceapi.api.ws;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.base.AbstractBinanceWSApi;
import com.helei.constants.WebSocketStreamParamKey;
import com.helei.binanceapi.constants.command.AccountCommandType;
import com.helei.binanceapi.constants.command.BaseCommandType;
import com.helei.dto.ASKey;
import com.helei.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;


@Slf4j
public class BinanceWSBaseApi extends AbstractBinanceWSApi {
    public BinanceWSBaseApi(BinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 测试服务端联通性
     */
    public void pingServer() {
        binanceWSApiClient.sendPing();
    }


    /**
     * 查询服务端的时间
     * @param callback callback, 失败则会传入null. 由父类的线程池执行
     */
    public void queryServerTime(Consumer<Long> callback) {
        JSONObject command = WebSocketCommandBuilder.builder().setCommandType(BaseCommandType.TIME).build();

        String id = command.getString("id");
        binanceWSApiClient.sendRequest(1, command, result -> {
            if (result != null) {
                try {
                    callback.accept(result.getLong("serverTime"));
                    log.debug("get server time [{}], request id[{}] success", result, id);
                } catch (Exception e) {
                    callback.accept(null);
                    log.error("parse server time error, requestId [{}]", id,e);
                }
            } else {
                callback.accept(null);
                log.warn("get server time, request id[{}] fail", id);
            }
        });
    }


    /**
     * 查询交易规范信息,
     * @param permissions permissions
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            Consumer<JSONObject> callback,
            List<String> permissions
    ) {
        queryExchangeInfo(null, null, permissions, callback);
    }

    /**
     * 查询交易规范信息,
     * @param symbols symbols
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            List<String> symbols,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(null, symbols, null, callback);
    }

    /**
     * 查询交易规范信息, symbol,
     * @param symbol symbol
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(symbol, null, null, callback);
    }


    /**
     * 查询交易规范信息, symbol,symbols,permissions三个参数只能生效一个，从前到后第一个不为空的生效
     * @param symbol symbol
     * @param symbols symbols
     * @param permissions permissions
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            List<String> symbols,
            List<String> permissions,
            Consumer<JSONObject> callback
    ) {


        JSONObject jb = new JSONObject();
        if (StrUtil.isNotBlank(symbol)) {
            jb.put("symbol", symbol);
        }
        else if (symbols != null && !symbols.isEmpty()) {
            jb.put("symbols", symbols);
        }
        else if (permissions != null && !permissions.isEmpty()) {
            jb.put("permissions", permissions);
        }
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(BaseCommandType.EXCHANGE_INFO)
                .setParams(jb)
                .build();
        binanceWSApiClient.sendRequest(20, command, callback);
    }



        /**
         * 请求listenKey
         * @return CompletableFuture<String> listenKey
         */
        public CompletableFuture<String> requestListenKey(ASKey asKey) {
            JSONObject command = WebSocketCommandBuilder.builder()
                    .setCommandType(AccountCommandType.USER_DATA_STREAM_START)
                    .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                    .build();

            log.info("请求获取listenKey， 请求[{}}", command);
            return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                    .thenApplyAsync(json -> json.getJSONObject("result").getString("listenKey"));
        }

        /**
         * Websocket API延长listenKey有效期
         * 有效期延长至本次调用后60分钟
         * @return CompletableFuture<String> listenKey
         */
        public CompletableFuture<String> lengthenListenKey(String listenKey, ASKey asKey) {
            JSONObject command = WebSocketCommandBuilder.builder()
                    .setCommandType(AccountCommandType.USER_DATA_STREAM_PING)
                    .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                    .addParam(WebSocketStreamParamKey.LISTEN_KEY, listenKey)
                    .build();

            log.info("请求延长listenKey， 请求[{}}", command);
            return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                    .thenApplyAsync(json -> json.getJSONObject("result").getString("listenKey"));
        }

        /**
         * Websocket API关闭listenKey
         * @return CompletableFuture<String> listenKey
         */
        public CompletableFuture<Boolean> closeListenKey(String listenKey, ASKey asKey) {
            JSONObject command = WebSocketCommandBuilder.builder()
                    .setCommandType(AccountCommandType.USER_DATA_STREAM_CLOSE)
                    .addParam(WebSocketStreamParamKey.API_KEY, asKey.getApiKey())
                    .addParam(WebSocketStreamParamKey.LISTEN_KEY, listenKey)
                    .build();

            log.info("请求关闭listenKey， 请求[{}}", command);
            return binanceWSApiClient.sendRequest(5, command, ASKey.EMPTY_ASKEY)
                    .thenApplyAsync(json -> json.getInteger("status") == 200);
        }

}




package com.helei.binanceapi.dto.accountevent;

import com.helei.constants.PositionSide;
import com.helei.binanceapi.constants.AccountEventType;
import lombok.*;

import java.util.List;

/**
 * 保证金追加通知
 *
 * <p>
 *     当用户持仓风险过高，会推送此消息。
 *  此消息仅作为风险指导信息，不建议用于投资策略。
 * 在大波动市场行情下,不排除此消息发出的同时用户仓位已被强平的可能。
 * 全仓模式下若保证金不足每小时仅会推送一次此事件，不会重复推送；逐仓模式下保证金不足一个交易对每小时仅会推送一次此事件，不会重复推送
 * </p>
 */
@Getter
@Setter
@ToString
public class BailNeedEvent extends AccountEvent {

    /**
     * 除去逐仓仓位保证金的钱包余额, 仅在全仓 margin call 情况下推送此字段
     */
    private Double bailRemoveWalletBalance;

    /**
     * 涉及持仓
     */
    private List<PositionNeedInfo> positionNeedInfos;

    public BailNeedEvent(Long eventTime) {
        super(AccountEventType.MARGIN_CALL, eventTime);
    }


    /**
     * 需要保证金的信息
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class PositionNeedInfo {

        /**
         * 交易对
         */
        private String symbol;

        /**
         * 持仓方向
         */
        private PositionSide positionSide;

        /**
         * 仓位
         */
        private Double position;

        /**
         * 保证金模式
         * TODO 枚举
         */
        private String mode;

        /**
         * 保证金
         */
        private Double bail;

        /**
         * 标记价格
         */
        private Double markPrice;

        /**
         * 未实现盈亏
         */
        private Double unrealizedProfitOrLoss;

        /**
         * 持仓需要的维持保证金
         */
        private Double needBail;
    }

}

package com.helei.binanceapi.dto.accountevent;

import com.helei.constants.PositionSide;
import com.helei.binanceapi.constants.AccountEventType;
import lombok.*;

import java.util.List;

/**
 *
 * <p>账户资金仓位发生变化事件</p>
 * <p>
 * 账户更新事件的 event type 固定为 ACCOUNT_UPDATE
 * <p/>
 * <p>
 *  当账户信息有变动时，会推送此事件： 1.仅当账户信息有变动时(包括资金、仓位、保证金模式等发生变化)，才会推送此事件；
 *                               2.订单状态变化没有引起账户和持仓变化的，不会推送此事件；
 *                               3.position 信息：仅当symbol仓位有变动时推送。
 *  </p>
 *
    <p>
 * "FUNDING FEE" 引起的资金余额变化，仅推送简略事件：
 * 1.当用户某全仓持仓发生"FUNDING FEE"时，事件ACCOUNT_UPDATE将只会推送相关的用户资产余额信息B(仅推送FUNDING FEE 发生相关的资产余额信息)，而不会推送任何持仓信息P。
 * 2.当用户某逐仓仓持仓发生"FUNDING FEE"时，事件ACCOUNT_UPDATE将只会推送相关的用户资产余额信息B(仅推送"FUNDING FEE"所使用的资产余额信息)，和相关的持仓信息P(仅推送这笔"FUNDING FEE"发生所在的持仓信息)，其余持仓信息不会被推送。
 * </p>
 * <p>
 * 字段"m"代表了事件推出的原因，包含了以下可能类型:
 * 1.DEPOSIT
 * 2.WITHDRAW
 * 3.ORDER
 * 4.FUNDING_FEE
 * 5.WITHDRAW_REJECT
 * 6.ADJUSTMENT
 * 7.INSURANCE_CLEAR
 * 8.ADMIN_DEPOSIT
 * 9.ADMIN_WITHDRAW
 * 10.MARGIN_TRANSFER
 * 11.MARGIN_TYPE_CHANGE
 * 12.ASSET_TRANSFER
 * 13.OPTIONS_PREMIUM_FEE
 * 14.OPTIONS_SETTLE_PROFIT
 * 15.AUTO_EXCHANGE
 * 16.COIN_SWAP_DEPOSIT
 * 17.COIN_SWAP_WITHDRAW
 * </p>
 * <p>
 * 字段"bc"代表了钱包余额的改变量，即 balance change，但注意其不包含仓位盈亏及交易手续费。
 * </p>
 */
@EqualsAndHashCode(callSuper = true)
@Getter
@Setter
@ToString
public class BalancePositionUpdateEvent extends AccountEvent {

    /**
     * 撮合时间
     */
    private Long matchMakingTime;

    /**
     * 事件推出原因
     */
    private String reason;

    /**
     * 资金发生变化的信息
     */
    private List<BalanceChangeInfo> balanceChangeInfos;

    /**
     * 仓位发生变化的信息
     */
    private List<PositionChangeInfo> positionChangeInfos;

    public BalancePositionUpdateEvent(Long eventTime) {
        super(AccountEventType.ACCOUNT_UPDATE, eventTime);
    }



    /**
     * 资产变化信息
     */
    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @EqualsAndHashCode(callSuper = false)
    public static class BalanceChangeInfo {

        /**
         * 资产名称
         */
        private String asset;

        /**
         * 钱包余额
         */
        private Double walletBalance;

        /**
         * 除去逐仓保证金的钱包余额
         */
        private Double bailRemoveWalletBalance;

        /**
         * 除去盈亏和手续费的变化量
         */
        private Double walletBalanceChange;
    }


    /**
     * 仓位变化信息
     */
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Builder
    public static class PositionChangeInfo {

        /**
         * 交易对
         */
        private String symbol;

        /**
         * 仓位
         */
        private Double position;

        /**
         * 入仓价格
         */
        private Double enterPosition;

        /**
         * 盈亏平衡价
         */
        private Double balanceEqualPrice;

        /**
         * 总盈亏
         */
        private Double countProfitOrLoss;

        /**
         * 未实现盈亏
         */
        private Double unrealizedProfitOrLoss;

        /**
         * 保证金模式
         * TODO 切换枚举
         */
        private String  model;

        /**
         * 保证金
         */
        private Double bail;

        /**
         * 持仓方向
         */
        private PositionSide positionSide;

    }

}



package com.helei.binanceapi.dto.accountevent;

import com.helei.binanceapi.constants.AccountEventType;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

/**
 * listenKey过期事件
 * <p>当前连接使用的有效listenKey过期时，user data stream 将会推送此事件。</p>
 * <p>注意:</p>
 * <p>
 * 1.此事件与websocket连接中断没有必然联系
 * 2.只有正在连接中的有效listenKey过期时才会收到此消息
 * 3.收到此消息后user data stream将不再更新，直到用户使用新的有效的listenKey
 * </p>
 */
@Getter
@Setter
@ToString

public class ListenKeyExpireEvent extends AccountEvent {

    public ListenKeyExpireEvent(Long eventTime) {
        super(AccountEventType.LISTEN_KEY_EXPIRED, eventTime);
    }

}



package com.helei.binanceapi.dto.accountevent;

import com.helei.binanceapi.constants.AccountEventType;
import com.helei.binanceapi.constants.order.*;
import com.helei.binanceapi.constants.TimeInForce;
import com.helei.constants.PositionSide;
import com.helei.constants.TradeSide;
import lombok.*;

/**
 * 订单交易更新推送事件
 */
@Getter
@Setter
@ToString

public class OrderTradeUpdateEvent extends AccountEvent {

    /**
     * 撮合时间
     */
    private Long MatchMakingTime;

    /**
     * 发生更新的交易对详情
     */
    private OrderTradeUpdateDetails orderTradeUpdateDetails;

    public OrderTradeUpdateEvent(Long eventTime) {
        super(AccountEventType.ORDER_TRADE_UPDATE, eventTime);
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    @EqualsAndHashCode(callSuper = false)
    public static class OrderTradeUpdateDetails {
        /**
         * 交易对
         */
        private String symbol;
        /**
         * 客户端自定订单ID
         */
        private String clientOrderId;
        /**
         * 订单方向
         */
        private TradeSide orderSide;
        /**
         * 订单类型
         */
        private OrderType orderType;
        /**
         * 有效方式
         */
        private TimeInForce timeInForce;
        /**
         * 订单原始数量
         */
        private Double originalQuantity;
        /**
         * 订单原始价格
         */
        private Double originalPrice;
        /**
         * 订单平均价格
         */
        private Double averagePrice;
        /**
         * 条件订单触发价格,对追踪止损单无效
         */
        private String stopPrice;
        /**
         * 本次事件的具体执行类型
         */
        private OrderExcuteType executionType;
        /**
         * 订单的当前状态
         */
        private OrderStatus orderStatus;
        /**
         * 订单ID
         */
        private Long orderId;
        /**
         * 订单末次成交量
         */
        private Double lastFilledQuantity;
        /**
         * 订单累计已成交量
         */
        private Double cumulativeFilledQuantity;
        /**
         *  订单末次成交价格
         */
        private Double lastFilledPrice;
        /**
         * 手续费资产类型
         */
        private String commissionAsset;
        /**
         * 手续费数量
         */
        private Double commissionAmount;
        /**
         * 成交时间
         */
        private Long tradeTime;
        /**
         * 成交ID
         */
        private Long tradeId;
        /**
         * 买单净值
         */
        private Double buyerNetValue;
        /**
         * 卖单净值
         */
        private Double sellerNetValue;
        /**
         * 该成交是作为挂单成交吗？
         */
        private boolean maker;
        /**
         * 是否是只减仓单
         */
        private boolean reduceOnly;
        /**
         * 触发价类型
         */
        private WorkingType workingType;
        /**
         * 原始订单类型
         */
        private OrderType originalOrderType;
        /**
         *  持仓方向
         */
        private PositionSide positionSide;
        /**
         * 是否为触发平仓单,仅在条件订单情况下会推送此字段
         */
        private boolean closePosition;
        /**
         * 追踪止损激活价格,仅在追踪止损单时会推送此字段
         */
        private Double activationPrice;
        /**
         * 追踪止损回调比例,仅在追踪止损单时会推送此字段
         */
        private Double callbackRate;
        /**
         * 是否开启条件单触发保护
         */
        private boolean priceProtect;
        /**
         * 该交易实现盈亏
         */
        private Double realizedProfit;
        /**
         *  自成交防止模式
         */
        private SelfTradePreventionMode selfTradePreventionMode;
        /**
         * 价格匹配模式
         */
        private OpponentPriceMode opponentPriceMode;
        /**
         * TIF为GTD的订单自动取消时间
         */
        private long gtdCancelTime;
    }

}

package com.helei.binanceapi.supporter;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.constants.TimeInForce;
import com.helei.binanceapi.constants.order.*;
import com.helei.binanceapi.constants.strategy.StrategyOPCode;
import com.helei.binanceapi.constants.strategy.StrategyStatus;
import com.helei.binanceapi.constants.strategy.StrategyType;
import com.helei.binanceapi.dto.accountevent.*;
import com.helei.constants.PositionSide;
import com.helei.constants.TradeSide;

import java.util.ArrayList;
import java.util.List;

public interface AccountEventConverter {
    AccountEvent convertFromJsonObject(JSONObject jsonObject);


    enum Converter implements AccountEventConverter {
        LISTEN_KEY_EXPIRED{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                return new ListenKeyExpireEvent(jsonObject.getLong("E"));
            }
        },
        ACCOUNT_UPDATE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                BalancePositionUpdateEvent event = new BalancePositionUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject a = jsonObject.getJSONObject("a");
                event.setReason(a.getString("m"));

                List<BalancePositionUpdateEvent.BalanceChangeInfo> bList = new ArrayList<>();
                for (int i = 0; i < a.getJSONArray("B").size(); i++) {
                    JSONObject jb = a.getJSONArray("B").getJSONObject(i);
                    BalancePositionUpdateEvent.BalanceChangeInfo changeInfo = new BalancePositionUpdateEvent.BalanceChangeInfo();
                    changeInfo.setAsset(jb.getString("a"));
                    changeInfo.setWalletBalance(jb.getDouble("wb"));
                    changeInfo.setWalletBalanceChange(jb.getDouble("cw"));
                    changeInfo.setBailRemoveWalletBalance(jb.getDouble("bc"));
                    bList.add(changeInfo);
                }
                event.setBalanceChangeInfos(bList);

                List<BalancePositionUpdateEvent.PositionChangeInfo> pList = new ArrayList<>();
                for (int i = 0; i < a.getJSONArray("P").size(); i++) {
                    JSONObject jb = a.getJSONArray("P").getJSONObject(i);
                    BalancePositionUpdateEvent.PositionChangeInfo changeInfo = new BalancePositionUpdateEvent.PositionChangeInfo();
                    changeInfo.setSymbol(jb.getString("s"));
                    changeInfo.setPosition(jb.getDouble("pa"));
                    changeInfo.setEnterPosition(jb.getDouble("ep"));
                    changeInfo.setBalanceEqualPrice(jb.getDouble("bep"));
                    changeInfo.setCountProfitOrLoss(jb.getDouble("cr"));
                    changeInfo.setUnrealizedProfitOrLoss(jb.getDouble("up"));
                    changeInfo.setModel(jb.getString("mt"));
                    changeInfo.setBail(jb.getDouble("iw"));
                    changeInfo.setPositionSide(PositionSide.STATUS_MAP.get(jb.getString("ps")));
                }
                event.setPositionChangeInfos(pList);
                return event;
            }
        },

        MARGIN_CALL{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                BailNeedEvent event = new BailNeedEvent(jsonObject.getLong("E"));
                event.setBailRemoveWalletBalance(jsonObject.getDouble("cw"));

                JSONObject p = jsonObject.getJSONObject("p");

                BailNeedEvent.PositionNeedInfo positionNeedInfo = new BailNeedEvent.PositionNeedInfo();
                positionNeedInfo.setSymbol(p.getString("s"));
                positionNeedInfo.setPositionSide(PositionSide.STATUS_MAP.get(p.getString("ps")));
                positionNeedInfo.setPosition(p.getDouble("pa"));
                positionNeedInfo.setMode(p.getString("mt"));
                positionNeedInfo.setBail(p.getDouble("iw"));
                positionNeedInfo.setMarkPrice(p.getDouble("mp"));
                positionNeedInfo.setUnrealizedProfitOrLoss(p.getDouble("up"));
                positionNeedInfo.setNeedBail(p.getDouble("mm"));

                return event;
            }
        },

        ORDER_TRADE_UPDATE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                OrderTradeUpdateEvent event = new OrderTradeUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject o = jsonObject.getJSONObject("o");

                OrderTradeUpdateEvent.OrderTradeUpdateDetails details = new OrderTradeUpdateEvent.OrderTradeUpdateDetails();
                details.setSymbol(o.getString("s"));
                details.setClientOrderId(o.getString("c"));
                details.setOrderSide(TradeSide.STATUS_MAP.get(o.getString("S")));
                details.setOrderType(OrderType.STATUS_MAP.get(o.getString("o")));
                details.setTimeInForce(TimeInForce.STATUS_MAP.get(o.getString("f")));
                details.setOriginalQuantity(o.getDouble("q"));
                details.setOriginalPrice(o.getDouble("p"));
                details.setAveragePrice(o.getDouble("ap"));
                details.setStopPrice(o.getString("sp"));
                details.setExecutionType(OrderExcuteType.STATUS_MAP.get(o.getString("x")));
                details.setOrderStatus(OrderStatus.STATUS_MAP.get(o.getString("X")));
                details.setOrderId(o.getLong("i"));
                details.setLastFilledQuantity(o.getDouble("l"));
                details.setCumulativeFilledQuantity(o.getDouble("z"));
                details.setLastFilledPrice(o.getDouble("L"));
                details.setCommissionAsset(o.getString("N"));
                details.setCommissionAmount(o.getDouble("n"));
                details.setTradeTime(o.getLong("T"));
                details.setTradeId(o.getLong("t"));
                details.setBuyerNetValue(o.getDouble("b"));
                details.setSellerNetValue(o.getDouble("a"));
                details.setMaker(o.getBoolean("m"));
                details.setReduceOnly(o.getBoolean("R"));
                details.setWorkingType(WorkingType.STATUS_MAP.get(o.getString("wt")));
                details.setOriginalOrderType(OrderType.STATUS_MAP.get(o.getString("ot")));
                details.setPositionSide(PositionSide.STATUS_MAP.get(o.getString("ps")));
                details.setClosePosition(o.getBoolean("cp"));
                details.setActivationPrice(o.getDouble("AP"));
                details.setCallbackRate(o.getDouble("cr"));
                details.setPriceProtect(o.getBoolean("pP"));
                details.setRealizedProfit(o.getDouble("rp"));
                details.setSelfTradePreventionMode(SelfTradePreventionMode.STATUS_MAP.get(o.getString("V")));
                details.setOpponentPriceMode(OpponentPriceMode.STATUS_MAP.get(o.getString("pm")));
                details.setGtdCancelTime(o.getLong("gtd"));

                event.setOrderTradeUpdateDetails(details);
                return event;
            }
        },

        TRADE_LITE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                OrderTradeUpdateLiteEvent event = new OrderTradeUpdateLiteEvent(jsonObject.getLong("E"));
                event.setTradeTime(jsonObject.getLong("T"));
                event.setSymbol(jsonObject.getString("s"));
                event.setOriginalQuantity(jsonObject.getDouble("q"));
                event.setOriginalPrice(jsonObject.getDouble("p"));
                event.setIsMaker(jsonObject.getBoolean("m"));
                event.setClientOrderId(jsonObject.getString("c"));
                event.setOrderSide(TradeSide.STATUS_MAP.get(jsonObject.getString("S")));
                event.setLastTradePrice(jsonObject.getDouble("L"));
                event.setLastTradeQuantity(jsonObject.getDouble("l"));
                event.setTradeId(jsonObject.getLong("t"));
                event.setOrderId(jsonObject.getLong("i"));
                return event;
            }
        },

        ACCOUNT_CONFIG_UPDATE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                AccountConfigUpdateEvent event = new AccountConfigUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject ac = jsonObject.getJSONObject("ac");
                if (ac != null) {
                    AccountConfigUpdateEvent.AccountLeverConfigChangeInfo leverConfigChangeInfo = new AccountConfigUpdateEvent.AccountLeverConfigChangeInfo();
                    leverConfigChangeInfo.setSymbol(ac.getString("s"));
                    leverConfigChangeInfo.setLever(ac.getInteger("l"));
                    event.setLeverChangeInfo(leverConfigChangeInfo);
                }

                JSONObject ai = jsonObject.getJSONObject("ai");
                if (ai != null) {
                    AccountConfigUpdateEvent.AccountInfoChangeInfo accountInfoChangeInfo = new AccountConfigUpdateEvent.AccountInfoChangeInfo();
                    accountInfoChangeInfo.setUnitBailState(ai.getBoolean("j"));
                    event.setInfoChangeInfo(accountInfoChangeInfo);
                }

                return event;
            }
        },

        STRATEGY_UPDATE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                StrategyUpdateEvent event = new StrategyUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                StrategyUpdateEvent.StrategyUpdateInfo updateInfo = new StrategyUpdateEvent.StrategyUpdateInfo();
                JSONObject su = jsonObject.getJSONObject("su");
                updateInfo.setStrategyId(su.getLong("si"));
                updateInfo.setStrategyType(StrategyType.STATUS_MAP.get(su.getString("st")));
                updateInfo.setStrategyStatus(StrategyStatus.STATUS_MAP.get(su.getString("ss")));
                updateInfo.setSymbol(su.getString("s"));
                updateInfo.setUpdateTime(su.getLong("ut"));
                updateInfo.setStrategyOPCode(StrategyOPCode.STATUS_MAP.get(su.getInteger("c")));
                event.setStrategyUpdateInfo(updateInfo);
                return event;
            }
        },

        GRID_UPDATE{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                GridUpdateEvent event = new GridUpdateEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));

                JSONObject gu = jsonObject.getJSONObject("gu");
                GridUpdateEvent.GridUpdateInfo updateInfo = new GridUpdateEvent.GridUpdateInfo();
                updateInfo.setStrategyId(gu.getLong("si"));
                updateInfo.setStrategyType(StrategyType.STATUS_MAP.get(gu.getString("st")));
                updateInfo.setStrategyStatus(StrategyStatus.STATUS_MAP.get(gu.getString("ss")));
                updateInfo.setSymbol(gu.getString("s"));
                updateInfo.setRealizedPnl(gu.getDouble("r"));
                updateInfo.setUnpairedAverage(gu.getDouble("up"));
                updateInfo.setUnpairedQuantity(gu.getDouble("uq"));
                updateInfo.setUnpairedFee(gu.getDouble("uf"));
                updateInfo.setMatchedPnl(gu.getDouble("mp"));
                updateInfo.setUpdateTime(gu.getLong("ut"));

                event.setGridUpdateInfo(updateInfo);
                return event;
            }
        },

        CONDITIONAL_ORDER_TRIGGER_REJECT{
            @Override
            public AccountEvent convertFromJsonObject(JSONObject jsonObject) {
                ConditionalOrderTriggerRejectEvent event = new ConditionalOrderTriggerRejectEvent(jsonObject.getLong("E"));
                event.setMatchMakingTime(jsonObject.getLong("T"));


                JSONObject or = jsonObject.getJSONObject("or");
                ConditionalOrderTriggerRejectEvent.OrderRejectInfo orderRejectInfo = new ConditionalOrderTriggerRejectEvent.OrderRejectInfo();

                orderRejectInfo.setSymbol(or.getString("s"));
                orderRejectInfo.setOrderId(or.getLong("o"));
                orderRejectInfo.setRejectReason(or.getString("r"));
                event.setOrderRejectInfo(orderRejectInfo);
                return event;
            }
        }
    }
}
package com.helei.cexapi.client;

import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.dto.ASKey;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.InetSocketAddress;
import java.util.UUID;
import java.util.concurrent.*;
import java.util.function.Consumer;


/**
 * 币安账户综合客户端
 * <P>主要由两部分组成</P>
 * <p>一是用于请求维护listenKey的BinanceWSApiClient</p>
 * <p>
 * 二是ConcurrentMap< ASKey, BinanceWSAccountStreamClient>
 * 里面记录了账户鉴权信息和对应的账户信息推送连接BinanceWSAccountStreamClient
 * </p>
 */
@Slf4j
public class BinanceAccountMergeClient {

    /**
     * 处理相关异步任务的线程池
     */
    @Getter
    private final ExecutorService executor;

    /**
     * 用于请求listenKey，更新listenKey等请求的WSClient
     */
    private final BinanceWSApiClient requestClient;

    /**
     * 账户信息推送的base url
     */
    private final String accountStreamUrl;

    /**
     * 代理
     */
    private InetSocketAddress proxy;


    public BinanceAccountMergeClient(
            BinanceWSApiClient requestClient,
            String accountStreamUrl,
            ExecutorService executor

    ) throws Exception {
        this.requestClient = requestClient;
        if (StrUtil.isBlank(requestClient.getName())) {
            this.requestClient.setName("账户信息请求客户端-" + UUID.randomUUID().toString().substring(0, 8));
        }

        this.accountStreamUrl = accountStreamUrl;
        this.executor = executor;

        log.info("开始连接请求服务器");
        requestClient.connect().get();
    }


    public void setProxy(InetSocketAddress proxy) {
        this.proxy = proxy;
        requestClient.setProxy(proxy);
    }


    /**
     * 添加账户流，根据asKey创建BinanceWSAccountStreamClient对象进行连接，并绑定收到事件的回调。
     *
     * @param asKey                   asKey
     * @param whenReceiveAccountEvent channel收到事件消息时的回调
     * @return this
     * @throws Exception exception
     */
    public BinanceWSAccountStreamClient getAccountStream(ASKey asKey, Consumer<AccountEvent> whenReceiveAccountEvent) throws Exception {

        try {
            BinanceWSAccountStreamClient client = new BinanceWSAccountStreamClient(
                    accountStreamUrl,
                    new IpWeightSupporter("localIp"),
                    asKey,
                    whenReceiveAccountEvent,
                    requestClient.getBaseApi()
            );
            client.setProxy(proxy);

            return client;
        } catch (Exception e) {
            log.error("创建account连接出错, apiKey[{}]", asKey.getApiKey(), e);
            throw new RuntimeException(e);
        }
    }

    /**
     * 刷新BinanceWSAccountStreamClient
     *
     * @param streamClient streamClient
     * @return boolean
     */
    private static boolean refreshClient(BinanceWSAccountStreamClient streamClient) {
        try {
            String s = streamClient.lengthenListenKey().get();
            if (s == null) {
                log.error("延长listenKey[{}]得到结果为null", streamClient.getListenKey());
                return false;
            }
            return true;
        } catch (InterruptedException | ExecutionException e) {
            log.error("延长listenKey[{}]发生错误", streamClient.getListenKey(), e);
            return false;
        }
    }


    /**
     * 重连接账户信息推送流
     *
     * @param streamClient streamClient
     * @param retryTimes   retryTimes
     */
    private static boolean reConnectStream(BinanceWSAccountStreamClient streamClient, int retryTimes) {
        for (int i = 1; i <= retryTimes; i++) {
            log.info("开始重连接account stream， [{}/{}]，旧的listenKey[{}]", i, retryTimes, streamClient.getListenKey());
            Boolean b = null;
            try {

                //关闭，重置
                streamClient.close();

                //开始连接
                b = streamClient.startAccountInfoStream().get();
            } catch (InterruptedException | ExecutionException e) {
                log.error("重新连接account stream发生错误，", e);
            }
            if (BooleanUtil.isTrue(b)) {
                log.info("重连接account stream成功, 新的listenKey[{}]", streamClient.getListenKey());
                return true;
            }
        }

        log.error("重连接失败,apiKey[{}]", streamClient.getAsKey().getApiKey());
        return false;
    }
}




package com.helei.cexapi;


import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.BinanceWSApiClientHandler;
import com.helei.binanceapi.api.rest.BinanceUContractMarketRestApi;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutorService;

@Slf4j
public class CEXApiFactory {

    private static final String CLIENT_CONNECT_KEY_SPACER = "<@>?";
    //TODO 配置化
//    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7897);
    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7890);
//    private static InetSocketAddress proxy = null;

    private static IpWeightSupporter ipWeightSupporter = new IpWeightSupporter("localIp");

    private static final ConcurrentMap<String, BinanceWSApiClient> CLIENT_CONNECTION_MAP = new ConcurrentHashMap<>();

    public static BinanceWSApiClient binanceApiClient(
            String url,
            String name
    ) {
        String clientKey = buildClientConnectKey(url, name);

        BinanceWSApiClient binanceWSApiClient = CLIENT_CONNECTION_MAP.get(clientKey);
        if (binanceWSApiClient != null) {
            log.info("已存在链接客户端 [{}] - [{}]", name, url);
            return binanceWSApiClient;
        }

        BinanceWSApiClient client;
        synchronized (CEXApiFactory.class) {
            try {
                log.info("创建链接客户端 [{}] - [{}]", name, url);

                client = binanceApiClient(url);
                client.setName(name);
                CLIENT_CONNECTION_MAP.put(clientKey, client);

                log.info("创建链接客户端 [{}] - [{}] 成功", name, url);
            } catch (Exception e) {
                log.error("创建链接客户端 [{}] - [{}] 失败", name, url, e);
                throw new RuntimeException("创建连接客户端失败", e);
            }
        }
        return client;
    }

    public static BinanceWSApiClient binanceApiClient(
            String url
    ) throws URISyntaxException, SSLException {

        BinanceWSApiClientHandler handler = new BinanceWSApiClientHandler();

        BinanceWSApiClient client = new BinanceWSApiClient(
                url,
                ipWeightSupporter,
                handler
        );
        client.setProxy(proxy);
        client.setName("binance-api-client-" + UUID.randomUUID().toString().substring(0, 8));

        return client;
    }

    public static BinanceUContractMarketRestApi binanceUContractMarketRestApi(String baseUrl,
                                                                              ExecutorService executor) {
        return new BinanceUContractMarketRestApi(executor, baseUrl, ipWeightSupporter);
    }


    /**
     * 创建客户端链接的key，保证同一个名和url只有一个链接
     * @param url url
     * @param name name
     * @return String
     */
    private static String buildClientConnectKey(String url, String name) {
        return name + CLIENT_CONNECT_KEY_SPACER + url;
    }
}



package com.helei.reaktimedatacenter.service.impl;


import com.helei.binanceapi.dto.accountevent.*;
import com.helei.dto.account.PositionInfo;
import com.helei.dto.account.UserAccountInfo;
import com.helei.reaktimedatacenter.manager.BinanceAccountClientManager;
import com.helei.reaktimedatacenter.mapper.PositionInfoMapper;
import com.helei.reaktimedatacenter.service.AccountEventResolveService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

@Slf4j
@Service
public class BinanceAccountEventResolveService implements AccountEventResolveService {

    private final ExecutorService eventExecutor = Executors.newVirtualThreadPerTaskExecutor();


    @Autowired
    private BinanceAccountClientManager binanceAccountClientManager;


    @Override
    public void resolveAccountEvent(UserAccountInfo accountInfo, AccountEvent accountEvent) {
        CompletableFuture<Void> future = null;

        if (accountEvent instanceof ListenKeyExpireEvent listenKeyExpireEvent) {
            future = resolveListenKeyExpireEvent(accountInfo, listenKeyExpireEvent);
        } else if (accountEvent instanceof BailNeedEvent bailNeedEvent) {
            future = resolveBailNeedEvent(accountInfo, bailNeedEvent);
        } else if (accountEvent instanceof BalancePositionUpdateEvent balancePositionUpdateEvent) {
            future = resolveBalancePositionUpdateEvent(accountInfo, balancePositionUpdateEvent);
        }


        if (future == null) return;


        future.whenCompleteAsync((unused, throwable) -> {
            if (throwable != null) {

            }
        }, eventExecutor);
    }

    /**
     * 创立账户仓位更新事件
     * @param accountInfo accountInfo
     * @param balancePositionUpdateEvent balancePositionUpdateEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveBalancePositionUpdateEvent(UserAccountInfo accountInfo, BalancePositionUpdateEvent balancePositionUpdateEvent) {
        List<BalancePositionUpdateEvent.PositionChangeInfo> positionChangeInfos = balancePositionUpdateEvent.getPositionChangeInfos();
        List<PositionInfo> positionInfos = PositionInfoMapper.INSTANCE.convertFromPositionChangeInfoList(positionChangeInfos);

        accountInfo.getAccountPositionInfo().updatePositionInfos(positionInfos);
    }


    /**
     * 处理追加保证金事件
     * @param accountInfo accountInfo
     * @param bailNeedEvent bailNeedEvent
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> resolveBailNeedEvent(UserAccountInfo accountInfo, BailNeedEvent bailNeedEvent) {
        return CompletableFuture.runAsync(() -> {
            log.warn("账户userId[{}]-accountId[{}]追加保证金事件, 详情:[{}]", accountInfo.getUserId(), accountInfo.getId(), bailNeedEvent);

        }, eventExecutor);
    }


    /**
     * listenKey过期了，要重新获取
     *
     * @param listenKeyExpireEvent listenKeyExpireEvent
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> resolveListenKeyExpireEvent(UserAccountInfo userAccountInfo, ListenKeyExpireEvent listenKeyExpireEvent) {
        long accountId = userAccountInfo.getId();
        log.info("收到accountId[{}]的账户listenKey过期事件，尝试重新连接", accountId);

        CompletableFuture.runAsync(() -> {
            boolean result = binanceAccountClientManager.startAccountEventStream(accountId);
            if (result) {
                log.info("accountId[{}]的账户重新获取listenKey成功", accountId);
            } else {
                // TODO 日志上传
                log.error("accountId[{}]的账户重新获取listenKey失败", accountId);
            }
        }, eventExecutor);
    }
}


package com.helei.reaktimedatacenter.service.impl;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.constants.RunEnv;
import com.helei.constants.TradeType;
import com.helei.dto.account.UserAccountInfo;
import com.helei.dto.account.UserInfo;
import com.helei.reaktimedatacenter.manager.BinanceAccountClientManager;
import com.helei.reaktimedatacenter.service.AccountEventResolveService;
import com.helei.reaktimedatacenter.service.AccountEventStreamService;
import com.helei.reaktimedatacenter.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;


@Slf4j
@Service
public class BinanceAccountEventStreamService implements AccountEventStreamService {

    private static final ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();

    private static final int ACCOUNT_STREAM_START_TIMES_LIMIT = 3;


    @Autowired
    private UserService userService;

    @Autowired
    private AccountEventResolveService  accountEventResolveService;


    @Autowired
    private BinanceAccountClientManager binanceAccountClientManager;


    /**
     * 开启所有用户事件流
     */
    @Override
    public void startAllUserInfoEventStream() {
        log.info("开始获取所有用户的账户事件流");

        List<CompletableFuture<Void>> list = userService.queryAll().stream()
                .map(userInfo -> CompletableFuture.runAsync(() -> startUserInfoEventStream(userInfo), executor)).toList();
        list.forEach(CompletableFuture::join);

        log.info("所有用户账户事件流获取完毕，共[{}]个用户", list.size());
    }


    /**
     * 开启用户信息事件，会开启用户名下所有账户的事件流
     * @param userInfo userInfo
     */
    @Override
    public void startUserInfoEventStream(UserInfo userInfo) {
        log.info("开始获取用户id[{}]-name[{}]拥有账户事件流", userInfo.getId(), userInfo.getUsername());

        List<UserAccountInfo> accountInfos = userInfo.getAccountInfos();

        if (accountInfos == null || accountInfos.isEmpty()) {
            log.warn("用户[{}]-id[{}]没有注册交易账户事件", userInfo.getUsername(), userInfo.getId());
            return;
        }

        List<CompletableFuture<Void>> futures = new ArrayList<>();

        for (UserAccountInfo accountInfo : accountInfos) {
            CompletableFuture<Void> future = buildAndStartAccountEventStream(accountInfo);
            futures.add(future);
        }

        futures.forEach(CompletableFuture::join);

        log.info("用户id[{}]-name[{}]所有账户事件流[共{}个]开启成功", userInfo.getId(), userInfo.getUsername(), futures.size());
    }

    /**
     * 构建并启动账户事件流，
     * @param accountInfo accountInfo
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Void> buildAndStartAccountEventStream(UserAccountInfo accountInfo) {
        long userId = accountInfo.getUserId();
        long accountId = accountInfo.getId();

        RunEnv runEnv = accountInfo.getRunEnv();
        TradeType tradeType = accountInfo.getTradeType();



        log.info("开始获取账户事件流, userId[{}], accountId[{}], runEvn[{}], tradeType[{}]", userId, accountId, runEnv, tradeType);

        CompletableFuture<Void> future = CompletableFuture
                //1 获取流客户端
                .supplyAsync(() -> {
                    BinanceWSAccountStreamClient binanceWSAccountStreamClient = null;

                    //1.1 带重试
                    for (int i = 0; i < ACCOUNT_STREAM_START_TIMES_LIMIT; i++) {
                        try {
                            log.info("第 [{}] 次获取账户事件流, userId[{}], accountId[{}]", i, userId, accountId);

                            //1.2 创建 binanceWSAccountStreamClient 用于开启事件流
                            binanceWSAccountStreamClient = binanceAccountClientManager.getAccountInfoStream(accountInfo, this::resolveAccountEvent);

                            log.info("第 [{}] 次获取账户事件流成功, userId[{}], accountId[{}], listenKey[{}]", i, userId, accountId, binanceWSAccountStreamClient.getListenKey());

                            return binanceWSAccountStreamClient;
                        } catch (Exception e) {
                            log.error("第 [{}] 次获取账户事件流失败， userId[{}], accountId[{}]", i, userId, accountId, e);

                            binanceAccountClientManager.removeAccountStreamClient(accountId);

                            if (i == ACCOUNT_STREAM_START_TIMES_LIMIT - 1) {
                                log.error("重试次数 [{}] 超过了限制[{}], 不再继续重试, userId[{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, userId, accountId);
                            }
                        }
                    }

                    return binanceWSAccountStreamClient;
                }, executor)
                //2 开启流客户端
                .thenAcceptAsync(binanceWSAccountStreamClient -> {
                    // 开启事件流
                    startAccountEventStream(accountInfo, binanceWSAccountStreamClient);
                }, executor);

        return future;
    }


    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     * @param accountInfo accountInfo
     * @param binanceWSAccountStreamClient binanceWSAccountStreamClient
     */
    private void startAccountEventStream(UserAccountInfo accountInfo,
                                         BinanceWSAccountStreamClient binanceWSAccountStreamClient) {
        long accountId = accountInfo.getId();

        boolean success = binanceAccountClientManager.startAccountEventStream(accountId, binanceWSAccountStreamClient);

        if (success) {
            log.info("开启账户事件流成功, accountId[{}], listenKey [{}]", accountId, binanceWSAccountStreamClient.getListenKey());
        } else {
            // TODO 错误日志上传
            log.error("开启账户事件流失败, accountId[{}]", accountId);
        }
    }



    @Override
    public void resolveAccountEvent(final UserAccountInfo accountInfo, AccountEvent accountEvent) {
        log.info("账户[{}]-[{}]收到事件 [{}]", accountInfo.getUserId(), accountInfo.getId(), accountEvent);
        accountEventResolveService.resolveAccountEvent(accountInfo, accountEvent);
    }
}

package com.helei.reaktimedatacenter.service.impl;


import com.helei.dto.account.UserAccountInfo;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class RealtimeAccountInfoSpace {

    private final ConcurrentMap<Long, UserAccountInfo> userAccountInfoMap = new ConcurrentHashMap<>();




}




package com.helei.reaktimedatacenter.service;

import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.dto.account.UserAccountInfo;

public interface AccountEventResolveService {


    /**
     * 处理账户事件
     * @param accountInfo 账户信息
     * @param accountEvent 账户事件
     */
    void resolveAccountEvent(UserAccountInfo accountInfo, AccountEvent accountEvent);
}





package com.helei.reaktimedatacenter.manager;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.config.BinanceApiConfig;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.client.BinanceAccountMergeClient;
import com.helei.constants.RunEnv;
import com.helei.constants.TradeType;
import com.helei.dto.ASKey;
import com.helei.dto.KeyValue;
import com.helei.dto.account.UserAccountInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.stereotype.Component;

import java.net.InetSocketAddress;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;


@Slf4j
@Component
public class BinanceAccountClientManager implements InitializingBean {

    private final static long REFRESH_TASK_SLEEP_TIME = 60000;

    private final static long REFRESH_INTERVAL = 1000 * 60 * 10;

    private final static int REFRESH_CONCURRENT_LIMIT = 10;

    private static final int ACCOUNT_STREAM_START_TIMES_LIMIT = 3;


    private final ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();


    private final static ConcurrentMap<String, BinanceAccountMergeClient> mergeClientMap = new ConcurrentHashMap<>();


    private final static ConcurrentMap<Long, KeyValue<BinanceWSAccountStreamClient, Long>> accountIdMapClientAndExpireMap = new ConcurrentHashMap<>();


    private final BinanceApiConfig binanceApiConfig = BinanceApiConfig.INSTANCE;


    private final AtomicBoolean streamRefreshTaskState = new AtomicBoolean(true);


    /**
     * 创建 BinanceWSAccountStreamClient，用来获取账户事件推送流
     *
     * @param accountInfo accountInfo
     * @return BinanceWSAccountStreamClient
     * @throws Exception Exception
     */
    public BinanceWSAccountStreamClient getAccountInfoStream(final UserAccountInfo accountInfo, BiConsumer<UserAccountInfo, AccountEvent> whenReceiveAccountEvent) throws Exception {

        RunEnv runEnv = accountInfo.getRunEnv();
        TradeType tradeType = accountInfo.getTradeType();
        ASKey asKey = accountInfo.getAsKey();


        BinanceApiConfig.BinanceTypedUrl envUrlSet = binanceApiConfig.getEnvUrlSet(runEnv, tradeType);


        // 1. 创建用于获取 listenKey 的客户端
        BinanceWSApiClient requestClient = CEXApiFactory.binanceApiClient(envUrlSet.getWs_market_url(), "账户事件请求链接");

        // 2, 获取 merge 客户端
        String key = generateMergeClientKey(runEnv, tradeType);
        String streamUrl = envUrlSet.getWs_account_info_stream_url();

        BinanceAccountMergeClient accountMergeClient = mergeClientMap.compute(key, (k, v) -> {
            if (v == null) {
                try {
                    v = new BinanceAccountMergeClient(requestClient, streamUrl, executor);

                    InetSocketAddress proxy = binanceApiConfig.getProxy();
                    if (proxy != null) {
                        v.setProxy(proxy);
                    }
                } catch (Exception e) {
                    log.error("创建BinanceAccountMergeClient发生错误, url[{}}", streamUrl, e);
                    throw new RuntimeException(e);
                }
            }

            return v;
        });


        // 3. 开始根据 merge 客户端，获取该账户的推送流链接
        KeyValue<BinanceWSAccountStreamClient, Long> clientLongKeyValue = accountIdMapClientAndExpireMap.compute(accountInfo.getId(), (k, v) -> {
            if (v == null) {
                try {
                    BinanceWSAccountStreamClient binanceWSAccountStreamClient = accountMergeClient.getAccountStream(asKey, accountEvent -> whenReceiveAccountEvent.accept(accountInfo, accountEvent));

                    //刷新时间ddl设置为特殊值0代表没有启动
                    v = new KeyValue<>(binanceWSAccountStreamClient, 0L);
                } catch (Exception e) {
                    throw new RuntimeException("创建币按账户推送流失", e);
                }
            }

            return v;
        });

        return clientLongKeyValue.getKey();
    }


    /**
     * 根据accountId删除accountIdMapClientAndExpireMap里缓存的client
     * @param accountId accountId
     */
    public void removeAccountStreamClient(long accountId) {
        KeyValue<BinanceWSAccountStreamClient, Long> remove = accountIdMapClientAndExpireMap.remove(accountId);
        if (remove != null) {
            log.warn("已移除AccountStreamClient [{}]", remove.getKey().getName());
        }
    }

    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     * <p>带重试次数，未达到重试限制之前，都会一直重试</p>
     *
     * @param accountId                    accountId
     */
    public boolean startAccountEventStream(long accountId) {
        KeyValue<BinanceWSAccountStreamClient, Long> pair = accountIdMapClientAndExpireMap.get(accountId);

        if (pair == null) return false;

        return startAccountEventStream(accountId, pair.getKey());
    }


    /**
     * 开始账户事件流，通过 binanceWSAccountStreamClient 进行获取
     * <p>带重试次数，未达到重试限制之前，都会一直重试</p>
     *
     * @param accountId                    accountId
     * @param binanceWSAccountStreamClient binanceWSAccountStreamClient
     */
    public boolean startAccountEventStream(long accountId,
                                           BinanceWSAccountStreamClient binanceWSAccountStreamClient) {

        for (int i = 0; i < ACCOUNT_STREAM_START_TIMES_LIMIT; i++) {
            try {
                Boolean success = binanceWSAccountStreamClient.startAccountInfoStream().get();

                if (success) {

                    //设置刷新时间
                    accountIdMapClientAndExpireMap.compute(accountId, (k,v)->{
                        if (v == null) v = new KeyValue<>(binanceWSAccountStreamClient, System.currentTimeMillis() + REFRESH_INTERVAL);
                        return v;
                    });

                    return true;
                } else {
                    log.error("开启账户事件流失败[{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId);
                }
            } catch (InterruptedException | ExecutionException e) {
                log.error("开启账户事件流发生错误[{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId, e);
            }

            log.warn("开始账户事件流重试 [{}/{}], accountId[{}]", i, ACCOUNT_STREAM_START_TIMES_LIMIT, accountId);

        }

        log.error(" accountId[{}] 重试次数[{}]超过限制[{}],", accountId, ACCOUNT_STREAM_START_TIMES_LIMIT, ACCOUNT_STREAM_START_TIMES_LIMIT);
        return false;
    }


    /**
     * 定期刷新账户流的ListenKey
     */
    private void refreshAccountStreamListenKey() {
        while (streamRefreshTaskState.get()) {
            long startTime = System.currentTimeMillis();
            Semaphore semaphore = new Semaphore(REFRESH_CONCURRENT_LIMIT);
            try {


                // 1. 去除失效的
                List<Long> expireIdList = accountIdMapClientAndExpireMap.entrySet().stream().filter(e -> e.getValue().getValue() == -1L).map(Map.Entry::getKey).toList();

                if (!expireIdList.isEmpty()) {
                    log.warn("去除失效的客户端链接 accountIds [{}]", expireIdList);
                    expireIdList.forEach(accountIdMapClientAndExpireMap::remove);
                }

                // 2.尝试刷新listenKey
                for (Map.Entry<Long, KeyValue<BinanceWSAccountStreamClient, Long>> entry : accountIdMapClientAndExpireMap.entrySet()) {
                    Long accountId = entry.getKey();
                    KeyValue<BinanceWSAccountStreamClient, Long> keyValue = entry.getValue();
                    BinanceWSAccountStreamClient client = keyValue.getKey();
                    Long expireTime = keyValue.getValue();

                    //没启动的，特殊特殊处理，跳过刷新listenKey
                    if (expireTime == 0L) continue;

                    semaphore.acquire();

                    if (System.currentTimeMillis() <= expireTime) {
                        log.info("accountId[{}]的事件流到了刷新时间，开始延长listenKey[{}]", accountId, client.getListenKey());

                        client.lengthenListenKey().whenCompleteAsync((listenKey, e) -> {
                            try {
                                if (e != null) {
                                    log.error("延长accountId[{}]的listenKey[{}]发生错误, 重新启动account链接", accountId, client.getListenKey(), e);

                                    //重新获取listenKey启动
                                    boolean result = startAccountEventStream(accountId, client);
                                    if (!result) {
                                        // TODO 错误日志上传
                                        log.error("accountId[{}}重新获取推送链接失败", accountId);

                                        //特殊标记，下一次刷新时删掉
                                        keyValue.setValue(-1L);
                                    } else {
                                        log.info("accountId[{}]重新获取推送链接成功, listenKey[{}]", accountId, client.getListenKey());
                                        keyValue.setValue(System.currentTimeMillis() + REFRESH_INTERVAL);
                                    }
                                }
                            } finally {
                                semaphore.release();

                            }
                        }, executor);
                    }
                }
            } catch (InterruptedException e) {
                log.error("定时刷新账户流ListenKey失败");
            }

            try {
                TimeUnit.MILLISECONDS.sleep(REFRESH_TASK_SLEEP_TIME - System.currentTimeMillis() + startTime);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }


    /**
     * 初始化，开始刷新链接任务
     *
     * @throws Exception Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        executor.execute(this::refreshAccountStreamListenKey);
    }


    /**
     * 获取 MergeClientKey
     *
     * @param runEnv    runEnv
     * @param tradeType tradeType
     * @return key
     */
    private String generateMergeClientKey(RunEnv runEnv, TradeType tradeType) {
        return runEnv + "." + tradeType;
    }


    public void close() {
        streamRefreshTaskState.set(false);
        executor.shutdown();
    }
}


package com.helei.reaktimedatacenter.mapper;

import com.helei.binanceapi.dto.accountevent.BalancePositionUpdateEvent;
import com.helei.dto.account.PositionInfo;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Mappings;
import org.mapstruct.factory.Mappers;

import java.util.List;

@Mapper
public interface PositionInfoMapper {

    PositionInfoMapper INSTANCE = Mappers.getMapper(PositionInfoMapper.class);


    @Mappings({
            @Mapping(source = "symbol", target = "symbol"),
            @Mapping(source = "position", target = "position"),
            @Mapping(source = "enterPosition", target = "enterPosition"),
            @Mapping(source = "balanceEqualPrice", target = "balanceEqualPrice"),
            @Mapping(source = "countProfitOrLoss", target = "countProfitOrLoss"),
            @Mapping(source = "unrealizedProfitOrLoss", target = "unrealizedProfitOrLoss"),
            @Mapping(source = "model", target = "model"),
            @Mapping(source = "bail", target = "bail"),
            @Mapping(source = "positionSide", target = "positionSide")
    })
    PositionInfo convertFromPositionChangeInfo(BalancePositionUpdateEvent.PositionChangeInfo positionChangeInfo);

    List<PositionInfo> convertFromPositionChangeInfoList(List<BalancePositionUpdateEvent.PositionChangeInfo> positionChangeInfoList);
}



accountinfomapper
bainanceacocuntEventSource
accountinfoservice
比南accounteventSourceTest



