package cn.com.helei.bot_father;

import cn.com.helei.bot_father.anno.BotApplication;
import cn.com.helei.bot_father.bot.AutoLaunchBot;
import cn.com.helei.bot_father.config.AutoBotConfig;
import cn.com.helei.bot_father.service.BotApi;
import cn.com.helei.common.exception.BotInitException;
import cn.com.helei.common.exception.BotStartException;
import cn.hutool.core.util.StrUtil;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.ImportAutoConfiguration;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ConfigurableApplicationContext;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;
import java.util.Optional;

@SpringBootApplication(exclude = ServletWebServerFactoryAutoConfiguration.class)
@ImportAutoConfiguration({BotFatherAutoConfig.class})
public class BotLauncher {

    private static final String BOT_KEY_PARAM_KEY = "--bot.botKey=";

    /**
     * 启动bot
     *
     * @param botClass botClass
     * @param args     args
     * @param <T>      T
     * @return ApplicationContext
     * @throws BotStartException BotStartException
     * @throws BotInitException  BotInitException
     */
    public static <T extends AutoLaunchBot<T>> ApplicationContext launch(Class<T> botClass, String[] args)
            throws BotStartException, BotInitException {
        // 命令行参数设置app name
        Optional<String> botKeyOp = Arrays.stream(args).filter(arg -> arg.startsWith("--bot.botKey=")).findFirst();
        if (botKeyOp.isEmpty()) throw new BotStartException("bot key is empty");
        System.setProperty("spring.application.name", botKeyOp.get().replace(BOT_KEY_PARAM_KEY, ""));

        // 解析注解上的bot name
        BotApplication annotation = botClass.getAnnotation(BotApplication.class);
        String botName = null;
        if (annotation == null || StrUtil.isBlank((botName = annotation.name()))) {
            throw new BotStartException("bot must have @BotApplication annotation and must have name");
        }
        AutoBotConfig.BOT_Name = botName;


        // Step 1 创建容器
        ConfigurableApplicationContext applicationContext = SpringApplication.run(BotLauncher.class, args);

        // Step 2 获取配置Bean
        AutoBotConfig botConfig = applicationContext.getBean(AutoBotConfig.class);
        BotApi botApi = applicationContext.getBean(BotApi.class);

        // Step 3 创建bot实例
        Constructor<T> constructor = null;
        T t = null;
        try {
            constructor = botClass.getConstructor();
            t = constructor.newInstance();
        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException |
                 InvocationTargetException e) {
            throw new BotInitException(e);
        }

        // Step 4 启动bot
        t.launch(botConfig, botApi);

        return applicationContext;
    }
}

spring:
  datasource:
    url: "jdbc:sqlite://D:\\workspace\\DepinBot\\auto-bot-v_1.1\\botData\\config\\system\\auto_bot.db"

dubbo:
  application:
    name: bot-platform
    logger: slf4j
  registry:
#    id: zk-registry
#    address: zookeeper://127.0.0.1:2181
    id: nacos-registry
    address: nacos://localhost:8848

logging:
  level:
    org:
      apache:
        dubbo: WARN
        zookeeper: WARN
server:
  port: 12010
package cn.com.helei.common.constants;

/**
 * Bot Job 类型
 */
public enum BotJobType {
    /**
     * 注册
     */
    REGISTER,
    /**
     * 登录
     */
    LOGIN,
    /**
     * 查询奖励
     */
    QUERY_REWARD,
    /**
     * 只运行一次的任务
     */
    ONCE_TASK,
    /**
     * 定时任务
     */
    TIMED_TASK,
    /**
     * web socket连接任务
     */
    WEB_SOCKET_CONNECT,

    ACCOUNT_SPLIT_JOB
}
package cn.com.helei.common.dto.job;

import cn.com.helei.common.constants.BotJobType;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;


@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class AutoBotJobParam implements Serializable {

    @Serial
    private static final long serialVersionUID = 5651494651564179417L;


    public static final String  START_AT = "start_at";

    private BotJobType jobType;

    private String jobName;

    private String description;

    private String cronExpression;

    private Integer intervalInSecond;

    private Integer concurrentCount;

    private AutoBotJobWSParam autoBotJobWSParam;

    private Boolean uniqueAccount;

    private Boolean dynamicTrigger;

    private Integer dynamicTimeWindow;

    private Map<String, Object> params = new HashMap<>();
}
package cn.com.helei.common.dto.job;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serial;
import java.io.Serializable;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class AutoBotJobWSParam implements Serializable {

    @Serial
    private static final long serialVersionUID = 984984151765154986L;


    private Boolean isRefreshWSConnection;

    private Boolean wsUnlimitedRetry;

    private Integer wsConnectCount;

    private Integer reconnectLimit;

    private Integer heartBeatIntervalSecond;

    private Integer reconnectCountDownSecond;

}
package cn.com.helei.common.entity;


import cn.com.helei.common.dto.ConnectStatusInfo;
import cn.com.helei.common.util.excel.IntegerStringConverter;
import cn.com.helei.common.util.propertylisten.PropertyChangeListenClass;
import cn.com.helei.common.util.propertylisten.PropertyChangeListenField;
import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.common.util.typehandler.MapTextTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
@PropertyChangeListenClass(isDeep = true)
public class AccountContext implements Serializable {

    @Serial
    private static final long serialVersionUID = 5648946541345416541L;

    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("bot_id")
    @CommandTableField
    private Integer botId;

    @TableField("bot_key")
    @ExcelProperty(value = "bot_key")
    @CommandTableField
    private String botKey;

    @TableField("account_base_info_id")
    @ExcelProperty(value = "account_base_info_id", converter = IntegerStringConverter.class)
    @CommandTableField
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty(value = "twitter_id", converter = IntegerStringConverter.class)
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty(value = "discord_id", converter = IntegerStringConverter.class)
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty(value = "proxy_id", converter = IntegerStringConverter.class)
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty(value = "browser_env_id", converter = IntegerStringConverter.class)
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty(value = "telegram_id", converter = IntegerStringConverter.class)
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty(value = "wallet_id", converter = IntegerStringConverter.class)
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    /**
     * 账号状态
     * 0 表示初始状态
     * 1 表示已注册
     */
    @TableField("status")
    @PropertyChangeListenField
    @CommandTableField
    private Integer status;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    @CommandTableField
    private ProxyInfo proxy;

    @TableField(exist = false)
    @CommandTableField
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return params.get(key) == null ? "" : params.get(key).toString();
    }

    public void setParam(String key, Object value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        if (accountBaseInfo == null) return "";
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().generateAddressStr());
    }

    public Boolean isSignUp() {
        return status != null && status == 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }

    public static void signUpSuccess(AccountContext accountContext) {
        accountContext.setStatus(1);
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.fastjson.JSONObject;
import com.baomidou.mybatisplus.annotation.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-07
 */
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_info")
public class BotInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 1000026515674412242L;

    public static final String CONFIG_PARAMS_KEY = "config_params_key";

    public static final String ACCOUNT_PARAMS_KEY = "account_params_key";

    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("name")
    private String name;

    @TableField("describe")
    private String describe;

    @TableField("image")
    private String image;

    @TableField("limit_project_ids")
    private String limitProjectIds;

    @TableField("job_params")
    private Map<String, AutoBotJobParam> jobParams = new HashMap<>();

    @TableField("params")
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    /**
     * 序列化为Json保存的，读取时会存在将AutoBotJobParam变成泛型JsonObject
     */
    public void fixMapValueType() {
        if (jobParams == null || jobParams.isEmpty()) return;
        for (Map.Entry<String, ?> entry : jobParams.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            if (value instanceof AutoBotJobParam param) {
                this.jobParams.put(key, param);
            } else if (value instanceof JSONObject jb) {
                this.jobParams.put(key, JSONObject.parseObject(jb.toJSONString(), AutoBotJobParam.class));
            } else {
                throw new IllegalArgumentException("error map entity value type");
            }
        }

    }
}
package cn.com.helei.common.entity;

import com.baomidou.mybatisplus.annotation.*;

import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * @author com.helei
 * @since 2025-02-18
 */
@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@TableName("t_bot_instance")
public class BotInstance implements Serializable {

    @Serial
    private static final long serialVersionUID = 4984719841947412242L;


    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("bot_key")
    private String botKey;

    @TableField("account_table_name")
    private String accountTableName;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

    public BotInfo botInfo;
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.hutool.core.util.StrUtil;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.Getter;
import lombok.Setter;


/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_browser_env")
public class BrowserEnv implements Serializable {
    @Serial
    private static final long serialVersionUID = 949819741465456514L;

    public static final String USER_AGENT_KEY = "User-Agent";

    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("user_agent")
    @ExcelProperty("user_agent")
    @CommandTableField
    private String userAgent;

    @TableField("other_header")
    @ExcelProperty("other_header")
    @CommandTableField
    private Map<String, Object> otherHeader;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public Map<String, String> generateHeaders() {
        HashMap<String, String> map = new HashMap<>();
        map.put("User-Agent", userAgent);
        otherHeader.forEach((k, v) -> map.put(k, StrUtil.toString(v)));
        return map;
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@Builder
@TableName("t_discord_account")
@AllArgsConstructor
@NoArgsConstructor
public class DiscordAccount implements Serializable {

    @Serial
    private static final long serialVersionUID = 5616541919849819774L;


    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("password")
    @ExcelProperty("password")
    @CommandTableField
    private String password;

    @TableField("username")
    @ExcelProperty("username")
    @CommandTableField
    private String username;

    @TableField("bind_email")
    @ExcelProperty("bind_email")
    @CommandTableField
    private String bindEmail;

    @TableField("bind_email_password")
    @ExcelProperty("bind_email_password")
    @CommandTableField
    private String bindEmailPassword;

    @TableField("token")
    @ExcelProperty("token")
    @CommandTableField
    private String token;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;

}
package cn.com.helei.common.entity;

import cn.com.helei.common.constants.ProxyProtocol;
import cn.com.helei.common.constants.ProxyType;
import cn.com.helei.common.util.excel.IntegerStringConverter;
import cn.com.helei.common.util.excel.ProxyProtocolConverter;
import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_proxy_info")
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class ProxyInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 7841981984165165142L;


    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField(value = "proxy_type")
    @CommandTableField
    private ProxyType proxyType;

    @TableField(value = "proxy_protocol")
    @ExcelProperty(value = "proxy_protocol", converter = ProxyProtocolConverter.class)
    @CommandTableField
    private ProxyProtocol proxyProtocol;

    @TableField("host")
    @ExcelProperty(value = "host")
    @CommandTableField
    private String host;

    @TableField("port")
    @ExcelProperty(value = "port", converter = IntegerStringConverter.class)
    @CommandTableField
    private Integer port;

    @TableField("username")
    @ExcelProperty(value = "username")
    @CommandTableField
    private String username;

    @TableField("password")
    @ExcelProperty(value = "password")
    @CommandTableField
    private String password;

    @TableField("params")
    private Map<String, Object> params;

    private Boolean usable;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public ProxyInfo(Object originLine) {
        String proxyUrl = (String) originLine;

        String[] split = proxyUrl.split("://");
        String protocol = split[0];

        proxyProtocol = switch (protocol.toLowerCase()) {
            case "http" -> ProxyProtocol.HTTP;
            case "socks5" -> ProxyProtocol.SOCKS5;
            default -> throw new IllegalStateException("Unexpected value: " + protocol);
        };
        String[] upAndAddress = split[1].split("@");

        if (upAndAddress.length == 1) {
            String[] address = upAndAddress[0].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        } else if (upAndAddress.length == 2) {
            String[] up = upAndAddress[0].split(":");
            this.username = up[0];
            this.password = up[1];

            String[] address = upAndAddress[1].split(":");
            this.host = address[0];
            this.port = Integer.parseInt(address[1]);
        }
    }


    public SocketAddress generateAddress() {
        return new InetSocketAddress(host, port);
    }

    public String generateAddressStr() {
        return host + ":" + port;
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.propertylisten.PropertyChangeListenClass;
import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;


import lombok.Getter;
import lombok.Setter;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_reword_info")
@PropertyChangeListenClass
public class RewordInfo implements Serializable {

    @Serial
    private static final long serialVersionUID = 6919845416514161654L;


    @TableId(value = "project_account_id", type = IdType.INPUT)
    @CommandTableField
    private Integer projectAccountId;

    @TableField("total_points")
    @CommandTableField
    private Double totalPoints;

    @TableField("session")
    @CommandTableField
    private String session;

    @TableField("session_points")
    @CommandTableField
    private Double sessionPoints;

    @TableField("daily_points")
    @CommandTableField
    private Double dailyPoints;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    public RewordInfo newInstance() {
        RewordInfo rewordInfo = new RewordInfo();
        rewordInfo.totalPoints = this.totalPoints;
        rewordInfo.session = this.session;
        rewordInfo.sessionPoints = this.sessionPoints;
        rewordInfo.dailyPoints = this.dailyPoints;
        rewordInfo.insertDatetime = this.insertDatetime;
        rewordInfo.updateDatetime = this.updateDatetime;
        rewordInfo.isValid = this.isValid;

        return rewordInfo;
    }
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.tableprinter.CommandTableField;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@Getter
@Setter
@Builder
@TableName("t_telegram_account")
@AllArgsConstructor
@NoArgsConstructor
public class TelegramAccount implements Serializable {

    @Serial
    private static final long serialVersionUID = 1649841654984796545L;

    @TableId(value = "id", type = IdType.INPUT)
    @CommandTableField
    private Integer id;

    @TableField("username")
    @ExcelProperty("username")
    @CommandTableField
    private String username;

    @TableField("password")
    @ExcelProperty("password")
    @CommandTableField
    private String password;

    @TableField("phone_prefix")
    @ExcelProperty("phone_prefix")
    @CommandTableField
    private String phonePrefix;

    @TableField("phone")
    @ExcelProperty("phone")
    @CommandTableField
    private String phone;

    @TableField("token")
    @ExcelProperty("token")
    @CommandTableField
    private String token;

    @TableField("params")
    private Map<String, Object> params;

    @TableField("insert_datetime")
    private LocalDateTime insertDatetime;

    @TableField("update_datetime")
    private LocalDateTime updateDatetime;

    @TableField("is_valid")
    private Integer isValid;
}
package cn.com.helei.common.entity;

import cn.com.helei.common.util.tableprinter.CommandTableField;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import com.alibaba.excel.annotation.ExcelProperty;
import com.baomidou.mybatisplus.annotation.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@Builder
@TableName("t_twitter_account")
@AllArgsConstructor
@NoArgsConstructor
public class TwitterAccount implements Serializable {

    @Serial
    private static final long serialVersionUID = 8945289498414514514L;


    @TableId(value = "id", type = IdType.AUTO)
    @CommandTableField
    private Integer id;

    @TableField("username")
    @ExcelProperty("username")
    @CommandTableField
    private String username;

    @TableField("password")
    @ExcelProperty("password")
    @CommandTableField
    private String password;

    @TableField("email")
    @ExcelProperty("email")
    @CommandTableField
    private String email;

    @TableField("email_password")
    @ExcelProperty("email_password")
    @CommandTableField
    private String emailPassword;

    @TableField("token")
    @ExcelProperty("token")
    @CommandTableField
    private String token;

    @TableField("f2a_key")
    @ExcelProperty("f2a_key")
    @CommandTableField
    private String f2aKey;

    @TableField("params")
    private Map<String, Object> params;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;
}
package cn.com.helei.db_layer.config;

import cn.com.helei.common.util.typehandler.JsonTypeHandler;
import cn.com.helei.common.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.common.util.typehandler.MapTextTypeHandler;
import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.LocalDateTime;

@Configuration
public class MybatisConfig implements MetaObjectHandler {

    @Autowired
    private ApplicationContext applicationContext;

    /**
     * 使用mp做添加操作时候，这个方法执行
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        //设置属性值
        this.setFieldValByName("insertDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
        this.setFieldValByName("isValid", 1, metaObject);
    }

    /**
     * 使用mp做修改操作时候，这个方法执行
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        this.setFieldValByName("updateDatetime", LocalDateTime.now(), metaObject);
    }


    @Bean
    @ConditionalOnMissingBean
    public JsonTypeHandler jsonTypeHandler() {
        return new JsonTypeHandler();
    }

    @Bean
    @ConditionalOnMissingBean
    public MapTextTypeHandler mapTextTypeHandler() {
        return new MapTextTypeHandler();
    }

    @Bean
    @ConditionalOnMissingBean
    public LocalDateTimeTypeHandler localDateTimeTypeHandler() {
        return new LocalDateTimeTypeHandler();
    }
}
package cn.com.helei.db_layer.plugn.table_shard.strategy;

import java.util.Arrays;


public class BotIdBasedTableShardStrategy implements ITableShardStrategy {
    @Override
    public String generateTableName(String tableNamePrefix, Object[] value) {
        verificationTableNamePrefix(tableNamePrefix);

        if (value == null || value.length != 2 || value[0] == null || value[1] == null) {
            throw new IllegalArgumentException("table shard params[%s] illegal".formatted(Arrays.toString(value)));
        }

        long bot_id = Long.parseLong(value[0].toString());
        String bot_key = (String) value[1];

        // 特殊字段过滤
        bot_key = bot_key.replace("-", "_");

        //此处可以缓存优化
        return tableNamePrefix + "_" + bot_id + "_" + bot_key;
    }
}
package cn.com.helei.db_layer.plugn.table_shard;

import cn.com.helei.db_layer.plugn.table_shard.strategy.ITableShardStrategy;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import org.apache.ibatis.binding.MapperMethod;
import org.apache.ibatis.executor.statement.StatementHandler;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.plugin.*;
import org.apache.ibatis.reflection.DefaultReflectorFactory;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.ReflectorFactory;
import org.apache.ibatis.reflection.SystemMetaObject;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.util.HashMap;

@Intercepts({
        @Signature(
                type = StatementHandler.class,
                method = "prepare",
                args = {Connection.class, Integer.class}
        )
})
public class TableShardInterceptor implements Interceptor {

    private static final ReflectorFactory defaultReflectorFactory = new DefaultReflectorFactory();

    private final ITableShardStrategy tableShardStrategy;

    public TableShardInterceptor(ITableShardStrategy tableShardStrategy) {
        this.tableShardStrategy = tableShardStrategy;
    }

    @Override
    public Object intercept(Invocation invocation) throws Throwable {

        // MetaObject是mybatis里面提供的一个工具类，类似反射的效果
        MetaObject metaObject = getMetaObject(invocation);
        BoundSql boundSql = (BoundSql) metaObject.getValue("delegate.boundSql");
        MappedStatement mappedStatement = (MappedStatement) metaObject.getValue("delegate.mappedStatement");

        // 获取Mapper执行方法
        Method method = invocation.getMethod();

        // 获取分表注解
        TableShard tableShard = getTableShard(method, mappedStatement);

        // 如果method与class都没有TableShard注解或执行方法不存在，执行下一个插件逻辑
        if (tableShard == null) {
            return invocation.proceed();
        }

        //获取值
        String[] values = tableShard.values();
        //value是否字段名，如果是，需要解析请求参数字段名的值
        boolean fieldFlag = tableShard.fieldFlag();

        Class<?> targetClass = tableShard.targetClass();

        if (fieldFlag) {
            //获取请求参数
            Object parameterObject = boundSql.getParameterObject();
            Object[] valueObjects = new Object[values.length];

            for (int i = 0; i < values.length; i++) {
                String value = values[i];

                // 1 传入QueryWrapper的情况
                if (parameterObject instanceof MapperMethod.ParamMap paramMap) {
                    // 根据字段名获取参数值
                    valueObjects[i] = resolveValueObject(paramMap, boundSql, value, tableShard);
                } else if (targetClass.isInstance(parameterObject)) {
                    // 2 传入目标对象当query
                    Field field = targetClass.getDeclaredField(value);
                    field.setAccessible(true);
                    valueObjects[i] = field.get(parameterObject);
                } else if (parameterObject instanceof HashMap map) {

                    valueObjects[i] = map.get(value);
                }
            }

            // 替换表名
            replaceSql(tableShard, valueObjects, metaObject, boundSql);
        }
        //执行下一个插件逻辑
        return invocation.proceed();
    }

    private static Object resolveValueObject(MapperMethod.ParamMap paramMap, BoundSql boundSql, String value, TableShard tableShard) throws NoSuchFieldException, IllegalAccessException {
        if (boundSql.getParameterMappings().isEmpty()) {
            return paramMap.get(value);
        }

        for (ParameterMapping parameterMapping : boundSql.getParameterMappings()) {
            String property = parameterMapping.getProperty();
            if (property.endsWith("." + value)) {
                String[] split = property.split("\\.");
                Object o = paramMap.get(split[0]);

                if (o instanceof QueryWrapper<?> queryWrapper) {
                    Object entity = queryWrapper.getEntity();
                    Class<?> targetClass = tableShard.targetClass();
                    if (targetClass.isInstance(entity)) {
                        Field field = targetClass.getDeclaredField(value);
                        field.setAccessible(true);
                        return field.get(entity);
                    }
                }
                break;
            }
        }
        return null;
    }

    /**
     * @param target target
     * @return Object
     */
    @Override
    public Object plugin(Object target) {
        // 当目标类是StatementHandler类型时，才包装目标类，否者直接返回目标本身, 减少目标被代理的次数
        if (target instanceof StatementHandler) {
            return Plugin.wrap(target, this);
        } else {
            return target;
        }
    }

    /**
     * 基本数据类型验证，true是，false否
     *
     * @param object object
     * @return boolean
     */
    private static boolean isBaseType(Object object) {
        return object.getClass().isPrimitive()
                || object instanceof String
                || object instanceof Integer
                || object instanceof Double
                || object instanceof Float
                || object instanceof Long
                || object instanceof Boolean
                || object instanceof Byte
                || object instanceof Short;
    }

    /**
     * @param tableShard 分表注解
     * @param values     值
     * @param metaObject mybatis反射对象
     * @param boundSql   sql信息对象
     */
    private void replaceSql(TableShard tableShard, Object[] values, MetaObject metaObject, BoundSql boundSql) {
        String tableNamePrefix = tableShard.tableNamePrefix();
        // 获取策略class
        Class<? extends ITableShardStrategy> strategyClazz = tableShard.shardStrategy();
        // 生成分表名
        String shardTableName = tableShardStrategy.generateTableName(tableNamePrefix, values);
        // 获取sql
        String sql = boundSql.getSql();
        // 完成表名替换
        metaObject.setValue("delegate.boundSql.sql", sql.replaceAll(tableNamePrefix, shardTableName));
    }

    /**
     * 获取MetaObject对象-mybatis里面提供的一个工具类，类似反射的效果
     *
     * @param invocation invocation
     * @return MetaObject
     */
    private MetaObject getMetaObject(Invocation invocation) {
        StatementHandler statementHandler = (StatementHandler) invocation.getTarget();
        // MetaObject是mybatis里面提供的一个工具类，类似反射的效果

        return MetaObject.forObject(statementHandler,
                SystemMetaObject.DEFAULT_OBJECT_FACTORY,
                SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,
                defaultReflectorFactory
        );
    }

    /**
     * 获取分表注解
     *
     * @param method          method
     * @param mappedStatement mappedStatement
     * @return TableShard
     */
    private TableShard getTableShard(Method method, MappedStatement mappedStatement) throws ClassNotFoundException {
        String id = mappedStatement.getId();
        // 获取Class
        final String className = id.substring(0, id.lastIndexOf("."));
        // 分表注解
        TableShard tableShard = null;
        // 获取Mapper执行方法的TableShard注解
        tableShard = method.getAnnotation(TableShard.class);
        // 如果方法没有设置注解，从Mapper接口上面获取TableShard注解
        if (tableShard == null) {
            // 获取TableShard注解
            tableShard = Class.forName(className).getAnnotation(TableShard.class);
        }
        return tableShard;
    }

}
package cn.com.helei.db_layer.service;

import cn.com.helei.common.dto.PageResult;
import cn.com.helei.common.service.IBaseService;
import cn.com.helei.common.util.ConditionBuildUtil;
import cn.com.helei.db_layer.mapper.IBaseMapper;
import cn.com.helei.db_layer.util.ConditionQueryUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.github.pagehelper.PageInfo;
import lombok.extern.slf4j.Slf4j;
import org.springframework.transaction.annotation.Transactional;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@Slf4j
public abstract class AbstractBaseService<M extends IBaseMapper<T>, T> extends ServiceImpl<M, T> implements IBaseService<T> {

    private final Consumer<T> fillFunction;

    protected AbstractBaseService(Consumer<T> fillFunction) {
        this.fillFunction = fillFunction;
    }

    @Override
    public T queryById(Serializable id) {
        return getById(id);
    }

    /**
     * 插入或更新
     *
     * @param t t
     * @return Integer
     */
    @Override
    public Integer insertOrUpdate(T t) throws SQLException {
        fillFunction.accept(t);
        return getBaseMapper().insertOrUpdate(t);
    }


    /**
     * 批量插入或更新
     *
     * @param tList tList
     * @return Integer
     */
    @Override
    public Integer insertOrUpdateBatch(List<T> tList) throws SQLException {
        int successCount = 0;
        for (T t : tList) {
            try {
                Integer count = insertOrUpdate(t);
                successCount += count == null ? 0 : count;
            } catch (Exception e) {
                throw new SQLException("insert or update error", e);
            }
        }

        return successCount;
    }

    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            Map<String, Object> filterMap
    ) throws SQLException {
        return conditionPageQuery(page, limit, "params", filterMap);
    }


    /**
     * 条件分页查询
     *
     * @param page      page
     * @param limit     limit
     * @param paramsKey paramsKey
     * @param filterMap filterMap
     * @return PageInfo<T>
     * @throws SQLException SQLException
     */
    @Override
    public PageResult<T> conditionPageQuery(
            int page,
            int limit,
            String paramsKey,
            Map<String, Object> filterMap
    ) throws SQLException {
        try {
            PageInfo<T> pageInfo = ConditionQueryUtil.conditionQuery(
                    page,
                    limit,
                    filterMap,
                    paramsKey,
                    condition -> getBaseMapper().multipleConditionQuery(condition),
                    entityClass
            );
            List<T> list = pageInfo.getList();
            PageResult<T> pageResult = new PageResult<>();
            pageResult.setPages(pageInfo.getPages());
            pageResult.setPageNum(pageInfo.getPageNum());
            pageResult.setPageSize(pageInfo.getPageSize());
            pageResult.setTotal(pageInfo.getTotal());
            pageResult.setList(list);
            return pageResult;
        } catch (InvocationTargetException | NoSuchMethodException | InstantiationException |
                 IllegalAccessException e
        ) {
            throw new SQLException("condition query error", e);
        }
    }

    @Override
    public List<T> conditionQuery(Map<String, Object> filterMap) throws SQLException {
        return conditionQuery("params", filterMap);
    }

    @Override
    public List<T> conditionQuery(String paramsKey, Map<String, Object> filterMap) throws SQLException {
        T condition = null;
        try {
            condition = ConditionBuildUtil.getMapContainsCondition(
                    filterMap,
                    paramsKey,
                    entityClass
            );
        } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                 IllegalAccessException e) {
            throw new SQLException(e);
        }

        return getBaseMapper().multipleConditionQuery(condition);
    }

    /**
     * 删除
     *
     * @param ids ids
     * @return Result
     */
    @Transactional
    public Boolean delete(List<Integer> ids) {
        return removeBatchByIds(ids);
    }


    protected <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }

    protected Integer toInteger(Object obj) {
        return obj == null ? null : Integer.valueOf(obj.toString());
    }
}
package cn.com.helei.db_layer;

import cn.com.helei.db_layer.config.MybatisConfig;
import cn.com.helei.db_layer.plugn.table_shard.strategy.BotIdBasedTableShardStrategy;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@MapperScan(basePackages = "cn.com.helei.db_layer.mapper")
@Import(MybatisConfig.class)
public class DBLayerAutoConfig {

}
package cn.com.helei.job.constants;

public enum JobStatus {

    NOT_REGISTER,

    PARSED,

    STARTED
}
package cn.com.helei.job.dto;

import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.job.service.BotJobService;
import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Slf4j
@Component
@DisallowConcurrentExecution
public class AutoBotJob implements Job {

    public static final String BOT_JOB_PARAM_KEY = "bot_job_param";


    @Autowired
    private BotJobService botJobService;

    @Override
    public void execute(JobExecutionContext context) throws JobExecutionException {
        JobDataMap jobDataMap = context.getJobDetail().getJobDataMap();

        // 提取JobDataMap里的参数
        AutoBotJobParam autoBotJobParam = (AutoBotJobParam) jobDataMap.get(BOT_JOB_PARAM_KEY);

        JobKey key = context.getJobDetail().getKey();

        // 获取job调用者
        AutoBotJobInvoker invoker = botJobService.getJobInvoker(key);

        if (invoker != null) {
            // 调用invoke方法
            invoker.invokeJob(key, autoBotJobParam);
        } else {
            log.warn("job[{}] invoker is null", key);
        }
    }

}
package cn.com.helei.job.service.impl;

import cn.com.helei.common.constants.BotJobType;
import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.job.constants.JobStatus;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import cn.com.helei.job.dto.AutoBotJob;
import cn.com.helei.job.service.BotJobService;
import lombok.extern.slf4j.Slf4j;
import org.quartz.*;
import org.quartz.impl.matchers.GroupMatcher;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

import static cn.com.helei.common.dto.job.AutoBotJobParam.START_AT;
import static cn.com.helei.job.dto.AutoBotJob.BOT_JOB_PARAM_KEY;


@Slf4j
@Service
public class QuartzBotJobService implements BotJobService {

    private final ConcurrentMap<JobKey, AutoBotJobInvoker> invokerMap;

    @Autowired
    private Scheduler scheduler;

    public QuartzBotJobService() {
        this.invokerMap = new ConcurrentHashMap<>();
    }

    @Override
    public void registerJobInvoker(JobKey jobKey, AutoBotJobInvoker invoker) {
        this.invokerMap.put(jobKey, invoker);
    }


    @Override
    public AutoBotJobInvoker getJobInvoker(JobKey jobKey) {
        return invokerMap.get(jobKey);
    }

    @Override
    public List<BotACJobResult> startJobList(
            String botKey,
            String jobName,
            Collection<AutoBotJobParam> autoBotJobParams,
            AutoBotJobInvoker invoker
    ) {
        List<BotACJobResult> resultList = new ArrayList<>(autoBotJobParams.size());

        for (AutoBotJobParam autoBotJob : autoBotJobParams) {
            resultList.add(startJob(botKey, jobName, autoBotJob, invoker));
        }

        return resultList;
    }


    @Override
    public BotACJobResult startJob(
            String botKey,
            String jobName,
            AutoBotJobParam jobParam,
            AutoBotJobInvoker invoker
    ) {

        BotACJobResult result = BotACJobResult
                .builder()
                .group(botKey)
                .jobName(jobName)
                .success(true)
                .build();

        JobKey jobKey = new JobKey(jobName, botKey);
        TriggerKey triggerKey = new TriggerKey(jobName, botKey);

        try {

            JobStatus status = queryJobStatus(jobKey);

            switch (status) {
                case PARSED -> resumeJob(jobKey);
                case STARTED -> {
                    // 检查trigger是否发生变化
                    JobDetail jobDetail = scheduler.getJobDetail(jobKey);
                    AutoBotJobParam dbJobParam = (AutoBotJobParam) jobDetail.getJobDataMap().get(BOT_JOB_PARAM_KEY);

                    // 发生变化，修改trigger，重新启动
                    if (!dbJobParam.equals(jobParam)) {
                        Trigger configTrigger = generateTriggerFromParam(jobKey, jobParam);
                        scheduler.rescheduleJob(triggerKey, configTrigger);
                        log.info("[{}] trigger 修改成功 new trigger [{}]", jobKey, configTrigger);
                    } else {
                        result.setSuccess(false);
                        result.setErrorMsg("job exist");
                    }
                }
                case NOT_REGISTER -> registryAndStartJob(jobKey, jobParam);
            }
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMsg(e.getMessage());

            log.error("注册[{}]job发生异常", jobKey, e);
        }

        return result;
    }

    @Override
    public void parseJob(JobKey jobKey) throws SchedulerException {
        if (scheduler.getJobDetail(jobKey) == null) {
            log.warn("[{}] not exist, cancel parse", jobKey);
            return;
        }

        scheduler.pauseJob(jobKey);
        log.info("[{}] parsed", jobKey);
    }


    @Override
    public void parseJob(String botKey, String jobName) throws SchedulerException {
        JobKey jobKey = new JobKey(jobName, botKey);
        parseJob(jobKey);
    }

    @Override
    public void parseGroupJob(String botKey) throws SchedulerException {
        scheduler.pauseJobs(GroupMatcher.jobGroupEquals(botKey));
        log.info("bot[{}] all job parsed", botKey);
    }

    @Override
    public void resumeJob(String botKey, String jobName) throws SchedulerException {
        JobKey jobKey = new JobKey(jobName, botKey);
        resumeJob(jobKey);
    }

    @Override
    public void resumeJob(JobKey jobKey) throws SchedulerException {
        if (scheduler.getJobDetail(jobKey) == null) {
            log.warn("[{}] not exist, cancel resume", jobKey);
            return;
        }
        scheduler.resumeJob(jobKey);
        log.info("[{}] resumed", jobKey);
    }

    @Override
    public JobStatus queryJobStatus(String botKey, String jobName) throws SchedulerException {
        JobKey jobKey = new JobKey(jobName, botKey);
        return queryJobStatus(jobKey);
    }

    @Override
    public JobStatus queryJobStatus(JobKey jobKey) throws SchedulerException {

        if (!scheduler.checkExists(jobKey)) {
            return JobStatus.NOT_REGISTER;
        }
        if (scheduler.isStarted()) {
            return JobStatus.STARTED;
        }
        return JobStatus.PARSED;
    }


    /**
     * 注册并启动job
     *
     * @param jobKey   jobKey
     * @param jobParam jobParam
     * @throws SchedulerException SchedulerException
     */
    private void registryAndStartJob(JobKey jobKey, AutoBotJobParam jobParam) throws SchedulerException {
        JobDataMap jobDataMap = new JobDataMap();
        jobDataMap.put(BOT_JOB_PARAM_KEY, jobParam);

        // 不存在，创建并运行
        JobDetail jobDetail = JobBuilder.newJob(AutoBotJob.class)
                .withIdentity(jobKey)
                .withDescription(jobParam.getDescription())
                .setJobData(jobDataMap)
//                        .storeDurably()
                .build();

        Trigger trigger = generateTriggerFromParam(jobKey, jobParam);

        scheduler.scheduleJob(jobDetail, trigger);
    }

    private static Trigger generateTriggerFromParam(JobKey jobKey, AutoBotJobParam jobParam) {
        TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger()
                .withIdentity(jobParam.getJobName(), jobKey.getGroup())
                .startNow();

        if (BotJobType.ONCE_TASK.equals(jobParam.getJobType())) {
            Object start = jobParam.getParams().get(START_AT);
            if (start == null) {
                triggerBuilder.startNow();
            } else {
                triggerBuilder
                        .startAt(new Date((Long) start));
            }
        } else if (jobParam.getIntervalInSecond() != null) {
            triggerBuilder
                    .withSchedule(SimpleScheduleBuilder
                            .simpleSchedule()
                            .withIntervalInSeconds(jobParam.getIntervalInSecond())
                            .repeatForever()
                    );
        } else if (jobParam.getCronExpression() != null) {
            triggerBuilder
                    .withSchedule(CronScheduleBuilder.cronSchedule(jobParam.getCronExpression()));
        }
        return triggerBuilder.build();
    }

}
package cn.com.helei.job.service;


import cn.com.helei.common.dto.BotACJobResult;
import cn.com.helei.job.constants.JobStatus;
import cn.com.helei.job.core.AutoBotJobInvoker;
import cn.com.helei.common.dto.job.AutoBotJobParam;
import org.quartz.JobKey;
import org.quartz.SchedulerException;

import java.util.Collection;
import java.util.List;

public interface BotJobService {

    /**
     * 注册Job的调用者
     *
     * @param jobKey  jobKey
     * @param invoker invoker
     */
    void registerJobInvoker(JobKey jobKey, AutoBotJobInvoker invoker);

    /**
     * 获取job的调用者
     *
     * @param jobKey jobKey
     * @return invoker
     */
    AutoBotJobInvoker getJobInvoker(JobKey jobKey);

    /**
     * 批量注册job
     *
     * @param botKey           botKey
     * @param autoBotJobParams autoBotJobParams
     * @return Result
     */
    List<BotACJobResult> startJobList(
            String botKey,
            String jobName,
            Collection<AutoBotJobParam> autoBotJobParams,
            AutoBotJobInvoker invoker
    );

    /**
     * 注册job，开始定时执行
     *
     * @param group           group
     * @param autoBotJobParam autoBotJobParam
     * @return BotACJobResult
     */
    BotACJobResult startJob(
            String group,
            String jobName,
            AutoBotJobParam autoBotJobParam,
            AutoBotJobInvoker invoker
    );

    void parseJob(JobKey jobKey) throws SchedulerException;

    /**
     * 暂停Job
     *
     * @param botKey  botKey
     * @param jobName jobName
     */
    void parseJob(String botKey, String jobName) throws SchedulerException;

    /**
     * 暂停Bot的全部任务
     *
     * @param botKey botKey
     * @throws SchedulerException SchedulerException
     */
    void parseGroupJob(String botKey) throws SchedulerException;


    /**
     * 重新启动Job
     *
     * @param botKey  botKey
     * @param jobName jobName
     * @throws SchedulerException SchedulerException
     */
    void resumeJob(String botKey, String jobName) throws SchedulerException;

    /**
     * 重新启动Job
     *
     * @param jobKey jobKey
     * @throws SchedulerException SchedulerException
     */
    void resumeJob(JobKey jobKey) throws SchedulerException;


    /**
     * 查询job状态
     *
     * @param botKey  botKey
     * @param jobName jobName
     * @return JobStatus
     */
    JobStatus queryJobStatus(String botKey, String jobName) throws SchedulerException;

    /**
     * 查询Job状态
     *
     * @param jobKey jobKey
     * @return JobStatus
     * @throws SchedulerException SchedulerException
     */
    JobStatus queryJobStatus(JobKey jobKey) throws SchedulerException;

}
package cn.com.helei.job;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;
import org.quartz.spi.JobFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.quartz.SchedulerFactoryBean;
import org.springframework.scheduling.quartz.SpringBeanJobFactory;

import javax.sql.DataSource;

@Configuration
@ComponentScan(basePackages = "cn.com.helei.job.service.impl")
public class JobAutoConfig {

    @Value("${spring.datasource.quartz.url}")
    private String quartzUrl;

    @Value("${spring.datasource.quartz.username}")
    private String username;

    @Value("${spring.datasource.quartz.password}")
    private String password;

    @Value("${spring.datasource.quartz.driver-class-name}")
    private String driverClassName;

    @Bean
    @Qualifier("quartzDataSource")
    public DataSource quartzDataSource() {
        HikariConfig hikariConfig = new HikariConfig();
        hikariConfig.setJdbcUrl(quartzUrl);
        hikariConfig.setUsername(username);
        hikariConfig.setPassword(password);
        hikariConfig.setDriverClassName(driverClassName);
        hikariConfig.setMaximumPoolSize(10);
        hikariConfig.setMinimumIdle(5);

        return new HikariDataSource(hikariConfig);
    }


    @Bean
    public SchedulerFactoryBean schedulerFactoryBean() {
        SchedulerFactoryBean factoryBean = new SchedulerFactoryBean();
        factoryBean.setDataSource(quartzDataSource());
        factoryBean.setJobFactory(springBeanJobFactory());
        return factoryBean;
    }

    @Bean
    public JobFactory springBeanJobFactory() {
        return new SpringBeanJobFactory();
    }
}
