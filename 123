package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.dto.ConnectStatusInfo;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.bot.core.util.excel.IntegerStringConverter;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import cn.com.helei.bot.core.util.typehandler.MapTextTypeHandler;
import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenField;
import com.alibaba.excel.annotation.ExcelProperty;
import com.alibaba.fastjson.annotation.JSONField;
import com.baomidou.mybatisplus.annotation.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

import lombok.*;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_bot_account_context")
@NoArgsConstructor
@Builder
@AllArgsConstructor
@PropertyChangeListenClass(isDeep = true)
public class AccountContext {


    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    @TableField("bot_id")
    private Integer botId;

    @TableField("bot_key")
    @ExcelProperty(value = "bot_key")
    private String botKey;

    @TableField("account_base_info_id")
    @ExcelProperty(value = "account_base_info_id", converter = IntegerStringConverter.class)
    private Integer accountBaseInfoId;

    @TableField("twitter_id")
    @ExcelProperty(value = "twitter_id", converter = IntegerStringConverter.class)
    private Integer twitterId;

    @TableField("discord_id")
    @ExcelProperty(value = "discord_id", converter = IntegerStringConverter.class)
    private Integer discordId;

    @TableField("proxy_id")
    @ExcelProperty(value = "proxy_id", converter = IntegerStringConverter.class)
    private Integer proxyId;

    @TableField("browser_env_id")
    @ExcelProperty(value = "browser_env_id", converter = IntegerStringConverter.class)
    private Integer browserEnvId;

    @TableField("telegram_id")
    @ExcelProperty(value = "telegram_id", converter = IntegerStringConverter.class)
    private Integer telegramId;

    @TableField("wallet_id")
    @ExcelProperty(value = "wallet_id", converter = IntegerStringConverter.class)
    private Integer walletId;

    @TableField("reward_id")
    private Integer rewardId;

    /**
     * 账号状态
     * 0 表示初始状态
     * 1 表示已注册
     */
    @TableField("status")
    @PropertyChangeListenField
    private Integer status;

    @JSONField(serialize = true, deserialize = true)
    @TableField(value = "params", typeHandler = MapTextTypeHandler.class)
    @PropertyChangeListenField
    private Map<String, Object> params = new HashMap<>();

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;


    @TableField(exist = false)
    @PropertyChangeListenField
    private RewordInfo rewordInfo = new RewordInfo();

    @TableField(exist = false)
    private AccountBaseInfo accountBaseInfo;

    @TableField(exist = false)
    private TwitterAccount twitter;

    @TableField(exist = false)
    private DiscordAccount discord;

    @TableField(exist = false)
    private TelegramAccount telegram;

    @TableField(exist = false)
    private ProxyInfo proxy;

    @TableField(exist = false)
    private BrowserEnv browserEnv;

    @TableField(exist = false)
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();

    public String getParam(String key) {
        return String.valueOf(params.get(key));
    }

    public void setParam(String key, Object value) {
        params.put(key, value);
    }

    public void removeParam(String key) {
        params.remove(key);
    }

    public String getName() {
        return accountBaseInfo.getName() == null ? accountBaseInfo.getEmail() : accountBaseInfo.getName();
    }

    public String getSimpleInfo() {
        return String.format("%s-账户[%s]-代理[%s]", getAccountBaseInfo().getId(), getName(), getProxy() == null ? "NO_PROXY" : getProxy().getAddressStr());
    }

    public Boolean isSignUp() {
        return status != null && status == 1;
    }

    public String getType() {
        return accountBaseInfo == null ? null : accountBaseInfo.getType();
    }

    public static void signUpSuccess(AccountContext accountContext) {
        accountContext.setStatus(1);
    }
}

package cn.com.helei.bot.core.entity;

import cn.com.helei.bot.core.supporter.propertylisten.PropertyChangeListenClass;
import cn.com.helei.bot.core.util.typehandler.LocalDateTimeTypeHandler;
import com.baomidou.mybatisplus.annotation.*;


        import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

/**
 * <p>
 *
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Getter
@Setter
@TableName("t_reword_info")
@PropertyChangeListenClass
public class RewordInfo {

    @TableId(value = "project_account_id", type = IdType.INPUT)
    private Integer projectAccountId;

    @TableField("total_points")
    private Double totalPoints;

    @TableField("session")
    private String session;

    @TableField("session_points")
    private Double sessionPoints;

    @TableField("daily_points")
    private Double dailyPoints;

    @TableField(value = "insert_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT)
    private LocalDateTime insertDatetime;

    @TableField(value = "update_datetime", typeHandler = LocalDateTimeTypeHandler.class, fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateDatetime;

    @TableField(value = "is_valid", fill = FieldFill.INSERT)
    @TableLogic
    private Integer isValid;



    public RewordInfo newInstance() {
        RewordInfo rewordInfo = new RewordInfo();
        rewordInfo.totalPoints = this.totalPoints;
        rewordInfo.session = this.session;
        rewordInfo.sessionPoints = this.sessionPoints;
        rewordInfo.dailyPoints = this.dailyPoints;
        rewordInfo.insertDatetime = this.insertDatetime;
        rewordInfo.updateDatetime = this.updateDatetime;
        rewordInfo.isValid = this.isValid;

        return rewordInfo;
    }
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.mvc.service.IBotAccountContextService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 * 前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/accountContext")
public class BotAccountContextController {

    @Autowired
    private IBotAccountContextService botAccountContextService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return botAccountContextService.saveBotAccountContext(importVO.getBotId(), importVO.getBotKey(), importVO.getRawLines());
    }
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/browserEnv")
public class BrowserEnvController {
    @Autowired
    private IBrowserEnvService browserEnvService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return browserEnvService.saveBrowserEnvs(importVO.getRawLines());
    }

}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.entity.DiscordAccount;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import cn.com.helei.bot.core.mvc.service.IDiscordAccountService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/discordAccount")
public class DiscordAccountController {
    @Autowired
    private IDiscordAccountService discordAccountService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return discordAccountService.saveDiscordAccounts(importVO.getRawLines());
    }
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.mvc.service.IProxyInfoService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/proxyInfo")
public class ProxyInfoController {

    @Autowired
    private IProxyInfoService proxyInfoService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return proxyInfoService.saveProxyInfos(importVO.getRawLines());
    }

}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.mvc.service.ITelegramAccountService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@RestController
@RequestMapping("/core/telegramAccount")
public class TelegramAccountController {

    @Autowired
    private ITelegramAccountService telegramAccountService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return telegramAccountService.saveTelegrams(importVO.getRawLines());
    }
}
package cn.com.helei.bot.core.mvc.controller;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TwitterAccount;
import cn.com.helei.bot.core.mvc.service.ITwitterAccountService;
import cn.com.helei.bot.core.mvc.vo.BotImportVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

/**
 * <p>
 *  前端控制器
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@RestController
@RequestMapping("/core/twitterAccount")
public class TwitterAccountController {
    @Autowired
    private ITwitterAccountService twitterAccountService;

    @PostMapping("/batchAdd")
    public Result batchAdd(@RequestBody BotImportVO importVO) {
        return twitterAccountService.saveTwitters(importVO.getRawLines());
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import cn.com.helei.bot.core.mvc.mapper.BotAccountContextMapper;
import cn.com.helei.bot.core.mvc.service.IBotAccountContextService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class BotAccountContextServiceImpl extends ServiceImpl<BotAccountContextMapper, AccountContext> implements IBotAccountContextService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(AccountContext accountBaseInfo) {
        accountBaseInfo.setInsertDatetime(LocalDateTime.now());
        accountBaseInfo.setUpdateDatetime(LocalDateTime.now());
        accountBaseInfo.setIsValid(1);

        return baseMapper.insertOrUpdate(accountBaseInfo);
    }

    @Override
    public Integer insertOrUpdateBatch(List<AccountContext> accountContext) {
        int successCount = 0;
        for (AccountContext accountBaseInfo : accountContext) {
            try {
                Integer count = insertOrUpdate(accountBaseInfo);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", accountBaseInfo, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> rawLines) {
        if (botId == null || StrUtil.isBlank(botKey)) {
            return Result.fail("botId或botKey不能为空");
        }

        try {
            importService.importBotAccountContextFromRaw(botId, botKey, rawLines);

            return Result.ok();
        } catch (Exception e) {
            log.error("botId[{}]-botKey[{}] 报错账户信息失败", botId, botKey, e);
            return Result.fail("保存失败, " + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BrowserEnv;
import cn.com.helei.bot.core.mvc.mapper.BrowserEnvMapper;
import cn.com.helei.bot.core.mvc.service.IBrowserEnvService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class BrowserEnvServiceImpl extends ServiceImpl<BrowserEnvMapper, BrowserEnv> implements IBrowserEnvService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(BrowserEnv browserEnv) {
        browserEnv.setInsertDatetime(LocalDateTime.now());
        browserEnv.setUpdateDatetime(LocalDateTime.now());
        browserEnv.setIsValid(1);

        return baseMapper.insertOrUpdate(browserEnv);
    }

    @Override
    public Integer insertOrUpdateBatch(List<BrowserEnv> browserEnvs) {
        int successCount = 0;
        for (BrowserEnv browserEnv : browserEnvs) {
            try {
                Integer count = insertOrUpdate(browserEnv);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", browserEnv, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveBrowserEnvs(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importBrowserEnvFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入浏览器环境失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.DiscordAccount;
import cn.com.helei.bot.core.mvc.mapper.DiscordAccountMapper;
import cn.com.helei.bot.core.mvc.service.IDiscordAccountService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class DiscordAccountServiceImpl extends ServiceImpl<DiscordAccountMapper, DiscordAccount> implements IDiscordAccountService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(DiscordAccount discordAccount) {
        discordAccount.setInsertDatetime(LocalDateTime.now());
        discordAccount.setUpdateDatetime(LocalDateTime.now());
        discordAccount.setIsValid(1);

        return baseMapper.insertOrUpdate(discordAccount);
    }

    @Override
    public Integer insertOrUpdateBatch(List<DiscordAccount> browserEnvs) {
        int successCount = 0;
        for (DiscordAccount discordAccount : browserEnvs) {
            try {
                Integer count = insertOrUpdate(discordAccount);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", discordAccount, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveDiscordAccounts(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importDiscordFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入discord账号失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.mvc.mapper.ProxyInfoMapper;
import cn.com.helei.bot.core.mvc.service.IProxyInfoService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.IService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class ProxyInfoServiceImpl extends ServiceImpl<ProxyInfoMapper, ProxyInfo> implements IProxyInfoService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(ProxyInfo proxyInfo) {
        proxyInfo.setInsertDatetime(LocalDateTime.now());
        proxyInfo.setUpdateDatetime(LocalDateTime.now());
        proxyInfo.setIsValid(1);

        return baseMapper.insertOrUpdate(proxyInfo);
    }

    @Override
    public Integer insertOrUpdateBatch(List<ProxyInfo> browserEnvs) {
        int successCount = 0;
        for (ProxyInfo proxyInfo : browserEnvs) {
            try {
                Integer count = insertOrUpdate(proxyInfo);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", proxyInfo, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveProxyInfos(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importProxyFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入代理信息失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TelegramAccount;
import cn.com.helei.bot.core.mvc.mapper.TelegramAccountMapper;
import cn.com.helei.bot.core.mvc.service.ITelegramAccountService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
@Slf4j
@Service
public class TelegramAccountServiceImpl extends ServiceImpl<TelegramAccountMapper, TelegramAccount> implements ITelegramAccountService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(TelegramAccount telegramAccount) {
        telegramAccount.setInsertDatetime(LocalDateTime.now());
        telegramAccount.setUpdateDatetime(LocalDateTime.now());
        telegramAccount.setIsValid(1);

        return baseMapper.insertOrUpdate(telegramAccount);
    }

    @Override
    public Integer insertOrUpdateBatch(List<TelegramAccount> browserEnvs) {
        int successCount = 0;
        for (TelegramAccount telegramAccount : browserEnvs) {
            try {
                Integer count = insertOrUpdate(telegramAccount);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", telegramAccount, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveTelegrams(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importTelegramFormRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入telegram账号失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service.impl;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TwitterAccount;
import cn.com.helei.bot.core.mvc.mapper.TwitterAccountMapper;
import cn.com.helei.bot.core.mvc.service.ITwitterAccountService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
@Slf4j
@Service
public class TwitterAccountServiceImpl extends ServiceImpl<TwitterAccountMapper, TwitterAccount> implements ITwitterAccountService {

    @Autowired
    private ImportService importService;

    @Override
    public Integer insertOrUpdate(TwitterAccount twitterAccount) {
        twitterAccount.setInsertDatetime(LocalDateTime.now());
        twitterAccount.setUpdateDatetime(LocalDateTime.now());
        twitterAccount.setIsValid(1);

        return baseMapper.insertOrUpdate(twitterAccount);
    }

    @Override
    public Integer insertOrUpdateBatch(List<TwitterAccount> browserEnvs) {
        int successCount = 0;
        for (TwitterAccount twitterAccount : browserEnvs) {
            try {
                Integer count = insertOrUpdate(twitterAccount);
                successCount += count == null ? 0 : count;;
            } catch (Exception e) {
                log.error("insert or update [{}] error", twitterAccount, e);
            }
        }

        return successCount;
    }

    @Override
    public Result saveTwitters(List<Map<String, Object>> rawLines) {
        if (rawLines == null || rawLines.isEmpty()) {
            return Result.fail("导入数据不能为空");
        }

        try {
            importService.importTwitterFromRaw(rawLines);
            return Result.ok();
        } catch (Exception e) {
            return Result.fail("导入twitter 账号失败," + e.getMessage());
        }
    }
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.AccountContext;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 * 服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IBotAccountContextService extends IService<AccountContext> {
    Integer insertOrUpdate(AccountContext accountBaseInfo);

    Integer insertOrUpdateBatch(List<AccountContext> twitterAccounts);

    Result saveBotAccountContext(Integer botId, String botKey, List<Map<String, Object>> acKVMap);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.BrowserEnv;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IBrowserEnvService extends IService<BrowserEnv> {

    Integer insertOrUpdate(BrowserEnv browserEnv);

    Integer insertOrUpdateBatch(List<BrowserEnv> browserEnvs);

    Result saveBrowserEnvs(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.DiscordAccount;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IDiscordAccountService extends IService<DiscordAccount> {

    Integer insertOrUpdate(DiscordAccount discordAccount);

    Integer insertOrUpdateBatch(List<DiscordAccount> discordAccounts);

    Result saveDiscordAccounts(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.ProxyInfo;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface IProxyInfoService extends IService<ProxyInfo> {

    Integer insertOrUpdate(ProxyInfo proxyInfo);

    Integer insertOrUpdateBatch(List<ProxyInfo> proxyInfo);

    Result saveProxyInfos(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TelegramAccount;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-06
 */
public interface ITelegramAccountService extends IService<TelegramAccount> {

    Integer insertOrUpdate(TelegramAccount telegramAccount);

    Integer insertOrUpdateBatch(List<TelegramAccount> telegramAccounts);

    Result saveTelegrams(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.service;

import cn.com.helei.bot.core.dto.Result;
import cn.com.helei.bot.core.entity.TwitterAccount;
import com.baomidou.mybatisplus.extension.service.IService;

import java.util.List;
import java.util.Map;

/**
 * <p>
 *  服务类
 * </p>
 *
 * @author com.helei
 * @since 2025-02-05
 */
public interface ITwitterAccountService extends IService<TwitterAccount> {

    Integer insertOrUpdate(TwitterAccount twitterAccount);

    Integer insertOrUpdateBatch(List<TwitterAccount> twitterAccounts);

    Result saveTwitters(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.mvc.vo;

import lombok.Data;

import java.util.List;
import java.util.Map;

@Data
public class BotImportVO {

    private Integer botId;

    private String botKey;

    private List<Map<String, Object>> rawLines;
}
package cn.com.helei.bot.core.supporter.botapi.impl;

import cn.com.helei.bot.core.config.SystemConfig;
import cn.com.helei.bot.core.constants.ProxyProtocol;
import cn.com.helei.bot.core.constants.ProxyType;
import cn.com.helei.bot.core.entity.*;
import cn.com.helei.bot.core.mvc.service.*;
import cn.com.helei.bot.core.mvc.service.ITelegramAccountService;
import cn.com.helei.bot.core.supporter.botapi.ImportService;
import cn.com.helei.bot.core.util.excel.ExcelReadUtil;
import cn.com.helei.bot.core.util.FileUtil;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Lazy;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

import static cn.com.helei.bot.core.constants.MapConfigKey.USER_AGENT_KEY;

@Slf4j
@Component
public class DBImportService implements ImportService {

    public static final String DEFAULT_ACCOUNT_TYPE = "default";

    @Autowired
    @Lazy
    private IBotAccountContextService botAccountContextService;

    @Autowired
    @Lazy
    private IAccountBaseInfoService accountBaseInfoService;

    @Autowired
    @Lazy
    private IProxyInfoService proxyInfoService;

    @Autowired
    @Lazy
    private IBrowserEnvService browserEnvService;

    @Autowired
    @Lazy
    private ITwitterAccountService twitterAccountService;

    @Autowired
    @Lazy
    private IDiscordAccountService discordAccountService;

    @Autowired
    @Lazy
    private ITelegramAccountService telegramAccountService;


    @Override
    public Integer importBotAccountContextFromExcel(Integer botId, String botKey, String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_APP_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            return importBotAccountContextFromRaw(botId, botKey, rawLines);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importBotAccountContextFromRaw(Integer botId, String botKey, List<Map<String, Object>> rawLines) {
        List<AccountContext> accountContexts = rawLines.stream().map(map -> {
                    Integer customBotId = autoCast(map.remove("bot_id"));
                    String customBotKey = autoCast(map.remove("bot_key"));

                    return AccountContext.builder()
                            .botId(customBotId == null ? botId : customBotId)
                            .botKey(StrUtil.isBlank(customBotKey) ? botKey : customBotKey)
                            .accountBaseInfoId(toInteger(map.remove("account_base_info_id")))
                            .twitterId(toInteger(map.remove("twitter_id")))
                            .discordId(toInteger(map.remove("discord_id")))
                            .proxyId(toInteger((map.remove("proxy_id"))))
                            .browserEnvId(toInteger(map.remove("browser_env_id")))
                            .telegramId(toInteger(map.remove("telegram_id")))
                            .walletId(toInteger(map.remove("wallet_id")))
                            .params(map)
                            .build();
                })
                .toList();

        // 没设置代理的根据配置填充代理
//            tryFillProxy(accountContexts, proxyRepeat, proxyType);

        // 没设置浏览器环境的根据设置填充环境
        tryFillBrowserEnv(accountContexts);

        return botAccountContextService.insertOrUpdateBatch(accountContexts);
    }


    @Override
    public Integer importBrowserEnvFromExcel(String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        List<Map<String, Object>> headerList = ExcelReadUtil.readExcelToMap(proxyFilePath);

        log.info("文件解析成功, 共[{}]个", headerList.size());
        return importProxyFromRaw(headerList);
    }

    @Override
    public Integer importBrowserEnvFromRaw(List<Map<String, Object>> rawLines) {

        List<BrowserEnv> list = rawLines.stream().map(map -> {
            Object userAgent = map.remove(USER_AGENT_KEY);
            if (userAgent == null) return null;

            BrowserEnv browserEnv = new BrowserEnv();
            browserEnv.setUserAgent((String) userAgent);
            browserEnv.setOtherHeader(map);
            return browserEnv;
        }).filter(Objects::nonNull).toList();

        return browserEnvService.insertOrUpdateBatch(list);
    }

    @Override
    public Integer importProxyFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);

        int total = 0;

        try {
            List<Map<String, Object>> staticProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "static");

            total += importProxyFromRaw(staticProxies);

            List<Map<String, Object>> dynamicProxies = ExcelReadUtil.readExcelToMap(proxyFilePath, "dynamic");

            total += importProxyFromRaw(dynamicProxies);

            log.info("代理配置文件解析成功，static-proxy:[{}], dynamic-proxy:[{}]", staticProxies.size(), dynamicProxies.size());

            return total;
        } catch (Exception e) {
            log.error("解析代理配置文件[{}]错误", proxyFilePath, e);

            return 0;
        }
    }

    @Override
    public Integer importProxyFromRaw(List<Map<String, Object>> rawLines) {

        List<ProxyInfo> list = rawLines.stream().map(map -> {
            String proxyProtocol = autoCast(map.remove("proxy_protocol"));

            return ProxyInfo.builder()
                    .proxyType(ProxyType.STATIC)
                    .host(autoCast(map.remove("host")))
                    .port(Integer.valueOf(autoCast(map.remove("port"))))
                    .proxyProtocol(ProxyProtocol.valueOf(proxyProtocol.toUpperCase()))
                    .username(autoCast(map.remove("username")))
                    .password(autoCast(map.remove("password")))
                    .params(map)
                    .build();
        }).toList();

        return proxyInfoService.insertOrUpdateBatch(list);
    }

    @Override
    public Map<String, Integer> importAccountBaseInfoFromExcel(String botConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, botConfigPath);
        Map<String, Integer> result = new HashMap<>();

        try {
            ExcelReadUtil.readExcelAsMap(
                    proxyFilePath,
                    (type, map) -> AccountBaseInfo.builder()
                            .type(type)
                            .name(autoCast(map.remove("name")))
                            .email(autoCast(map.remove("email")))
                            .password(autoCast(map.remove("password")))
                            .params(map)
                            .build(),
                    (type, accountBaseInfos) -> CompletableFuture.runAsync(() -> {
                        log.info("[{}] 账号基本信息读取完毕, 共[{}]", type, accountBaseInfos.size());
                        Integer insertCount = accountBaseInfoService.insertOrUpdateBatch(accountBaseInfos);

                        log.info("[{}] 账号基本信息保存成功, 新增[{}], 共[{}]", type, insertCount, accountBaseInfos.size());

                        result.put(type, accountBaseInfos.size());
                    })
            );

        } catch (IOException e) {
            log.error("从文件导入账号基本信息出错", e);
        }

        return result;
    }

    @Override
    public Integer importAccountBaseInfoFromRaw(List<Map<String, Object>> rawLines) {
        List<AccountBaseInfo> list = rawLines.stream().map(map -> {
            String type = autoCast(map.remove("type"));

            return AccountBaseInfo.builder()
                    .type(StrUtil.isBlank(type) ? DEFAULT_ACCOUNT_TYPE : type)
                    .name(autoCast(map.remove("name")))
                    .email(autoCast(map.remove("email")))
                    .password(autoCast(map.remove("password")))
                    .params(map)
                    .build();
        }).toList();

        return accountBaseInfoService.insertOrUpdateBatch(list);
    }

    @Override
    public Integer importTwitterFromExcel(String fileBotConfigPath) {
        String proxyFilePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(proxyFilePath);

            return importTwitterFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取twitter account 文件[{}]发生异常", proxyFilePath, e);
            return 0;
        }
    }

    @Override
    public Integer importTwitterFromRaw(List<Map<String, Object>> rawLines) {
        List<TwitterAccount> twitterAccounts = rawLines.stream().map(map -> TwitterAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .email(autoCast(map.remove("email")))
                .emailPassword(autoCast(map.remove("email_password")))
                .token(autoCast(map.remove("token")))
                .f2aKey(autoCast(map.remove("f2a_key")))
                .params(map)
                .build()).toList();

        return twitterAccountService.insertOrUpdateBatch(twitterAccounts);
    }

    @Override
    public Integer importDiscordFromExcel(String fileBotConfigPath) {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);

            return importDiscordFromRaw(rawLines);
        } catch (Exception e) {
            log.error("读取discord account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }

    @Override
    public Integer importDiscordFromRaw(List<Map<String, Object>> rawLines) {
        List<DiscordAccount> discordAccounts = rawLines.stream().map(map -> DiscordAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .bindEmail(autoCast(map.remove("bind_email")))
                .bindEmailPassword(autoCast(map.remove("bind_email_password")))
                .token(autoCast(map.remove("token")))
                .params(map)
                .build()
        ).toList();

        return discordAccountService.insertOrUpdateBatch(discordAccounts);
    }

    @Override
    public Integer importTelegramFormExcel(String fileBotConfigPath) {
        String dirResourcePath = FileUtil.getConfigDirResourcePath(SystemConfig.CONFIG_DIR_BOT_PATH, fileBotConfigPath);

        try {
            List<Map<String, Object>> rawLines = ExcelReadUtil.readExcelToMap(dirResourcePath);

            return importTelegramFormRaw(rawLines);
        } catch (Exception e) {
            log.error("读取telegram account 文件[{}]发生异常", dirResourcePath, e);
            return 0;
        }
    }

    @Override
    public Integer importTelegramFormRaw(List<Map<String, Object>> rawLines) {

        List<TelegramAccount> telegramAccounts = rawLines.stream().map(map -> TelegramAccount.builder()
                .username(autoCast(map.remove("username")))
                .password(autoCast(map.remove("password")))
                .phonePrefix(autoCast(map.remove("phone_prefix")))
                .phone(autoCast(map.remove("phone")))
                .token(autoCast(map.remove("token")))
                .params(map)
                .build()
        ).toList();


        return telegramAccountService.insertOrUpdateBatch(telegramAccounts);
    }


    private static <T> T autoCast(Object obj) {
        return obj == null ? null : (T) obj;
    }

    private static Integer toInteger(Object obj) {
        return obj == null ? null : Integer.valueOf(obj.toString());
    }

    /**
     * 填充代理
     *
     * @param accountContexts accountContexts
     * @param proxyType       proxyType
     */
    private void tryFillProxy(List<AccountContext> accountContexts, Boolean proxyRepeat, ProxyType proxyType) {
        ;// 创建 Page 对象，设置当前页和每页的条数

        Page<ProxyInfo> page = new Page<>(1, accountContexts.size());
        QueryWrapper<ProxyInfo> queryWrapper = new QueryWrapper<>(ProxyInfo.builder().proxyType(proxyType).build())
                .select("id");

        List<ProxyInfo> allProxy = proxyInfoService.list(page, queryWrapper);


        // 筛选
        Map<Integer, Integer> proxyUseCount = new HashMap<>();
        Map<Integer, ProxyInfo> idMapProxy = allProxy.stream().collect(Collectors.toMap(ProxyInfo::getId, p -> {
            proxyUseCount.put(p.getId(), 0);
            return p;
        }));

        Set<AccountContext> noProxyAccounts = new HashSet<>();

        accountContexts.forEach(accountContext -> {

            Integer proxyId = accountContext.getProxyId();

            if (proxyId == null || !idMapProxy.containsKey(proxyId)) {
                // 代理配置无效，给他添上
                noProxyAccounts.add(accountContext);
            } else if (proxyUseCount.getOrDefault(proxyId, 0) > 1 && BooleanUtil.isFalse(proxyRepeat)) {
                // 代理被使用过,并且不允许重复使用
                noProxyAccounts.add(accountContext);
            } else {
                proxyUseCount.put(proxyId, proxyUseCount.getOrDefault(proxyId, 0) + 1);
            }
        });


        // 填充代理
        List<Integer> ids = getLessUsedItem(proxyUseCount, noProxyAccounts.size());
        ArrayList<AccountContext> list = new ArrayList<>(noProxyAccounts);
        for (int i = 0; i < ids.size(); i++) {
            list.get(i).setProxyId(ids.get(i));
        }
    }


    /**
     * 填充浏览器环境
     *
     * @param accountContexts accountContexts
     */
    private void tryFillBrowserEnv(List<AccountContext> accountContexts) {
        Page<BrowserEnv> page = new Page<>(1, accountContexts.size());
        QueryWrapper<BrowserEnv> queryWrapper = new QueryWrapper<BrowserEnv>().select("id");

        List<BrowserEnv> allProxy = browserEnvService.list(page, queryWrapper);

        Map<Integer, Integer> useCount = new HashMap<>();
        Map<Integer, BrowserEnv> idMapEnv = allProxy.stream().collect(Collectors.toMap(BrowserEnv::getId, p -> {
            useCount.put(p.getId(), 0);
            return p;
        }));


        Set<AccountContext> noUseAccounts = new HashSet<>();

        accountContexts.forEach(accountContext -> {
            Integer browserEnvId = accountContext.getBrowserEnvId();

            if (browserEnvId == null || !idMapEnv.containsKey(browserEnvId)) {
                // 配置无效，给他添上
                noUseAccounts.add(accountContext);
            } else {
                useCount.put(browserEnvId, useCount.getOrDefault(browserEnvId, 0) + 1);
            }
        });

        // 填充浏览器环境
        List<Integer> ids = getLessUsedItem(useCount, noUseAccounts.size());
        ArrayList<AccountContext> list = new ArrayList<>(noUseAccounts);
        for (int i = 0; i < ids.size(); i++) {
            list.get(i).setBrowserEnvId(ids.get(i));
        }
    }


    /**
     * 获取最少使用的
     *
     * @param count 数量
     * @return List<T>
     */
    private List<Integer> getLessUsedItem(Map<Integer, Integer> useCountMap, int count) {
        if (useCountMap == null || useCountMap.isEmpty()) return Collections.emptyList();
        int batchSize = Math.min(count, useCountMap.size());

        List<Integer> res = new ArrayList<>(count);

        int needCount = count;
        while (needCount > 0) {
            int currentSize = Math.min(needCount, batchSize);

            List<Integer> batch = useCountMap.entrySet().stream()
                    .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .limit(currentSize)
                    .map(e -> {
                        useCountMap.compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                        return e.getKey();
                    }).toList();
            res.addAll(batch);

            needCount -= batch.size();
        }

        return res;
    }

}
package cn.com.helei.bot.core.supporter.botapi.impl;

import cn.com.helei.bot.core.bot.job.AutoBotJob;
import cn.com.helei.bot.core.bot.job.AutoBotJobParam;
import cn.com.helei.bot.core.dto.BotACJobResult;
import cn.com.helei.bot.core.supporter.botapi.BotJobService;
import org.quartz.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import static cn.com.helei.bot.core.bot.job.AutoBotJob.BOT_JOB_PARAM_Key;

@Component
public class QuartzBotJobService implements BotJobService {

    private static final Logger log = LoggerFactory.getLogger(QuartzBotJobService.class);

    @Autowired
    private Scheduler scheduler;

    @Override
    public List<BotACJobResult> registerJobList(Collection<AutoBotJobParam> autoBotJobParams) {

        List<BotACJobResult> resultList = new ArrayList<>(autoBotJobParams.size());

        for (AutoBotJobParam autoBotJob : autoBotJobParams) {
            resultList.add(registerJob(autoBotJob));
        }

        return resultList;
    }


    @Override
    public BotACJobResult registerJob(AutoBotJobParam jobParam) {
        BotACJobResult result = BotACJobResult.builder()
                .botId(jobParam.getBotId())
                .group(jobParam.getGroup())
                .jobName(jobParam.getJobName())
                .success(true)
                .build();

        JobKey jobKey = new JobKey(jobParam.getJobName(), jobParam.getGroup());

        try {
            // 存在这个job
            if (scheduler.checkExists(jobKey)) {
                result.setSuccess(false);
                result.setErrorMsg("job exist");
            } else {
                JobDataMap jobDataMap = new JobDataMap();
                jobDataMap.put(BOT_JOB_PARAM_Key, jobParam);

                // 不存在，创建并运行
                JobDetail jobDetail = JobBuilder.newJob(AutoBotJob.class)
                        .withIdentity(jobKey)
                        .withDescription(jobParam.getDescription())
                        .setJobData(jobDataMap)
                        .storeDurably()
                        .build();

                TriggerBuilder<Trigger> triggerBuilder = TriggerBuilder.newTrigger()
                        .withIdentity(jobParam.getJobName(), jobParam.getGroup())
                        .startNow();

                if (jobParam.getIntervalInSecond() != null) {
                    triggerBuilder
                            .withSchedule(SimpleScheduleBuilder
                                    .simpleSchedule()
                                    .withIntervalInSeconds(jobParam.getIntervalInSecond())
                                    .repeatForever()
                            );
                } else if (jobParam.getCronExpression() != null) {
                    triggerBuilder
                            .withSchedule(CronScheduleBuilder.cronSchedule(jobParam.getCronExpression()));
                }

                scheduler.scheduleJob(jobDetail, triggerBuilder.build());
            }
        } catch (Exception e) {
            result.setSuccess(false);
            result.setErrorMsg(e.getMessage());

            log.error("注册[{}]job发生异常", jobKey, e);
        }

        return result;
    }

}
package cn.com.helei.bot.core.supporter.botapi;


import java.util.List;
import java.util.Map;

public interface ImportService {

    Integer importBotAccountContextFromExcel(Integer botId, String botKey, String fileBotConfigPath);

    Integer importBotAccountContextFromRaw(Integer botId, String botKey, List<Map<String, Object>> rawLines);


    Map<String, Integer> importAccountBaseInfoFromExcel(String botConfigPath);

    Integer importAccountBaseInfoFromRaw(List<Map<String, Object>> rawLines);


    Integer importBrowserEnvFromExcel(String fileBotConfigPath);

    Integer importBrowserEnvFromRaw(List<Map<String, Object>> rawLines);


    Integer importProxyFromExcel(String botConfigPath);

    Integer importProxyFromRaw(List<Map<String, Object>> rawLines);



    Integer importTwitterFromExcel(String fileBotConfigPath);

    Integer importTwitterFromRaw(List<Map<String, Object>> rawLines);


    Integer importDiscordFromExcel(String fileBotConfigPath);

    Integer importDiscordFromRaw(List<Map<String, Object>> rawLines);


    Integer importTelegramFormExcel(String fileBotConfigPath);

    Integer importTelegramFormRaw(List<Map<String, Object>> rawLines);
}
package cn.com.helei.bot.core.util.captcha;

import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.com.helei.bot.core.util.RestApiClientFactory;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
public class CloudFlareResolver {

    private static final String CREATE_TASK_URL = "https://api.2captcha.com/createTask";

    private static final String GET_RESULT_URL = "https://api.2captcha.com/getTaskResult";

    private static final int GET_RESULT_TIMES = 10;

    private static final int GET_RESULT_INTERVAL_SECONDS = 3;

    public static CompletableFuture<JSONObject> cloudFlareResolve(
            ProxyInfo proxy,
            String websiteUrl,
            String websiteKey,
            String twoCaptchaApiKey
    ) {
        JSONObject body = new JSONObject();

        body.put("clientKey", twoCaptchaApiKey);
        JSONObject task = getTaskInfo(proxy, websiteUrl, websiteKey);
        body.put("task", task);

        log.info("url[{}] start CloudFlare resolve，create task id...", websiteUrl);
        return RestApiClientFactory.getClient(proxy).request(
                CREATE_TASK_URL,
                HttpMethod.POST,
                null,
                null,
                body
        ).thenApplyAsync(resultStr -> {
            JSONObject result = JSONObject.parseObject(resultStr);

            String taskId = result.getString("taskId");
            if (StrUtil.isNotBlank(taskId)) {
                try {
                    return getTaskSolution(proxy, twoCaptchaApiKey, taskId);
                } catch (Exception e) {
                    throw new RuntimeException(websiteUrl + " CloudFlare resolve error", e);
                }
            }

            throw new RuntimeException(websiteUrl + " CloudFlare resolve error, task create error," + resultStr);
        });
    }


    private static JSONObject getTaskSolution(ProxyInfo proxy, String apiKey, String taskId) throws CaptchaResolveException {
        for (int i = 0; i < GET_RESULT_TIMES; i++) {
            JSONObject body = new JSONObject();
            body.put("taskId", taskId);
            body.put("clientKey", apiKey);

            try {
                String resultStr = RestApiClientFactory.getClient(proxy).request(
                        GET_RESULT_URL,
                        HttpMethod.POST,
                        null,
                        null,
                        body
                ).get();

                JSONObject result = JSONObject.parseObject(resultStr);

                Integer errorId = result.getInteger("errorId");

                boolean isBreak = true;
                if (errorId == 0) {
                    String status = result.getString("status");

                    if ("processing".equals(status)) {
                        log.warn("tart[{}] in processing, [{}/{}] ", taskId, i + 1, GET_RESULT_TIMES);
                        isBreak = false;
                    } else if ("ready".equals(status)) {
                        log.info("tart[{}] is ready", taskId);
                        return result.getJSONObject("solution");
                    }
                } else if (errorId == 12) {
                    log.error("Workers could not solve the Captcha");
                    throw new CaptchaResolveException("Workers could not solve the Captcha");
                }

                if (isBreak) {
                    String message = String.format("tart[%s] receive unknown response, %s",
                            taskId, resultStr);
                    log.error(message);
                    throw new CaptchaResolveException(message);
                }

                TimeUnit.SECONDS.sleep(GET_RESULT_INTERVAL_SECONDS);
            } catch (Exception e) {
                throw new CaptchaResolveException("task " + taskId + " resolve occur an error",e);
            }
        }

        throw new CaptchaResolveException("task " + taskId + " result request times out of limit " + GET_RESULT_TIMES);
    }

    @NotNull
    private static JSONObject getTaskInfo(
            ProxyInfo proxy,
            String websiteUrl,
            String websiteKey
    ) {
        JSONObject task = new JSONObject();
        task.put("type", "TurnstileTask");
        task.put("websiteURL", websiteUrl);
        task.put("websiteKey", websiteKey);

        if (proxy != null) {
            task.put("proxyType", proxy.getHost().toLowerCase());
            task.put("proxyAddress", proxy.getHost());
            task.put("proxyPort", String.valueOf(proxy.getPort()));
            task.put("proxyLogin", proxy.getUsername());
            task.put("proxyPassword", proxy.getPassword());
        }
        return task;
    }
}
package cn.com.helei.bot.core.util.exception;

public class RequestException extends Exception{

    // 默认构造函数
    public RequestException() {
        super("request failed.");
    }

    // 传入错误信息的构造函数
    public RequestException(String message) {
        super(message);
    }

    // 传入错误信息和异常原因的构造函数
    public RequestException(String message, Throwable cause) {
        super(message, cause);
    }

    // 传入异常原因的构造函数
    public RequestException(Throwable cause) {
        super(cause);
    }
}
package cn.com.helei.bot.core.util.llm;

import com.alibaba.fastjson.JSONObject;
import lombok.*;

import java.util.ArrayList;
import java.util.List;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Setter
@Getter
public class OpenAIPrompt {

    private String model;

    private final List<JSONObject> messages = new ArrayList<>();

    private String system;

    private final JSONObject systemJB = new JSONObject();

    private boolean stream = false;

    private double temperature;

    private double topP = 0.7;

    private double presencePenalty = 0;

    private final JSONObject responseForMatObj = new JSONObject();

    public JSONObject build() {
        JSONObject jb = new JSONObject();
        jb.put("model", model);
        jb.put("messages", messages);
        jb.put("system", system);
        jb.put("stream", stream);
        jb.put("temperature", temperature);
        jb.put("top_p", topP);
        jb.put("presence_penalty", presencePenalty);
        jb.put("response_format", responseForMatObj);

        return jb;
    }

    public void setSystem(String content) {
        this.system = content;

        if (messages.isEmpty() || "system".equals(messages.getFirst().getString("role"))) {
            if (messages.isEmpty()) messages.addFirst(systemJB);
            systemJB.put("role", "system");
            systemJB.put("content", content);
        }
    }

    public void addQuestion(String content) {

        if (!messages.isEmpty() && "user".equals(messages.getLast().getString("role"))) {
            messages.getLast().put("content", content);
        } else {
            JSONObject question = new JSONObject();
            question.put("role", "user");
            question.put("content", content);

            this.messages.add(question);
        }
    }

    public void addAnswer(String content) {

        if (!messages.isEmpty() && "assistant".equals(messages.getLast().getString("role"))) {
            messages.getLast().put("content", content);
        } else {
            JSONObject question = new JSONObject();
            question.put("role", "assistant");
            question.put("content", content);

            this.messages.add(question);
        }
    }

    public void setResponseFormat(String type) {
        this.responseForMatObj.put("type", type);
    }

    public String getLastAnswer() {

        for (int i = messages.size() - 1; i >= 0; i--) {
            if ("user".equals(messages.get(i).getString("role"))) return messages.get(i).getString("content");
        }

        return null;
    }
}
package cn.com.helei.bot.core.util.llm;

import cn.com.helei.bot.core.util.RestApiClientFactory;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public class QwenLLMAgent {

    private static final String BASE_URL = "";

    private final String apiKey;

    public QwenLLMAgent(String apiKey) {
        this.apiKey = apiKey;
    }

    public CompletableFuture<OpenAIPrompt> request(OpenAIPrompt prompt) {

        Map<String, String> headers = new HashMap<>();
        headers.put("Authorization", "Bearer " + apiKey);

        return RestApiClientFactory
                .getClient(null)
                .request(
                        BASE_URL,
                        HttpMethod.POST,
                        headers,
                        null,
                        prompt.build()
                )
                .thenApplyAsync(response -> {
                    JSONObject result = JSONObject.parseObject(response);
                    String answer = result.getJSONArray("choices").getJSONObject(0).getString("content");
                    prompt.addAnswer(answer);
                    return prompt;
                });
    }

}
package cn.com.helei.bot.core.util.pool;

import cn.com.helei.bot.core.util.tableprinter.CommandLineTablePrintHelper;
import lombok.Getter;
import lombok.Setter;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicInteger;

@Getter
public class IdMarkPool<T> {

    private static Random random = new Random();

    private final Class<T> tClass;

    @Getter
    @Setter
    private List<Object> list;

    @Setter
    private String configClassPath;


    private final ConcurrentMap<Integer, IdMarkPoolItem<T>> idMapItem = new ConcurrentHashMap<>();

    /**
     * 使用次数
     */
    private final Map<Integer, Integer> useCountMap = new HashMap<>();

    public IdMarkPool(Class<T> tClass) {
        this.tClass = tClass;
    }

    public static <C> IdMarkPool<C> create(List<C> items, Class<C> cClass) {
        IdMarkPool<C> tIdMarkPool = new IdMarkPool<>(cClass);

        AtomicInteger idCounter = new AtomicInteger();

        for (C item : items) {
            int id = idCounter.getAndIncrement();

            tIdMarkPool.getIdMapItem().put(id, new IdMarkPoolItem<>(id, item));
            tIdMarkPool.getUseCountMap().put(id, 0);
        }

        return tIdMarkPool;
    }

    /**
     * 获取代理
     *
     * @param id id
     * @return NetworkProxy
     */
    public synchronized T getItem(Integer id) {
        IdMarkPoolItem<T> compute = idMapItem.compute(id, (k, v) -> {
            if (v == null) return null;

            useCountMap.compute(id, (k1, v1) -> {
                if (v1 == null) v1 = 0;

                return v1 + 1;
            });

            return v;
        });

        if (compute == null) return null;

        return compute.data;
    }


    /**
     * 随机获取
     *
     * @param count count
     * @return List<T>
     */
    public synchronized List<T> getRandomItem(int count) {
        List<T> res = new ArrayList<>(count);

        List<IdMarkPoolItem<T>> values = new ArrayList<>(getIdMapItem().values());

        for (int i = 0; i < count; i++) {
            res.add(values.get(random.nextInt(0, values.size())).data);
        }

        return res;
    }

    /**
     * 获取最少使用的
     *
     * @param count 数量
     * @return List<T>
     */
    public synchronized List<T> getLessUsedItem(int count) {
        int batchSize = Math.min(count, getUseCountMap().size());

        List<T> res = new ArrayList<>(count);

        int needCount = count;
        while (needCount > 0) {
            int currentSize = Math.min(needCount, batchSize);

            List<T> batch = getUseCountMap().entrySet().stream()
                    .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                    .limit(currentSize)
                    .map(e -> {
                        getUseCountMap().compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                        return (T) getIdMapItem().get(e.getKey()).getData();
                    }).toList();
            res.addAll(batch);

            needCount -= batch.size();
        }

        return res;
    }

    /**
     * 获取全部
     *
     * @return List<T>
     */
    public List<T> getAllItem() {
        return getIdMapItem().values().stream().map(e -> (T) e).toList();
    }


    /**
     * 打印池
     *
     * @return String
     */
    public String printPool() {
        return CommandLineTablePrintHelper.generateTableString(new ArrayList<>(idMapItem.values()), tClass);
    }


    public T buildTInstanceFromLineStr(Object originLine)
            throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        Constructor<T> constructor = getTClass().getConstructor(Object.class);
        return constructor.newInstance(originLine);
    }


    @Getter
    @Setter
    public static class IdMarkPoolItem<T> {
        private T data;

        private Integer id;

        public IdMarkPoolItem(int id, T item) {
            this.id = id;
            this.data = item;
        }
    }
}
package cn.com.helei.bot.core.util;

import cn.com.helei.bot.core.entity.ProxyInfo;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import io.netty.handler.codec.http.HttpMethod;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import okio.BufferedSource;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.net.Proxy;
import java.net.SocketTimeoutException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.TimeUnit;


@Slf4j
public class RestApiClient {

    private static final int RETRY_TIMES = 1;

    @Getter
    private final OkHttpClient okHttpClient;

    private final ExecutorService executorService;

    public RestApiClient(
            ProxyInfo proxy,
            ExecutorService executorService
    ) {
        this.executorService = executorService;
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        builder
                // 连接超时
                .connectTimeout(25, TimeUnit.SECONDS)
                // 读取超时
                .readTimeout(120, TimeUnit.SECONDS)
                // 写入超时
                .writeTimeout(60, TimeUnit.SECONDS);

        if (proxy != null) {
            builder.proxy(new Proxy(Proxy.Type.HTTP, proxy.getAddress()));
            if (StrUtil.isNotBlank(proxy.getUsername())) {
                builder.proxyAuthenticator((route, response) -> {
                    String credential = Credentials.basic(proxy.getUsername(), proxy.getPassword());
                    return response.request().newBuilder()
                            .header("Proxy-Authorization", credential)
                            .build();
                });
            }
        }
        this.okHttpClient = builder.build();
    }


    /**
     * 发送请求，如果有asKey参数不为null，则会鉴权
     *
     * @param url     url
     * @param method  method
     * @param headers headers
     * @param params  params
     * @param body    body
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<String> request(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return CompletableFuture.supplyAsync(() -> {
            Request request = buildRequest(url, method, headers, params, body);

            return normalRequest(url, method, request);
        }, executorService);
    }

    public CompletableFuture<List<String>> streamRequest(
            String url,
            HttpMethod method,
            Map<String, String> headers,
            JSONObject params,
            JSONObject body
    ) {
        return CompletableFuture.supplyAsync(() -> {
            Request request = buildRequest(url, method, headers, params, body);


            Exception exception = null;
            for (int i = 0; i < RETRY_TIMES; i++) {
                // 发送请求并获取响应
                try (Response response = okHttpClient.newCall(request).execute()) {
                    return streamRequest(url, response);
                } catch (SocketTimeoutException e) {
                    log.warn("请求[{}]超时，尝试重新请求 [{}}/{}],", url, i, RETRY_TIMES);
                    exception = e;
                } catch (IOException e) {
                    throw new RuntimeException("请求url [" + url + "] 失败", e);
                }
            }

            throw new RuntimeException("请求重试次数超过限制, " + RETRY_TIMES, exception);
        });
    }

    @NotNull
    private static Request buildRequest(String url, HttpMethod method, Map<String, String> headers, JSONObject params, JSONObject body) {
        // 创建表单数据
        StringBuilder queryString = new StringBuilder();

        String requestUrl = url;
        if (params != null) {
            params.keySet().forEach(key -> {
                queryString.append(key).append("=").append(params.get(key)).append("&");
            });

            if (!queryString.isEmpty()) {
                queryString.deleteCharAt(queryString.length() - 1);
            }
            requestUrl = url + "?" + queryString;
        }


        Request.Builder builder = new Request.Builder();


        MediaType JSON = MediaType.get("application/json; charset=utf-8");

        RequestBody requestBody = null;
        if (body != null) {
            requestBody = RequestBody.create(body.toJSONString(), JSON);
        }


        // 创建 POST 请求
        builder.url(requestUrl);

        if (HttpMethod.GET.equals(method)) {
            builder.get();
        } else {
            builder.method(method.name(), requestBody);
        }

        if (headers != null) {
            for (Map.Entry<String, String> header : headers.entrySet()) {
                builder.addHeader(header.getKey(), header.getValue());
            }
        }
        return builder.build();
    }


    @NotNull
    private static List<String> streamRequest(String url, Response response) throws IOException {
        ResponseBody responseBody = response.body();
        if (response.isSuccessful() || responseBody == null) {
            throw new RuntimeException("请求 " + url + "失败, " + (responseBody == null ? null : responseBody.string()));
        }

        List<String> result = new ArrayList<>();

        BufferedSource source = responseBody.source();
        while (!source.exhausted()) {
            String chunk = source.readUtf8Line();
            System.out.println(chunk);
            if (chunk != null) {
                result.add(chunk);
            }
        }
        return result;
    }


    @Nullable
    private String normalRequest(String url, HttpMethod method, Request request) {
        log.debug("创建请求 url[{}], method[{}]成功，开始请求服务器", url, method);

        Exception exception = null;
        for (int i = 0; i < RETRY_TIMES; i++) {
            // 发送请求并获取响应
            try (Response response = okHttpClient.newCall(request).execute()) {
                ResponseBody responseBody = response.body();
                if (response.isSuccessful()) {
                    try {
                        return responseBody == null ? null : responseBody.string();
                    } catch (IOException e) {
                        throw new RuntimeException(e);
                    }
                } else {
                    String body = "";
                    if (responseBody != null) {
                        body =  responseBody.string();
                        body = body.substring(0, Math.min(body.length(), 200));
                    }
                    throw new RuntimeException("请求 " + url + "失败[" + response.code() + "], "+ body);
                }
            } catch (SocketTimeoutException e) {
                log.warn("请求[{}]超时，尝试重新请求 [{}}/{}],", url, i, RETRY_TIMES);
                exception = e;
            } catch (IOException e) {
                throw new RuntimeException("请求url [" + url + "] 失败", e);
            }
        }

        throw new RuntimeException("请求重试次数超过限制, " + RETRY_TIMES, exception);
    }
}

