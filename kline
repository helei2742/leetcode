package com.helei.tradedatacenter.entity;


import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * WebSocket里发送请求的格式
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class WebSocketCommand {

    /**
     * 请求的类型
     */
    private String method;

    /**
     * 参数
     */
    private JSONObject params;

    /**
     * id
     */
    private String id;

    public synchronized void setParams(JSONObject params) {
        this.params = params;
    }

    public synchronized void addParam(String key, Object value) {
        if (params == null) {
            params = new JSONObject();
        }
        params.put(key, value);
    }

    public static WebSocketCommandBuilder builder() {
        return new WebSocketCommandBuilder();
    }

    static class WebSocketCommandBuilder{

        private final WebSocketCommand command;

        WebSocketCommandBuilder() {
            command = new WebSocketCommand();
            command.setId(UUID.randomUUID().toString());
        }

        public WebSocketCommand buildPing() {
            return setCommandType(WebSocketCommandType.PING).build();
        }

        public WebSocketCommand buildPong() {
            return setCommandType(WebSocketCommandType.PONG).build();
        }

        public WebSocketCommandBuilder setCommandType(WebSocketCommandType webSocketCommandType) {
            command.setMethod(webSocketCommandType.getDescription());
            return this;
        }

        public WebSocketCommandBuilder setParams(JSONObject param) {
            command.setParams(param);
            return this;
        }

        public WebSocketCommandBuilder noRateLimit() {
            command.addParam("returnRateLimits ", true);
            return this;
        }

        public WebSocketCommand build() {
            return command;
        }
    }
}



enum WebSocketCommandType {

    SUBSCRIBE("SUBSCRIBE"),
    UNSUBSCRIBE("UNSUBSCRIBE"),
    LIST_SUBSCRIPTIONS("LIST_SUBSCRIPTIONS"),
    SET_PROPERTY("SET_PROPERTY"),
    GET_PROPERTY("GET_PROPERTY"),
    PING("ping")
    PONG("pong")
    ;
    WebSocketCommandType(String description) {
        this.description = description;
    }

    private final String description;

    public String getDescription() {
        return description;
    }
}

class WebScoketUrl{
    public static final String NORMAL_URL = "wss://ws-api.binance.com:443/ws-api/v3";

    public static final String SPOT_TEST_URL = "wss://testnet.binance.vision/ws-api/v3";
}

package com.helei.tradedatacenter.entity;

import cn.hutool.json.JSONObject;
import com.alibaba.fastjson.JSON;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.List;


@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class WebSocketResponse {

    /**
     * 请求的id
     */
    private Integer id;

    /**
     * 相应状态
     */
    private Integer status;

    /**
     * 响应内容
     */
    private JSON result;

    /**
     * 错误描述
     */
    private String error;

    /**
     * 限速状态
     */
    private List<RateLimit> rateLimits;
}

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
class RateLimit{
    /**
     * 	频率限制类型: REQUEST_WEIGHT, ORDERS
     */
    private String rateLimitType;

    /**
     * 	频率限制间隔: SECOND, MINUTE, HOUR, DAY
     */
    private String interval;

    /**
     * 频率限制间隔乘数
     */
    private Integer intervalNum;

    /**
     * 每个间隔的请求限制
     */
    private Integer limit;

    /**
     * 	每个间隔的当前使用情况
     */
    private Integer count;
}


package com.helei.tradedatacenter.netty.base;


import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;
import io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;
import io.netty.handler.codec.http.websocketx.WebSocketVersion;
import io.netty.handler.codec.http.websocketx.extensions.compression.WebSocketClientCompressionHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import lombok.extern.slf4j.Slf4j;

import java.net.URI;
import java.net.URISyntaxException;

@Slf4j
public abstract class AbstractWebsocketClient {

    private final String url;

    private final AbstractWebSocketClientHandler handler;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler handler
    ) throws URISyntaxException {
        this.url = url;
        this.handler = handler;
        resolveParamFromUrl();
    }

    public void connect() throws Exception {
        log.info("websocket client 连接中....");

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        EventLoopGroup group = new NioEventLoopGroup();
        try {
            WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders());

            handler.init(handshaker);

            Bootstrap b = new Bootstrap();
            b.group(group)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<SocketChannel>() {
                        @Override
                        protected void initChannel(SocketChannel ch) {
                            ChannelPipeline p = ch.pipeline();
                            if (sslCtx != null) {
                                p.addLast(sslCtx.newHandler(ch.alloc(), host, port));
                            }
                            p.addLast(new HttpClientCodec());
                            p.addLast(new HttpObjectAggregator(8192));
                            p.addLast(WebSocketClientCompressionHandler.INSTANCE);
                            p.addLast(handler);
                        }
                    });

            channel = b.connect(uri.getHost(), port).sync().channel();

            handler.handshakeFuture().sync();

//            // 在这里可以添加一个默认心跳 15s发一次
//            channel.eventLoop().scheduleAtFixedRate(() -> {
//                channel.writeAndFlush(new TextWebSocketFrame("pong"));
//            }, 0, 15, TimeUnit.SECONDS);

            channel.closeFuture().sync();
        } catch (Exception e) {
//            channel.close();
            log.error("websocket client 启动失败，失败原因：{}", e.getMessage());
        } finally {
            group.shutdownGracefully();
        }
    }

    /**
     * 发送消息
     * @param message message
     */
    public void sendMessage(String message) {
        // 进行注册
        channel.writeAndFlush(message);
    }



    /**
     * 解析参数
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }
}


package com.helei.tradedatacenter.netty.base;

import com.alibaba.fastjson.JSON;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.util.CharsetUtil;
import lombok.extern.slf4j.Slf4j;

import io.netty.channel.*;


@Slf4j
public abstract class AbstractWebSocketClientHandler extends SimpleChannelInboundHandler<Object> {

    private WebSocketClientHandshaker handshaker;

    private ChannelPromise handshakeFuture;

    public ChannelFuture handshakeFuture() {
        return handshakeFuture;
    }

    public void init(WebSocketClientHandshaker handshaker) {
        this.handshaker = handshaker;
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        handshakeFuture = ctx.newPromise();
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        handshaker.handshake(ctx.channel());
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        log.info("WebSocket Client disconnected!");
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        Channel ch = ctx.channel();
        if (!handshaker.isHandshakeComplete()) {
            try {
                handshaker.finishHandshake(ch, (FullHttpResponse) msg);
                log.info("websocket client 连接成功");
                handshakeFuture.setSuccess();
            } catch (WebSocketHandshakeException e) {
                log.info("websocket client 连接失败");
                handshakeFuture.setFailure(e);
            }
            return;
        }

        if (msg instanceof FullHttpResponse response) {
            throw new IllegalStateException(
                    "Unexpected FullHttpResponse (getStatus=" + response.status() +
                            ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
        }

        WebSocketFrame frame = (WebSocketFrame) msg;
        if (frame instanceof TextWebSocketFrame) {
            TextWebSocketFrame textFrame = (TextWebSocketFrame) frame;
            log.info("websocket client 接收到的消息：{}",textFrame.text());
            receiveMessage(JSON.parseObject(textFrame.text()));
        } else if (frame instanceof PongWebSocketFrame) {
            log.info("WebSocket Client received pong");
        } else if (frame instanceof CloseWebSocketFrame) {
            log.info("websocket client关闭");
            ch.close();
        }
    }

    protected void receiveMessage(JSON json) {}

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        cause.printStackTrace();
        if (!handshakeFuture.isDone()) {
            handshakeFuture.setFailure(cause);
        }
        ctx.close();
        log.error("业务处理错误，websocket client关闭");
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
    }

}

