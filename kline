//
//  KLineChart.swift
//  CoinWatch
//
//  Created by 何磊 on 2024/9/25.
//

import Foundation
import SwiftUI


/**
    图表显示的类型 
        K_LINE  只显示k线
        MA_LINE 只显示MA
        K_MA_LINE 显示K线和MA线
*/
enum ChartPrintState: CaseIterable {
    case K_LINE
    case MA_LINE
    case K_MA_LINE
    case K_BOLL_LINE

    func next() -> ChartPrintState {
        let allCases = MyEnum.allCases
        let currentIndex = allCases.firstIndex(of: self) 
        let nextIndex = allCases.index(after: currentIndex)
        return nextIndex < allCases.endIndex ? allCases[nextIndex] : allCases.first()
    }
}

struct KLineChart: View {
    
    /**
     当前K线视图的宽度
     */
    @State private var windowWidth: Double = 0
    
    /**
     当前K线视图的高度
     */
    @State private var windowHeight: Double = 0
    
    
    /**
     当前选中的数据
     */
    @State private var selectedPosition:CGPoint? = .zero
    
    /**
     是否长按k线的某点
     */
    @State private var isLineItemLongPress = false
    
    
    /**
     当前是否在加载k线数据
     */
    @State private var isLoadingKLineData: Bool = false
    
    /**
        当前显示哪些图表
    */
    @State private var chartPrintState: ChartPrintState = .K_MA_LINE

    /**
     K线视图的Position， 可用于滚动到指定位置
     */
    @State var position:ScrollPosition = ScrollPosition(edge: .leading)
    
    /**
        当前图表滚动区域的偏移量
    */
    @State var scrollViewOffset:Double?
    
    /**
     表冠滚动的值
     */
    @State private var crownValue: Double = 0.0
    
    /**
     当前视图显示的K线线段的个数
     */
    let viewKLineItemCount:Int = 15
    
    /**
     k线元素之间的间距
     */
    let marginOfLineItem: Double = 0
    
    /**
     坐标轴线的宽度
     */
    let scaleWidth: Double = 2
    
    /**
     每个K线元素的宽度
     */
    @State var lineItemWidth: Double = 0
    
    /**
     滚动区域的宽度，也就是k线图展示的区域。窗口宽度减去轴线宽度
     */
    @State var scrollAreaWidth: Double = 0
    
    /**
     滚动区域的高度，也就是k线图展示的区域。窗口高度减去轴线宽度
     */
    @State var scrollAreaHeight: Double = 0
    
    /**
     组件item的高度比例，因为y轴是价格，所以表示单位价格的长度 height / (maxPrice - minPrice)
     */
    @State var heightRatio: Double = 1
    
    /**
     高度偏移量
     */
    @State var heightOffset: Double = 0
    
    
    /**
     数据集
     */
    @State var dataset: LineDataset = LineDataset(
        symbol: "BTCUSDT",
        kLineInterval: .d_1,
        dataset: [],
        windowStartIndex: 0,
        windowLength: 0
    )

    /**
        均线类型
    */
    @State var maIntervals: [MAType] = []
    
    /**
        boll线设置
    */
    @State var bollConfig:(average:Int, n:Int) = (average: 21, n: 2)

    init(
        symbol: String, 
        kLineInterval: KLineInterval,
        maIntervals: [MAType],
        bollConfig:(average:Int, n:Int)?
    ) {
        self.dataset.symbol = symbol
        self.dataset.kLineInterval = kLineInterval
        self.dataset.windowLength = viewKLineItemCount
        self.maINtervals.append(contentsOf: maIntervals)

        if let bollConfig = bollConfig {
            self.bollConfig = bollConfig
        }
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                
                //背景显示的字
                Text(dataset.symbol)
                    .font(.title)
                    .foregroundStyle(.white)


                //加载动画
                if isLoadingKLineData {
                    ActivityIndicator(isAnimationL .constant(true)).padding()
                }

                if dataset.count > 0{
                    //图表
                    dynamicChartPrinter
                    
                    //图表控制栏
                    chartInfoControlBar
                }

                // 显示十字线以及按住的KLineItem的信息
                if isLineItemLongPress { //在长按
                    if selectedPosition != .zero {
                        longPressPrintView
                    }
                }
            }
            .frame(
                width: .infinity,
                height: .infinity
            )
            .onAppear{
                //设置K线视图宽度、高度
                windowWidth = geometry.size.width
                windowHeight = geometry.size.height
                lineItemWidth = windowWidth / Double(viewKLineItemCount) - marginOfLineItem
                scrollAreaWidth = windowWidth
                scrollAreaHeight = windowHeight
                
                isLoadingKLineData = true
                
                
                print("window区域宽 \(windowWidth) 高 \(windowHeight)")
                print("滚动区域宽 \(scrollAreaWidth) 高 \(scrollAreaHeight)")
                print("单个k线宽度 \(lineItemWidth)")
                print("高度比 \(heightRatio)")
            }
        }
    }

    /**
        图表信息栏
    */
    @ViewBuilder
    var chartInfoControlBar() -> some View {
         //以及当前显示图表状态
        HStack {
            // 实时获取当前显示的k线数据的下标
            var index:Int = Int((scrollViewOffset + windowWidth) / lineItemWidth)        
            if isLineItemLongPress {
                index = Int((xPosition + scrollViewOffset!) / lineItemWidth)
            }

            if chartPrintState == .MA_LINE, chartPrintState == .K_MA_LINE {
                //显示每根均线当前位置的价值                
                maIntervals.ForEach { maInterval in
                   
                    let interval = maInterval.rawValue.interval
                    Text("MA(\(interval)): \(dataset.getIndex(index).dictOfMA[interval])")
                        .font(.littleFont())
                        .foregroundStyle(maInterval.rawValue.color) 
                }
            }
            
            if chartPrintState == .K_BOLL_LINE {
                //显示Boll指标值
                let bollLine = dataset.getIndex(index).bollLine
                Text("BOLL:(\(bollConfig.average),\(bollConfig.n))")
                    .foregroundStyle(.orange)
                Text("UP:\(bollLine.upper))")
                    .foregroundStyle(.orange)
                Text("MB:\(bollLine.average)")
                    .foregroundStyle(.pink)
                Text("DN:\(bollLine.lower)")
                    .foregroundStyle(.purpole)
            }

            //选择k线间隔
            List{
                Picker("k线间隔", selection: $dataset.kLineInterval) {
                    Text("15分").tag(KLineInterval.m_15)
                    Text("1时").tag(KLineInterval.h_1)
                    Text("1日").tag(KLineInterval.d_1)
                    Text("1周").tag(KLineInterval.w_1)
                    Text("1月").tag(KLineInterval.M_1)
                }
            }

            // 切换显示类型，选择显示的类型，
            Button {
                chartPrintState = chartPrintState.next()
                chartPrintState.toggle()
            } label: {
                Label("Graph", systemImage: "chevron.right.circle")
                    .labelStyle(.iconOnly)
                    .imageScale(.large)
                    .rotationEffect(.degrees(showDetail ? 90 : 0))
                    .padding()
                    .animation(.easeInOut, value: chartPrintState)
            }
        }
        .font(.littleFont())
        .frame {
            height: 15
        }
    }


    /**
        动态显示当前的图表
    */
    @ViewBuilder
    var dynamicChartPrinter: some View {
        if  chartPrintState == .MA_LINE || chartPrintState == .K_MA_LINE {
                //绘制均线
            maIntervals.forEach( maInterval in
                MALine(
                    maType: maInterval,
                    lineDataEntryList: dataset.dataset,
                    heightRatio: heightRatio,
                    heightOffset: heightOffset,
                    entryWidth: lineItemWidth
                )
                .content
            )
        }
        if chartPrintState == .K_LINE || chartPrintState == .K_MA_LINE || chartPrintState == .K_BOLL_LINE {
                //x线图
            kLineScrollArea
                .frame(
                    maxWidth: .infinity, maxHeight: .infinity
                )
                .background(.gray.opacity(0.5))
        }
        if chartPrintState == .K_BOLL_LINE {
            //Boll线
            BollLine(
                lineDataEntryList: dataset.dataset,
                heightRatio: heightRatio,
                heightOffset: heightOffset,
                entryWidth: lineItemWidth
            )
            .content
        }

    }
    

    /**
        最新价格到y轴的线
    */
    @ViewBuilder
    var newLineDataPriceLine: some View {
        Path { path in
            let priceY = dataset.dataset.last.close * heightRatio - heightOffset
            let priceX  = dataset.count * lineItemWidth - lineItemWidth / 2 - scrollViewOffset
            let rect = CGRect (
                    x: priceX,
                    y: priceY,
                    width: windowWidth - priceX,
                    height: 1                  
            )

            path.move(to: CGPoint(x: windowWidth, y: priveHeight))
            path.
        }
    }

    /**
     长按k线中的元素后展示的十字线和信息卡
     */
    @ViewBuilder
    var longPressPrintView: some View {
        //获取x坐标
        let xPosition:CGFloat = selectedPosition!.x
        let yPosition:CGFloat = selectedPosition!.y
        
//        let windowX = xPosition - scrollViewOffset!
        
        //点击的坐标在左边还是右边
        let clickWindowLeft:Bool = xPosition < windowWidth/2
        //点击的坐标在左边还是右边
        let clickWindowTop:Bool = yPosition < windowHeight/2
        
        
        let index = Int((xPosition + scrollViewOffset!) / lineItemWidth)
        let itemData = dataset.getIndex(index)
        
        if let itemData = itemData {
            // 十字线
            Path { path in
                path.move(to: CGPoint(x: xPosition, y: 0))
                path.addLine(to: CGPoint(x: xPosition, y: scrollAreaHeight))
            }
            .stroke(
                .gray,
                lineWidth: 1
            )
            
            ZStack{
                Path { path in
                    path.move(to: CGPoint(x: 0, y: yPosition))
                    path.addLine(to: CGPoint(x: windowWidth, y: yPosition))
                }
                .stroke(
                    .gray,
                    lineWidth: 1
                )
                let priceX = clickWindowLeft ? windowWidth - 25 : 20
                
                Text(String(format:"%.2f" ,(scrollAreaHeight - yPosition + heightOffset)/heightRatio))
                    .font(.littleFont())
                    .padding(3)
                    .background(.black)
                    .foregroundColor(.white)
                    .clipShape(RoundedRectangle(cornerRadius: 8))
                    .position(x: priceX, y: yPosition)
            }
            
            let cardX = clickWindowLeft ? xPosition + 3 : max(xPosition - windowWidth/3, 0)
            
            let cardY = clickWindowTop ? yPosition : yPosition - windowHeight/3
            
            
            
            //信息卡片
            HStack {
                VStack {
                    Text("时间")
                    Text("开")
                    Text("高")
                    Text("低")
                    Text("收")
                }
                VStack{
                    Text(DateUtil.dateToStr(date: itemData.openTime))
                    Text(itemData.open.coinPriceFormat())
                    Text(itemData.high.coinPriceFormat())
                    Text(itemData.low.coinPriceFormat())
                    Text(itemData.close.coinPriceFormat())
                }
            }
            .padding(10)
            .font(.littleFont())
            .background(Color.black.opacity(0.5))
            .foregroundStyle(.white)
            .clipShape(
                RoundedRectangle(cornerRadius: 10)
            )
            .position(x: cardX, y: cardY)
        }
    }
    
    @ViewBuilder
    var KLineItemList: some View {
        LazyHStack(spacing: 0){
            // 绘制每一根蜡烛
            ForEach(dataset.dataset) { lineDataEntry in
                CandlesstickShape(
                    lineDataEntry: lineDataEntry,
                    heightRatio: heightRatio,
                    heightOffset: heightOffset
                )
                .fill(lineDataEntry.getColor())
                .stroke(
                    lineDataEntry.getColor(),
                    lineWidth: 1
                )
                .frame(
                    width: lineItemWidth,
                    height: scrollAreaHeight
                )
                .scaleEffect(x:1,y:-1)
                .id(lineDataEntry.id)
            }
        }
        .scrollTargetLayout()
        .overlay(   //X 轴
            VStack {
                Spacer()
                XAxisLine()
                    .stroke(
                        .gray,
                        lineWidth: 1
                    )
                    .frame(width: scrollAreaWidth, height: 2)
            }
        )
        .frame( //动态设置scollview的宽度
            width: scrollAreaWidth,
            height: scrollAreaHeight
        )
        .onAppear {
            //首次，加载数据，滚动到最后
            loadLineDataNetwork(beforeSuccessComplate: {
                if dataset.count >= viewKLineItemCount {
                    print("第一次加载数据完毕，scrollTo x-\(scrollAreaWidth)")
                    print("scrollOffset:\(String(describing: scrollViewOffset)), position\(String(describing: scrollPosition))")
                    
                    position.scrollTo(x: scrollAreaWidth)
                    updateHeightRatioAndOffset(windowStart: 0)
                    
                    print("滑动完毕")
                    print("scrollOffset:\(String(describing: scrollViewOffset)), position\(String(describing: scrollPosition))")
                }
                
            })
        }
    }
    
    /**
     K线滚动区域，添加了x，y轴
     */
    @ViewBuilder
    var kLineScrollArea: some View {
        HStack {
            // 绘制可滚动的k线展示区域以及x轴
            ScrollView(.horizontal) {
                dynamicChartPrinter 
            }
            .scrollPosition($position)
            .onScrollGeometryChange( // 更新实偏移
                for: CGFloat.self,
                of: { geo in geo.contentOffset.x},
                action:{ old, new in
                    print(new)
                    self.scrollViewOffset = new
                }
            )
            .onChange(of: scrollViewOffset) { old, new in
                guard let new else { return }

                if !new.isPositionedByUser {  // 调用position.scrollTo() 引起的偏移不调用whenOffsetChange
                    print("系统引起的偏移，from\(old), to\(new)")
                    return
                }
                
                var newOffset = new
                if newOffset < 0 {
                    newOffset = 0
                }
                if newOffset > scrollAreaWidth {
                    newOffset = scrollAreaWidth
                }
                print("用户滚动偏移：\(new.formatted())")

                whenOffsetChange(newOffset: newOffset)
           }
            .digitalCrownRotation( //表冠滚动
                $crownValue,
                from: 0.0,
                through: Double(dataset.count),
                by: 1.0,
                sensitivity: .low,
                isContinuous: false,
                isHapticFeedbackEnabled: true
            )
            .onChange(of: crownValue){ newValue in
                
                let index:Int = dataset.count - Int(newValue)
                let scrollX:Double = Double(index) * lineItemWidth - windowWidth + lineItemWidth/2
                position.scrollTo(x: scrollX)
                print("表冠滚动 \(newValue), index:\(index), scrollX:\(scrollX)")
            }
            .focusable(true)
            .onChange(of: dataset.kLineInterval) { new in //监听k线种类的改变，手动刷新
                
                loadLineDataNetwork(beforeSuccessComplate: {
                    if dataset.count >= viewKLineItemCount {
                        print("K线类型改变，加载数据完毕。scrollTo x-\(scrollAreaWidth)")
                        print("scrollOffset:\(String(describing: scrollViewOffset)), position\(String(describing: scrollPosition))")
                        
                        position.scrollTo(x: scrollAreaWidth)
                        updateHeightRatioAndOffset(windowStart: 0)
                        
                        print("scrollOffset:\(String(describing: scrollViewOffset)), position\(String(describing: scrollPosition))")
                    }    
                })
            }
        }
        .overlay (  // Y轴
            HStack {
                Spacer()
                //Y轴线
                YAxisLine(
                    windowHeight: windowHeight,
                    windowWidth: windowWidth,
                    heightRatio: heightRatio,
                    heightOffset: heightOffset,
                    scaleNumber: 3
                )
                .stroke(
                    .gray,
                    lineWidth: 1
                )
                .frame(
                    width: windowWidth,
                    height: windowHeight
                )
            }
        )
        .gesture ( //手势按压
            LongPressGesture(minimumDuration: 3)
                .onChanged { value in
                    self.isLineItemLongPress = !self.isLineItemLongPress
                }
                .simultaneously(
                    with:DragGesture(minimumDistance: 0)
                        .onChanged({ value in
                            selectedPosition = value.location
                            
                            print("按压，坐标（x:\(selectedPosition!.x),y:\(selectedPosition!.y)） scrollOffset:\(scrollViewOffset) windowWidth:\(windowWidth)")
                        })
                )
        )
    }
    
    
    /**
     offset更改的回调
     */
    func whenOffsetChange(newOffset: Double) {
        //实时更新偏移量
        print("new scroll offset \(newOffset)")
        
        //剩余没展示的点不足以覆盖整个窗口，再次尝试请求数据，需要再获取k线数据
        if dataset.count >= viewKLineItemCount ,
           newOffset < (Double(viewKLineItemCount) * lineItemWidth) ,
           !isLoadingKLineData {
            
            isLoadingKLineData = true
            
            let oldOffset = newOffset
            let oldCount = dataset.count
            
            //网络请求更新数据
            loadLineDataNetwork(beforeSuccessComplate: {
                position.scrollTo(point: CGPoint(x: Double(dataset.count - oldCount)*lineItemWidth + oldOffset , y: 0))
            })
        }
        
        
        updateHeightRatioAndOffset(windowStart: Int(newOffset/lineItemWidth))
    }
    
    /**
     网络请求加载数据，并处理相应的状态
     */
    func loadLineDataNetwork(beforeSuccessComplate:(()->Void)?) {
        print("开始价值k显示数据")
        dataset.loadLineData { res in
            switch res {
            case false: // load k线数据失败
                print("Load K 线数据失败")
            case true: // 成功
                
                
                print("load k 线数据完成 \n \(dataset.count)")
                //根据K线数据个数，滚动到相应位置
                scrollAreaWidth = Double(dataset.count) * lineItemWidth
                
                print("视图状态已更新， scrollAreaWidth \(scrollAreaWidth)")
                
                beforeSuccessComplate?()
                isLoadingKLineData = false
            }
        }
    }
    
    /**
        更新高度比和偏移量
     */
    func updateHeightRatioAndOffset(windowStart: Int) {
        //移动后要计算最大值和最小值
        print("更新前 maxprice \(dataset.maxPrice), minprice \(dataset.minPrice),heightRatio \(heightRatio), heightOffset \(heightOffset)")
        dataset.calMaxMinPriceOfWindow(start: windowStart)
        heightRatio = windowHeight / (dataset.maxPrice - dataset.minPrice)
        heightOffset = dataset.minPrice * heightRatio
        
        print("更新完毕 maxprice \(dataset.maxPrice), minprice \(dataset.minPrice),heightRatio \(heightRatio), heightOffset \(heightOffset)")
    }
}




#Preview {
    //       let lineDataEntry = LineDataEntry(openTime: Date(), closeTime: Date(), open: 100, close: 120, high: 131, low: 98, volume: 1000)
    
    KLineChart(symbol: "BTCUSDT", kLineInterval: .M_1)
    //        .frame(width: 120, height: 120)
}


//
//  LineDataset.swift
//  CoinWatch
//
//  Created by 何磊 on 2024/9/25.
//

import Foundation
import SwiftUI
import SwiftyJSON

/**
 线的数据集
 */
@Observable
class LineDataset {
    
    /**
     币种名称，如 BTCUSDT
     */
    var symbol: String

    /**
        上一次网络请求时的k线频率
    */
    var lastKLineInterval: KLineInterval
    
    /**
        k线频率
    **/
    var kLineInterval: KLineInterval
    
    /**
        具体的数据
    */
    var dataset: [LineDataEntry]


    /**
        数据集是否加载完毕
    */
    var isEndOfDataset:Bool = false


    /**
        当前显示窗口的起始位置的下标
    */
    var windowStartIndex: Int

    /**
        窗口长度
    */  
    var windowLength: Int

    init(
        symbol: String,
        kLineInterval: KLineInterval,
        dataset: [LineDataEntry],
        windowStartIndex: Int,
        windowLength: Int
    ) {
        self.symbol = symbol
        self.kLineInterval = kLineInterval
        self.lastKLineInterval = kLineInterval
        self.dataset = dataset
    
        self.windowStartIndex = windowStartIndex
        self.windowLength = windowLength
    }
    
    var count: Int = 0
    
    /**
     最高价格
     */
    var maxPrice: Double = 0
    
    /**
     最低价格
     */
    var minPrice: Double = 0
    
    /**
        下一次加载数据时的startTIme
    */
    var startTime:Date = Date()
    
    


    /**
        刷新最新的k线数据，也就是dataset数组里的最后一个的数据
    */
    func refreshNewLineData() -> Void {
        if dataset.isEmpty {
            print("刷新k线数据失败，当前数据集为null")
            return
        }
        let startTime: Date = dataset.last.opentTime

        loadLineData(
            startTime: startTime, 
            limit: 1, 
            actionOfNewData:{ newData in
                if newData.isEmpty {
                    print("最新的k线数据为null，startTime:\(startTime), kLineInterval:\(kLineInterval)")
                    return
                }
                if dataset.isEmpty {
                    print("数据集信息为null,")
                    return
                }
                

                dataset[dataset.count - 1] = newData[0]
            },
            whenComplate: { res in

            }
        )
    }

    /**
     加载数据
     */
    func loadLineData(whenComplate: @escaping (Bool) -> Void) {
        loadLineData(
            startTime: getStartTime(endTime: startTime), 
            limit: onceLoadLineDataCountLimit,
            actionOfNewData: { newData in
                self.dataset.append(contentsOf: newData)
            }
            whenComplate: whenComplate)
    }


    /**
     加载数据
     */
    func loadLineData(
        startTime: Date, 
        limit: Int, 
        actionOfNewData: @escaping (JSON) -> Void,
        whenComplate: @escaping (Bool) -> Void
    ) {
        //判断是否是重新获取k线数据，还是继续加k线数据
        let reload = lastKLineInterval != kLineInterval

        //更新上次请求的k线频率
        lastKLineInterval = kLineInterval

        //不是重新加载数，并且标识已经完成，直接返回false
        if !reload, isEndOfDataset {
            whenComplate(false)
        }


        print("开始获取k线数据, reload(\(reload)) 当前\(self.dataset.count)条")
        BinanceApi.spotApi.kLineData(
            symbol: symbol,
            interval: kLineInterval,
            startTime: startTime,
            limit: limit,
            successCall: { data in
                //更新dataset
                let newData = self.generalJSONToLineDataEntryArray(data: data).sorted(by:{$0.openTime > $1.openTime})
                if newData.count == 0 {
                    self.isEndOfDataset = true
                }

                if reload { //是重新加载，清除之前所有的
                    self.dataset.removeAll()
                }

                actionOfNewData(newData)                

                //更新count，max，min等
                self.count = self.dataset.count

                if self.count != 0 {
                    //更新startTime
                    self.startTime = self.getStartTime(endTime: self.startTime)
                }

                print("获取k线数据完成共： \(self.dataset.count) - \(self.count) 条")
                print("maxprice： \(self.maxPrice) - minprice \(self.minPrice)")
                whenComplate(true)
            },
            failureCall: { error in
                whenComplate(false)
            }
        )
    }

    func generalJSONToLineDataEntryArray(data: JSON) -> [LineDataEntry] {
        print("解析k线数据")
        var res:[LineDataEntry] = []
        // 遍历 JSON 数组
        if let jsonArray = data.array {
            res = jsonArray.map { json in
                let openTime = json[0].int64Value
                let open = json[1].doubleValue
                let high = json[2].doubleValue
                let low = json[3].doubleValue
                let close = json[4].doubleValue
                let volume = json[5].doubleValue
                let closeTime = json[6].int64Value
                
                
                return LineDataEntry(
                    openTime: Date(timeIntervalSince1970:  TimeInterval(openTime/1000)),
                    closeTime: Date(timeIntervalSince1970:  TimeInterval(closeTime/1000)),
                    open: open,
                    close: close,
                    high: high,
                    low: low
                )
            }
        }
        print("解析k线数据success\n")
        return res
    }

    /**
        根据爽口计算最大价格和最小价格
    */
    func calMaxMinPriceOfWindow(start: Int) {
        calMaxMinPriceOfWindow(start: start, end: start + windowLength - 1)
    }

    func calMaxMinPriceOfWindow(start: Int, end: Int) {
        print("计算最小值和最大值 from-\(start) to-\(end)")
        if self.dataset.isEmpty || start < 0 || end >= dataset.count{
            print("数据为不合法，无法计算最值")
            return
        }
        var minV:Double = self.dataset[0].low
        var maxV:Double = 0

        for i in (start...end) {
            minV = min(minV, dataset[i].low)
            maxV = max(maxV, dataset[i].high)
        }
        self.maxPrice = maxV
        self.minPrice = minV
        print("计算最小值和最大值完成 max\(maxV) min \(minV)")
    }
    
    
    
    func getStartTime(endTime:Date) -> Date{
        return DateUtil.calDate(from: endTime, days: -1 * 30, timeUnit: kLineInterval.rawValue.timeUnit) ?? Date()
    }

    func getIndex(_ index:Int) -> LineDataEntry? {
        
        if dataset.isEmpty || index >= dataset.count || index < 0 {
            return nil
        }

        return dataset[index]
    }

   /**
       计算均线
   */
   func calculateMA(maIntervals:[MAType] = [.ma_5]) -> Void{
       var intervalWindow: [Int:(interval:Int, windowLength:Int, windowTotal:Double)] = [:]
       for element in maIntervals {
            let interval = element.rawValue.interval
           intervalWindow[interval] = (interval, 0, 0)
       }
     

       var currentIdx = dataset.count - 1
       for entry in dataset {
           for (_, value) in intervalWindow {
               var (interval, windowLength, windowTotal) = value

               if windowLength < interval {
                   windowLength += 1
                   windowTotal += entry.close
               } else {
                   windowTotal = windowTotal - dataset[(currentIdx + windowLength - 1)].close + entry.close

                   let ma = windowTotal / Double(windowLength)
                   entry.addMA(maInterval: interval, value: ma)
               }
               
               currentIdx -= 1
           }
       }
   }
    
    
    /**
        计算Boll指标
    */
    func calculateBoll(
        maInterval:Int = 21, 
        n: Double = 2
    ) -> Void {
        for i in maInterval-1...dataset.count {
            let periodPrices = data[i-maInterval+1...i].map{$0.close}
            let sum = periodPrices.reduce(0, +)
            let average = sum / Double(maInterval)

            let variance = periodPrices.map {pow($0 - average, 2)}.reduce(0, +) / Double(maInterval)
            let standardDeviation = sqrt(variance)

            let upper = average + (n * standardDeviation)
            let lower = average - (n * standardDeviation)

            dataset[i].bollLine = (upper, average, lower)
        }
    }

}



//
//  LineDataEntry.swift
//  CoinWatch
//
//  Created by 何磊 on 2024/9/25.
//

import Foundation
import SwiftUI

/**
    一条线含的所有数据
*/
class LineDataEntry: Identifiable , Sendable{
    
    var id: UUID = UUID()

    /**
        开盘时间
    */
    let openTime: Date

    /**
        收盘时间
    */
    let closeTime: Date
    /**
        开盘价格
    */
    let open: Double

    /**
        收盘价格

    */
    let close: Double
    
    /**
        最高价格

    */
    let high: Double
    
    /**
        最低价格
    */
    let low: Double 


    /**
        量能
    */
    var volume: Double = 0.0
    
    /**
        MA指标
    */
    var dictOfMA: [Int:Double] = [:]

    /**
        Boll指标
    */
    var bollLine: (upper:Double, ma:Double, lower:Double) = (0, 0, 0)

    
    init (
        openTime: Date,
        closeTime: Date,
        open: Double,
        close: Double,
        high: Double,
        low: Double
    ) {
        self.openTime = openTime
        self.closeTime = closeTime
        self.open = open
        self.close = close
        self.high = high
        self.low = low
    }
    
    func addMA(maInterval:Int, value: Double) {
        dictOfMA[maInterval] = value
    }
    
    /**
        获取应该现实的颜色
    - Parameters:
    - Returns: Color k蜡烛的颜色
    */
    func getColor() -> Color {
        return close > open ? Color.green : Color.red
    }
}


extension Double {

    func coinPriceFormat() -> String {
        if self >= 1 || self <= -1 {
            return String(format: "%0.2f", self)
        } else {
            let formatter = NumberFormatter()
            formatter.minimumFractionDigits = 1
            formatter.maximumFractionDigits = 8
            formatter.numberStyle = .decimal

            return formatter.string(from: self as NSNumber) ?? String(self)
        }
    }
    
}



import Foundation
import SwiftUI


/**
   绘制均线图
*/
struct MALine: Shape {

   /**
       均线间隔
   */
   @Binding let maType: MAType

   /**
       数据
   */
   @Binding let lineDataEntryList: [lineDataEntry]

   /**
       高的比例
   */
   @Binding let heightRatio: Double

    /**
        高度的偏移
    */
   @Binding let heightOffset: Double

   /**
       单个k线数据的宽度
   */
   @Binding let entryWidth: Double


    @ViewBuilder
    var content: some View  {

       Path { path in
           if lineDataEntryList.isEmpty {
               return
           }
           let maInterval = maType.rawValue.interval
           let color = maType.rawValue.color

           //绘制不同间隔的MA
           var width:Double = entryWidth / 2
           
           //ma的线
           var lastPoint:CGPoint? = nil
           lineDataEntryList.forEach { dataEntry in

               if let ma = dataEntry.dictOfMA[maInterval] {
                    var y = ma * heightRatio - heightOffset
                    let currentPoint:CGPoint = CGPoint(x: width, y: y)

                    if let lastPoint = lastPoint {
                        path.move(to: lastPoint)
                    } else {
                        path.move(to: CGPoint(x: width, y: y))
                    }

                    path.addLine(to: currentPoint)

                    lastPoint = currentPoint
               }

               width += entryWidth
           }
       }
   }
}




import Foundation
import SwiftUI


/**
    绘制Boll线
*/
struct BollLine {


   /**
       数据
   */
   @Binding let lineDataEntryList: [lineDataEntry]

   /**
       高的比例
   */
   @Binding let heightRatio: Double

    /**
        高度的偏移
    */
   @Binding let heightOffset: Double

   /**
       单个k线数据的宽度
   */
   @Binding let entryWidth: Double


   @ViewBuilder
   var content: some View {

        if lineDataEntryList.isEmpty {
            return
        }

        var upperPath = Path()
        var averagePath = Path()
        var lowerPath = Path()

        var x = entryWidth / 2
        var lastUpper: CGPoint? = nil
        var lastAverage: CGPoint? = nil
        var lastLower: CGPoint? = nil


        lineDataEntryList.forEach( entry in
            if let bollLine = entry.bollLine {
                
                //上轨
                lastUpper = addLine(path: upperPath, lastPoint: lastUpper, x: x, price, bollLine.upper)
                
                //中轨
                lastAverage = addLine(path: averagePath, lastPoint: lastUpper, x: x, price, bollLine.average)

                //下轨
                lastLower = addLine(path: lowerPath, lastPoint: lastUpper, x: x, price, bollLine.lower)

            }
            x += entryWidth
        )

        upperPath.stroke(
            .orange,
            lineWidth: 1
        )
        averagePath.stroe(
            .pink,
            lineWidth: 1
        )
        lowerPath.stroke(
            .purpole,
            lineWidth: 1
        )
    }


    func addLine(path: Path, lastPoint:CGPoint?, x: Double, price: Double) -> CGPoint {
        var y = ma * heightRatio - heightOffset
        let currentPoint:CGPoint = CGPoint(x: width, y: y)

        if let lastPoint = lastPoint {
            path.move(to: lastPoint)
        } else {
            path.move(to: currentPoint)
        }

        path.addLine(to: currentPoint)

        return currentPoint
    }
}
