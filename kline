//
//  KLineChart.swift
//  CoinWatch
//
//  Created by 何磊 on 2024/9/25.
//

import Foundation
import SwiftUI



struct KLineChart: View {
    
    /**
     当前K线视图的宽度
     */
    @State private var windowWidth: Double = 0
    
    /**
     当前K线视图的高度
     */
    @State private var windowHeight: Double = 0
    

    /**
     当前选中的数据
     */
    @State private var selectedPosition:CGPoint? = .zero
    
    /**
     是否长按k线的某点
     */
    @GestureState private var isLineItemLongPress = false
    
    
    /**
     当前是否在加载k线数据
     */
    @State private var isLoadingKLineData: Bool = false
    
    /**
        滑动区域组件对象，，可以获取到当前的scrolloffset，当前滚动到的id，以及滑动到指定区域
    */
    private var stateScrollView: StateScrollView

    /**
     当前视图显示的K线线段的个数
     */
    let viewKLineItemCount:Int = 15
    
    /**
     k线元素之间的间距
     */
    let marginOfLineItem: Double = 0
    
        
    /**
     坐标轴线的宽度
     */
    let scaleWidth: Double = 2
    
    /**
     每个K线元素的宽度
     */
    @State var lineItemWidth: Double = 0
    
    /**
     滚动区域的宽度，也就是k线图展示的区域。窗口宽度减去轴线宽度
     */
    @State var scrollAreaWidth: Double = 0
    
    /**
     滚动区域的高度，也就是k线图展示的区域。窗口高度减去轴线宽度
     */
    @State var scrollAreaHeight: Double = 0
    
    /**
     组件item的高度比例，因为y轴是价格，所以表示单位价格的长度 height / (maxPrice - minPrice)
     */
    @State var heightRatio: Double = 1
    
    
    /**
     数据集
     */
    @State var dataset: LineDataset = LineDataset(
        symbol: "BTCUSDT",
        kLineInterval: .d_1,
        dataset: [],
        windowStartIndex: 0,
        windowLength: viewKLineItemCount
    )
    
    
    init(symbol: String, kLineInterval: KLineInterval) {
        self.dataset.symbol = symbol
        self.dataset.kLineInterval = kLineInterval
    }
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                
                //背景显示的字
                Text(dataset.symbol)
                    .font(.title)
                    .foregroundStyle(.white)

                //x线图
                kLineScrollArea
                    .frame(
                        maxWidth: .infinity, maxHeight: .infinity
                    )
                    .background(.gray.opacity(0.5))
                
                
                // 显示十字线以及按住的KLineItem的信息
                if isLineItemLongPress { //在长按
                    if selectedPosition != .zero {
                        longPressPrintView
                    }
                }
            }
            .frame(
                width: .infinity,
                height: .infinity
            )
            .onAppear{
                //设置K线视图宽度、高度
                windowWidth = geometry.size.width
                windowHeight = geometry.size.height
                lineItemWidth = windowWidth / Double(viewKLineItemCount) - marginOfLineItem
                scrollAreaWidth = windowWidth
                scrollAreaHeight = windowHeight
                
                isLoadingKLineData = true
                
                //heightRatio = windowHeight / (dataset.maxPrice - dataset.minPrice)
                
                print("window区域宽 \(windowWidth) 高 \(windowHeight)")
                print("滚动区域宽 \(scrollAreaWidth) 高 \(scrollAreaHeight)")
                print("单个k线宽度 \(lineItemWidth)")
                print("高度比 \(heightRatio)")
            }
        }
    }
    
    /**
     长按k线中的元素后展示的十字线和信息卡
     */
    @ViewBuilder
    var longPressPrintView: some View {
        
        // 十字线
        
        //获取相对于视图的x坐标
        let xPosition:CGFloat = selectedPosition!.x
        let yPosition:CGFloat = selectedPosition.y

        let index = dataset.count - Int((stateScrollView.scrollViewOffset + xPosition) / lineItemWidth) - 1
        let itemData = dataset.getIndex(index)
        
        Path { path in
            path.move(to: CGPoint(x: xPosition, y: 0))
            path.addLine(to: CGPoint(x: xPosition, y: scrollAreaHeight))

            path.move(to: CGPoint(x: 0, y: yPosition))
            path.addLine(to: CGPoint(x: windowWidth, y: yPosition))            
        }
        .stroke(
            .gray,
            lineWidth: 1
        )
        
        //信息卡片
        
        //显示在坐标还是右边
        let showOnLeft:Bool = xPosition > windowWidth / 2
        HStack {
            if showOnLeft == false {
                Spacer()
            }
            
            VStack {
                Text("时间")
                Text("开")
                Text("高")
                Text("低")
                Text("收")
            }
            
            VStack{
                Text(DateUtil.dateToStr(date: itemData.openTime))
                Text(itemData.open.coinPriceFormat())
                Text(itemData.high.coinPriceFormat())
                Text(itemData.low.coinPriceFormat())
                Text(itemData.close.coinPriceFormat())
            }
            
            
            if showOnLeft {
                Spacer()
            }
        }
        .padding(10)
        .font(.littleFont())
        .background(Color.black.opacity(0.5))
        .foregroundStyle(.white)
        .clipShape(
            RoundedRectangle(cornerRadius: 10)
        )
    }

    /**
        offset更改的回调
    */
    func whenOffsetChange(currentOffset:Double, positionId:Int?) {
        //实时更新偏移量
        print("scroll offset \(currentOffset)")

        //剩余没展示的点不足以覆盖整个窗口，再次尝试请求数据，需要再获取k线数据
        if dataset.count >= viewKLineItemCount , positionId < viewKLineItemCount , !isLoadingKLineData {
            isLoadingKLineData = true

            let oldIndex = stateScrollView.currentPositionId
            let oldCount = dataset.count
            
            //网络请求更新数据
            loadLineDataNetwork(beforeSuccessComplate: {
                stateScrollView.position.scrollTo(id: dataset.count - oldCount + oldIndex, anchor: .left)
            })
        }

        //移动后要计算最大值和最小值
        dataset.calMaxMinPriceOfWindow(start: positionId)
    }

    /**
        网络请求加载数据，并处理相应的状态
    */
    func loadLineDataNetwork(beforeSuccessComplate:(()->Void)?) {
        print("开始价值k显示数据")
        dataset.loadLineData { res in
            switch res {
            case false: // load k线数据失败
                print("Load K 线数据失败")
            case true: // 成功
                heightRatio = windowHeight / (dataset.maxPrice - dataset.minPrice)
            
                print("load k 线数据完成 \n \(dataset.count)")
                //根据K线数据个数，滚动到相应位置
                scrollAreaWidth = Double(dataset.count) * lineItemWidth
                
                print("视图状态已更新， heightRatio\(heightRatio), scrollAreaWidth \(scrollAreaWidth)")
                
                beforeSuccessComplate?()
                isLoadingKLineData = false
            }
        }
    }
    

    /**
     K线滚动区域，添加了x，y轴
     */
    @ViewBuilder
    var kLineScrollArea: some View {
        HStack {
            // 绘制可滚动的k线展示区域以及x轴
                StateScrollView(
                    aligenment: .horizontal, 
                    positionInit: {position in 
                        scrollPosition = position
                    }
                    whenOffsetChange: whenOffsetChange
                ){
                    HStack(spacing: 0){
                        // 绘制每一根蜡烛
                        if dataset.count > 0 {
                            var id = 0
                            ForEach(dataset.dataset.reversed()) { lineDataEntry in
                                CandlesstickShape(
                                    lineDataEntry: lineDataEntry,
                                    heightRatio: heightRatio,
                                    heightOffset: dataset.minPrice * heightRatio
                                )
                                .fill(lineDataEntry.getColor())
                                .stroke(
                                    lineDataEntry.getColor(),
                                    lineWidth: 1
                                )
                                .frame(
                                    width: lineItemWidth,
                                    height: scrollAreaHeight
                                )
                                .scaleEffect(x:1,y:-1)
                                .id(id) //用于StateScrollView
                            }
                        }
                    }
                    .overlay(   //X 轴
                        VStack {
                            Spacer()
                            XAxisLine()
                                .stroke(
                                    .gray,
                                    lineWidth: 1
                                )
                                .frame(width: scrollAreaWidth, height: 2)
                        }
                    )
                    .frame( //动态设置scollview的宽度
                        width: scrollAreaWidth,
                        height: scrollAreaHeight
                    )
                    .onAppear {
                        //首次，加载数据，滚动到最后
                        loadLineDataNetwork(beforeSuccessComplate: {
                            if dataset.count >= viewKLineItemCount {
                                StateScrollView.position.scrollTo(id: dataset.count - 1, anchor: .left)
                            }
                        }) 
                    }   
                    .gesture (
                        LongPressGesture(minimumDuration: 1)
                            .updating($isLineItemLongPress){ currentState, gestureState, transaction in
                                gestureState = currentState
                            }
                            .simultaneously(
                                with:DragGesture(minimumDistance: 0)
                                    .onChanged({ value in
                                        selectedPosition = value.location
                                    })
                            )
                    )
                }
        }
        .overlay (  // Y轴
            HStack {
                Spacer()
                //Y轴线
                YAxisLine(
                    height: windowHeight,
                    max: dataset.maxPrice,
                    min: dataset.minPrice,
                    scaleNumber: 3
                )
                .stroke(
                    .gray,
                    lineWidth: 1
                )
                .frame(
                    width: scaleWidth,
                    height: windowHeight
                )
            }
        )
    }
}


/**
 一根蜡烛的形状
 */
struct CandlesstickShape: Shape  {
    
    /**
     一根k线图的数据
     */
    let lineDataEntry: LineDataEntry
    
    /**
     高的比例，所有与高有关的数据都要乘
     */
    let heightRatio: Double
    
    let heightOffset: Double
    
    func path(in rect: CGRect) -> Path {
        let itemWidth = rect.width
        return Path { path in
            
            //绘制上下影线s
            path.move(to: CGPoint(x: itemWidth / 2, y: lineDataEntry.high * heightRatio - heightOffset))
            path.addLine(to: CGPoint(x: itemWidth / 2, y: lineDataEntry.low * heightRatio - heightOffset))
            
            //绘制实体部分 (矩形)
            if lineDataEntry.open < lineDataEntry.close { //涨
                let rect = CGRect (
                    x: (itemWidth / 2) - (itemWidth / 4),
                    y: lineDataEntry.open * heightRatio - heightOffset,
                    width: itemWidth / 2,
                    height:  CGFloat(abs(lineDataEntry.open - lineDataEntry.close) * heightRatio)
                )
                path.addRect(rect)
            } else {
                let rect = CGRect (
                    x: (itemWidth / 2) - (itemWidth / 4),
                    y: lineDataEntry.close * heightRatio - heightOffset,
                    width: itemWidth / 2,
                    height:  CGFloat(abs(lineDataEntry.open - lineDataEntry.close) * heightRatio)
                )
                path.addRect(rect)
            }
            
            
        }
    }
}

/**
 Y轴线
 */
struct YAxisLine: Shape {
    
    /**
     轴线高度
     */
    let height: CGFloat
    
    /**
     最大值
     */
    let max: CGFloat
    
    /**
     最小值
     */
    let min: CGFloat
    
    /**
     刻度数
     */
    let scaleNumber:Int
    
    func path(in rect: CGRect) -> Path {
        Path { path in
            let width:CGFloat = rect.width
            
            let heightPrice:Double = (max - min) / height
            
            //画轴线
            path.move(to: CGPoint(x: width / 2, y: height))
            path.addLine(to: CGPoint(x: width / 2, y: 0))
            
            //画刻度
            let interval:CGFloat = height / Double(scaleNumber)
            
            let numbers: [Int] = Array(0...scaleNumber)
            numbers.forEach { i in
                let height:CGFloat = Double(i) * interval
                
                let printPrice = height * heightPrice
                
                //刻度线
                path.move(to: CGPoint(x: 0, y:height))
                path.addLine(to: CGPoint(x: width, y:height))
                
                
                Text(String(printPrice))
                    .font(.footnote)
                    .position(x: 0, y: height)
            }
        
        }
        
    }
}

/**
    X轴线
*/
struct XAxisLine: Shape {
    func path(in rect: CGRect) -> Path {
        let height = rect.height
        let width = rect.width
        var path = Path()
        //画轴线
        path.move(to: CGPoint(x: 0, y: height))
        path.addLine(to: CGPoint(x: width, y: height))

        //画刻度
//        let interval:CGFloat = height / Double(scaleNumber)
        
        return path
    }
}


#Preview {
//       let lineDataEntry = LineDataEntry(openTime: Date(), closeTime: Date(), open: 100, close: 120, high: 131, low: 98, volume: 1000)
    
    KLineChart(symbol: "BTCUSDT", kLineInterval: .d_1)
    //        .frame(width: 120, height: 120)
}




//
//  LineDataset.swift
//  CoinWatch
//
//  Created by 何磊 on 2024/9/25.
//

import Foundation
import SwiftUI
import SwiftyJSON

/**
 线的数据集
 */
@Observable
class LineDataset {
    
    /**
     币种名称，如 BTCUSDT
     */
    var symbol: String
    
    /**
        k线频率
    **/
    var kLineInterval: KLineInterval
    
    /**
        具体的数据
    */
    var dataset: [LineDataEntry]
    
    /**
        当前显示窗口的起始位置的下标
    */
    var windowStartIndex: Int

    /**
        窗口长度
    */
    var windowLength: Int

    init(
        symbol: String, 
        kLineInterval: KLineInterval, 
        dataset: [LineDataEntry],
        windowStartIndex: Int,
        windowLength: Int
    ) {
        self.symbol = symbol
        self.kLineInterval = kLineInterval
        self.dataset = dataset
    
        self.windowStartIndex = windowStartIndex
        self.windowLength = windowLength
    }
    
    var count: Int = 0
    
    /**
     最高价格
     */
    var maxPrice: Double = 0
    
    /**
     最低价格
     */
    var minPrice: Double = 0
    
    /**
        下一次加载数据时的startTIme
    */
    var startTime:Date = Date()
    
    
    

    func getStartTime(endTime:Date) -> Date{
        return DateUtil.calDate(from: endTime, days: -1 * 30, timeUnit: kLineInterval.rawValue.timeUnit) ?? Date()
    }

    func getIndex(_ index:Int) -> LineDataEntry {
        return dataset[index]
    }
    /**
     加载数据
     */
    func loadLineData(whenComplate: @escaping (Bool) -> Void) {
        print("开始获取k线数据, 当前\(self.dataset.count)条")
        BinanceApi.spotApi.kLineData(
            symbol: symbol,
            interval: kLineInterval,
            startTime: getStartTime(endTime: startTime),
            limit: 30,
            successCall: { data in
                //更新dataset
                
                let newData = self.generalJSONToLineDataEntryArray(data: data).sorted(by:{$0.openTime > $1.openTime})
                
                self.dataset.append(contentsOf: newData)
                
                //更新count，max，min等
                self.count = self.dataset.count

                if self.count != 0 {
                    //更新startTime
                    self.startTime = self.getStartTime(endTime: self.startTime)
                }

                print("获取k线数据完成共： \(self.dataset.count) - \(self.count) 条")
                print("maxprice： \(self.maxPrice) - minprice \(self.minPrice)")
                whenComplate(true)
            },
            failureCall: { error in
                whenComplate(false)
            }
        )
    }

    func generalJSONToLineDataEntryArray(data: JSON) -> [LineDataEntry] {
        print("解析k线数据")
        var res:[LineDataEntry] = []
        // 遍历 JSON 数组
        if let jsonArray = data.array {
            res = jsonArray.map { json in
                let openTime = json[0].int64Value
                let open = json[1].doubleValue
                let high = json[2].doubleValue
                let low = json[3].doubleValue
                let close = json[4].doubleValue
                let volume = json[5].doubleValue
                let closeTime = json[6].int64Value
                
                
                return LineDataEntry(
                    openTime: Date(timeIntervalSince1970:  TimeInterval(openTime/1000)),
                    closeTime: Date(timeIntervalSince1970:  TimeInterval(closeTime/1000)),
                    open: open,
                    close: close,
                    high: high,
                    low: low
                )
            }
        }
        print("解析k线数据success\n")
        return res
    }

    /**
        根据爽口计算最大价格和最小价格
    */
    func calMaxMinPriceOfWindow(start: Int) {
        calMaxMinPriceOfWindow(start: start, end: start + windowLength - 1)
    }

    func calMaxMinPriceOfWindow(start: Int, end: Int) {
        var minV:Double = self.dataset[0].low
        var maxV:Double = 0

        for entry in (start...end) {
            minV = min(minV, entry.low)
            maxV = max(maxV, entry.high)
        }
        self.maxPrice = maxV
        self.minPrice = minV
    }
    
}






import Foundation



struct StateScrollView: View {

    /**
     K线视图的Position， 可用于滚动到指定位置
     */
    @State var position:ScrollPosition = ScrollPosition(edge: .left)

    @State var scrollViewOffset:Double?
    
    @State var currentPositionId: Int?

    /**
        滚动区域的方向
    */
    var aligenment:Axis.vertical = .horizontal

    var init: ((stateScrollView: StateScrollView) -> Void)?

    /**
        实时滚动回调
    */
    var whenOffsetChange: ((offset:CGFloat) -> Void)?

    /**
        scroll的内容
    */
    @ViewBuilder var content: () -> Content 

    var body: some View {
        ScrollView(aligenment) {
            content
        }
        .onAppear(
            positionInit?(stateScrollView: self)
        )
        .scrollPosition(id: $currentPositionId)
        .scrollPosition(position)
        .onChange(of: position) { old, new in
            currentPositionId = new.viewId as? Int
        }
        .onScrollGeometryChange(
            for: CGFloat.self, 
            of: { geo in geo.contentOffset.y}, 
            action:{ old, new in
                scrollViewOffset = new
            }
        )
        .onChange(of: scrollViewOffset) { _, new in
            guard let new else {return}
            whenOffsetChange?(offset: new.formatted(), positionId: currentPositionId)        
        }
    }
}

