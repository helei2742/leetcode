package com.helei.tradesignalcenter.config;

import com.helei.constants.TradeType;
import com.helei.tradesignalcenter.constants.RunEnv;
import lombok.Data;
import org.yaml.snakeyaml.Yaml;

import java.io.InputStream;
import java.io.Serializable;
import java.util.Map;

@Data
public class TradeSignalConfig implements Serializable {
    private static final String CONFIG_FILE = "trade-signal-config.yaml";

    public static final TradeSignalConfig TRADE_SIGNAL_CONFIG;

    /**
     * 信号名
     */
    private String name;

    /**
     * 信号交易对
     */
    private String symbol;

    /**
     * 运行环境，测试网或者普通网
     */
    private RunEnv run_env;

    /**
     * 交易类型
     */
    private TradeType trade_type;

    /**
     * 历史k线加载批大小
     */
    private int historyKLineBatchSize;

    /**
     * 批加载并发度
     */
    private int batchLoadConcurrent;

    /**
     * 实时数据配置
     */
    private RealtimeConfig realtime;

    static {
        Yaml yaml = new Yaml();
        try (InputStream inputStream = TradeSignalConfig.class.getClassLoader().getResourceAsStream(CONFIG_FILE)) {
            if (inputStream == null) {
                throw new IllegalArgumentException("File not found: " + CONFIG_FILE);
            }
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> shinano = (Map<String, Object>) yamlData.get("shinano");
            Map<String, Object> quantity = (Map<String, Object>) shinano.get("quantity");
            Map<String, Object> trade_signal_maker = (Map<String, Object>) quantity.get("trade_signal_maker");


            TRADE_SIGNAL_CONFIG = yaml.loadAs(yaml.dump(trade_signal_maker), TradeSignalConfig.class);

        } catch (Exception e) {
            throw new RuntimeException("Failed to load YAML file: " + CONFIG_FILE, e);
        }
    }

    private TradeSignalConfig() {}
    
    public String getSinkTopic() {
        return run_env.name() + "." + trade_type + "." + symbol + "." + name;
    }


    @Data
    public static class RealtimeConfig  implements Serializable  {

        private RealtimeKafkaConfig kafka;

        private RealtimeFlinkConfig flink;

    }


    @Data
    public static class RealtimeKafkaConfig  implements Serializable  {
        /**
         * kafka集群连接地址
         */
        private String bootstrapServer;

        /**
         * 消费者组名
         */
        private String groupId;
    }

    @Data
    public static class RealtimeFlinkConfig  implements Serializable  {

        /**
         * flink job manager host
         */
        private String jobManagerHost;
        /**
         * flink job manager port
         */
        private Integer jobManagerPort;
    }

    public static void main(String[] args) {
        System.out.println(TRADE_SIGNAL_CONFIG);
    }
}

package com.helei.tradesignalcenter.support;


import com.helei.constants.KLineInterval;
import com.helei.constants.TradeSide;
import com.helei.tradesignalcenter.config.FlinkConfig;
import com.helei.tradesignalcenter.resolvestream.*;
import com.helei.tradesignalcenter.resolvestream.a_datasource.RandomKLineSource;
import com.helei.tradesignalcenter.dto.OriginOrder;
import com.helei.dto.KLine;
import com.helei.dto.TradeSignal;
import com.helei.tradesignalcenter.resolvestream.c_signal.TradeSignalService;
import com.helei.tradesignalcenter.resolvestream.d_decision.DecisionMakerService;
import com.helei.tradesignalcenter.resolvestream.d_decision.maker.AbstractDecisionMaker;
import com.helei.dto.indicator.Indicator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.BollCalculator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.MACDCalculator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.PSTCalculator;
import com.helei.dto.indicator.config.BollConfig;
import com.helei.dto.indicator.config.IndicatorConfig;
import com.helei.dto.indicator.config.MACDConfig;
import com.helei.dto.indicator.config.PSTConfig;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.AbstractSignalMaker;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.BollSignalMaker;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.PSTSignalMaker;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.streaming.api.TimerService;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import java.util.concurrent.TimeUnit;

public class RandomKLineSourceTest {
    private static final Logger log = LoggerFactory.getLogger(RandomKLineSourceTest.class);
    private static String btcusdt = "btcusdt";

    private static String ethusdt = "ethusdt";

    private static StreamExecutionEnvironment env;

    private static StreamExecutionEnvironment env2;


    private static RandomKLineSource randomKLineSource;


    @BeforeAll
    public static void before() {
        try {
            env = FlinkConfig.streamExecutionEnvironment();
            randomKLineSource = new RandomKLineSource(btcusdt, Set.of(KLineInterval.m_1),
                    LocalDateTime.of(2022, 10, 27, 22, 0), 2000.0, 19000.0);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testRandomKLineSource() throws Exception {
        DataStreamSource<KLine> streamSource = env.addSource(randomKLineSource);

        streamSource.print();

        env.execute();
        TimeUnit.MINUTES.sleep(1000);
    }

    @Test
    public void testAutoTradeV2() throws Exception {
        PSTConfig pstConfig = new PSTConfig(60, 3, 3);
        BollConfig bollConfig = new BollConfig(15);


        TradeSignalService tradeSignalService = buildTradeSignalService(pstConfig, bollConfig);
        DecisionMakerService decisionMakerService = new DecisionMakerService(new AbstractDecisionMaker("测试用决策生成器") {
            @Override
            protected OriginOrder decisionAndBuilderOrder(String symbol, List<TradeSignal> windowSignal, HashMap<IndicatorConfig<? extends Indicator>, Indicator> indicatorMap) {
                log.info("收到信号【{}】\n{}", symbol, windowSignal);
                return OriginOrder
                        .builder()
                        .symbol(symbol)
                        .tradeSide(TradeSide.BUY)
//                        .targetPrice(BigDecimal.valueOf(windowSignal.getFirst().getTargetPrice()))
//                        .stopPrice(BigDecimal.valueOf(windowSignal.getFirst().getStopPrice()))
                        .build();
            }
        });

        AutoTradeTask autoTradeTask = new AutoTradeTask(tradeSignalService, decisionMakerService, null);
        autoTradeTask.execute("test");
    }

    private TradeSignalService buildTradeSignalService(PSTConfig pstConfig, BollConfig bollConfig) {
        return TradeSignalService
                .builder(env)
                .buildResolver()
                .setWindowLengthRationOfKLine(1.0 / 60)
                .addKLineSource(randomKLineSource)
                .addIndicator(new PSTCalculator(pstConfig))
                .addIndicator(new MACDCalculator(new MACDConfig(12, 26, 9)))
                .addIndicator(new BollCalculator(bollConfig))
                .addSignalMaker(new BollSignalMaker(bollConfig))
                .addSignalMaker(new PSTSignalMaker(pstConfig))
                .addSignalMaker(new AbstractSignalMaker(true) {

                    @Override
                    public void onOpen(OpenContext openContext) throws Exception {

                    }

                    @Override
                    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws Exception {
                        System.out.println(Instant.ofEpochMilli(kLine.getOpenTime()) + " - " + kLine.getIndicators());
                        return null;
                    }

                    @Override
                    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws Exception {
                        return null;
                    }
                })
//                .addSignalMaker(new AbstractSignalMaker(true) {
//                    private Random random = new Random();
//
//                    @Override
//                    public void onOpen(OpenContext openContext) throws Exception {
//
//                    }
//
//                    @Override
//                    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws Exception {
//                        if (random.nextBoolean()) {
//                            return null;
//                        }
//                        return TradeSignal.builder().description("这是一条测试信号1h").name("测试信号1h").tradeSide(TradeSide.BUY).build();
//                    }
//
//                    @Override
//                    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws Exception {
//                        if (random.nextBoolean()) {
//                            return null;
//                        }
//
//                        return TradeSignal.builder().description("这是一条测试信号1h").name("测试信号1h").tradeSide(TradeSide.BUY).build();
//                    }
//                })
                .addInService()
                .build();
    }

}
package com.helei.tradesignalcenter.resolvestream.e_order;

import com.helei.tradesignalcenter.config.TradeSignalConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.connector.sink2.Sink;

/**
 * 订单提交服务
 */
@Slf4j
public abstract class AbstractOrderCommitter<T> {

    protected TradeSignalConfig tradeSignalConfig;


    public AbstractOrderCommitter() {
        tradeSignalConfig = TradeSignalConfig.TRADE_SIGNAL_CONFIG;
    }


    public abstract Sink<T> getCommitSink();
}

package com.helei.tradesignalcenter.resolvestream.e_order;

import com.helei.tradesignalcenter.dto.OriginOrder;
import com.helei.util.Serializer;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.serialization.SerializationSchema;
import org.apache.flink.api.connector.sink2.Sink;
import org.apache.flink.connector.base.DeliveryGuarantee;
import org.apache.flink.connector.kafka.sink.KafkaRecordSerializationSchema;
import org.apache.flink.connector.kafka.sink.KafkaSink;


@Slf4j
public class KafkaOriginOrderCommitter extends AbstractOrderCommitter<OriginOrder>{


    @Override
    public Sink<OriginOrder> getCommitSink() {
        String bootstrap = tradeSignalConfig.getRealtime().getKafka().getBootstrapServer();
        String topic = tradeSignalConfig.getSinkTopic();

        log.info("创建 原始订单 Kafka Sink [{}] - topic [{}]", bootstrap, topic);

        return KafkaSink.<OriginOrder>builder()
                .setBootstrapServers(bootstrap)
                .setRecordSerializer(
                        KafkaRecordSerializationSchema
                                .builder()
                                .setTopic(topic)
                                .setValueSerializationSchema(new KafkaOriginOrderSchema())
                                .build()
                )
                .setDeliveryGuarantee(DeliveryGuarantee.EXACTLY_ONCE).build();
    }


    static class KafkaOriginOrderSchema implements SerializationSchema<OriginOrder> {
        @Override
        public byte[] serialize(OriginOrder originOrder) {
            return Serializer.Algorithm.Protostuff.serialize(originOrder);
        }
    }
}


package com.helei.tradesignalcenter.resolvestream;

import com.helei.tradesignalcenter.dto.OriginOrder;
import com.helei.dto.KLine;
import com.helei.dto.TradeSignal;
import com.helei.tradesignalcenter.resolvestream.c_signal.TradeSignalService;
import com.helei.tradesignalcenter.resolvestream.d_decision.DecisionMakerService;
import com.helei.tradesignalcenter.resolvestream.e_order.AbstractOrderCommitter;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.KeyedStream;

import java.util.List;

@Slf4j
public class AutoTradeTask {


    /**
     * 信号流服务
     */
    private final TradeSignalService tradeSignalService;

    /**
     * 决策服务
     */
    private final DecisionMakerService decisionMakerService;

    /**
     * 订单提交器
     */
    private final AbstractOrderCommitter<OriginOrder> abstractOrderCommitter;


    public AutoTradeTask(
            TradeSignalService tradeSignalService,
            DecisionMakerService decisionMakerService,
            AbstractOrderCommitter<OriginOrder> abstractOrderCommitter
    ) {
        this.tradeSignalService = tradeSignalService;

        this.decisionMakerService = decisionMakerService;

        this.abstractOrderCommitter = abstractOrderCommitter;
    }


    public void execute(String name) throws Exception {

        //1.信号服务
        KeyedStream<Tuple2<KLine, List<TradeSignal>>, String> symbolGroupSignalStream = tradeSignalService.getSymbolGroupSignalStream();

        symbolGroupSignalStream.print();
        //2.决策服务
        DataStream<OriginOrder> originOrderStream = decisionMakerService.decision(symbolGroupSignalStream);


        originOrderStream.sinkTo(abstractOrderCommitter.getCommitSink());
        tradeSignalService.getEnv().execute(name);
    }

}





shinano:
  quantity:
    # 信号生成服务配置
    trade_signal_maker:
      # name
      name: test
      # symbol
      symbol: btcusdt
      # 运行环境
      run_env: NORMAL
      # 交易类型
      trade_type: CONTRACT
      # 历史k线加载批大小
      historyKLineBatchSize: 200
      # 批加载的网络并发度
      batchLoadConcurrent: 10
      # 实时数据配置
      realtime:
        # kafka配置
        kafka:
          bootstrapServer: 192.168.1.2:9092
          groupId: trade_signal_app_test
        # flink配置
        flink:
          jobManagerHost: 192.168.1.2
          jobManagerPort: 8081
