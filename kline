package com.helei.cexapi.binanceapi.api;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApi;
import com.helei.cexapi.binanceapi.constants.command.AccountCommandType;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 用户相关api
 */
@Slf4j
public class BinanceWSAccountApi extends AbstractBinanceWSApi {

    public BinanceWSAccountApi(BinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    /**
     * 账户信息
     * @param omitZeroBalances 是否显示非0余额
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountStatus(
        Boolean omitZeroBalances,
        ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("omitZeroBalances", omitZeroBalances)
                .setCommandType(AccountCommandType.ACCOUNT_STATUS)
                .build();

        log.info("query account status command [{}]", command);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }

    /**
     * 显示用户在所有时间间隔内的未成交订单计数。
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountRateLimitsOrders(ASKey asKey) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(AccountCommandType.ACCOUNT_RATE_LIMITS_ORDERS)
                .build();

        log.info("query account rate limit orders command [{}]", command);
        return binanceWSApiClient.sendRequest(40, command, asKey);
    }

    /**
     * 账户订单历史
     * 获取所有账户订单； 有效，已取消或已完成。按时间范围过滤。
     * 订单状态报告与 order.status 相同。
     * 请注意，某些字段是可选的，仅在订单中有设置它们时才包括。
     * --
     * 如果指定了 startTime 和/或 endTime，则忽略 orderId。
     * 订单是按照最后一次更新的执行状态的time过滤的。
     * 如果指定了 orderId，返回的订单将是订单ID >= orderId
     * 如果不指定条件，则返回最近的订单。
     * 对于某些历史订单，cummulativeQuoteQty 响应字段可能为负数，代表着此时数据还不可用。
     * @param symbol 必须
     * @param orderId 起始订单ID，可选
     * @param startTime 可选
     * @param endTime 可选
     * @param limit 可选
     * @param asKey 签名参数
     * @return  CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountAllOrders(
            String symbol,
            Integer orderId,
            Long startTime,
            Long endTime,
            Integer limit,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("startTime", startTime)
                .addParam("endTime", endTime)
                .addParam("limit", limit)
                .setCommandType(AccountCommandType.ACCOUNT_ALL_ORDERS)
                .build();

        log.info("query account [{}] orders", symbol);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }


    /**
     * 账户成交历史
     * 如果指定了 fromId，则返回的交易将是 交易ID >= fromId。
     * 如果指定了 startTime 和/或 endTime，则交易按执行时间（time）过滤。
     * fromId 不能与 startTime 和 endTime 一起使用。
     * 如果指定了 orderId，则只返回与该订单相关的交易。
     * startTime 和 endTime 不能与 orderId 一起使用。
     * 如果不指定条件，则返回最近的交易。
     * @param symbol 必须
     * @param orderId 起始订单ID，可选
     * @param startTime 可选
     * @param endTime 可选
     * @param fromId 起始交易 ID
     * @param limit 可选
     * @param asKey 签名参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> accountTrades(
            String symbol,
            Integer orderId,
            Long startTime,
            Long endTime,
            Integer fromId,
            Integer limit,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("startTime", startTime)
                .addParam("endTime", endTime)
                .addParam("fromId", fromId)
                .addParam("limit", limit)
                .setCommandType(AccountCommandType.ACCOUNT_ALL_ORDERS)
                .build();

        log.info("query account all trades, command[{}]", command);
        return binanceWSApiClient.sendRequest(20, command, asKey);
    }
}



package com.helei.cexapi.binanceapi.api;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApi;
import com.helei.cexapi.binanceapi.constants.command.WebSocketCommandType;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.List;
import java.util.function.Consumer;


@Slf4j
public class BinanceWSBaseApi extends AbstractBinanceWSApi {
    public BinanceWSBaseApi(BinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 测试服务端联通性
     */
    public void pingServer() {
        binanceWSApiClient.sendPing();
    }


    /**
     * 查询服务端的时间
     * @param callback callback, 失败则会传入null. 由父类的线程池执行
     */
    public void queryServerTime(Consumer<Long> callback) {
        JSONObject command = WebSocketCommandBuilder.builder().setCommandType(WebSocketCommandType.TIME).build();

        String id = command.getString("id");
        binanceWSApiClient.sendRequest(1, command, result -> {
            if (result != null) {
                try {
                    callback.accept(result.getLong("serverTime"));
                    log.debug("get server time [{}], request id[{}] success", result, id);
                } catch (Exception e) {
                    callback.accept(null);
                    log.error("parse server time error, requestId [{}]", id,e);
                }
            } else {
                callback.accept(null);
                log.warn("get server time, request id[{}] fail", id);
            }
        });
    }


    /**
     * 查询交易规范信息,
     * @param permissions permissions
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            Consumer<JSONObject> callback,
            List<String> permissions
    ) {
        queryExchangeInfo(null, null, permissions, callback);
    }

    /**
     * 查询交易规范信息,
     * @param symbols symbols
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            List<String> symbols,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(null, symbols, null, callback);
    }

    /**
     * 查询交易规范信息, symbol,
     * @param symbol symbol
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            Consumer<JSONObject> callback
    ) {
        queryExchangeInfo(symbol, null, null, callback);
    }


    /**
     * 查询交易规范信息, symbol,symbols,permissions三个参数只能生效一个，从前到后第一个不为空的生效
     * @param symbol symbol
     * @param symbols symbols
     * @param permissions permissions
     * @param callback callback。失败则会传入null. 由父类的线程池执行
     */
    public void queryExchangeInfo(
            String symbol,
            List<String> symbols,
            List<String> permissions,
            Consumer<JSONObject> callback
    ) {


        JSONObject jb = new JSONObject();
        if (StrUtil.isNotBlank(symbol)) {
            jb.put("symbol", symbol);
        }
        else if (symbols != null && !symbols.isEmpty()) {
            jb.put("symbols", symbols);
        }
        else if (permissions != null && !permissions.isEmpty()) {
            jb.put("permissions", permissions);
        }
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(WebSocketCommandType.EXCHANGE_INFO)
                .setParams(jb)
                .build();
        binanceWSApiClient.sendRequest(20, command, callback);
    }
}

package com.helei.cexapi.binanceapi.api;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApi;
import com.helei.cexapi.binanceapi.constants.KLineInterval;
import com.helei.cexapi.binanceapi.constants.command.WebSocketCommandType;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.function.Consumer;


/**
 * 现货api
 */
@Slf4j
public class BinanceWSMarketApi extends AbstractBinanceWSApi {


    public BinanceWSMarketApi(BinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }

    /**
     * 获取当前深度信息。
     * 请注意，此请求返回有限的市场深度。
     * 如果需要持续监控深度信息更新，请考虑使用 WebSocket Streams：
     * <symbol>@depth<levels>
     * <symbol>@depth
     * 如果需要维护本地orderbook，您可以将 depth 请求与 <symbol>@depth streams 一起使用。
     * 权重(IP): 根据限制调整：
     * 限制	重量
     * 1–100	5
     * 101–500	25
     * 501–1000	50
     * 1001-5000	250
     * 参数:
     * 名称	类型	是否必需	描述
     * symbol	STRING	YES
     * limit	INT	NO	默认 100; 最大值 5000
     *
     * @param symbol   symbol
     * @param limit    limit
     * @param callback callback
     *                 {
     *                 "lastUpdateId": 2731179239,
     *                 // bid 水平从最高价到最低价排序。
     *                 "bids": [
     *                 [
     *                 "0.01379900",   // 价格
     *                 "3.43200000"    // 重量
     *                 ]
     *                 ],
     *                 // ask 水平从最低价到最高价排序。
     *                 "asks": [
     *                 [
     *                 "0.01380000",
     *                 "5.91700000"
     *                 ]
     *                 ]
     *                 }
     */
    public void queryDepth(String symbol, Integer limit, Consumer<JSONObject> callback) {
        int ipWeight = 100;
        if (limit >= 1 && limit <= 100) {
            ipWeight = 5;
        } else if (limit >= 101 && limit <= 500) {
            ipWeight = 25;
        } else if (limit >= 501 && limit <= 1000) {
            ipWeight = 50;
        } else if (limit >= 1001 && limit <= 5000) {
            ipWeight = 250;
        } else {
            ipWeight = 250;
            limit = 5000;
        }

        WebSocketCommandBuilder builder = WebSocketCommandBuilder
                .builder();
        builder.setCommandType(WebSocketCommandType.DEPTH);
        builder.addParam("symbol", symbol);
        builder.addParam("limit", limit);
        JSONObject command = builder
                .build();


        binanceWSApiClient.sendRequest(ipWeight, command, callback);
    }


    /**
     * 查询最近交易信息
     *
     * @param symbol   symbol
     * @param limit    多少条
     * @param callback callback
     *                 [
     *                 {
     *                 "id": 194686783,
     *                 "price": "0.01361000",
     *                 "qty": "0.01400000",
     *                 "quoteQty": "0.00019054",
     *                 "time": 1660009530807,
     *                 "isBuyerMaker": true,
     *                 "isBestMatch": true
     *                 }
     *                 ]
     */
    public void queryTradesRecent(String symbol, int limit, Consumer<JSONObject> callback) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(WebSocketCommandType.TRADES_RECENT)
                .addParam("symbol", symbol)
                .addParam("limit", limit)
                .build();

        binanceWSApiClient.sendRequest(20, command, callback);
    }


    /**
     * 查询历史k线数据
     * @param symbol symbol
     * @param interval interval
     * @param startTimeSecond startTimeSecond
     * @param limit limit
     * @param callback callback
     */
    public void queryHistoryKLine(
            String symbol,
            KLineInterval interval,
            long startTimeSecond,
            int limit,
            Consumer<JSONObject> callback
    ){
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(WebSocketCommandType.KLINES)
                .addParam("symbol", symbol)
                .addParam("interval", interval.getDescribe())
                .addParam("startTime", startTimeSecond*1000)
                .addParam("limit", limit)
                .build();

        binanceWSApiClient.sendRequest(2, command, callback);
    }
}

package com.helei.cexapi.binanceapi.api;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApi;
import com.helei.cexapi.binanceapi.constants.order.CancelRestrictions;
import com.helei.cexapi.binanceapi.constants.command.TradeCommandType;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import com.helei.cexapi.binanceapi.dto.order.BaseOrder;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;


/**
 * 交易相关api
 */
@Slf4j
public class BinanceWSTradeApi extends AbstractBinanceWSApi {

    public BinanceWSTradeApi(BinanceWSApiClient binanceWSApiClient) throws URISyntaxException {
        super(binanceWSApiClient);
    }


    /**
     * 提交订单，
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitOrder(BaseOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_PLACE)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 提交测试订单，
     * @param order 订单信息
     * @param asKey 签名需要的参数
     * @return 下单的的结果CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> commitTestOrder(BaseOrder order, ASKey asKey) {
        String jsonString = JSON.toJSONString(order);
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .setCommandType(TradeCommandType.ORDER_TEST)
                .setParams(JSON.parseObject(jsonString))
                .build();

        log.info("commit test order command [{}]", jsonString);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 查询订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * 对于某些历史订单，cummulativeQuoteQty 响应字段可能为负数，意味着此时数据不可用。
     * @param symbol symbol
     * @param orderId orderId
     * @param origClientOrderId origClientOrderId
     * @param asKey 签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> queryOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .setCommandType(TradeCommandType.ORDER_STATUS)
                .build();

        log.info("query order [{}]", command);
        return binanceWSApiClient.sendRequest(4, command, asKey);
    }


    /**
     * 撤销订单
     * 如果同时指定了 orderId 和 origClientOrderId 参数，仅使用 orderId 并忽略 origClientOrderId。
     * newClientOrderId 将替换已取消订单的 clientOrderId，为新订单腾出空间。
     * 如果您取消属于订单列表的订单，则整个订单列表将被取消。
     * @param symbol symbol
     * @param orderId 按 orderId 取消订单
     * @param origClientOrderId 按 clientOrderId 取消订单
     * @param newClientOrderId 已取消订单的新 ID。如果未发送，则自动生成
     * @param cancelRestrictions 支持的值:
     *                            ONLY_NEW - 如果订单状态为 NEW，撤销将成功。
     *                            ONLY_PARTIALLY_FILLED - 如果订单状态为 PARTIALLY_FILLED，撤销将成功。
     * @param asKey 签名需要的参数
     * @return  CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> cancelOrder(
            String symbol,
            Integer orderId,
            String origClientOrderId,
            String newClientOrderId,
            CancelRestrictions cancelRestrictions,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .addParam("orderId", orderId)
                .addParam("origClientOrderId", origClientOrderId)
                .addParam("newClientOrderId", newClientOrderId)
                .addParam("cancelRestrictions", cancelRestrictions)
                .setCommandType(TradeCommandType.ORDER_CANCEL)
                .build();

        log.info("cancel order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }

    /**
     * 撤销单一交易对的所有挂单
     * @param symbol symbol
     * @param asKey 签名需要的参数
     * @return  CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersCancelAll(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_CANCEL_ALL)
                .build();

        log.info("cancel all order [{}]", command);
        return binanceWSApiClient.sendRequest(1, command, asKey);
    }



    /**
     * 查询用户当前挂单情况
     * @param symbol symbol
     * @param asKey 签名需要的参数
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<JSONObject> openOrdersStatus(
            String symbol,
            ASKey asKey
    ) {
        JSONObject command = WebSocketCommandBuilder
                .builder()
                .addParam("symbol", symbol)
                .setCommandType(TradeCommandType.OPEN_ORDER_STATUS)
                .build();
        int weight = 6;
        if (StrUtil.isBlank(symbol)) {
            weight = 80;
        }

        log.info("open order status [{}]", command);
        return binanceWSApiClient.sendRequest(weight, command, asKey);
    }
}



package com.helei.cexapi.binanceapi.base;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.dto.StreamSubscribeEntity;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import com.helei.cexapi.binanceapi.supporter.BinanceWSStreamSupporter;
import com.helei.cexapi.binanceapi.supporter.IpWeightSupporter;
import com.helei.cexapi.binanceapi.util.SignatureUtil;
import com.helei.cexapi.netty.base.AbstractWebsocketClient;
import com.helei.cexapi.binanceapi.constants.command.WebSocketCommandType;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.security.InvalidKeyException;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * 币按ws接口客户端抽象类
 */
@Slf4j
public class AbstractBinanceWSApiClient extends AbstractWebsocketClient<JSONObject, JSONObject> {

    /**
     * 处理ip限制相关
     */
    private final IpWeightSupporter ipWeightSupporter;


    /**
     * 处理stream流相关
     */
    private final BinanceWSStreamSupporter binanceWSStreamSupporter;

    public AbstractBinanceWSApiClient(
            int threadPoolSize,
            String url,
            IpWeightSupporter ipWeightSupporter,
            BinanceWSStreamSupporter binanceWSStreamSupporter,
            AbstractBinanceWSApiClientHandler handler
    ) throws URISyntaxException {
        super(threadPoolSize, url, handler);

        this.ipWeightSupporter = ipWeightSupporter;

        this.binanceWSStreamSupporter = binanceWSStreamSupporter;
    }


    @Override
    public String getIdFromRequest(JSONObject request) {
        return request.getString("id");
    }

    @Override
    public void submitStreamResponse(String streamName, JSONObject message) {
        binanceWSStreamSupporter.publishStreamResponse(streamName, message, callbackInvoker);
    }


    /**
     * 发生请求
     *
     * @param ipWeight ip weight
     * @param request  请求体
     * @param callback 回调
     */
    public void sendRequest(
            int ipWeight,
            JSONObject request,
            Consumer<JSONObject> callback
    ) {
        sendRequest(ipWeight, request, false, callback);
    }

    /**
     * 发生请求
     *
     * @param ipWeight    ip weight
     * @param request     请求体
     * @param asKey         签名参数
     * @param callback    回调
     */
    public void sendRequest(
            int ipWeight,
            JSONObject request,
            ASKey asKey,
            Consumer<JSONObject> callback
    ) {
        try {
            if (ipWeightSupporter.submitIpWeight(ipWeight)) {
                String id = getIdFromRequest(request);

                //需要签名
                if (asKey != null) {
                    JSONObject params = request.getJSONObject("params");
                    params.put("timestamp", System.currentTimeMillis());
                    try {
                        params.put("signature", SignatureUtil.signatureHMAC(asKey.getSecretKey(), params));
                    } catch (InvalidKeyException e) {
                        throw new IllegalArgumentException("signature params error");
                    }
                    params.put("apiKey", asKey.getApiKey());
                }

                super.sendRequest(request, response -> {
                    if (response != null) {

                        if (response.getInteger("status") != null && response.getInteger("status") != 200) {
                            log.error("receive error response [{}]", response);
                        }
                        log.debug("send request id[{}] success, response[{}]", id, response);
                        callback.accept(response);
                    } else {
                        callback.accept(null);
                        log.error("send request id[{}] fail", id);
                    }
                });
            } else {
                log.warn("current ipWeight[{}] not support send request", ipWeightSupporter.currentWeight());
            }
        } catch (Exception e) {
            log.error("send request error", e);
        }
    }

    /**
     * 发生请求
     * @param ipWeight    ip weight
     * @param request     请求体
     * @param asKey 签名
     */
    public CompletableFuture<JSONObject> sendRequest(
            int ipWeight,
            JSONObject request,
            ASKey asKey
    ) {
        if (ipWeightSupporter.submitIpWeight(ipWeight)) {
            log.error("ipWeight[{}] not support send request", ipWeightSupporter.currentWeight());
            return null;
        }
        return super.sendRequest(trySignatureRequest(request, asKey));
    }

    private JSONObject trySignatureRequest(JSONObject request, ASKey asKey) {
        //需要签名
        if (asKey != null) {
            JSONObject params = request.getJSONObject("params");
            params.put("timestamp", System.currentTimeMillis());
            params.put("apiKey", asKey.getApiKey());
            try {
                params.put("signature", SignatureUtil.signatureHMAC(asKey.getSecretKey(), params));
            } catch (InvalidKeyException e) {
                log.error("signature params error");
                return null;
            }
        }
        return request;
    }


    /**
     * 订阅stream
     *
     * @param symbol  需订阅的币种symbol
     * @param subList 需订阅的类型
     */
    public void subscribeStream(String symbol, List<StreamSubscribeEntity> subList) {
        WebSocketCommandBuilder builder = WebSocketCommandBuilder.builder().setCommandType(WebSocketCommandType.SUBSCRIBE);

        AtomicBoolean isSignature = new AtomicBoolean(false);
        subList.forEach(e -> {
            if (e.isSignature()) {
                isSignature.set(true);
            }
            builder.addArrayParam(e.getStreamName());
        });
        JSONObject command = builder.build();

        log.info("subscribe stream command: {}", command);

        String id = command.getString("id");

        sendRequest(1, command, isSignature.get(), response -> {
            if (response != null) {
                log.debug("get subscribe response: {}", response);
                binanceWSStreamSupporter.addSubscribe(symbol, subList);
            } else {
                log.error("get subscribe response error, requestId[{}]", id);
            }
        });
    }
}

package com.helei.cexapi.binanceapi.constants.command;

public enum AccountCommandType implements WSCommandType{

    /**
     * 账户信息
     */
    ACCOUNT_STATUS("account.status"),

    /**
     * 查询未成交的订单计数
     */
    ACCOUNT_RATE_LIMITS_ORDERS("account.rateLimits.orders"),

    /**
     * 账户订单历史
     */
    ACCOUNT_ALL_ORDERS("account.allOrders"),

    /**
     * 账户成交历史
     */
    MY_TRADES("myTrades")
    ;

    AccountCommandType(String description) {
        this.description = description;
    }

    private final String description;

    @Override
    public String toString() {
        return description;
    }

    @Override
    public String getDescription() {
        return description;
    }
}

package com.helei.cexapi.binanceapi.constants.command;

import lombok.Getter;

@Getter
public enum TradeCommandType implements WSCommandType {

    /**
     * 下新订单
     */
    ORDER_PLACE("order.place"),
    /**
     * 测试下单
     */
    ORDER_TEST("order.test"),
    /**
     * 查询订单
     */
    ORDER_STATUS("order.status"),
    /**
     * 撤销订单
     */
    ORDER_CANCEL("order.cancel"),

    /**
     * 当前挂单
     */
    OPEN_ORDER_STATUS("open.order.status"),

    /**
     * 撤销单一交易对所有挂单
     */
    OPEN_ORDER_CANCEL_ALL("open.order.cancel.all"),
    ;

    TradeCommandType(String description) {
        this.description = description;
    }

    private final String description;

    @Override
    public String toString() {
        return description;
    }
}

package com.helei.cexapi.binanceapi.constants.command;

import lombok.Getter;

@Getter
public enum WebSocketCommandType implements WSCommandType {
    /**
     * 订阅
     */
    SUBSCRIBE("SUBSCRIBE"),
    /**
     * 取消订阅
     */
    UNSUBSCRIBE("UNSUBSCRIBE"),
    /**
     * 当前订阅
     */
    LIST_SUBSCRIPTIONS("LIST_SUBSCRIPTIONS"),
    /**
     * 设置属性
     */
    SET_PROPERTY("SET_PROPERTY"),
    /**
     * 获取属性
     */
    GET_PROPERTY("GET_PROPERTY"),
    /**
     * ping
     */
    PING("ping"),
    /**
     * ping
     */
    PONG("pong"),
    /**
     * 获取服务器时间
     */
    TIME("time"),
    /**
     * 获取交易规范信息
     */
    EXCHANGE_INFO("exchangeInfo"),
    /**
     * 获取深度信息
     */
    DEPTH("depth"),
    TRADES_RECENT("trades.recent"),
    /**
     * 历史k线数据
     */
    KLINES("klines"),


    ;

    WebSocketCommandType(String description) {
        this.description = description;
    }

    private final String description;

    @Override
    public String toString() {
        return description;
    }
}

package com.helei.cexapi.binanceapi.constants.command;

public interface WSCommandType {
    String getDescription();
}


package com.helei.cexapi.binanceapi.constants.order;


/**
 * 根据订单状态撤销订单
 */
public enum CancelRestrictions {
    /**
     *  如果订单状态为 NEW，撤销将成功。
     */
    ONLY_NEW("ONLY_NEW "),

    /**
     * 如果订单状态为 PARTIALLY_FILLED，撤销将成功。
     */
    ONLY_PARTIALLY_FILLED("ONLY_PARTIALLY_FILLED "),
    ;

    private final String describe;

    CancelRestrictions(String describe) {
        this.describe = describe;
    }

    @Override
    public String toString() {
        return describe;
    }
}


package com.helei.cexapi.binanceapi.constants.order;

import lombok.Getter;

/**
 * 可选的响应格式: ACK，RESULT，FULL.
 * MARKET和LIMIT订单默认使用FULL，其他订单类型默认使用ACK。
 */
@Getter
public enum OrderRespType {

    ACK("ACK"),
    RESULT("RESULT"),
    FULL("FULL")
    ;

    private final String describe;

    OrderRespType(String describe) {
        this.describe = describe;
    }


    @Override
    public String toString() {
        return describe;
    }
}
package com.helei.cexapi.binanceapi.constants.order;

import lombok.Getter;

/**
 * 有效成交方式
 */
@Getter
public enum TimeInForce {
    /**
     * 成交为止
     * 订单会一直有效，直到被成交或者取消。
     */
    GTC("GTC"),
    /**
     * 无法立即成交的部分就撤销
     * 订单在失效前会尽量多的成交。
     */
    IOC("IOC"),
    /**
     * 无法全部立即成交就撤销
     * 如果无法全部成交，订单会失效。
     */
    FOK("FOK"),

    ;


    private final String describe;

    TimeInForce(String describe) {
        this.describe = describe;
    }


    @Override
    public String toString() {
        return describe;
    }
}


package com.helei.cexapi.binanceapi.constants.order;

import lombok.Getter;

@Getter
public enum TradePreventionMode {
    EXPIRE_TAKER("EXPIRE_TAKER"),
    EXPIRE_MAKER("EXPIRE_MAKER"),
    EXPIRE_BOTH("EXPIRE_BOTH"),
    NONE("NONE")
    ;


    private final String describe;

    TradePreventionMode(String describe) {
        this.describe = describe;
    }

    @Override
    public String toString() {
        return describe;
    }
}



package com.helei.cexapi.binanceapi.constants.order;

public enum TradeSide {
    BUY("BUY"),
    SALE("SALE")
    ;

    private final String describe;

    TradeSide(String describe) {
        this.describe = describe;
    }


    @Override
    public String toString() {
        return describe;
    }
}

package com.helei.cexapi.binanceapi.constants.order;

import lombok.Getter;

@Getter
public enum TradeType {

    /**
     * 限价单
     */
    LIMIT("LIMIT"),
    /**
     * 市价单
     */
    MARKET("MARKET"),
    /**
     *  止损单
     */
    STOP_LOSS("STOP_LOSS"),
    /**
     * 限价止损单
     */
    STOP_LOSS_LIMIT("STOP_LOSS_LIMIT"),
    /**
     * 止盈单
     */
    TAKE_PROFIT("TAKE_PROFIT"),
    /**
     * 限价止盈单
     */
    TAKE_PROFIT_LIMIT("TAKE_PROFIT_LIMIT"),
    /**
     *  限价只挂单
     */
    LIMIT_MAKER("LIMIT_MAKER"),
    ;


    private final String describe;

    TradeType(String describe) {
        this.describe = describe;
    }

    @Override
    public String toString() {
        return describe;
    }
}

package com.helei.cexapi.binanceapi.constants;


import lombok.Getter;
import java.util.Map;


@Getter
public enum WebSocketStreamType {

    /**
     * 交易流归集，推送交易信息，是对单一订单的集合
     */
    AGG_TRADE("aggTrade", (symbol, params) -> symbol + "@aggTrade"),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+0 时区的。
     * Stream 名称: <symbol>@kline_<interval
     */
    KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+8 时区的。
     * UTC+8 时区偏移量：
     * K线间隔的开始和结束时间会基于 UTC+8 时区。例如， 1d K线将在 UTC+8 当天开始，并在 UTC+8 当日完结时随之结束。
     * 请注意，Payload中的 E（event time），t（start time）和 T（close time）是 Unix 时间戳，它们始终以 UTC 格式解释。
     * Stream 名称: <symbol>@kline_<interval>@+08:00
     */
    MOVE_KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL) + "@" + params.get(WebSocketStreamParamKey.KLINE_TIMEZONE)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。
     *
     * 合约类型:
     * perpetual 永续合约
     * current_quarter 当季交割合约
     * next_quarter 次季交割合约
     * 订阅Kline需要提供间隔参数,最短为分钟线,最长为月线。支持以下间隔:
     *
     * m -> 分钟; h -> 小时; d -> 天; w -> 周; M -> 月
     */
    CONTINUOUS_KLINE("continuousKline", (symbol, params) ->
            String.format("%s_%s@continuousKline_%s", symbol, params.get(WebSocketStreamParamKey.CONTRACT_TYPE), params.get(WebSocketStreamParamKey.KLINE_INTERVAL))),

    /**
     * 按Symbol刷新的最近24小时精简ticker信息
     * Stream 名称: <symbol>@miniTicker
     */
    MINI_TICKER("miniTicker", (symbol, params) -> symbol + "@miniTicker"),

    /**
     * 按Symbol刷新的24小时完整ticker信息
     */
    TICKER("ticker",  (symbol, params) -> symbol + "@ticker"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_TICKER("!ticker@arr", (symbol, params) -> "@!ticker@arr"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_MINI_TICKER("!miniTicker@arr", (symbol, params) -> "!miniTicker@arr"),

    /**
     * 最新标记价格
     */
    MARK_PRICE("markPrice", (symbol, params) -> symbol + "@markPrice"),

    /**
     * 全市场最新标记价格
     */
    ALL_MARK_PRICE("!markPrice@arr", (symbol, params) -> "!markPrice@arr")
    ;


    WebSocketStreamType(String description, AbstractBinanceWSSHandler handler) {
        this.description = description;
        this.handler = handler;
    }

    private final String description;

    private final AbstractBinanceWSSHandler handler;


    public interface AbstractBinanceWSSHandler {
        String buildStreamName(String symbol, Map<String, Object> params);
    }

    @Override
    public String toString() {
        return description;
    }
}


package com.helei.cexapi.binanceapi.constants;


import lombok.Getter;
import java.util.Map;


@Getter
public enum WebSocketStreamType {

    /**
     * 交易流归集，推送交易信息，是对单一订单的集合
     */
    AGG_TRADE("aggTrade", (symbol, params) -> symbol + "@aggTrade"),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+0 时区的。
     * Stream 名称: <symbol>@kline_<interval
     */
    KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+8 时区的。
     * UTC+8 时区偏移量：
     * K线间隔的开始和结束时间会基于 UTC+8 时区。例如， 1d K线将在 UTC+8 当天开始，并在 UTC+8 当日完结时随之结束。
     * 请注意，Payload中的 E（event time），t（start time）和 T（close time）是 Unix 时间戳，它们始终以 UTC 格式解释。
     * Stream 名称: <symbol>@kline_<interval>@+08:00
     */
    MOVE_KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL) + "@" + params.get(WebSocketStreamParamKey.KLINE_TIMEZONE)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。
     *
     * 合约类型:
     * perpetual 永续合约
     * current_quarter 当季交割合约
     * next_quarter 次季交割合约
     * 订阅Kline需要提供间隔参数,最短为分钟线,最长为月线。支持以下间隔:
     *
     * m -> 分钟; h -> 小时; d -> 天; w -> 周; M -> 月
     */
    CONTINUOUS_KLINE("continuousKline", (symbol, params) ->
            String.format("%s_%s@continuousKline_%s", symbol, params.get(WebSocketStreamParamKey.CONTRACT_TYPE), params.get(WebSocketStreamParamKey.KLINE_INTERVAL))),

    /**
     * 按Symbol刷新的最近24小时精简ticker信息
     * Stream 名称: <symbol>@miniTicker
     */
    MINI_TICKER("miniTicker", (symbol, params) -> symbol + "@miniTicker"),

    /**
     * 按Symbol刷新的24小时完整ticker信息
     */
    TICKER("ticker",  (symbol, params) -> symbol + "@ticker"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_TICKER("!ticker@arr", (symbol, params) -> "@!ticker@arr"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_MINI_TICKER("!miniTicker@arr", (symbol, params) -> "!miniTicker@arr"),

    /**
     * 最新标记价格
     */
    MARK_PRICE("markPrice", (symbol, params) -> symbol + "@markPrice"),

    /**
     * 全市场最新标记价格
     */
    ALL_MARK_PRICE("!markPrice@arr", (symbol, params) -> "!markPrice@arr")
    ;


    WebSocketStreamType(String description, AbstractBinanceWSSHandler handler) {
        this.description = description;
        this.handler = handler;
    }

    private final String description;

    private final AbstractBinanceWSSHandler handler;


    public interface AbstractBinanceWSSHandler {
        String buildStreamName(String symbol, Map<String, Object> params);
    }

    @Override
    public String toString() {
        return description;
    }
}

package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * 限价只挂单
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class LimitMakerOrder extends BaseOrder {
    /**
     * 交易类型
     */
    private final TradeType type = TradeType.LIMIT_MAKER;

    /**
     * 价格
     */
    private BigDecimal price;

    /**
     * 量
     */
    private BigDecimal quantity;

}



package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TimeInForce;
import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * 限价单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class LimitOrder extends BaseOrder {
    /**
     * 交易类型
     */
    private final TradeType type = TradeType.LIMIT;

    /**
     * 有效成交方式
     */
    private TimeInForce timeInForce;

    /**
     * 价格
     */
    private BigDecimal price;

    /**
     * 量
     */
    private BigDecimal quantity;
}


package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * 市价单
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class MarketOrder extends BaseOrder {

    /**
     * 交易类型
     */
    private final TradeType type = TradeType.MARKET;

    /**
     * 量
     */
    private BigDecimal quantity;

    /**
     *
     */
    private BigDecimal quoteOrderQty;
}

package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TimeInForce;
import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.*;

import java.math.BigDecimal;

/**
 * 限价止损单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class StopLossLimitOrder extends BaseOrder {

    /**
     * 交易类型
     */
    private final TradeType type = TradeType.STOP_LOSS_LIMIT;

    /**
     * 有效成交方式
     */
    private TimeInForce timeInForce;
    /**
     * 价格
     */
    private BigDecimal price;

    /**
     * 量
     */
    private BigDecimal quantity;


    /**
     * 止损
     */
    private BigDecimal stopPrice;

    /**
     * 移动止损
     */
    private Integer trailingDelta;

}



package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;


/**
 * 止损单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class StopLossOrder extends BaseOrder {
    /**
     * 交易类型
     */
    private final TradeType type = TradeType.STOP_LOSS;
    /**
     * 量
     */
    private BigDecimal quantity;


    /**
     * 止损
     */
    private BigDecimal stopPrice;

    /**
     * 移动止损
     */
    private Integer trailingDelta;

}

package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TimeInForce;
import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;


/**
 * 限价止盈单
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class TakeProfitLimitOrder extends BaseOrder {
    /**
     * 交易类型
     */
    private final TradeType type = TradeType.TAKE_PROFIT_LIMIT;

    /**
     * 有效成交方式
     */
    private TimeInForce timeInForce;
    /**
     * 价格
     */
    private BigDecimal price;

    /**
     * 量
     */
    private BigDecimal quantity;


    /**
     * 止损
     */
    private BigDecimal stopPrice;

    /**
     * 移动止损
     */
    private Integer trailingDelta;

}

package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.TradeType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

/**
 * 止盈单
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode(callSuper = false)
public class TakeProfitOrder extends BaseOrder {
    /**
     * 交易类型
     */
    private final TradeType type = TradeType.TAKE_PROFIT;
    
    /**
     * 量
     */
    private BigDecimal quantity;

    /**
     * 止损
     */
    private BigDecimal stopPrice;

    /**
     * 移动止损
     */
    private Integer trailingDelta;
}


package com.helei.cexapi.binanceapi.dto.order;

import com.helei.cexapi.binanceapi.constants.order.OrderRespType;
import com.helei.cexapi.binanceapi.constants.order.TimeInForce;

import java.math.BigDecimal;

@Deprecated
public class TradeOrder {


    /**
     * 有效成交方式
     */
    private TimeInForce timeInForce;

    /**
     * 价格
     */
    private BigDecimal price;

    /**
     * 量
     */
    private BigDecimal quantity;

    /**
     *
     */
    private BigDecimal quoteOrderQty;

    /**
     * 客户自定义的唯一订单ID。如果未发送，则自动生成。
     */
    private String newClientOrderId;

    /**
     * 响应格式
     */
    private OrderRespType newOrderRespType;


    /**
     * 止损
     */
    private BigDecimal stopPrice;

    /**
     * 移动止损
     */
    private Integer trailingDelta;


    private BigDecimal icebergQty;

    /**
     * 标识订单策略中订单的任意ID。
     */
    private Integer strategyId;

    /**
     * 标识订单策略的任意数值。
     * 小于1000000的值是保留的，不能使用。
     */
    private Integer strategyType;


}




package com.helei.cexapi.binanceapi.dto;


        import com.alibaba.fastjson.JSONArray;
        import com.alibaba.fastjson.JSONObject;
        import com.helei.cexapi.binanceapi.constants.command.WSCommandType;
        import com.helei.cexapi.binanceapi.constants.command.WebSocketCommandType;
        import lombok.Data;
        import lombok.EqualsAndHashCode;

        import java.util.*;

/**
 * WebSocket里发送请求的格式
 */
@Data
@EqualsAndHashCode
public class WebSocketCommandBuilder {
    private final JSONObject command;

    WebSocketCommandBuilder() {
        command = new JSONObject();
        command.put("id", UUID.randomUUID().toString());
    }

    public static WebSocketCommandBuilder builder() {
        return new WebSocketCommandBuilder();
    }

    public JSONObject buildPing() {
        return setCommandType(WebSocketCommandType.PING).build();
    }

    public JSONObject buildPong() {
        return setCommandType(WebSocketCommandType.PONG).build();
    }

    public WebSocketCommandBuilder setCommandType(WSCommandType wsCommandType) {
        command.put("method", wsCommandType.getDescription());
        return this;
    }

    public WebSocketCommandBuilder setParams(JSONObject param) {
        command.put("params", param);
        return this;
    }

    public JSONObject build() {
        return command;
    }

    /**
     * 添加kv类型参数，
     * @param key key
     * @param value value
     * @return WebSocketCommandBuilder
     */
    public WebSocketCommandBuilder addParam(String key, Object value) {
        synchronized (command) {
            if (!command.containsKey("params")) {
                command.put("params", new JSONObject());
            }
            command.getJSONObject("params").put(key, value);
        }
        return this;
    }
    /**
     * 添加array类型参数，
     * @param value value
     * @return WebSocketCommandBuilder
     */
    public WebSocketCommandBuilder addArrayParam(Object value) {
        synchronized (command) {
            if (!command.containsKey("params")) {
                command.put("params", new JSONArray());
            }
            command.getJSONArray("params").add(value);
        }
        return this;
    }
}


package com.helei.cexapi.binanceapi;

import com.helei.cexapi.binanceapi.api.BinanceWSBaseApi;
import com.helei.cexapi.binanceapi.api.BinanceWSMarketApi;
import com.helei.cexapi.binanceapi.api.BinanceWSStreamApi;
import com.helei.cexapi.binanceapi.api.BinanceWSTradeApi;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.cexapi.binanceapi.base.AbstractBinanceWSApiClientHandler;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.supporter.BinanceWSStreamSupporter;
import com.helei.cexapi.binanceapi.supporter.IpWeightSupporter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;


/**
 * 币安ws接口客户端
 */
@Getter
@Slf4j
public class BinanceWSApiClient extends AbstractBinanceWSApiClient {


    /**
     * 基础的api
     */
    private final BinanceWSBaseApi baseApi;

    /**
     * 现货相关的api
     */
    private final BinanceWSMarketApi marketApi;

    /**
     * stream流推送相关api
     */
    private final BinanceWSStreamApi streamApi;

    /**
     * 交易相关api
     */
    private final BinanceWSTradeApi tradeApi;
    

    public BinanceWSApiClient(
            int threadPoolSize,
            String url,
            IpWeightSupporter ipWeightSupporter,
            AbstractBinanceWSApiClientHandler handler
    ) throws URISyntaxException {
        super(threadPoolSize, url, ipWeightSupporter, new BinanceWSStreamSupporter(), handler);
        baseApi = new BinanceWSBaseApi(this);
        marketApi = new BinanceWSMarketApi(this);
        streamApi = new BinanceWSStreamApi(this);
        tradeApi = new BinanceWSTradeApi(this);
    }

    public BinanceWSApiClient setSignature(ASKey asKey) {
        super.asKey = asKey;
        return this;
    }
}


package com.helei.cexapi.netty.base;


import com.alibaba.fastjson.JSON;
import com.helei.cexapi.netty.NettyConstants;
import com.helei.cexapi.netty.handler.RequestResponseHandler;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.Socks5ProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    private final String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    protected final ExecutorService callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected InetSocketAddress proxy = null;

    private Bootstrap bootstrap;

    private EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    private final RequestResponseHandler<T> requestResponseHandler;

    public AbstractWebsocketClient(
            int threadPoolSize,
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) throws URISyntaxException, SSLException {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        if (threadPoolSize <= 0) {
            this.callbackInvoker = null;
        } else {
            this.callbackInvoker = Executors.newFixedThreadPool(threadPoolSize);
        }

        requestResponseHandler = new RequestResponseHandler<>();

        resolveParamFromUrl();

        init();
    }

    private void init() throws SSLException {
        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders()
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            p.addLast(new Socks5ProxyHandler(proxy));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }

    /**
     * 链接服务端
     * @throws Exception Exception
     */
    public void connect() throws Exception {
        AtomicBoolean isSuccess = new AtomicBoolean(false);

        for (int i = 1; i <= NettyConstants.RECONNECT_LIMIT; i++) {
            log.info("start connect, current times [{}]", i);
            CountDownLatch latch = new CountDownLatch(1);;

            int finalI = i;
            eventLoopGroup.schedule(() -> {
                try {
                    channel = bootstrap.connect().sync().channel();
                    // 8. 等待 WebSocket 握手完成
                    handler.handshakeFuture().sync();

                    isSuccess.set(true);
                } catch (Exception e) {
                    isSuccess.set(false);
                    log.error("connect [{}] error", finalI, e);
                }
            }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

            latch.await();

            if (isSuccess.get()) {
                break;
            }
        }

        if (!isSuccess.get()) {
            log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
            close();
        }
    }


    /**
     * 关闭WebSocketClient
     */
    public void close() {
        log.info("start close websocket client");
        if (channel != null) {
            channel.close();
        }
        if (eventLoopGroup != null) {
            eventLoopGroup.shutdownGracefully();
        }
        log.info("web socket client closed");
    }


    /**
     * 从request获取id
     * @param request request
     * @return id
     */
    public abstract String getIdFromRequest(P request);

    /**
     * 发送请求, 注册响应监听
     * @param request  请求体
     * @param callback 请求结果的回调
     */
    public void sendRequest(P request, Consumer<T> callback) {
        sendRequest(request, callback, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request         请求体
     * @param callback        请求结果的回调
     * @param executorService 执行回调的线程池，传入为空则会尝试使用本类的线程池以及netty线程池
     */
    public void sendRequest(P request, Consumer<T> callback, ExecutorService executorService) {
        boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
            if (executorService == null) {
                if (callbackInvoker == null) { //netty线程处理
                    callback.accept(response);
                } else { //此类线程处理
                    callbackInvoker.submit(() -> {
                        callback.accept(response);
                    });
                }
            } else { //参数线程池处理
                executorService.submit(() -> {
                    callback.accept(response);
                });
            }

        });

        if (flag) {
            log.debug("send request [{}]", request);
            channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
        } else {
            throw new IllegalArgumentException("request id registered");
        }
    }

    /**
     * 发送请求, 注册响应监听
     * @param request         请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(()->{
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (! latch.await(NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        channel.writeAndFlush(new PongWebSocketFrame());
    }

    /**
     * 发送请求,不组册监听
     *
     * @param request 请求体
     */
    public void sendRequestNoListener(P request) {
        channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
    }


    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }


    /**
     * 提交请求的响应
     *
     * @param id       id
     * @param response response
     * @return 是否成功
     */
    public boolean submitResponse(String id, T response) {
        return requestResponseHandler.submitResponse(id, response);
    }

    /**
     * 提交stream流的响应
     *
     * @param streamName streamName, 通常由symbol和WebSocketStreamType组合成
     * @param message    message
     */
    public abstract void submitStreamResponse(String streamName, T message);
}


package com.helei.cexapi.netty.base;

import com.helei.cexapi.netty.NettyConstants;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPromise;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.util.CharsetUtil;
import lombok.extern.slf4j.Slf4j;

import io.netty.channel.*;

import java.util.concurrent.TimeUnit;


/**
 * WebSocket客户端处理器抽象类
 * @param <P>
 * @param <T>
 */
@Slf4j
public abstract class AbstractWebSocketClientHandler<P, T> extends SimpleChannelInboundHandler<Object> {

    private WebSocketClientHandshaker handshaker;

    private ChannelPromise handshakeFuture;

    protected AbstractWebsocketClient<P, T> websocketClient;

    /**
     * 收到消息处理
     * @param text 消息字符串
     */
    protected abstract void whenReceiveMessage(String text);


    public void init(WebSocketClientHandshaker handshaker) {
        this.handshaker = handshaker;
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        handshakeFuture = ctx.newPromise();
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        log.info("WebSocket Client connected!");
        handshaker.handshake(ctx.channel());
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        log.info("WebSocket Client disconnected!");
    }

    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        log.info("WebSocket Client unregistered!, start reconnect");

        websocketClient.connect();
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        Channel ch = ctx.channel();
        // 如果握手未完成，处理 FullHttpResponse
        if (!handshaker.isHandshakeComplete()) {
            if (msg instanceof FullHttpResponse response) {
                try {
                    handshaker.finishHandshake(ch, response);
                    System.out.println("WebSocket Handshake complete!");
                    handshakeFuture.setSuccess();
                } catch (WebSocketHandshakeException e) {
                    System.out.println("WebSocket Handshake failed!");
                    handshakeFuture.setFailure(e);
                }
                return;
            }
        }

        if (msg instanceof FullHttpResponse response) {
            throw new IllegalStateException(
                    "Unexpected FullHttpResponse (getStatus=" + response.status() +
                            ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
        }  else if (msg instanceof WebSocketFrame frame) {
            if (frame instanceof TextWebSocketFrame textFrame) {
                log.info("websocket client 接收到的消息：{}",textFrame.text());

                whenReceiveMessage(textFrame.text());

            } else if (frame instanceof PongWebSocketFrame) {
                log.info("WebSocket Client received pong");
            } else if (frame instanceof PingWebSocketFrame) {
                log.info("WebSocket Client received ping");
                websocketClient.sendPong();
                log.info("send pong");
            } else if (frame instanceof CloseWebSocketFrame) {
                log.info("websocket client关闭");
                ch.close();
            }
        }
    }



    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        if (!handshakeFuture.isDone()) {
            handshakeFuture.setFailure(cause);
        }
        ctx.close();
        log.error("业务处理错误，websocket client关闭", cause);
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        websocketClient.sendPing();
    }

    public ChannelFuture handshakeFuture() {
        return handshakeFuture;
    }
}

package com.helei.cexapi.netty.handler;

import com.helei.cexapi.netty.NettyConstants;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;


@Slf4j
public class RequestResponseHandler<T> {

    private final ConcurrentMap<String, HandlerEntity<T>> requestIdMap = new ConcurrentHashMap<>();


    /**
     * 注册request
     * @param id request的id
     * @return 是否注册成功
     */
    public boolean registryRequest(String id, Consumer<T> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        requestIdMap.compute(id, (k, v)->{
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", id, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 提交resoonse
     * @param id id
     * @param response response
     */
    public boolean submitResponse(String id, T response) {
        HandlerEntity<T> entity = requestIdMap.get(id);
        if (entity == null) {
            log.warn("request id[{}} didn't exist", id);
            return false;
        } else {
            long currentTimeMillis = System.currentTimeMillis();
            if (entity.expireTime < currentTimeMillis) {
                log.warn("request id[{}] expired, expire time[{}], currentTime[{}] cancel invoke callback",
                        id, entity.expireTime, currentTimeMillis);
                return false;
            } else {
                entity.callback.accept(response);
                log.debug("invoke request id[{}] callback success", id);
                return true;
            }
        }
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @EqualsAndHashCode
    static class HandlerEntity<T>{
        private long expireTime;

        private Consumer<T> callback;
    }
}

package com.helei.cexapi.netty;

import io.netty.util.AttributeKey;

public class NettyConstants {

    /**
     * 一朕的最大长度
     */
    public final static int MAX_FRAME_LENGTH = 1024;


    /**
     * 放在netty channel 里的 client id 的 key
     */
    public static final AttributeKey<String> ATTRIBUTE_KEY = AttributeKey.valueOf("clientId");

    /**
     * 请求等待时间
     */
    public static final long REQUEST_WAITE_SECONDS = 60;

    /**
     * netty客户端断线重连时间
     */
    public static final int RECONNECT_DELAY_SECONDS = 5;


    /**
     * netty客户端断线重连次数
     */
    public static final int RECONNECT_LIMIT = 3;
}


package com.helei.cexapi;

import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.BinanceWSApiClientHandler;
import com.helei.cexapi.binanceapi.supporter.IpWeightSupporter;

import java.net.InetSocketAddress;
import java.net.URISyntaxException;

public class CEXApiFactory {

    //TODO 配置化
    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7897);
//    private static InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7890);
//    private static InetSocketAddress proxy = null;

    public static BinanceWSApiClient binanceApiClient(
            int threadPoolSize,
            String url
    ) throws URISyntaxException {
        BinanceWSApiClientHandler handler = new BinanceWSApiClientHandler();

        BinanceWSApiClient client = new BinanceWSApiClient(
                threadPoolSize,
                url,
                new IpWeightSupporter("localIp"),
                handler
        );
        client.setProxy(proxy);
        return client;
    }
}

package com.helei.tradedatacenter.datasource;

import com.alibaba.fastjson.JSONArray;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.constants.KLineInterval;
import com.helei.tradedatacenter.conventor.KLineMapper;
import com.helei.tradedatacenter.entity.KLine;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * 历史k线数据源
 */
@Slf4j
public class HistoryKLineLoader {

    private final transient BinanceWSApiClient binanceWSApiClient;

    private final int limit;

    private final ExecutorService loadThreadPool;

    public HistoryKLineLoader(
            int limit,
            BinanceWSApiClient binanceWSApiClient,
            ExecutorService loadThreadPool
    ) {
        this.limit = limit;
        this.binanceWSApiClient = binanceWSApiClient;
        this.loadThreadPool = loadThreadPool;

    }

    public CompletableFuture<Long> startLoad (
            String symbol,
            KLineInterval interval,
            LocalDateTime startTime,
            Consumer<List<KLine>> batchKLineConsumer
    ) {
        String upperSymbol = symbol.toUpperCase();
        return CompletableFuture.supplyAsync(()->{

            long curTimeSecond = startTime.toInstant(ZoneOffset.UTC).getEpochSecond();

            while (curTimeSecond <= LocalDateTime.now().toInstant(ZoneOffset.UTC).getEpochSecond()) {
                CountDownLatch latch = new CountDownLatch(1);

                binanceWSApiClient
                        .getMarketApi()
                        .queryHistoryKLine(upperSymbol, interval, curTimeSecond, limit, (result) -> {
                            JSONArray jsonArray = result.getJSONArray("result");

                            List<KLine> collect = jsonArray.stream().map(e -> {
                                JSONArray kArr = (JSONArray) e;
                                KLine e1 = KLineMapper.mapJsonArrToKLine(kArr);
                                e1.setSymbol(upperSymbol);
                                return e1;
                            }).collect(Collectors.toList());

                            log.debug("history kline [{}]", collect);
                            batchKLineConsumer.accept(collect);

                            latch.countDown();
                        });

                try {
                    latch.await();
                } catch (InterruptedException e) {
                    log.error("CountDownLatch error", e);
                    break;
                }
                curTimeSecond += interval.getSecond() * limit;
            }
            return curTimeSecond;
        }, loadThreadPool);
    }
}

package com.helei.tradedatacenter.entity;

import com.helei.cexapi.binanceapi.constants.order.TradeSide;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 交易信号
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class TradeSignal {

    /**
     * 信号名
     */
    private String name;

    /**
     * 当前时间
     */
    private LocalDateTime createTime;

    /**
     * 交易方向
     */
    private TradeSide tradeSide;

    /**
     * 当前价格
     */
    private Double currentPrice;

    /**
     * 目标价格
     */
    private Double targetPrice;

    /**
     * 止损价格
     */
    private Double protectPrice;
}





package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Indicator;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;


@Slf4j
public abstract class BaseIndicatorCalculator<T extends Indicator> extends ProcessFunction<KLine, KLine> {

    private final String name;

    protected BaseIndicatorCalculator(String name) {
        this.name = name;
    }

    @Override
    public void processElement(KLine kLine, ProcessFunction<KLine, KLine>.Context context, Collector<KLine> collector){
        try {
            T Indicator = calculateInKLine(kLine);
            kLine.getIndicators().put(name, Indicator);
            collector.collect(kLine);
        } catch (Exception e) {
            log.error("calculate indicator error", e);
            throw new RuntimeException(e);
        }
    }

//    public abstract String indicatorKey(T indicator) throws Exception;

    /**
     * 计算指标，放进kLine里
     * @param kLine kLine
     * @return kLine
     */
    public abstract T calculateInKLine(KLine kLine) throws Exception;
}


package com.helei.tradedatacenter.signal;

import cn.hutool.core.util.BooleanUtil;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;

import java.io.IOException;


/**
 * 信号生成器的抽象类，会把传入的KLine分为两类
 * 1. 已完结的k线数据， kLine.end = true
 *      这样的k线数据，可以认为是历史k线数据，可用于状态更新。
 * 2、实时的k线数据， kLine.end = false
 *      实时数据，用于决策是否产出信号
 */
@Slf4j
public abstract class AbstractSignalMaker extends ProcessFunction<KLine, TradeSignal> {

    /**
     * 是否是一条k线只发出一个信号
     */
    private final boolean isAKLineSendOneSignal;

    /**
     * 当前k线，就是buildSignal(kline) 参数kline同意openTime的k线
     */
    private ValueState<KLine> curKLine;

    /**
     * 当前是否发出过信号
     */
    private ValueState<Boolean> isCurSendSignal;

    protected AbstractSignalMaker(boolean isAKLineSendOneSignal) {
        this.isAKLineSendOneSignal = isAKLineSendOneSignal;
    }

    @Override
    public void open(OpenContext openContext) throws Exception {
        curKLine = getRuntimeContext().getState(new ValueStateDescriptor<>("currentKLine", TypeInformation.of(KLine.class)));
        isCurSendSignal = getRuntimeContext().getState(new ValueStateDescriptor<>("isCurSendSignal", Boolean.class));

        this.onOpen(openContext);
    }


    @Override
    public void processElement(KLine kLine, ProcessFunction<KLine, TradeSignal>.Context context, Collector<TradeSignal> collector) throws Exception {
        try {
            if (BooleanUtil.isTrue(kLine.isEnd())) {
                stateUpdate(kLine);
            } else {
                TradeSignal signal = buildSignal(kLine);
                if (signal == null)  return;

                if (isAKLineSendOneSignal && BooleanUtil.isTrue(isCurSendSignal.value())) {
                    //当前k线发送过信号
                    log.info("已发送过macd信号");
                } else {
                    isCurSendSignal.update(true);
                    collector.collect(signal);
                    log.info("signal maker send a signal: [{}]", signal);
                }
            }
        } catch (Exception e) {
            log.error("build signal error", e);
            throw new RuntimeException(e);
        }

        updateCurKLine(kLine);
    }


    /**
     * onOpen.定义state的初始化等
     * @param openContext openContext
     * @throws Exception Exception
     */
    public abstract void onOpen(OpenContext openContext) throws Exception;


    /**
     * 更新状态，传入的k线是已完结的k线数据
     * @param kLine 已完结的k线数据
     */
    protected abstract void stateUpdate(KLine kLine) throws IOException;

    /**
     * 产生信号
     * @param kLine 实时推送的k线数据
     * @return 交易信号
     */
    protected abstract TradeSignal buildSignal(KLine kLine) throws IOException;



    /**
     * 更新当前k线，如果成功更新，还要将isSendSignal设置为false
     * @param cur cur
     * @throws IOException IOException
     */
    private void updateCurKLine(KLine cur) throws IOException {
        KLine last = curKLine.value();
        //存储的k线为空，或存储的k线的open时间与收到的open时间不同。说明当前k线发生变化，重置状态
        if (last == null || !last.getOpenTime().isEqual(cur.getOpenTime())) {
            curKLine.update(cur);
            isCurSendSignal.update(false );
        }
    }
}



package com.helei.tradedatacenter.signal;

import com.helei.cexapi.binanceapi.constants.order.TradeSide;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.MACD;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;

import java.io.IOException;


@Slf4j
public class MACDSignal_V1 extends AbstractSignalMaker{

    private final String macdName;



    /**
     * 上一跟MACD
     */
    private ValueState<MACD> lastMACD;

    /**
     * 水下金叉次数
     */
    private ValueState<Integer> underLineGoldAcrossCount;


    public MACDSignal_V1(String macdName) {
        super(true);
        this.macdName = macdName;
    }


    @Override
    public void onOpen(OpenContext openContext) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("lastMACD", TypeInformation.of(MACD.class));
        lastMACD = getRuntimeContext().getState(descriptor);

        underLineGoldAcrossCount = getRuntimeContext().getState(new ValueStateDescriptor<>("underLineGoldAcrossCount", Integer.class));

    }


    @Override
    protected void stateUpdate(KLine kLine) throws IOException {
        MACD lastMACD = this.lastMACD.value();

        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);


        if (lastMACD != null) {
            int acrossState = calGoldDeathAcross(lastMACD, currentMACD);

            //是否在水下
            boolean under = currentMACD.dif() <= 0;

            //水下金叉
            if (under && acrossState == 1) {
                underLineGoldAcrossCount.update(getUnderGoldAcrossCount() + 1);
            }
        }

        log.info("update macd signal state completed, last MACD[{}], current MACD[{}], underLineGoldAcrossCount[{}]", lastMACD, currentMACD, underLineGoldAcrossCount.value());
        this.lastMACD.update(currentMACD);
    }

    @Override
    protected TradeSignal buildSignal(KLine kLine) throws IOException {

        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);
        MACD lastMACD = this.lastMACD.value();

        if (lastMACD == null) {
            return null;
        }
        int acrossState = calGoldDeathAcross(lastMACD, currentMACD);
        boolean under = currentMACD.dif() <= 0;

        // 水下第二次金叉，产出买入信号
        if (under && acrossState == 1 && getUnderGoldAcrossCount() == 1) {
            return trySendSignal(TradeSignal
                    .builder()
                    .name(macdName)
                    .tradeSide(TradeSide.BUY)
                    .currentPrice(kLine.getClose())
                    .build());
        }

        // 水上死叉，卖出
        if (!under && acrossState == -1) {
            return trySendSignal(TradeSignal
                    .builder()
                    .name(macdName)
                    .tradeSide(TradeSide.SALE)
                    .currentPrice(kLine.getClose())
                    .build());
        }

        return null;
    }

    /**
     * 尝试发送， 必须满足未发送过信号的条件
     * @param signal signal
     * @return signal
     * @throws IOException IOException
     */
    private TradeSignal trySendSignal(TradeSignal signal) throws IOException {
        log.info("macd [{}]信号", signal.getTradeSide());
        return signal;
    }

    private int getUnderGoldAcrossCount() throws IOException {
        return underLineGoldAcrossCount.value() == null ? 0 : underLineGoldAcrossCount.value();
    }

    /**
     * 计算金叉死叉
     * @param last  上一次的MACD
     * @param current   当前MACD
     * @return  1 表示金叉， -1 表示死叉， 0 表示没有交叉
     */
    private int calGoldDeathAcross(MACD last, MACD current) {
        if ((last.dif() > last.getDea()) && (current.dif() <= current.getDea())) {
            return -1;
        }
        if ((last.dif() < last.getDea()) && (current.dif() >= current.getDea())) {
            return 1;
        }
        return 0;
    }
}


package com.helei.tradedatacenter;

import com.helei.tradedatacenter.datasource.BaseKLineSource;
import com.helei.tradedatacenter.decision.AbstractDecisionMaker;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.cexapi.binanceapi.dto.order.TradeOrder;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.calculater.BaseIndicatorCalculator;
import com.helei.tradedatacenter.order.AbstractOrderCommiter;
import com.helei.tradedatacenter.signal.AbstractSignalMaker;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class AutoTradeTask {

    /**
     * 环境
     */
    private final StreamExecutionEnvironment env;

    /**
     * k线数据源
     */
    private final BaseKLineSource memoryKLineSource;

    /**
     * 指标计算器
     */
    private final List<BaseIndicatorCalculator<? extends Indicator>> indicatorCalList;

    /**
     * 信号处理器
     */
    private final List<AbstractSignalMaker> signalMakers;

    /**
     * 决策器
     */
    private final List<AbstractDecisionMaker> decisionMakers;

    /**
     * 订单提交器
     */
    private final List<AbstractOrderCommiter> orderCommiters;


    public AutoTradeTask(StreamExecutionEnvironment env, BaseKLineSource memoryKLineSource) {
        // 设置 Flink 流环境
        this.env = env;

        this.memoryKLineSource = memoryKLineSource;

        this.indicatorCalList = new ArrayList<>();

        this.signalMakers = new ArrayList<>();

        this.decisionMakers = new ArrayList<>();

        this.orderCommiters = new ArrayList<>();
    }

    /**
     * 添加指标计算器
     * @param calculator 指标计算器
     * @return  this
     * @param <T>  指标类型
     */
    public <T extends Indicator> AutoTradeTask addIndicator(BaseIndicatorCalculator<T> calculator) {
        indicatorCalList.add(calculator);
        return this;
    }

    /**
     * 添加信号生成器
     * @param signalMaker 信号生成器
     * @return this
     */
    public AutoTradeTask addSignalMaker(AbstractSignalMaker signalMaker) {
        this.signalMakers.add(signalMaker);
        return this;
    }

    /**
     * 添加决策器
     * @param decisionMaker 决策器
     * @return this
     */
    public AutoTradeTask addDecisionMaker(AbstractDecisionMaker decisionMaker) {
        this.decisionMakers.add(decisionMaker);
        return this;
    }


    /**
     * 添加订单提交器
     * @param orderCommiter 订单提交器
     * @return this
     */
    public AutoTradeTask addOrderCommiter(AbstractOrderCommiter orderCommiter) {
        this.orderCommiters.add(orderCommiter);
        return this;
    }

    public void execute() throws Exception {
        //1. 使用自定义 SourceFunction 生成 K 线数据流
        DataStream<KLine> kLineStream = env.addSource(memoryKLineSource);

        // 2.指标处理，串行
        for (BaseIndicatorCalculator<? extends Indicator> calculator : indicatorCalList) {
            kLineStream = kLineStream.process(calculator);
        }

        if (signalMakers.isEmpty()) {
            throw new IllegalArgumentException("no signal maker");
        }

        //3, 信号处理,并行
        Iterator<AbstractSignalMaker> signalMakerIterator = signalMakers.iterator();

        DataStream<TradeSignal> signalStream = kLineStream.process(signalMakerIterator.next());

        while (signalMakerIterator.hasNext()) {
            signalStream.union(kLineStream.process(signalMakerIterator.next()));
        }


        if (decisionMakers.isEmpty()) {
            throw new IllegalArgumentException("no decision maker");
        }

        //4、决策器
        Iterator<AbstractDecisionMaker> decisionMakerIterator = decisionMakers.iterator();

        DataStream<TradeOrder> orderStream = signalStream.process(decisionMakerIterator.next());

        while (decisionMakerIterator.hasNext()) {
            orderStream.union(signalStream.process(decisionMakerIterator.next()));
        }


        //最后将决策走到订单提交器
        for (AbstractOrderCommiter orderCommiter : orderCommiters) {
            orderStream.addSink(orderCommiter);
        }

        env.execute("test1");
    }

}



package com.helei.tradedatacenter.decision;

import com.helei.cexapi.binanceapi.dto.order.TradeOrder;
import com.helei.tradedatacenter.entity.TradeSignal;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;

public abstract class AbstractDecisionMaker extends ProcessFunction<TradeSignal, TradeOrder> {

    @Override
    public void processElement(TradeSignal tradeSignal, ProcessFunction<TradeSignal, TradeOrder>.Context context, Collector<TradeOrder> collector) throws Exception {

    }

    public abstract TradeOrder decisionAndBuilderOrder(TradeSignal signal);
}


package com.helei.tradedatacenter.order;

import com.helei.cexapi.binanceapi.dto.order.BaseOrder;
import com.helei.cexapi.binanceapi.dto.order.TradeOrder;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.sink.RichSinkFunction;

@Slf4j
public abstract class AbstractOrderCommiter extends RichSinkFunction<BaseOrder> {


    @Override
    public void invoke(BaseOrder order, Context context) throws Exception {

        if (commitTradeOrder(order)) {
            log.info("Order committed successfully");
        } else {
            log.error("Order committed error");
            //TODO 重试？？
        }
    }

    public abstract boolean commitTradeOrder(BaseOrder order);
}


package com.helei.tradedatacenter.order;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.api.BinanceWSTradeApi;
import com.helei.cexapi.binanceapi.dto.order.BaseOrder;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ExecutionException;


/**
 * 币安订单提交
 */
@Slf4j
public class BinanceOrderCommiter extends AbstractOrderCommiter{

    private final BinanceWSTradeApi tradeApi;

    public BinanceOrderCommiter(BinanceWSApiClient binanceWSApiClient) {
        tradeApi = binanceWSApiClient.getTradeApi();
    }


    @Override
    public boolean commitTradeOrder(BaseOrder order) {
        JSONObject response = null;
        try {
            response = tradeApi.commitOrder(order).get();

            if (response == null) {
                log.error("get trade response is null");
                return false;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error("get trade response error", e);
        }


        return false;
    }
}


