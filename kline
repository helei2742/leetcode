package com.helei.tradedatacenter;

import com.helei.cexapi.binanceapi.constants.order.BaseOrder;
import com.helei.tradedatacenter.datasource.BaseKLineSource;
import com.helei.tradedatacenter.decision.AbstractDecisionMaker;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.calculater.BaseIndicatorCalculator;
import com.helei.tradedatacenter.indicator.calculater.PSTCalculator;
import com.helei.tradedatacenter.indicator.config.PSTConfig;
import com.helei.tradedatacenter.order.AbstractOrderCommitter;
import com.helei.tradedatacenter.signal.AbstractSignalMaker;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


public class AutoTradeTask {

    /**
     * 环境
     */
    private final StreamExecutionEnvironment env;

    /**
     * k线数据源
     */
    private final BaseKLineSource memoryKLineSource;

    /**
     * PST设置
     */
    private PSTConfig pstConfig;

    /**
     * 指标计算器
     */
    private final List<BaseIndicatorCalculator<? extends Indicator>> indicatorCalList;

    /**
     * 信号处理器
     */
    private final List<AbstractSignalMaker> signalMakers;

    /**
     * 决策器
     */
    private final List<AbstractDecisionMaker> decisionMakers;

    /**
     * 订单提交器
     */
    private final List<AbstractOrderCommitter> orderCommiters;


    public AutoTradeTask(StreamExecutionEnvironment env, BaseKLineSource memoryKLineSource) {
        // 设置 Flink 流环境
        this.env = env;

        this.memoryKLineSource = memoryKLineSource;

        this.indicatorCalList = new ArrayList<>();

        this.signalMakers = new ArrayList<>();

        this.decisionMakers = new ArrayList<>();

        this.orderCommiters = new ArrayList<>();
    }

    /**
     * 添加指标计算器
     *
     * @param calculator 指标计算器
     * @param <T>        指标类型
     * @return this
     */
    public <T extends Indicator> AutoTradeTask addIndicator(BaseIndicatorCalculator<T> calculator) {
        indicatorCalList.add(calculator);
        return this;
    }

    /**
     * 添加信号生成器
     *
     * @param signalMaker 信号生成器
     * @return this
     */
    public AutoTradeTask addSignalMaker(AbstractSignalMaker signalMaker) {
        this.signalMakers.add(signalMaker);
        return this;
    }

    /**
     * 添加决策器
     *
     * @param decisionMaker 决策器
     * @return this
     */
    public AutoTradeTask addDecisionMaker(AbstractDecisionMaker decisionMaker) {
        this.decisionMakers.add(decisionMaker);
        return this;
    }


    /**
     * 添加订单提交器
     *
     * @param orderCommiter 订单提交器
     * @return this
     */
    public AutoTradeTask addOrderCommiter(AbstractOrderCommitter orderCommiter) {
        this.orderCommiters.add(orderCommiter);
        return this;
    }

    public void execute(String name) throws Exception {
        //1. 使用自定义 SourceFunction 生成 K 线数据流
        KeyedStream<KLine, String> kLineStream = env.addSource(memoryKLineSource).keyBy(KLine::getStreamKey);

        //   支流，计算pst
        KeyedStream<KLine, String> pstStream = kLineStream.process(new PSTCalculator(pstConfig)).keyBy(KLine::getStreamKey);
        pstStream.

        // 2.指标处理，串行
        for (BaseIndicatorCalculator<? extends Indicator> calculator : indicatorCalList) {
            kLineStream = kLineStream.process(calculator).keyBy(KLine::getStreamKey);
        }

        if (signalMakers.isEmpty()) {
            throw new IllegalArgumentException("no signal maker");
        }

        //3, 信号处理,并行
        Iterator<AbstractSignalMaker> signalMakerIterator = signalMakers.iterator();

        KeyedStream<TradeSignal, String> signalStream = kLineStream.process(signalMakerIterator.next()).keyBy(signal -> signal.getKLine().getStreamKey());

        while (signalMakerIterator.hasNext()) {
            signalStream.union(kLineStream.process(signalMakerIterator.next()));
        }


        if (decisionMakers.isEmpty()) {
            throw new IllegalArgumentException("no decision maker");
        }

        //4、决策器，
        Iterator<AbstractDecisionMaker> decisionMakerIterator = decisionMakers.iterator();

        KeyedStream<BaseOrder, String> orderStream = signalStream.process(decisionMakerIterator.next()).keyBy(BaseOrder::getSymbol);

        while (decisionMakerIterator.hasNext()) {
            orderStream.union(signalStream.process(decisionMakerIterator.next()));
        }


        //最后将决策走到订单提交器
        for (AbstractOrderCommitter orderCommitter : orderCommiters) {
            orderStream.addSink(orderCommitter);
        }

        env.execute(name);
    }

}
package com.helei.tradedatacenter.signal;

import com.helei.cexapi.binanceapi.constants.order.TradeSide;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.MACD;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.TimerService;

import java.io.IOException;


@Slf4j
public class MACDSignal_V1 extends AbstractSignalMaker{

    private final String macdName;


    /**
     * 上一跟MACD
     */
    private ValueState<MACD> lastMACD;

    /**
     * 水下金叉次数
     */
    private ValueState<Integer> underLineGoldAcrossCount;


    public MACDSignal_V1(String macdName) {
        super(true);
        this.macdName = macdName;
    }


    @Override
    public void onOpen(OpenContext openContext) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("lastMACD", TypeInformation.of(MACD.class));
        lastMACD = getRuntimeContext().getState(descriptor);

        underLineGoldAcrossCount = getRuntimeContext().getState(new ValueStateDescriptor<>("underLineGoldAcrossCount", Integer.class));

    }


    @Override
    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws IOException {
        MACD lastMACD = this.lastMACD.value();

        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);



        if (lastMACD != null) {
            //是否在水下
            boolean under = currentMACD.dif() <= 0;
            int acrossState = calGoldDeathAcross(lastMACD, currentMACD);

            //水下金叉
            if (under && acrossState == 1) {
                underLineGoldAcrossCount.update(getUnderGoldAcrossCount() + 1);
            }

            return trySendSignal(kLine, under, acrossState);
        }

        log.info("update macd signal state completed, last MACD[{}], current MACD[{}], underLineGoldAcrossCount[{}]", lastMACD, currentMACD, underLineGoldAcrossCount.value());
        this.lastMACD.update(currentMACD);

        return null;
    }

    @Override
    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws IOException {

        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);
        MACD lastMACD = this.lastMACD.value();

        if (lastMACD == null) {
            return null;
        }
        int acrossState = calGoldDeathAcross(lastMACD, currentMACD);
        boolean under = currentMACD.dif() <= 0;

        return trySendSignal(kLine, under, acrossState);
    }

    /**
     * 尝试发送信号
     * @param kLine kLine
     * @param under 是否水下交叉
     * @param acrossState 交叉形态
     * @return  信号，不适合产生信号则返回null
     */
    private TradeSignal trySendSignal(KLine kLine, boolean under, int acrossState) throws IOException {
        // 水下第二次金叉，产出买入信号
        if (under && acrossState == 1 && getUnderGoldAcrossCount() == 1) {
            return sendSignal(kLine, TradeSide.BUY);
        }

        // 水上死叉，卖出
        if (!under && acrossState == -1) {
            return sendSignal(kLine, TradeSide.SALE);
        }

        return null;
    }

    /**
     * 尝试发送， 必须满足未发送过信号的条件
     * @return signal
     * @throws IOException IOException
     */
    private TradeSignal sendSignal(KLine kLine, TradeSide tradeSide) throws IOException {
        TradeSignal signal = TradeSignal
                .builder()
                .name(macdName)
                .tradeSide(tradeSide)
                .kLine(kLine)
                .currentPrice(kLine.getClose())
                .build();
        log.info("macd [{}]信号", signal.getTradeSide());
        return signal;
    }


    private int getUnderGoldAcrossCount() throws IOException {
        return underLineGoldAcrossCount.value() == null ? 0 : underLineGoldAcrossCount.value();
    }


    /**
     * 计算金叉死叉
     * @param last  上一次的MACD
     * @param current   当前MACD
     * @return  1 表示金叉， -1 表示死叉， 0 表示没有交叉
     */
    private int calGoldDeathAcross(MACD last, MACD current) {
        if ((last.dif() > last.getDea()) && (current.dif() <= current.getDea())) {
            return -1;
        }
        if ((last.dif() < last.getDea()) && (current.dif() >= current.getDea())) {
            return 1;
        }
        return 0;
    }
}

package com.helei.tradedatacenter.signal;

import com.helei.cexapi.binanceapi.constants.order.TradeSide;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.Boll;
import com.helei.tradedatacenter.indicator.config.BollConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.TimerService;

import java.io.IOException;
import java.time.LocalDateTime;

@Slf4j
public class BollSignalMaker extends AbstractSignalMaker{

    private final BollConfig bollConfig;
    
    /**
     * 上一个实时k
     */
    private ValueState<KLine> lastRealTimeKLineState;


    protected BollSignalMaker(BollConfig bollConfig) {
        super(true);
        this.bollConfig = bollConfig;
    }

    @Override
    public void onOpen(OpenContext openContext) throws Exception {
        lastRealTimeKLineState = getRuntimeContext().getState(new ValueStateDescriptor<>(bollConfig.getIndicatorName() + "_lastKLineState", TypeInformation.of(KLine.class)));
    }


    @Override
    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws IOException {
        return tryBuildCenterSignal(kLine);
    }

    @Override
    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws IOException {
        return tryBuildUpDownSignal(kLine);
    }

    /**
     * 上下轨信号
     * @param kLine kLine
     * @return TradeSignal
     */
    private TradeSignal tryBuildUpDownSignal(KLine kLine) throws IOException {
        KLine lastRealTimeKLine = lastRealTimeKLineState.value();
        if (lastRealTimeKLine == null) {
            return null;
        }

        Boll boll = kLine.getIndicator(bollConfig);
        if (boll == null) return null;

        double price = kLine.getClose();
        Double upper = boll.getUpper();
        Double lower = boll.getLower();
        Double sma = boll.getSma();

        //1.上下轨信号
        if (price >= upper) { //触碰boll上轨，卖出信号
            return buildSignal(kLine, TradeSide.SALE, "触碰boll上轨");
        }
        if (price <= lower) { //触碰boll下轨，买入信号
            return buildSignal(kLine, TradeSide.BUY, "触碰boll下轨");
        }

        lastRealTimeKLineState.update(kLine);
        return null;
    }

    /**
     * 中轨穿越信号
     * @param kLine kLine
     * @return TradeSignal
     */
    private TradeSignal tryBuildCenterSignal(KLine kLine){
        Boll curBoll = kLine.getIndicator(bollConfig);
        if (curBoll == null) return null;

        if (kLine.getOpen() < curBoll.getSma() && kLine.getClose() > curBoll.getSma()) { //上穿中轨
            return buildSignal(kLine, TradeSide.BUY, "上穿中轨");
        }

        if (kLine.getOpen() < curBoll.getSma() && kLine.getClose() < curBoll.getSma()) {
            return buildSignal(kLine, TradeSide.SALE, "下穿中轨");
        }

        return null;
    }

    private TradeSignal buildSignal(KLine kLine, TradeSide tradeSide, String description) {
        return TradeSignal.builder()
                .name(bollConfig.getIndicatorName())
                .description(description)
                .tradeSide(tradeSide)
                .currentPrice(kLine.getClose())
                .kLine(kLine)
                .createTime(LocalDateTime.now())
                .build();
    }
}
package com.helei.tradedatacenter.signal;

import cn.hutool.core.util.BooleanUtil;
import com.helei.tradedatacenter.dto.TrendLine;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.PST;
import com.helei.tradedatacenter.indicator.config.IndicatorConfig;
import com.helei.tradedatacenter.indicator.config.PSTConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.streaming.api.TimerService;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;

import java.io.IOException;
import java.util.Set;


/**
 * 信号生成器的抽象类，会把传入的KLine分为两类
 * 1. 已完结的k线数据， kLine.end = true
 * 这样的k线数据，可以认为是历史k线数据，可用于状态更新。
 * 2、实时的k线数据， kLine.end = false
 * 实时数据，用于决策是否产出信号
 */
@Slf4j
public abstract class AbstractSignalMaker extends KeyedProcessFunction<String, KLine, TradeSignal> {

    /**
     * 是否是一条k线只发出一个信号
     */
    private final boolean isAKLineSendOneSignal;

    /**
     * 当前k线，就是buildSignal(kline) 参数kline同意openTime的k线
     */
    private ValueState<KLine> curKLine;

    /**
     * 前一条已完结的k线
     */
    protected ValueState<KLine> lastHistoryKLine;

    /**
     * 当前是否发出过信号
     */
    private ValueState<Boolean> isCurSendSignal;


    protected AbstractSignalMaker(boolean isAKLineSendOneSignal) {
        this.isAKLineSendOneSignal = isAKLineSendOneSignal;
    }

    @Override
    public void open(OpenContext openContext) throws Exception {
        curKLine = getRuntimeContext().getState(new ValueStateDescriptor<>("currentKLine", TypeInformation.of(KLine.class)));
        lastHistoryKLine = getRuntimeContext().getState(new ValueStateDescriptor<>("lastHistoryKLine", TypeInformation.of(KLine.class)));
        isCurSendSignal = getRuntimeContext().getState(new ValueStateDescriptor<>("isCurSendSignal", Boolean.class));

        this.onOpen(openContext);
    }

    @Override
    public void processElement(KLine kLine, KeyedProcessFunction<String, KLine, TradeSignal>.Context context, Collector<TradeSignal> collector) throws Exception {
        try {

            TradeSignal tradeSignal;

            if (BooleanUtil.isTrue(kLine.isEnd())) { //历史k线发出的信号打上标识
                tradeSignal = resolveHistoryKLine(kLine, context.timerService());
                if (tradeSignal == null) return;
                tradeSignal.setIsExpire(true);
            } else {
                tradeSignal = resolveRealTimeKLine(kLine, context.timerService());
                if (tradeSignal == null) return;
                tradeSignal.setIsExpire(false);
            }

            if (isAKLineSendOneSignal && BooleanUtil.isTrue(isCurSendSignal.value())) {
                //当前k线发送过信号
                log.warn("this kLine sent signal, cancel send this time");
            } else {
                isCurSendSignal.update(true);
                collector.collect(tradeSignal);

                log.info("signal maker send a signal: [{}]", tradeSignal);
            }
        } catch (Exception e) {
            log.error("build signal error", e);
            throw new RuntimeException(e);
        }

        //更新历史k，实时k
        updateCurKLine(kLine);
    }


    @Override
    public void onTimer(long timestamp, KeyedProcessFunction<String, KLine, TradeSignal>.OnTimerContext ctx, Collector<TradeSignal> out) throws Exception {
        TradeSignal tradeSignal = buildTimerSignal();
        if (tradeSignal != null) {
            log.info("signal maker send a timer signal: [{}]", tradeSignal);
            out.collect(tradeSignal);
        }
    }


    /**
     * onOpen.定义state的初始化等
     *
     * @param openContext openContext
     * @throws Exception Exception
     */
    public abstract void onOpen(OpenContext openContext) throws Exception;


    /**
     * 更新状态，传入的k线是已完结的k线数据
     *
     * @param kLine        已完结的k线数据
     * @param timerService timerService
     */
    protected abstract TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws IOException;

    /**
     * 产生信号
     *
     * @param kLine        实时推送的k线数据
     * @param timerService timerService
     * @return 交易信号
     */
    protected abstract TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws IOException;


    /**
     * 产出定时信号，要触发，先要调用 context.timerService().registerProcessingTimeTimer(timer);
     * @return TradeSignal
     * @throws IOException IOException
     */
    protected TradeSignal buildTimerSignal() throws IOException {
        return null;
    }

    /**
     * 更新当前k线，如果成功更新，还要将isSendSignal设置为false
     *
     * @param cur cur
     * @throws IOException IOException
     */
    private void updateCurKLine(KLine cur) throws IOException {
        KLine last = curKLine.value();
        //存储的k线为空，或存储的k线的open时间与收到的open时间不同。说明当前k线发生变化，重置状态
        if (last == null || !last.getOpenTime().isEqual(cur.getOpenTime())) {
            curKLine.update(cur);
            isCurSendSignal.update(false);
        }
        if (cur.isEnd()) {
            lastHistoryKLine.update(cur);
        }
    }
}

package com.helei.tradedatacenter.indicator;

import com.helei.tradedatacenter.dto.TrendLine;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.io.Serializable;
import java.util.List;

/**
 * 支撑、压力、趋势线
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class PST implements Indicator, Serializable {

    /**
     * 压力线
     */
    private List<Double> pressure;

    /**
     * 支撑线
     */
    private List<Double> support;

    /**
     * 上趋势线,根据相对高点计算
     */
    private TrendLine relativeUpTrendLine;

    /**
     * 下趋势线，根据相对低点计算
     */
    private TrendLine relativeDownTrendLine;

    /**
     * 最大值
     */
    private double maxPrice;

    /**
     * 最小值
     */
    private double minPrice;

    @Override
    public Indicator clone() {
        return new PST(pressure, support, relativeUpTrendLine, relativeDownTrendLine, maxPrice, minPrice);
    }

}

package com.helei.tradedatacenter.indicator;

import java.io.Serializable;


/**
 * 指标接口
 */
public interface Indicator extends Serializable {


    Indicator clone();

}
package com.helei.tradedatacenter.indicator.config;

import com.helei.tradedatacenter.indicator.RSI;
import lombok.Getter;

@Getter
public class RSIConfig extends IndicatorConfig<RSI> {
    private final int period;

    public RSIConfig(int period) {
        super(RSI.class);
        this.period = period;
    }

    @Override
    public String getIndicatorName() {
        return name + "-" + period;
    }
}


package com.helei.tradedatacenter.indicator.config;

import com.helei.tradedatacenter.indicator.PST;
import lombok.Getter;

@Getter
public class PSTConfig extends IndicatorConfig<PST>{
    private final int pressureCount;

    private final int supportCount;

    private final int windowLength;


    public PSTConfig(int pressureCount, int supportCount, int windowLength) {
        super(PST.class);
        this.pressureCount = pressureCount;
        this.supportCount = supportCount;
        this.windowLength = windowLength;
    }

    @Override
    public String getIndicatorName() {
        return name + "-" + supportCount + "-" + supportCount + "-" + windowLength;
    }
}


package com.helei.tradedatacenter.indicator.config;

import com.helei.tradedatacenter.indicator.MA;
import lombok.Getter;

@Getter
public class MAConfig extends IndicatorConfig<MA>{
    private final int period;

    public MAConfig(final int period) {
        super(MA.class);
        this.period = period;
    }

    @Override
    public String getIndicatorName() {
        return name + "-" + period;
    }
}
package com.helei.tradedatacenter.indicator.config;

import com.helei.tradedatacenter.indicator.MACD;
import lombok.Getter;

@Getter
public class MACDConfig extends IndicatorConfig<MACD>{
    private int ema1Period = 12;

    private int ema2Period = 26;

    private int deaPeriod = 9;

    public MACDConfig(int ema1Period, int ema2Period, int deaPeriod) {
        super(MACD.class);
        this.ema1Period = ema1Period;
        this.ema2Period = ema2Period;
        this.deaPeriod = deaPeriod;
    }

    public MACDConfig() {
        super(MACD.class);
    }

    @Override
    public String getIndicatorName() {
        return name + "-" + ema1Period + "-" + ema2Period + "-" + deaPeriod;
    }
}

package com.helei.tradedatacenter.indicator.config;

import com.alibaba.fastjson.JSONObject;

/**
 * 指标配置
 */
public abstract class IndicatorConfig<T> {
    public final Class<T> indicatorClass;

    public final String name;

    public final JSONObject config = new JSONObject();;

    protected IndicatorConfig(Class<T> indicatorClass) {
        this.indicatorClass = indicatorClass;
        this.name = indicatorClass.getSimpleName();
    }

    public abstract String getIndicatorName();
}


package com.helei.tradedatacenter.indicator.config;

import com.helei.tradedatacenter.indicator.EMA;
import lombok.Getter;

@Getter
public class EMAConfig extends IndicatorConfig<EMA>{
    private final int period;

    public EMAConfig(int period) {
        super(EMA.class);
        this.period = period;
    }

    @Override
    public String getIndicatorName() {
        return name + "-" +period;
    }
}

package com.helei.tradedatacenter.indicator.config;


import com.helei.tradedatacenter.indicator.Boll;
import lombok.Getter;

@Getter
public class BollConfig extends IndicatorConfig<Boll> {

    private final int period;

    public BollConfig(int period) {
        super(Boll.class);
        this.period = period;
    }

    @Override
    public String getIndicatorName() {
        return name + "-" + period;
    }
}

package com.helei.tradedatacenter.indicator;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Boll implements Indicator{

    private Double sma;

    private Double upper;

    private Double lower;

    @Override
    public Indicator clone() {
        return null;
    }
}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.RSI;
import com.helei.tradedatacenter.indicator.config.RSIConfig;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;

public class RSICalculator extends BaseIndicatorCalculator<RSI>{
    private final int period;

    private ValueState<Double> rsiState;

    public RSICalculator(RSIConfig rsiConfig) {
        super(rsiConfig);
        this.period = rsiConfig.getPeriod();
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        rsiState = getRuntimeContext().getState(new ValueStateDescriptor<>(indicatorConfig.getIndicatorName() + "_rsiState", Double.class));
    }

//    @Override
//    public String indicatorKey(RSI indicator) {
//        return "RSI-" + period;
//    }

    @Override
    public RSI calculateInKLine(KLine kLine) throws IOException {
        Double rsi = rsiState.value();

        if (rsi == null) {
            rsi = 50.0;
        }

        Double open = kLine.getOpen();
        Double close = kLine.getClose();


        rsi = CalculatorUtil.calculateRSI(open, close, rsi, period);

        rsiState.update(rsi);

        return new RSI(rsi);
    }
}

package com.helei.tradedatacenter.indicator.calculater;

import cn.hutool.core.util.BooleanUtil;
import com.helei.tradedatacenter.dto.TrendLine;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.PST;
import com.helei.tradedatacenter.indicator.config.PSTConfig;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.configuration.Configuration;

import java.time.ZoneOffset;
import java.util.*;

/**
 * 计算压力线，支撑线，趋势线
 */
public class PSTCalculator extends BaseIndicatorCalculator<PST> {

    private final int pCount;

    private final int sCount;

    private final int windowLength;

    private ListState<KLine> windowDataState;

    public PSTCalculator(PSTConfig pstConfig) {
        super(pstConfig);
        this.windowLength = pstConfig.getWindowLength();
        this.pCount = pstConfig.getPressureCount();
        this.sCount = pstConfig.getSupportCount();
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        this.windowDataState = getRuntimeContext().getListState(new ListStateDescriptor<>(indicatorConfig.getIndicatorName() + "-WindowData", TypeInformation.of(KLine.class)));
    }

    @Override
    public PST calculateInKLine(KLine kLine) throws Exception {
        if (BooleanUtil.isFalse(kLine.isEnd())) return null;


        LinkedList<KLine> priceList = new LinkedList<>();

        for (KLine line : windowDataState.get()) {
            priceList.add(line);
        }
        priceList.add(kLine);
        while (priceList.size() > windowLength) {
            priceList.remove(0);
        }

        windowDataState.update(priceList);

        if (priceList.size() < 3) {
            return null;
        }

        // 相对高点
        List<KLine> high = new ArrayList<>();
        // 相对低点
        List<KLine> low = new ArrayList<>();
        //压力
        List<Double> pList = new ArrayList<>();
        //支持
        List<Double> sList = new ArrayList<>();


        int[] mmIdx = calRelativeHL(priceList, high, low, pList, sList);

        return calPST(priceList, high, low, pList, sList, mmIdx);
    }

    private PST calPST(LinkedList<KLine> priceList, List<KLine> high, List<KLine> low, List<Double> pList, List<Double> sList, int[] mmIdx) {
        int maxIdx = mmIdx[0];
        int minIdx = mmIdx[1];

        TrendLine upTrendLine = CalculatorUtil.calculateTrend(
                CalculatorUtil.getLastMonotonicPart(high, KLine::getHigh),
                k -> Double.valueOf(k.getOpenTime().toInstant(ZoneOffset.UTC).getEpochSecond()),
                KLine::getHigh
        );
        TrendLine downTrendLine = CalculatorUtil.calculateTrend(
                CalculatorUtil.getLastMonotonicPart(low, KLine::getLow),
                k -> Double.valueOf(k.getOpenTime().toInstant(ZoneOffset.UTC).getEpochSecond()),
                KLine::getLow
        );

        return PST
                .builder()
                .pressure(new ArrayList<>(pList.subList(0, Math.max(0,  Math.min(pList.size()-1, pCount)))))
                .support(new ArrayList<>(sList.subList(0, Math.max(0, Math.min(sList.size()-1, sCount)))))
                .relativeUpTrendLine(upTrendLine)
                .relativeDownTrendLine(downTrendLine)
                .maxPrice(priceList.get(maxIdx).getHigh())
                .minPrice(priceList.get(minIdx).getLow())
                .build();
    }



    private int[] calRelativeHL(LinkedList<KLine> priceList, List<KLine> high, List<KLine> low, List<Double> pList, List<Double> sList) {
        int maxIdx = 0;
        int minIdx = 0;

        KLine pre = priceList.get(0);
        KLine cur = priceList.get(1);
        //取趋势线,
        for (int i = 3; i < priceList.size(); i++) {
             KLine next = priceList.get(i);
             //相对低点
             if (cur.getLow() < next.getLow() && pre.getLow() > cur.getLow()) {
                 low.add(cur);
                 //添加压力线，为前一个的相对高点
                 if (!high.isEmpty()) {
                     pList.add(high.get(high.size() - 1).getHigh());
                 }
             }

             //相对高点
             if (cur.getHigh() > next.getClose() && pre.getHigh() < cur.getHigh()) {
                 high.add(cur);
                 //添加支撑线，为前一个的相对低点
                 if (!low.isEmpty()) {
                     sList.add(low.get(low.size() - 1).getLow());
                 }
             }

//             最值点
             if (priceList.get(maxIdx).getHigh() < next.getHigh()) {
                 maxIdx = priceList.size() - 1;
             }
             if (priceList.get(minIdx).getLow() > next.getLow()) {
                 minIdx = priceList.size() - 1;
             }
             pre = cur;
             cur = next;
         }
        return new int[]{maxIdx, minIdx};
    }
}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.MACD;
import com.helei.tradedatacenter.indicator.config.MACDConfig;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;

import java.io.IOException;

public class MACDCalculator extends BaseIndicatorCalculator<MACD> {
    private final int ema1Period;

    private final int ema2Period;

    private final int deaPeriod;

    private transient ValueState<MACD> macdState;


    public MACDCalculator(MACDConfig macdConfig) {
        super(macdConfig);
        this.ema1Period = macdConfig.getEma1Period();
        this.ema2Period = macdConfig.getEma2Period();
        this.deaPeriod = macdConfig.getDeaPeriod();
    }


    @Override
    public void open(org.apache.flink.configuration.Configuration parameters) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("macdState", TypeInformation.of(MACD.class));
        macdState = getRuntimeContext().getState(descriptor);
    }

//    @Override
//    public String indicatorKey(MACD indicator) {
//        return "MACE" +  ema1Period + "-"  + ema2Period + "-" + deaPeriod;
//    }

    @Override
    public MACD calculateInKLine(KLine kLine) throws IOException {
        Double close = kLine.getClose();
        MACD macd = macdState.value();

        if (macd == null) {
            macd = new MACD(close, close, close);
        }

        double ema1 = macd.getEma1();
        double ema2 = macd.getEma2();
        double dea = macd.getDea();

        // 计算新的 EMA12 和 EMA26

        ema1 = CalculatorUtil.calculateEMA(close, ema1, ema1Period);
        ema2 = CalculatorUtil.calculateEMA(close, ema2, ema2Period);

        // 计算 DIF
        double dif = ema1 - ema2;
        dea = CalculatorUtil.calculateEMA(dif, dea, deaPeriod);

        macd.setEma1(ema1);
        macd.setEma2(ema2);
        macd.setDea(dea);
        macdState.update(macd);
        return macd;
    }

}

package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.MA;
import com.helei.tradedatacenter.indicator.config.MAConfig;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;

/**
 * SMA
 */
public class MACalculator extends BaseIndicatorCalculator<MA> {

    private final int period;

    private transient ValueState<Double> maState;

    public MACalculator(MAConfig maConfig) {
        super(maConfig);
        this.period = maConfig.getPeriod();
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        this.maState = getRuntimeContext().getState(new ValueStateDescriptor<>("maState", Double.class));
    }


    @Override
    public MA calculateInKLine(KLine kLine) throws IOException {
        Double ma = this.maState.value();
        Double close = kLine.getClose();

        if (ma == null) {
            ma = close;
        }

        ma = CalculatorUtil.calculateMA(close, ma, period);

        maState.update(ma);
        return new MA(ma);
    }
}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.EMA;
import com.helei.tradedatacenter.indicator.config.EMAConfig;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;


public class EMACalculator extends BaseIndicatorCalculator<EMA>{
    private final int period;

    private ValueState<Double> emaState;

    public EMACalculator(EMAConfig emaConfig) {
        super(emaConfig);
        this.period = emaConfig.getPeriod();
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        emaState = getRuntimeContext().getState(new ValueStateDescriptor<>("emaState", Double.class));
    }


    @Override
    public EMA calculateInKLine(KLine kLine) throws IOException {
        Double ema = emaState.value();
        Double close = kLine.getClose();
        if (ema == null) {
            ema = close;
        }

        ema = CalculatorUtil.calculateEMA(close, ema, period);
        emaState.update(ema);
        return new EMA(ema);
    }
}

package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Boll;
import com.helei.tradedatacenter.indicator.config.BollConfig;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.util.LinkedList;

public class BollCalculator extends BaseIndicatorCalculator<Boll> {

    private final int period;

    private transient ListState<Double> priceListState;

    public BollCalculator(BollConfig bollConfig) {
        super(bollConfig);
        this.period = bollConfig.getPeriod();
    }

    @Override
    public void open(Configuration parameters) throws Exception {

        priceListState = getRuntimeContext().getListState(new ListStateDescriptor<>("priceListState", Double.class));
    }

    @Override
    public Boll calculateInKLine(KLine kLine) throws Exception {
        LinkedList<Double> priceList = new LinkedList<>();
        for (Double price : priceListState.get()) {
            priceList.add(price);
        }
        priceList.add(kLine.getClose());

        while (priceList.size() > period) {
            priceList.remove(0);
        }
        priceListState.update(priceList);


        // 计算 SMA
        if (priceList.size() == period) {
            double sma = calculateSMA(priceList);

            // 计算标准差
            double stddev = calculateStandardDeviation(priceList, sma);

            // 计算布林带上下轨
            double upperBand = sma + 2 * stddev;
            double lowerBand = sma - 2 * stddev;

            return new Boll(sma, upperBand, lowerBand);
        }
        return null;
    }

    // 计算简单移动平均线（SMA）
    private double calculateSMA(LinkedList<Double> prices) {
        double sum = 0.0;
        for (Double price : prices) {
            sum += price;
        }
        return sum / prices.size();
    }

    // 计算标准差
    private double calculateStandardDeviation(LinkedList<Double> prices, double sma) {
        double sumSquaredDiffs = 0.0;
        for (Double price : prices) {
            sumSquaredDiffs += Math.pow(price - sma, 2);
        }
        return Math.sqrt(sumSquaredDiffs / prices.size());
    }

}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.config.IndicatorConfig;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;


@Slf4j
public abstract class BaseIndicatorCalculator<T extends Indicator> extends KeyedProcessFunction<String, KLine, KLine> {

    protected final IndicatorConfig indicatorConfig;

    protected BaseIndicatorCalculator(IndicatorConfig indicatorConfig) {
        this.indicatorConfig = indicatorConfig;
    }

    @Override
    public void processElement(KLine kLine, KeyedProcessFunction<String, KLine, KLine>.Context context, Collector<KLine> collector) throws Exception {
        try {
            T Indicator = calculateInKLine(kLine);
            kLine.getIndicators().put(indicatorConfig, Indicator);
            collector.collect(kLine);
        } catch (Exception e) {
            log.error("calculate indicator error", e);
            throw new RuntimeException(e);
        }
    }

    /**
     * 计算指标，放进kLine里
     *
     * @param kLine kLine
     * @return kLine
     */
    public abstract T calculateInKLine(KLine kLine) throws Exception;
}

package com.helei.tradedatacenter.entity;

import com.helei.cexapi.binanceapi.constants.order.TradeSide;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 交易信号
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class TradeSignal {

    /**
     * 信号名
     */
    private String name;

    /**
     * 信号描述
     */
    private String description;

    /**
     * 发出这个信号的k线
     */
    private KLine kLine;

    /**
     * 当前时间
     */
    private LocalDateTime createTime;

    /**
     * 交易方向
     */
    private TradeSide tradeSide;

    /**
     * 当前价格
     */
    private Double currentPrice;

    /**
     * 目标价格
     */
    private Double targetPrice;

    /**
     * 止损价格
     */
    private Double protectPrice;

    /**
     * 信号是否过期
     */
    private Boolean isExpire;
}

package com.helei.tradedatacenter.entity;

import com.helei.cexapi.binanceapi.constants.KLineInterval;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.config.IndicatorConfig;
import lombok.*;

import java.io.Serial;
import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.HashMap;

/**
 * K线实体类
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class KLine implements Serializable {

    @Serial
    private static final long serialVersionUID = 8888L; // 显式声明 serialVersionUID

    public  static final KLine HISTORY_END_KLINE = KLine.builder().symbol("HISTORY_END_KLINE").build();

    public  static final KLine STREAM_END_KLINE = KLine.builder().symbol("STREAM_END_KLINE").build();

    /**
     * symbol
     */
    private String symbol;

    /**
     * 开盘价格
     */
    private double open;

    /**
     * 收盘价格
     */
    private double close;

    /**
     * 最高价格
     */
    private double high;

    /**
     * 最低价格
     */
    private double low;

    /**
     * 成交量
     */
    private double volume;

    /**
     * 开盘时间
     */
    private LocalDateTime openTime;

    /**
     * 收盘时间
     */
    private LocalDateTime closeTime;


    /**
     * 这根线是否执行完
     */
    private boolean end;

    /**
     * k线频率
     */
    private KLineInterval kLineInterval;

    /**
     * 存放各种指标以及他的值
     */
    private HashMap<IndicatorConfig<? extends Indicator>, Indicator> indicators = new HashMap<>();


    public <T extends Indicator> T getIndicator(IndicatorConfig<T> config) {
        Indicator indicator = indicators.get(config);
        if (indicator == null) return null;
        return (T) indicator;
    }

    /**
     * 获取stream流名称
     * @return stream流名称
     */
    public String getStreamKey() {
        return symbol + "@kline_" + kLineInterval.getDescribe();
    }

    @Override
    public String toString() {
        return "KLine{" +
                "symbol='" + symbol + '\'' +
                ", open=" + open +
                ", close=" + close +
                ", high=" + high +
                ", low=" + low +
                ", volume=" + volume +
                ", openTime=" + openTime +
                ", closeTime=" + closeTime +
                ", end=" + end +
                ", indicators=" + indicators +
                '}';
    }
}



package com.helei.tradedatacenter.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;


/**
 * 盈亏比
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class ProfitLoss {

    private Double support;

    private Double pressure;

}



package com.helei.tradedatacenter.decision;


import com.helei.cexapi.binanceapi.constants.order.BaseOrder;
import com.helei.tradedatacenter.entity.TradeSignal;

/**
 * 根据PST和Boll指标决策下单
 */
public class PSTBollDecisionMaker extends AbstractDecisionMaker {

    private final String bollKey;

    private final String pstKey;


    public PSTBollDecisionMaker(String bollKey, String pstKey) {
        this.bollKey = bollKey;
        this.pstKey = pstKey;
    }


    @Override
    public BaseOrder decisionAndBuilderOrder(TradeSignal signal) {


        return null;
    }
}



