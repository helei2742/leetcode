package com.helei.tradedatacenter.datasource;

import com.helei.cexapi.binanceapi.constants.KLineInterval;
import com.helei.tradedatacenter.entity.KLine;

import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.HashMap;
import java.util.Random;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;

public class RandomKLineSource extends BaseKLineSource {

    private final String symbol;

    private final AtomicLong startTimeStamp;

    private final Random random = new Random();

    private final Double maxPrice;

    private final Double minPrice;

    public RandomKLineSource(String symbol, KLineInterval kLineInterval, LocalDateTime startTimeStamp, Double maxPrice, Double minPrice) {
        super(kLineInterval);
        this.symbol = symbol;

        this.startTimeStamp = new AtomicLong(startTimeStamp.toInstant(ZoneOffset.UTC).toEpochMilli());
        this.maxPrice = maxPrice;
        this.minPrice = minPrice;
    }

    @Override
    protected KLine loadKLine() throws Exception {

        double nextLow = minPrice + (maxPrice - minPrice) * random.nextDouble();
        double nextHigh = nextLow + (maxPrice - nextLow) * random.nextDouble();
        double nextOpen = nextLow + (nextHigh - nextLow) * random.nextDouble();
        double nextClose = nextLow + (nextHigh - nextLow) * random.nextDouble();

        double volume = 10 + (Double.MAX_VALUE / 2 - 10) * random.nextDouble();

        long plus = kLineInterval.getSecond() * 1000;
        long openTime = startTimeStamp.getAndAdd(plus);

        TimeUnit.MILLISECONDS.sleep(200);

        KLine kLine = new KLine(symbol, nextOpen, nextClose, nextHigh, nextLow, volume, openTime, openTime + plus - 1000, true, kLineInterval, new HashMap<>());
        return kLine;
    }
}
package com.helei.tradedatacenter.support;


import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.binanceapi.BinanceWSApiClient;
import com.helei.cexapi.binanceapi.constants.KLineInterval;
import com.helei.cexapi.constants.WebSocketUrl;
import com.helei.tradedatacenter.AutoTradeTask;
import com.helei.tradedatacenter.TradeSignalService;
import com.helei.tradedatacenter.datasource.MemoryKLineDataPublisher;
import com.helei.tradedatacenter.datasource.MemoryKLineSource;
import com.helei.tradedatacenter.datasource.RandomKLineSource;
import com.helei.tradedatacenter.dto.OriginOrder;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.resolvestream.GroupSignalResolver;
import com.helei.tradedatacenter.resolvestream.decision.PSTBollDecisionMaker;
import com.helei.tradedatacenter.resolvestream.decision.config.PSTBollDecisionConfig_v1;
import com.helei.tradedatacenter.resolvestream.indicator.calculater.BollCalculator;
import com.helei.tradedatacenter.resolvestream.indicator.calculater.MACDCalculator;
import com.helei.tradedatacenter.resolvestream.indicator.calculater.PSTCalculator;
import com.helei.tradedatacenter.resolvestream.indicator.config.BollConfig;
import com.helei.tradedatacenter.resolvestream.indicator.config.MACDConfig;
import com.helei.tradedatacenter.resolvestream.indicator.config.PSTConfig;
import com.helei.tradedatacenter.resolvestream.order.AbstractOrderCommitter;
import com.helei.tradedatacenter.resolvestream.signal.BollSignalMaker;
import com.helei.tradedatacenter.resolvestream.signal.PSTSignalMaker;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@SpringBootTest
public class RandomKLineSourceTest {
    private static String btcusdt = "btcusdt";

    private static String ethusdt = "ethusdt";

    private static RandomKLineSource btc_1d_source;


    @Autowired
    @Qualifier("flinkEnv")
    private StreamExecutionEnvironment env;

    @Autowired
    @Qualifier("flinkEnv2")
    private StreamExecutionEnvironment env2;


    @BeforeAll
    public static void before() {
        try {
            btc_1d_source = new RandomKLineSource(btcusdt, KLineInterval.d_1, LocalDateTime.of(2022, 10, 3, 0, 0),2000.0, 19000.0);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testAutoTradeV2() throws Exception {
        PSTConfig pstConfig = new PSTConfig(60, 3, 3);

        BollConfig bollConfig = new BollConfig(15);
        TradeSignalService tradeSignalService = TradeSignalService
                .builder(env)
                .buildResolver()
                .addKLineSource(btc_1d_source)
                .addIndicator(new PSTCalculator(pstConfig))
                .addIndicator(new MACDCalculator(new MACDConfig(12, 26, 9)))
                .addIndicator(new BollCalculator(bollConfig))
                .addSignalMaker(new BollSignalMaker(bollConfig))
                .addSignalMaker(new PSTSignalMaker(pstConfig))
                .addGroupSignalResolver(new GroupSignalResolver() {
                    private transient BufferedWriter writer;

                    @Override
                    public void open(Configuration parameters) throws Exception {
                        writer = new BufferedWriter(new FileWriter("test-kline-file.txt", true));
                    }

                    @Override
                    public void invoke(Tuple2<KLine, List<TradeSignal>> value, Context context) throws Exception {
                        List<TradeSignal> list = value.getField(1);

//                        if (list.isEmpty()) return;

                        writer.write("\n<<start>>\n");
                        writer.write(value.getField(0).toString());
                        writer.newLine();

                        for (TradeSignal tradeSignal : list) {
                            writer.write(tradeSignal.toString());
                        }
                        writer.write("\n<<end>>\n");
                        writer.flush();
                    }

                    // 任务结束时调用，关闭文件流
                    @Override
                    public void close() throws Exception {
                        if (writer != null) {
                            writer.flush();
                            writer.close(); // 关闭文件流
                        }
                        super.close();
                    }
                })
//                .addSignalMaker(new PSTSignalMaker(pstConfig))
                .addInService()
                .build();

        AutoTradeTask autoTradeTask = new AutoTradeTask(tradeSignalService);

        autoTradeTask
                .addDecisionMaker(new PSTBollDecisionMaker(new PSTBollDecisionConfig_v1(pstConfig, bollConfig)))
                .addOrderCommiter(new AbstractOrderCommitter() {
                    @Override
                    public boolean commitTradeOrder(OriginOrder order) {
                        System.out.println(order);
                        return false;
                    }
                })
                .execute("test");
    }

}


package com.helei.tradedatacenter;

import com.helei.tradedatacenter.datasource.BaseKLineSource;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.resolvestream.GroupSignalResolver;
import com.helei.tradedatacenter.resolvestream.SignalSplitResolver;
import com.helei.tradedatacenter.resolvestream.indicator.Indicator;
import com.helei.tradedatacenter.resolvestream.indicator.calculater.BaseIndicatorCalculator;
import com.helei.tradedatacenter.resolvestream.signal.AbstractSignalMaker;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.state.*;
import org.apache.flink.api.common.typeinfo.BasicTypeInfo;
import org.apache.flink.api.common.typeinfo.TypeHint;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.BroadcastStream;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;

import java.util.*;
import java.util.function.Function;


@Slf4j
@Getter
public class TradeSignalService {
    /**
     * 环境
     */
    private final StreamExecutionEnvironment env;


    private final List<TradeSignalStreamResolver> resolverList;

    public TradeSignalService(StreamExecutionEnvironment env) {
        this.env = env;
        this.resolverList = new ArrayList<>();
    }


    public static TradeSignalServiceBuilder builder(StreamExecutionEnvironment env) {
        return new TradeSignalServiceBuilder(new TradeSignalService(env));
    }


    /**
     * 添加信号流处理器
     *
     * @param resolver resolver
     */
    public void addTradeSignalStreamResolver(TradeSignalStreamResolver resolver) {
        this.resolverList.add(resolver);
    }


    /**
     * 当前信号流处理器是否为空
     *
     * @return boolean
     */
    public boolean isEmpty() {
        return resolverList.isEmpty();
    }


    /**
     * 获取联合的交易信号流，，根据交易对名symbol进行的keyby
     *
     * @return KeyedStream
     */
    public KeyedStream<TradeSignal, String> getCombineTradeSignalStream() {
        if (resolverList.isEmpty()) {
            log.error("没有添加信号流处理器");
            throw new IllegalArgumentException("没有添加信号流处理器");
        }

        DataStream<TradeSignal> combineStream = resolverList.get(0).makeSignalStream();
        for (int i = 1; i < resolverList.size(); i++) {
            combineStream.union(resolverList.get(i).makeSignalStream());
        }

        return combineStream.keyBy(TradeSignal::getStreamKey);
    }

    /**
     * 交易信号流处理器
     */
    @Getter
    public static class TradeSignalStreamResolver {
        /**
         * 环境
         */
        private final StreamExecutionEnvironment env;

        /**
         * k线数据源
         */
        private BaseKLineSource kLineSource;

        /**
         * 指标计算器
         */
        private final List<BaseIndicatorCalculator> indicatorCalList;

        /**
         * 信号处理器
         */
        private final List<AbstractSignalMaker> signalMakers;

        /**
         * 分组信号处理器，会将信号按k线进行分组
         */
        private final List<GroupSignalResolver> groupSignalResolvers;


        private final MapStateDescriptor<String, Tuple2<KLine, List<TradeSignal>>> broadcastStateDescriptor = new MapStateDescriptor<>("broadcast-close-kline",
                BasicTypeInfo.STRING_TYPE_INFO, TypeInformation.of(new TypeHint<Tuple2<KLine, List<TradeSignal>>>() {
        }));


        public TradeSignalStreamResolver(StreamExecutionEnvironment env) {
            this.env = env;

            this.indicatorCalList = new ArrayList<>();

            this.signalMakers = new ArrayList<>();

            this.groupSignalResolvers = new ArrayList<>();
        }


        /**
         * 开始执行产生信号流
         *
         * @return 信号流
         */
        public DataStream<TradeSignal> makeSignalStream() {
            if (kLineSource == null) {
                throw new IllegalArgumentException("未添加k线数据源");
            }

            //1. 使用自定义 SourceFunction 生成 K 线数据流
            KeyedStream<KLine, String> kLineStream = env.addSource(kLineSource).keyBy(KLine::getStreamKey);

//            kLineStream.print();
            // 2.指标处理，串行
            for (BaseIndicatorCalculator<?> calculator : indicatorCalList) {
                kLineStream = kLineStream.process(calculator).keyBy(KLine::getStreamKey);
            }
//            kLineStream.print();
            if (signalMakers.isEmpty()) {
                throw new IllegalArgumentException("没有信号生成器");
            }

            //3, 信号处理,并行
            Iterator<AbstractSignalMaker> signalMakerIterator = signalMakers.iterator();

            DataStream<TradeSignal> signalStream = kLineStream.process(signalMakerIterator.next());

            while (signalMakerIterator.hasNext()) {

                signalStream.union(kLineStream.process(signalMakerIterator.next()));
            }


            if (!groupSignalResolvers.isEmpty()) {
                buildAndSinkGroupStream(kLineStream, signalStream);
            }

            return signalStream;
        }


        /**
         * 根据kline中已完结k线，将signal按照k线进行分组。得到新的流后调用GroupSignalResolver进行sink
         *
         * @param kLineStream  kLineStream
         * @param signalStream signalStream
         */
        private void buildAndSinkGroupStream(KeyedStream<KLine, String> kLineStream, DataStream<TradeSignal> signalStream) {

            BroadcastStream<TradeSignal> broadcastSignalStream = signalStream.broadcast(broadcastStateDescriptor);

            DataStream<Tuple2<KLine, List<TradeSignal>>> groupSignalStream = kLineStream
                    .connect(broadcastSignalStream)
                    .process(new SignalSplitResolver(broadcastStateDescriptor));

            for (GroupSignalResolver groupSignalResolver : groupSignalResolvers) {
                groupSignalStream.addSink(groupSignalResolver);
            }
        }
    }

    public static class TradeSignalServiceBuilder {

        private final TradeSignalService tradeSignalService;

        public TradeSignalServiceBuilder(TradeSignalService tradeSignalService) {
            this.tradeSignalService = tradeSignalService;
        }

        public TradeSignalStreamResolverBuilder buildResolver() {
            return new TradeSignalStreamResolverBuilder(tradeSignalService.getEnv(), resolver -> {
                tradeSignalService.addTradeSignalStreamResolver(resolver);
                return this;
            });
        }


        public TradeSignalService build() {
            return tradeSignalService;
        }
    }

    public static class TradeSignalStreamResolverBuilder {

        private final TradeSignalStreamResolver tradeSignalStreamResolver;

        private final Function<TradeSignalStreamResolver, TradeSignalServiceBuilder> addInService;


        TradeSignalStreamResolverBuilder(StreamExecutionEnvironment env, Function<TradeSignalStreamResolver, TradeSignalServiceBuilder> addInService) {
            this.tradeSignalStreamResolver = new TradeSignalStreamResolver(env);
            this.addInService = addInService;
        }


        /**
         * 设置数据源
         *
         * @param kLineSource 数据源
         * @return this
         */
        public TradeSignalStreamResolverBuilder addKLineSource(BaseKLineSource kLineSource) {
            tradeSignalStreamResolver.kLineSource = kLineSource;
            return this;
        }

        /**
         * 添加指标计算器
         *
         * @param calculator 指标计算器
         * @param <>         指标类型
         * @return this
         */
        public TradeSignalStreamResolverBuilder addIndicator(BaseIndicatorCalculator calculator) {
            tradeSignalStreamResolver.getIndicatorCalList().add(calculator);
            return this;
        }

        /**
         * 添加信号生成器
         *
         * @param signalMaker 信号生成器
         * @return this
         */
        public TradeSignalStreamResolverBuilder addSignalMaker(AbstractSignalMaker signalMaker) {
            tradeSignalStreamResolver.getSignalMakers().add(signalMaker);
            return this;
        }


        /**
         * 添加组信号处理器
         *
         * @param groupSignalResolver 组信号处理器
         * @return this
         */
        public TradeSignalStreamResolverBuilder addGroupSignalResolver(GroupSignalResolver groupSignalResolver) {
            tradeSignalStreamResolver.getGroupSignalResolvers().add(groupSignalResolver);
            return this;
        }


        public TradeSignalServiceBuilder addInService() {
            return addInService.apply(tradeSignalStreamResolver);
        }
    }
}
package com.helei.tradedatacenter.resolvestream;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.api.common.state.*;
import org.apache.flink.api.common.typeinfo.TypeHint;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.co.KeyedBroadcastProcessFunction;
import org.apache.flink.util.Collector;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;


@Slf4j
public class SignalSplitResolver extends KeyedBroadcastProcessFunction<String, KLine, TradeSignal, Tuple2<KLine, List<TradeSignal>>> {

    private final MapStateDescriptor<String, Map<Long, List<TradeSignal>>> broadcastStateDescriptor;

    private final String SIGNAL_CACHE_KEY = "signalCache";

    private ValueState<Tuple2<KLine, List<TradeSignal>>> timebaseSignalState;


    public SignalSplitResolver(MapStateDescriptor<String, Map<Long, List<TradeSignal>>> broadcastStateDescriptor) {
        this.broadcastStateDescriptor = broadcastStateDescriptor;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        timebaseSignalState = getRuntimeContext().getState(new ValueStateDescriptor<>("timebaseSignalState", TypeInformation.of(new TypeHint<Tuple2<KLine, List<TradeSignal>>>() {})));
    }

    @Override
    public void processElement(KLine kLine, KeyedBroadcastProcessFunction<String, KLine, TradeSignal, Tuple2<KLine, List<TradeSignal>>>.ReadOnlyContext readOnlyContext, Collector<Tuple2<KLine, List<TradeSignal>>> collector) throws Exception {
        // 从状态中获取划分规则
        Tuple2<KLine, List<TradeSignal>> curTuple = timebaseSignalState.value();

        if (curTuple == null) {
            timebaseSignalState.update(new Tuple2<>(kLine, new ArrayList<>()));
        }
        if (!kLine.isEnd()) return;
        // 来到新的k线
        //更新当前k状态
        BroadcastState<String, Tuple2<KLine, List<TradeSignal>>> broadcastState = context.getBroadcastState(broadcastStateDescriptor);

        Tuple2<KLine, List<TradeSignal>> tuple2 = broadcastState.get(SIGNAL_CACHE_KEY);

        if (tuple2 != null) collector.collect(tuple2);

        broadcastState.put(SIGNAL_CACHE_KEY, new Tuple2<>(kLine, new ArrayList<>()));

    }

    @Override
    public void processBroadcastElement(TradeSignal signal, KeyedBroadcastProcessFunction<String, KLine, TradeSignal, Tuple2<KLine, List<TradeSignal>>>.Context context, Collector<Tuple2<KLine, List<TradeSignal>>> collector) throws Exception {
        BroadcastState<String, Map<Long, List<TradeSignal>>> signalState = context.getBroadcastState(broadcastStateDescriptor);

        Map<Long, List<TradeSignal>> timebaseSignals = signalState.get(SIGNAL_CACHE_KEY);

        Long timebase = signal.getKLine().getOpenTime();

        timebaseSignals.compute(timebase, (k,v)->{
            if (v == null) {
                v = new ArrayList<>();
            }
            v.add(signal);
            return v;
        });

        return;
    }
}

