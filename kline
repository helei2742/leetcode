package com.helei.cexapi.binanceapi.base;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.dto.StreamSubscribeEntity;
import com.helei.cexapi.binanceapi.dto.WebSocketCommandBuilder;
import com.helei.cexapi.binanceapi.supporter.BinanceWSStreamSupporter;
import com.helei.cexapi.binanceapi.supporter.IpWeightSupporter;
import com.helei.cexapi.binanceapi.supporter.SignatureUtil;
import com.helei.cexapi.netty.base.AbstractWebsocketClient;
import com.helei.cexapi.binanceapi.constants.WebSocketCommandType;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.security.InvalidKeyException;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;

/**
 * 币按ws接口客户端抽象类
 */
@Slf4j
public class AbstractBinanceWSApiClient extends AbstractWebsocketClient<JSONObject, JSONObject> {

    /**
     * 处理ip限制相关
     */
    private final IpWeightSupporter ipWeightSupporter;


    /**
     * 处理stream流相关
     */
    private final BinanceWSStreamSupporter binanceWSStreamSupporter;

    protected ASKey asKey;


    public AbstractBinanceWSApiClient(
            int threadPoolSize,
            String url,
            IpWeightSupporter ipWeightSupporter,
            BinanceWSStreamSupporter binanceWSStreamSupporter,
            AbstractBinanceWSApiClientHandler handler
    ) throws URISyntaxException {
        super(threadPoolSize, url, handler);

        this.ipWeightSupporter = ipWeightSupporter;

        this.binanceWSStreamSupporter = binanceWSStreamSupporter;
    }


    @Override
    public void submitStreamResponse(String streamName, JSONObject message) {
        binanceWSStreamSupporter.publishStreamResponse(streamName, message, callbackInvoker);
    }



    /**
     * 发生请求
     * @param ipWeight ip weight
     * @param id   请求的id
     * @param request   请求体
     * @param callback  回调
     */
    public void sendRequest(
            int ipWeight,
            String id,
            JSONObject request,
            Consumer<JSONObject> callback
    ) {
        sendRequest(ipWeight, id, request, false, callback);
    }
    /**
     * 发生请求
     * @param ipWeight ip weight
     * @param id   请求的id
     * @param request   请求体
     * @param isSignature   是否签名
     * @param callback  回调
     */
    public void sendRequest(
            int ipWeight,
            String id,
            JSONObject request,
            boolean isSignature,
            Consumer<JSONObject> callback
    ) {
        if (ipWeightSupporter.submitIpWeight(ipWeight)) {

            //需要签名
            if (isSignature) {
                JSONObject params = request.getJSONObject("params");
                params.put("timestamp", System.currentTimeMillis());
                try {
                    params.put("signature", SignatureUtil.signatureHMAC(asKey.getSecretKey(), params));
                } catch (InvalidKeyException e) {
                    throw new IllegalArgumentException("signature params error");
                }
                params.put("apiKey", asKey.getApiKey());
            }

            super.sendRequest(id, request, response -> {
                if (response != null) {
                    log.debug("send request id[{}] success, response[{}]", id, response);
                    JSONObject result = response.getJSONObject("result");
                    callback.accept(result == null ? new JSONObject(): result);
                } else {
                    callback.accept(null);
                    log.error("send request id[{}] fail", id);
                }
            });
        } else {
            log.warn("current ipWeight[{}] not support send request", ipWeightSupporter.currentWeight());
        }
    }
    /**
     * 订阅stream
     * @param symbol 需订阅的币种symbol
     * @param subList 需订阅的类型
     */
    public void subscribeStream(String symbol, List<StreamSubscribeEntity> subList) {
        WebSocketCommandBuilder builder = WebSocketCommandBuilder.builder().setCommandType(WebSocketCommandType.SUBSCRIBE);

        AtomicBoolean isSignature = new AtomicBoolean(false);
        subList.forEach(e->{
            if (e.isSignature()) {
                isSignature.set(true);
            }
            builder.addArrayParam(e.getStreamName());
        });
        JSONObject command = builder.build();

        log.info("subscribe stream command: {}", command);

        String id = command.getString("id");

        sendRequest(1, id, command, isSignature.get(), response -> {
            if (response != null) {
                log.debug("get subscribe response: {}", response);
                binanceWSStreamSupporter.addSubscribe(symbol, subList);
            }else {
                log.error("get subscribe response error, requestId[{}]", id);
            }
        });
    }
}


package com.helei.cexapi.binanceapi.dto;


import lombok.Data;

@Data
public class ASKey {

    /**
     * apikey，websocket时防请求参数体里，http时放在请求头
     */
    private String apiKey;

    /**
     * secretKey，用于加密算法计算签名，放在请求参数里
     */
    private String secretKey;
}

package com.helei.cexapi.binanceapi.constants;


import lombok.Getter;
import java.util.Map;


@Getter
public enum WebSocketStreamType {

    /**
     * 交易流归集，推送交易信息，是对单一订单的集合
     */
    AGG_TRADE("aggTrade", (symbol, params) -> symbol + "@aggTrade"),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+0 时区的。
     * Stream 名称: <symbol>@kline_<interval
     */
    KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。此更新是基于 UTC+8 时区的。
     * UTC+8 时区偏移量：
     * K线间隔的开始和结束时间会基于 UTC+8 时区。例如， 1d K线将在 UTC+8 当天开始，并在 UTC+8 当日完结时随之结束。
     * 请注意，Payload中的 E（event time），t（start time）和 T（close time）是 Unix 时间戳，它们始终以 UTC 格式解释。
     * Stream 名称: <symbol>@kline_<interval>@+08:00
     */
    MOVE_KLINE("kline", (symbol, params) -> symbol + "@kline_" + params.get(WebSocketStreamParamKey.KLINE_INTERVAL) + "@" + params.get(WebSocketStreamParamKey.KLINE_TIMEZONE)),

    /**
     * K线stream逐秒推送所请求的K线种类(最新一根K线)的更新。
     *
     * 合约类型:
     * perpetual 永续合约
     * current_quarter 当季交割合约
     * next_quarter 次季交割合约
     * 订阅Kline需要提供间隔参数,最短为分钟线,最长为月线。支持以下间隔:
     *
     * m -> 分钟; h -> 小时; d -> 天; w -> 周; M -> 月
     */
    CONTINUOUS_KLINE("continuousKline", (symbol, params) ->
            String.format("%s_%s@continuousKline_%s", symbol, params.get(WebSocketStreamParamKey.CONTRACT_TYPE), params.get(WebSocketStreamParamKey.KLINE_INTERVAL))),

    /**
     * 按Symbol刷新的最近24小时精简ticker信息
     * Stream 名称: <symbol>@miniTicker
     */
    MINI_TICKER("miniTicker", (symbol, params) -> symbol + "@miniTicker"),

    /**
     * 按Symbol刷新的24小时完整ticker信息
     */
    TICKER("ticker",  (symbol, params) -> symbol + "@ticker"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_TICKER("!ticker@arr", (symbol, params) -> "@!ticker@arr"),

    /**
     * 所有symbol 24小时完整ticker信息.需要注意的是，只有发生变化的ticker更新才会被推送。
     */
    ALL_MINI_TICKER("!miniTicker@arr", (symbol, params) -> "!miniTicker@arr"),

    /**
     * 最新标记价格
     */
    MARK_PRICE("markPrice", (symbol, params) -> symbol + "@markPrice"),

    /**
     * 全市场最新标记价格
     */
    ALL_MARK_PRICE("!markPrice@arr", (symbol, params) -> "!markPrice@arr")
    ;


    WebSocketStreamType(String description, AbstractBinanceWSSHandler handler) {
        this.description = description;
        this.handler = handler;
    }

    private final String description;

    private final AbstractBinanceWSSHandler handler;


    public interface AbstractBinanceWSSHandler {
        String buildStreamName(String symbol, Map<String, Object> params);
    }
}



package com.helei.cexapi.binanceapi.constants;

/**
 * stream name 里参数的key
 */
public class WebSocketStreamParamKey {

    /**
     * k线频率
     */
    public static final String KLINE_INTERVAL = "interval";

    /**
     * k线时区
     */
    public static final String KLINE_TIMEZONE = "timezone";

    /**
     * 合约类型
     */
    public static final String CONTRACT_TYPE = "contractType";

    /**
     * 签名需要的参数 apiKey
     */
    public static final String API_KEY = "apiKey";

    /**
     * 签名需要的参数 secretKey
     */
    public static final String SECRET_KEY = "secretKey";

}

package com.helei.cexapi.binanceapi.supporter;


import com.alibaba.fastjson.JSONObject;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;

/**
 * 处理secret key签名相关
 */
public class SignatureUtil {

    private final static Mac sha256_HMAC;

    static {
        try {
            sha256_HMAC = Mac.getInstance("HmacSHA256");
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 计算signature
     * @param secretKey secretKey
     * @param params params
     * @return signature
     */
    public static String signatureHMAC(String secretKey, JSONObject params) throws InvalidKeyException {
        StringBuilder payload = new StringBuilder();

        params.keySet().stream().sorted().forEach(key->{
            payload.append(key).append("=").append(params.get(key)).append("&");
        });

        if (!payload.isEmpty()) {
            payload.deleteCharAt(payload.length()-1);
        }
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), "HmacSHA256");

        sha256_HMAC.init(secretKeySpec);

        byte[] hash = sha256_HMAC.doFinal(payload.toString().getBytes(StandardCharsets.UTF_8));

        return Base64.getEncoder().encodeToString(hash);
    }
}


package com.helei.cexapi;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.binanceapi.BinanceWSApiClientClient;
import com.helei.cexapi.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.cexapi.binanceapi.constants.WebSocketStreamParamKey;
import com.helei.cexapi.binanceapi.constants.WebSocketStreamType;
import com.helei.cexapi.binanceapi.dto.ASKey;
import com.helei.cexapi.binanceapi.dto.StreamSubscribeEntity;
import com.helei.cexapi.constants.WebSocketUrl;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.concurrent.TimeUnit;


class BinanceWSApiClientTest {
    private static BinanceWSApiClientClient binanceWSApiClient = null;

    @BeforeAll
    public static void before() {
        try {
            binanceWSApiClient = CEXApiFactory.binanceApiClient(5, WebSocketUrl.WS_STREAM_URL);
            binanceWSApiClient.connect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testAGG_TRADE() throws InterruptedException {
        binanceWSApiClient.getStreamApi()
                .builder()
                .symbol("btcusdt")
                .addSubscribeEntity(
                        WebSocketStreamType.AGG_TRADE,
                        (streamName, result) -> {
                            System.out.println(streamName);
                        }
                )
                .subscribe();

        TimeUnit.SECONDS.sleep(100);
    }

    @Test
    public void testKLine() throws InterruptedException {
        binanceWSApiClient
                .setSignature(new ASKey())
                .getStreamApi()
                .builder()
                .symbol("btcusdt")
                .addSubscribeEntity(
                        StreamSubscribeEntity
                                .builder()
                                .symbol("btcusdt")
                                .subscribeType(WebSocketStreamType.KLINE)
                                .invocationHandler((streamName, result) -> {
                                    System.out.println("<<<<<<======================");
                                    System.out.println(streamName);
                                    System.out.println(result);
                                    System.out.println("======================>>>>>>");
                                })
                                .isSignature(true)
                                .build()
                        .addParam(WebSocketStreamParamKey.KLINE_INTERVAL, "1m")
                         .addParam(WebSocketStreamParamKey.SECRET_KEY, "123")
                                .addParam(WebSocketStreamParamKey.API_KEY, "123")
                )
                .subscribe();

        TimeUnit.SECONDS.sleep(100);
    }
}

package com.helei.tradedatacenter.constants;

/**
 * 指标类型
 */
public enum IndicatorType {
    MA,
    EMA,
    MACD,
    BOLL,
    RSI
}


package com.helei.tradedatacenter.conventer;

import com.alibaba.fastjson.JSONObject;
import com.helei.tradedatacenter.entity.KLine;
import org.mapstruct.BeanMapping;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;


@Mapper
public interface KLineMapper {

    @BeanMapping(resultType = KLine.class, ignoreByDefault = true)
    @Mapping(target = "closeTime",expression = "java(Instant.ofEpochMilli(jsonObject.getLong(\"T\")).atZone(ZoneId.systemDefault()).toLocalDateTime())")
    @Mapping(target = "openTime",expression = "java(Instant.ofEpochMilli(jsonObject.getLong(\"t\")).atZone(ZoneId.systemDefault()).toLocalDateTime())")
    @Mapping(target = "s", expression = "java(jsonObject.getDouble(\"symbol\"))")
    @Mapping(target = "high", expression = "java(jsonObject.getDouble(\"h\"))")
    @Mapping(target = "low", expression = "java(jsonObject.getDouble(\"l\"))")
    @Mapping(target = "open", expression = "java(jsonObject.getDouble(\"o\"))")
    @Mapping(target = "close", expression = "java(jsonObject.getDouble(\"c\"))")
    @Mapping(target = "volume", expression = "java(jsonObject.getDouble(\"v\"))")
    @Mapping(target = "end", expression = "java(jsonObject.getDouble(\"x\"))")
    KLine jsonObj2KLine(JSONObject json);

    KLineMapper INSTANCE = Mappers.getMapper(KLineMapper.class);

}



package com.helei.tradedatacenter.datasource;

import com.alibaba.fastjson.JSONObject;
import com.helei.tradedatacenter.conventer.KLineMapper;
import com.helei.tradedatacenter.entity.KLine;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.source.SourceFunction;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.atomic.AtomicBoolean;


/**
 * 内存的k线数据源
 */
@Slf4j
public class MemoryKLineSource implements SourceFunction<KLine> {
    private final ArrayBlockingQueue<JSONObject> blockingQueue = new ArrayBlockingQueue<>(10);
    private final AtomicBoolean isRunning = new AtomicBoolean(true);

    @Override
    public void run(SourceContext<KLine> ctx) throws Exception {
        JSONObject originKLine = null;
        while (isRunning.get()) {
            originKLine = blockingQueue.take();

            KLine kLine = KLineMapper.INSTANCE.jsonObj2KLine(originKLine);
            if (kLine != null) {
//                if (kLine.isEnd()) {
                    ctx.collect(kLine);
//                    log.debug("append end kLine [{}]", kLine);
//                }
            } else {
                log.warn("origin kLine data warn, originKLine={}", originKLine);
            }
        }
    }

    @Override
    public void cancel() {
        isRunning.set(false);
    }
}

package com.helei.tradedatacenter.entity;

import com.helei.tradedatacenter.constants.IndicatorType;
import com.helei.tradedatacenter.indicator.Indicator;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.Map;

/**
 * K线实体类
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class KLine {

    /**
     * symbol
     */
    private String symbol;

    /**
     * 开盘价格
     */
    private Double open;

    /**
     * 收盘价格
     */
    private Double close;

    /**
     * 最高价格
     */
    private Double high;

    /**
     * 最低价格
     */
    private Double low;

    /**
     * 成交量
     */
    private Double volume;

    /**
     * 开盘时间
     */
    private LocalDateTime openTime;

    /**
     * 收盘时间
     */
    private LocalDateTime closeTime;


    /**
     * 这根线是否执行完
     */
    private boolean end;

    /**
     * 存放各种指标以及他的值
     */
    private Map<String, Indicator> indicators;
}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Indicator;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;


@Slf4j
public abstract class BaseIndicatorCalculator<T extends Indicator> extends KeyedProcessFunction<String, KLine, KLine> {

    @Override
    public void processElement(KLine kLine, KeyedProcessFunction<String, KLine, KLine>.Context context, Collector<KLine> collector){
        try {
            T Indicator = calculateInKLine(kLine);
            kLine.getIndicators().put(indicatorKey(Indicator), Indicator);
            collector.collect(kLine);
        } catch (Exception e) {
            log.error("calculate indicator error", e);
            throw new RuntimeException(e);
        }
    }

    public abstract String indicatorKey(T indicator) throws Exception;

    /**
     * 计算指标，放进kLine里
     * @param kLine kLine
     * @return kLine
     */
    public abstract T calculateInKLine(KLine kLine) throws Exception;
}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Boll;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.util.LinkedList;

public class BollCalculator extends BaseIndicatorCalculator<Boll> {

    private final int period;

    private transient ListState<Double> priceListState;

    public BollCalculator(int period) {
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {

        priceListState = getIterationRuntimeContext().getListState(new ListStateDescriptor<>("priceListState", Double.class));
    }

    @Override
    public String indicatorKey(Boll indicator) throws Exception {

        return "";
    }

    @Override
    public Boll calculateInKLine(KLine kLine) throws Exception {
        LinkedList<Double> priceList = new LinkedList<>();
        for (Double price : priceListState.get()) {
            priceList.add(price);
        }
        priceList.add(kLine.getClose());

        while (priceList.size() > period) {
            priceList.remove(0);
        }
        priceListState.update(priceList);


        // 计算 SMA
        if (priceList.size() == period) {
            double sma = calculateSMA(priceList);

            // 计算标准差
            double stddev = calculateStandardDeviation(priceList, sma);

            // 计算布林带上下轨
            double upperBand = sma + 2 * stddev;
            double lowerBand = sma - 2 * stddev;

            return new Boll(sma, upperBand, lowerBand);
        }
        return null;
    }

    // 计算简单移动平均线（SMA）
    private double calculateSMA(LinkedList<Double> prices) {
        double sum = 0.0;
        for (Double price : prices) {
            sum += price;
        }
        return sum / prices.size();
    }

    // 计算标准差
    private double calculateStandardDeviation(LinkedList<Double> prices, double sma) {
        double sumSquaredDiffs = 0.0;
        for (Double price : prices) {
            sumSquaredDiffs += Math.pow(price - sma, 2);
        }
        return Math.sqrt(sumSquaredDiffs / prices.size());
    }

}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.EMA;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;

public class EMACalculator extends BaseIndicatorCalculator<EMA>{
    private final int period;

    private ValueState<Double> emaState;

    public EMACalculator(int period) {
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        emaState = getRuntimeContext().getState(new ValueStateDescriptor<>("emaState", Double.class));
    }

    @Override
    public String indicatorKey(EMA indicator) {
        return "EMA-"+period;
    }

    @Override
    public EMA calculateInKLine(KLine kLine) throws IOException {
        Double ema = emaState.value();
        Double close = kLine.getClose();
        if (ema == null) {
            ema = close;
        }

        ema = CalculatorUtil.calculateEMA(close, ema, period);
        emaState.update(ema);
        return new EMA(ema);
    }
}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.MA;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;

/**
 * SMA
 */
public class MACalculator extends BaseIndicatorCalculator<MA>{

    private final int period;

    private transient ValueState<Double> maState;

    public MACalculator(int period) {
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        this.maState = getRuntimeContext().getState(new ValueStateDescriptor<>("maState", Double.class));
    }


    @Override
    public String indicatorKey(MA indicator) {
        return "MA-" + period;
    }

    @Override
    public MA calculateInKLine(KLine kLine) throws IOException {
        Double ma = this.maState.value();
        Double close = kLine.getClose();

        if (ma == null) {
            ma = close;
        }

        ma = CalculatorUtil.calculateMA(close, ma, period);

        maState.update(ma);
        return new MA(ma);
    }
}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.MACD;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;

import java.io.IOException;

public class MACDCalculator extends BaseIndicatorCalculator<MACD> {

    private int ema1Period = 12;

    private int ema2Period = 26;

    private int deaPeriod = 9;

    private transient ValueState<MACD> macdState;


    public MACDCalculator(int ema1Period, int ema2Period, int deaPeriod) {
        this.ema1Period = ema1Period;
        this.ema2Period = ema2Period;
        this.deaPeriod = deaPeriod;
    }


    @Override
    public void open(org.apache.flink.configuration.Configuration parameters) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("macdState", TypeInformation.of(MACD.class));
        macdState = getRuntimeContext().getState(descriptor);
    }

    @Override
    public String indicatorKey(MACD indicator) {
        return "MACE" +  ema1Period + "-"  + ema2Period + "-" + deaPeriod;
    }

    @Override
    public MACD calculateInKLine(KLine kLine) throws IOException {
        MACD macd = macdState.value();
        double ema1 = macd.getEma1();
        double ema2 = macd.getEma2();
        double dea = macd.getDea();

        // 计算新的 EMA12 和 EMA26
        ema1 = CalculatorUtil.calculateEMA(kLine.getClose(), ema1, ema1Period);
        ema2 = CalculatorUtil.calculateEMA(kLine.getClose(), ema2, ema2Period);

        // 计算 DIF
        double dif = ema1 - ema2;
        dea = CalculatorUtil.calculateEMA(dif, dea, deaPeriod);

        macd.setEma1(ema1);
        macd.setEma2(ema2);
        macd.setDea(dea);
        macdState.update(macd);
        return macd;
    }

}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.RSI;
import com.helei.tradedatacenter.util.CalculatorUtil;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;

public class RSICalculator extends BaseIndicatorCalculator<RSI>{
    
    private final int period;
    
    private ValueState<Double> rsiState;
    
    public RSICalculator(int period) {
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        rsiState = getRuntimeContext().getState(new ValueStateDescriptor<>("rsiState", Double.class));
    }

    @Override
    public String indicatorKey(RSI indicator) {
        return "RSI-" + period;
    }

    @Override
    public RSI calculateInKLine(KLine kLine) throws IOException {
        Double rsi = rsiState.value();
        
        if (rsi == null) {
            rsi = 50.0;
        }

        Double open = kLine.getOpen();
        Double close = kLine.getClose();

        
        rsi = CalculatorUtil.calculateRSI(open, close, rsi, period);
        
        rsiState.update(rsi);

        return new RSI(rsi);
    }
}


package com.helei.tradedatacenter.indicator;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Boll implements Indicator{

    private Double sma;

    private Double upper;

    private Double lower;

    @Override
    public Indicator clone() {
        return null;
    }
}



package com.helei.tradedatacenter.indicator;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * EMA
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class EMA implements Indicator {

    /**
     * ema值
     */
    private Double ema;


    @Override
    public EMA clone() {
        return new EMA(ema);
    }
}

package com.helei.tradedatacenter.indicator;

import java.io.Serializable;

/**
 * 指标接口
 */
public interface Indicator extends Serializable {


    Indicator clone();
}



package com.helei.tradedatacenter.indicator;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * MA指标数据
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class MA implements Indicator {


    /**
     * 值
     */
    private Double ma;

    @Override
    public MA clone() {
        return new MA(ma);
    }
}

package com.helei.tradedatacenter.indicator;


import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class RSI implements Indicator{

    private Double rsi;

    @Override
    public Indicator clone() {
        return new RSI(rsi);
    }
}



package com.helei.tradedatacenter.indicator;

import lombok.*;

@Data
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class MACD implements Indicator {

    private Double ema1 = 0.0;

    private Double ema2 = 0.0;

    /**
     * macd dea 慢线
     */
    private Double dea = 0.0;

    /**
     * macd dif 快线
     * @return dif值
     */
    public Double dif() {
        return ema1 - ema2;
    }

    /**
     * macd柱状图
     * @return 高度
     */
    public Double macdHistogram() {
        return  2 * (dif() - dea);
    }

    @Override
    public Indicator clone() {
        return new MACD(ema1, ema2, dea);
    }
}


package com.helei.tradedatacenter.util;

public class CalculatorUtil {


    /**
     *  EMA 计算公式
     * @param price 当前价格
     * @param previousMA 前一个ema值
     * @param period 间隔
     * @return 当前ma
     */
    public static double calculateMA(double price, double previousMA, int period) {
        return (previousMA * (period - 1) + price) / period;
    }


    /**
     *  EMA 计算公式
     * @param price 当前价格
     * @param previousEMA 前一个ema值
     * @param period 间隔
     * @return 当前ema
     */
    public static double calculateEMA(double price, double previousEMA, int period) {
        double alpha = 2.0 / (period + 1.0);
        return alpha * price + (1 - alpha) * previousEMA;
    }


    /**
     * 计算rsi
     * @param open 开盘价格
     * @param close 收盘价格
     * @param previousRSI   前一个rsi
     * @param interval  间隔
     * @return  rsi
     */
    public static double calculateRSI(double open, double close, double previousRSI, int interval) {
        double gain = Math.max(0, close - open);
        double loss = Math.max(0 , open - close);
        double avgGain = (gain + (interval - 2) * previousRSI) / (interval - 1);
        double avgLoss = (loss + (interval - 2) * (100 - previousRSI)) / (interval - 1);

        return 100 - (100/(1 + avgGain/avgLoss));
    }
}
package com.helei.tradedatacenter.support;

import org.apache.flink.api.common.eventtime.WatermarkStrategy;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import org.apache.flink.streaming.util.serialization.SimpleStringSchema;
import org.apache.flink.util.Collector;

import java.time.Duration;
import java.util.Properties;

public class KLineTradingDecision {

    public static void main(String[] args) throws Exception {
        // 设置 Flink 流环境
        final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // Kafka 配置
        Properties properties = new Properties();
        properties.setProperty("bootstrap.servers", "localhost:9092");
        properties.setProperty("group.id", "kline-consumer");

        // 从 Kafka 中读取 K 线数据
        FlinkKafkaConsumer<String> kafkaSource = new FlinkKafkaConsumer<>(
                "kline_topic",
                new SimpleStringSchema(),
                properties
        );

        kafkaSource.assignTimestampsAndWatermarks(
                WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(5))
        );

        // 解析 K 线数据 (假设 K 线数据是 JSON 格式)
        DataStream<KLine> klineStream = env.addSource(kafkaSource)
                .map(line -> parseKLine(line));  // 解析成 KLine 对象

        // 基于股票代码分区，并计算移动平均线 (SMA) 和 RSI
        klineStream.keyBy(KLine::getSymbol)
                .process(new TradingStrategy())
                .print();

        env.execute("Flink K-Line Trading Decision");
    }

    // 定义 K 线数据类
    public static class KLine {
        public String symbol;  // 股票或交易对
        public long timestamp; // 时间戳
        public double open;    // 开盘价
        public double close;   // 收盘价
        public double high;    // 最高价
        public double low;     // 最低价
        public double volume;  // 成交量

        public String getSymbol() {
            return symbol;
        }
    }

    // 解析 JSON 数据（简化，假设输入是 JSON 格式的 K 线数据）
    public static KLine parseKLine(String line) {
        // 这里可以使用任何 JSON 解析库来解析 K 线数据
        // 假设返回一个 KLine 对象
        return new KLine();  // 替换为真实解析逻辑
    }

    // 交易策略，计算 SMA 和 RSI 并做出决策
    public static class TradingStrategy extends KeyedProcessFunction<String, KLine, String> {

        // 移动平均线状态
        private transient ValueState<Double> smaState;
        private transient ValueState<Double> rsiState;

        @Override
        public void open(org.apache.flink.configuration.Configuration parameters) throws Exception {
            // 初始化状态
            smaState = getRuntimeContext().getState(new ValueStateDescriptor<>("sma", Double.class));
            rsiState = getRuntimeContext().getState(new ValueStateDescriptor<>("rsi", Double.class));
        }

        @Override
        public void processElement(KLine kline, Context ctx, Collector<String> out) throws Exception {
            // 获取当前 K 线的收盘价
            double closePrice = kline.close;

            // 获取历史的 SMA 和 RSI
            Double currentSma = smaState.value();
            Double currentRsi = rsiState.value();

            // 如果是第一次计算，初始化 SMA 和 RSI
            if (currentSma == null) currentSma = closePrice;
            if (currentRsi == null) currentRsi = 50.0;  // 初始 RSI 值

            // 计算新的 SMA (简单移动平均线)
            currentSma = (currentSma * 14 + closePrice) / 15;  // 假设 15 天窗口

            // 计算 RSI (相对强弱指数)
            double gain = Math.max(0, closePrice - kline.open);
            double loss = Math.max(0, kline.open - closePrice);
            double avgGain = (gain + (14 - 1) * currentRsi) / 14;
            double avgLoss = (loss + (14 - 1) * (100 - currentRsi)) / 14;
            currentRsi = 100 - (100 / (1 + avgGain / avgLoss));

            // 保存新的状态
            smaState.update(currentSma);
            rsiState.update(currentRsi);

            // 根据 SMA 和 RSI 做出决策
            if (currentSma > closePrice && currentRsi > 70) {
                out.collect("卖出信号: " + kline.symbol + "，价格：" + closePrice);
            } else if (currentSma < closePrice && currentRsi < 30) {
                out.collect("买入信号: " + kline.symbol + "，价格：" + closePrice);
            }
        }
    }
}
