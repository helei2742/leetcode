package com.helei.tradedatacenter.signal;

import cn.hutool.core.util.BooleanUtil;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;

import java.io.IOException;


/**
 * 信号生成器的抽象类，会把传入的KLine分为两类
 * 1. 已完结的k线数据， kLine.end = true
 *      这样的k线数据，可以认为是历史k线数据，可用于状态更新。
 * 2、实时的k线数据， kLine.end = false
 *      实时数据，用于决策是否产出信号
 */
@Slf4j
public abstract class AbstractSignalMaker extends KeyedProcessFunction<String, KLine, TradeSignal> {
    @Override
    public void processElement(KLine kLine, KeyedProcessFunction<String, KLine, TradeSignal>.Context context, Collector<TradeSignal> collector) throws Exception {
        try {
            if (BooleanUtil.isTrue(kLine.isEnd())) {
                stateUpdate(kLine);
            } else {
                collector.collect(buildSignal(kLine));
            }
        } catch (Exception e) {
            log.error("build signal error", e);
            throw new RuntimeException(e);
        }
    }

    /**
     * 更新状态，传入的k线是已完结的k线数据
     * @param kLine 已完结的k线数据
     */
    protected abstract void stateUpdate(KLine kLine) throws IOException;

    /**
     * 产生信号
     * @param kLine 实时推送的k线数据
     * @return 交易信号
     */
    protected abstract TradeSignal buildSignal(KLine kLine) throws IOException;
}

package com.helei.tradedatacenter.signal;

import com.helei.tradedatacenter.constants.TradeSide;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.entity.TradeSignal;
import com.helei.tradedatacenter.indicator.MACD;
import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import org.apache.flink.configuration.Configuration;

import java.io.IOException;


public class MACDSignal_V1 extends AbstractSignalMaker{

    private final String macdName;

    /**
     * 上一跟MACD
     */
    private ValueState<MACD> lastMACD;

    /**
     * 水下金叉次数
     */
    private ValueState<Integer> underLineGoldAcrossCount;


    public MACDSignal_V1(String macdName) {
        this.macdName = macdName;
    }


    @Override
    public void open(Configuration parameters) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("lastMACD", TypeInformation.of(MACD.class));
        lastMACD = getRuntimeContext().getState(descriptor);
        underLineGoldAcrossCount = getRuntimeContext().getState(new ValueStateDescriptor<>("underLineGoldAcrossCount", Integer.class));
    }


    @Override
    protected void stateUpdate(KLine kLine) throws IOException {
        MACD lastMACD = this.lastMACD.value();

        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);


        if (lastMACD != null) {
            int acrossState = calGoldDeathAcross(lastMACD, currentMACD);

            //是否在水下
            boolean under = currentMACD.dif() <= 0;

            //水下金叉
            if (under && acrossState == 1) {
                underLineGoldAcrossCount.update(underLineGoldAcrossCount.value() == null ? 0 : underLineGoldAcrossCount.value() + 1);
            }
        }

        this.lastMACD.update(currentMACD);
    }

    @Override
    protected TradeSignal buildSignal(KLine kLine) throws IOException {
        MACD currentMACD = (MACD) kLine.getIndicators().get(macdName);
        MACD lastMACD = this.lastMACD.value();

        int acrossState = calGoldDeathAcross(lastMACD, currentMACD);
        boolean under = currentMACD.dif() <= 0;

        // 水下第二次金叉，产出买入信号
        if (under && acrossState == 1 && underLineGoldAcrossCount.value() == 1) {

            return TradeSignal
                    .builder()
                    .tradeSide(TradeSide.BUY)
                    .currentPrice(kLine.getClose())
                    .build();
        }

        // 水上死叉，卖出
        if (!under && acrossState == 0) {
            return TradeSignal
                    .builder()
                    .name(macdName)
                    .tradeSide(TradeSide.SALE)
                    .currentPrice(kLine.getClose())
                    .build();
        }

        return null;
    }

    /**
     * 计算金叉死叉
     * @param last  上一次的MACD
     * @param current   当前MACD
     * @return  1 表示金叉， -1 表示死叉， 0 表示没有交叉
     */
    private int calGoldDeathAcross(MACD last, MACD current) {
        if ((last.dif() > last.getDea()) && (current.dif() <= current.getDea())) {
            return -1;
        }
        if ((last.dif() < last.getDea()) && (current.dif() >= current.getDea())) {
            return 1;
        }
        return 0;
    }
}


package com.helei.tradedatacenter;

import com.helei.tradedatacenter.datasource.BaseKLineSource;
import com.helei.tradedatacenter.datasource.MemoryKLineSource;
import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Indicator;
import com.helei.tradedatacenter.indicator.calculater.BaseIndicatorCalculator;
import org.apache.flink.streaming.api.datastream.KeyedStream;
import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.streaming.api.functions.source.SourceFunction;
import org.apache.flink.util.Collector;

import java.util.ArrayList;
import java.util.List;


public class AutoTradeTask {
    private final StreamExecutionEnvironment env;

    private final List<BaseIndicatorCalculator<? extends Indicator>> indicatorCalList;

    private final BaseKLineSource memoryKLineSource;

    public AutoTradeTask(StreamExecutionEnvironment env, MemoryKLineSource memoryKLineSource) {
        // 设置 Flink 流环境
        this.env = env;

        this.memoryKLineSource = memoryKLineSource;

        this.indicatorCalList = new ArrayList<>();
    }

    public <T extends Indicator> AutoTradeTask addIndicator(BaseIndicatorCalculator<T> calculator) {
        indicatorCalList.add(calculator);
        return this;
    }

    public void execute() throws Exception {
        // 使用自定义 SourceFunction 生成 K 线数据流
        KeyedStream<KLine, String> keyedStream = env.addSource(memoryKLineSource)
                .keyBy(KLine::getSymbol);

        SingleOutputStreamOperator<KLine> process = null;
        for (BaseIndicatorCalculator<? extends Indicator> calculator : indicatorCalList) {
            if (process == null) {
                process = keyedStream.process(calculator);
            } else {
                process = process.keyBy(KLine::getSymbol).process(calculator);
            }
        }

        SingleOutputStreamOperator<String> finalResultStream = null;
        if (process == null) {
            finalResultStream = keyedStream.process(new KeyedProcessFunction<String, KLine, String>() {
                @Override
                public void processElement(KLine kLine, Context context, Collector<String> collector) throws Exception {
                    collector.collect(kLine.toString());
                }
            });
        } else {
            finalResultStream = process.keyBy(KLine::getSymbol).process(new KeyedProcessFunction<String, KLine, String>() {
                @Override
                public void processElement(KLine kLine, Context context, Collector<String> collector) throws Exception {
                    collector.collect(kLine.toString());
                }
            });
        }

        // 4. 输出最终结果
        finalResultStream.print();
        env.execute("test1");
    }
}



package com.helei.tradedatacenter.indicator;

import com.helei.tradedatacenter.entity.KLine;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

/**
 * 支撑、压力、趋势线
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PST implements Indicator {

    /**
     * 压力线
     */
    private List<Double> pressure;

    /**
     * 支撑线
     */
    private List<Double> support;

    /**
     * 上升趋势线
     */
    private TrendLine upTrendLine;

    /**
     * 下降趋势线
     */
    private TrendLine downTrendLine;

    /**
     * 当前趋势是否向上
     */
    private boolean currentTrendUp;

    @Override
    public Indicator clone() {
        return new PST(pressure, support, upTrendLine, downTrendLine, currentTrendUp);
    }

    @Data
    public static class TrendLine {
        private double k;
        private double m;

        public TrendLine(double k, double m) {
            this.k = k;
            this.m = m;
        }

        public static TrendLine calculateTrend(List<KLine> data) {
            int n = data.size();
            double sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            for (KLine kLine : data) {
                double y = kLine.getClose();
                int x = kLine.getOpenTime().getSecond();

                sumY += y;
                sumX += x;
                sumXY += x * y;
                sumX2 += x * x;
            }

            double k = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            double m = (sumY - k * sumX) / n;

            return  new TrendLine(k, m);
        }
    }
}





package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
        import com.helei.tradedatacenter.indicator.RSI;
        import com.helei.tradedatacenter.util.CalculatorUtil;
        import org.apache.flink.api.common.state.ValueState;
        import org.apache.flink.api.common.state.ValueStateDescriptor;
        import org.apache.flink.configuration.Configuration;

        import java.io.IOException;

public class RSICalculator extends BaseIndicatorCalculator<RSI>{

    private final int period;

    private ValueState<Double> rsiState;

    public RSICalculator(String name, int period) {
        super(name);
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        rsiState = getRuntimeContext().getState(new ValueStateDescriptor<>("rsiState", Double.class));
    }

//    @Override
//    public String indicatorKey(RSI indicator) {
//        return "RSI-" + period;
//    }

    @Override
    public RSI calculateInKLine(KLine kLine) throws IOException {
        Double rsi = rsiState.value();

        if (rsi == null) {
            rsi = 50.0;
        }

        Double open = kLine.getOpen();
        Double close = kLine.getClose();


        rsi = CalculatorUtil.calculateRSI(open, close, rsi, period);

        rsiState.update(rsi);

        return new RSI(rsi);
    }
}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
        import com.helei.tradedatacenter.indicator.RSI;
        import com.helei.tradedatacenter.util.CalculatorUtil;
        import org.apache.flink.api.common.state.ValueState;
        import org.apache.flink.api.common.state.ValueStateDescriptor;
        import org.apache.flink.configuration.Configuration;

        import java.io.IOException;

public class RSICalculator extends BaseIndicatorCalculator<RSI>{

    private final int period;

    private ValueState<Double> rsiState;

    public RSICalculator(String name, int period) {
        super(name);
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {
        rsiState = getRuntimeContext().getState(new ValueStateDescriptor<>("rsiState", Double.class));
    }

//    @Override
//    public String indicatorKey(RSI indicator) {
//        return "RSI-" + period;
//    }

    @Override
    public RSI calculateInKLine(KLine kLine) throws IOException {
        Double rsi = rsiState.value();

        if (rsi == null) {
            rsi = 50.0;
        }

        Double open = kLine.getOpen();
        Double close = kLine.getClose();


        rsi = CalculatorUtil.calculateRSI(open, close, rsi, period);

        rsiState.update(rsi);

        return new RSI(rsi);
    }
}


package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
        import com.helei.tradedatacenter.indicator.MACD;
        import com.helei.tradedatacenter.util.CalculatorUtil;
        import org.apache.flink.api.common.state.ValueState;
        import org.apache.flink.api.common.state.ValueStateDescriptor;
        import org.apache.flink.api.common.typeinfo.TypeInformation;

        import java.io.IOException;

public class MACDCalculator extends BaseIndicatorCalculator<MACD> {

    private int ema1Period = 12;

    private int ema2Period = 26;

    private int deaPeriod = 9;

    private transient ValueState<MACD> macdState;


    public MACDCalculator(String name, int ema1Period, int ema2Period, int deaPeriod) {
        super(name);
        this.ema1Period = ema1Period;
        this.ema2Period = ema2Period;
        this.deaPeriod = deaPeriod;
    }


    @Override
    public void open(org.apache.flink.configuration.Configuration parameters) throws Exception {
        ValueStateDescriptor<MACD> descriptor = new ValueStateDescriptor<>("macdState", TypeInformation.of(MACD.class));
        macdState = getRuntimeContext().getState(descriptor);
    }

//    @Override
//    public String indicatorKey(MACD indicator) {
//        return "MACE" +  ema1Period + "-"  + ema2Period + "-" + deaPeriod;
//    }

    @Override
    public MACD calculateInKLine(KLine kLine) throws IOException {
        MACD macd = macdState.value();
        double ema1 = macd.getEma1();
        double ema2 = macd.getEma2();
        double dea = macd.getDea();

        // 计算新的 EMA12 和 EMA26
        ema1 = CalculatorUtil.calculateEMA(kLine.getClose(), ema1, ema1Period);
        ema2 = CalculatorUtil.calculateEMA(kLine.getClose(), ema2, ema2Period);

        // 计算 DIF
        double dif = ema1 - ema2;
        dea = CalculatorUtil.calculateEMA(dif, dea, deaPeriod);

        macd.setEma1(ema1);
        macd.setEma2(ema2);
        macd.setDea(dea);
        macdState.update(macd);
        return macd;
    }

}
package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Boll;
import org.apache.flink.api.common.state.ListState;
import org.apache.flink.api.common.state.ListStateDescriptor;
import org.apache.flink.configuration.Configuration;

import java.util.LinkedList;

public class BollCalculator extends BaseIndicatorCalculator<Boll> {

    private final int period;

    private transient ListState<Double> priceListState;

    public BollCalculator(String name, int period) {
        super(name);
        this.period = period;
    }

    @Override
    public void open(Configuration parameters) throws Exception {

        priceListState = getRuntimeContext().getListState(new ListStateDescriptor<>("priceListState", Double.class));
    }

//    @Override
//    public String indicatorKey(Boll indicator) throws Exception {
//        return "BOLL-" + period;
//    }

    @Override
    public Boll calculateInKLine(KLine kLine) throws Exception {
        LinkedList<Double> priceList = new LinkedList<>();
        for (Double price : priceListState.get()) {
            priceList.add(price);
        }
        priceList.add(kLine.getClose());

        while (priceList.size() > period) {
            priceList.remove(0);
        }
        priceListState.update(priceList);


        // 计算 SMA
        if (priceList.size() == period) {
            double sma = calculateSMA(priceList);

            // 计算标准差
            double stddev = calculateStandardDeviation(priceList, sma);

            // 计算布林带上下轨
            double upperBand = sma + 2 * stddev;
            double lowerBand = sma - 2 * stddev;

            return new Boll(sma, upperBand, lowerBand);
        }
        return null;
    }

    // 计算简单移动平均线（SMA）
    private double calculateSMA(LinkedList<Double> prices) {
        double sum = 0.0;
        for (Double price : prices) {
            sum += price;
        }
        return sum / prices.size();
    }

    // 计算标准差
    private double calculateStandardDeviation(LinkedList<Double> prices, double sma) {
        double sumSquaredDiffs = 0.0;
        for (Double price : prices) {
            sumSquaredDiffs += Math.pow(price - sma, 2);
        }
        return Math.sqrt(sumSquaredDiffs / prices.size());
    }

}



package com.helei.tradedatacenter.indicator.calculater;

import com.helei.tradedatacenter.entity.KLine;
import com.helei.tradedatacenter.indicator.Indicator;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.KeyedProcessFunction;
import org.apache.flink.util.Collector;


@Slf4j
public abstract class BaseIndicatorCalculator<T extends Indicator> extends KeyedProcessFunction<String, KLine, KLine> {

    private final String name;

    protected BaseIndicatorCalculator(String name) {
        this.name = name;
    }

    @Override
    public void processElement(KLine kLine, KeyedProcessFunction<String, KLine, KLine>.Context context, Collector<KLine> collector){
        try {
            T Indicator = calculateInKLine(kLine);
            kLine.getIndicators().put(name, Indicator);
            collector.collect(kLine);
        } catch (Exception e) {
            log.error("calculate indicator error", e);
            throw new RuntimeException(e);
        }
    }

//    public abstract String indicatorKey(T indicator) throws Exception;

    /**
     * 计算指标，放进kLine里
     * @param kLine kLine
     * @return kLine
     */
    public abstract T calculateInKLine(KLine kLine) throws Exception;
}



package com.helei.tradedatacenter.entity;

import com.helei.tradedatacenter.constants.KLineInterval;
import com.helei.tradedatacenter.indicator.Indicator;
import lombok.*;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * K线实体类
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class KLine {

    /**
     * symbol
     */
    private String symbol;

    /**
     * 开盘价格
     */
    private Double open;

    /**
     * 收盘价格
     */
    private Double close;

    /**
     * 最高价格
     */
    private Double high;

    /**
     * 最低价格
     */
    private Double low;

    /**
     * 成交量
     */
    private Double volume;

    /**
     * 开盘时间
     */
    private LocalDateTime openTime;

    /**
     * 收盘时间
     */
    private LocalDateTime closeTime;


    /**
     * 这根线是否执行完
     */
    private boolean end;

    /**
     * k线频率
     */
    private KLineInterval kLineInterval;

    /**
     * 存放各种指标以及他的值
     */
    private Map<String, Indicator> indicators = new HashMap<>();

    @Override
    public String toString() {
        return "KLine{" +
                "symbol='" + symbol + '\'' +
                ", open=" + open +
                ", close=" + close +
                ", high=" + high +
                ", low=" + low +
                ", volume=" + volume +
                ", openTime=" + openTime +
                ", closeTime=" + closeTime +
                ", end=" + end +
                ", indicators=" + indicators +
                '}';
    }
}


package com.helei.tradedatacenter.entity;

import com.helei.tradedatacenter.constants.TradeSide;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * 交易信号
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class TradeSignal {

    /**
     * 信号名
     */
    private String name;

    /**
     * 当前时间
     */
    private LocalDateTime createTime;

    /**
     * 交易方向
     */
    private TradeSide tradeSide;

    /**
     * 当前价格
     */
    private Double currentPrice;

    /**
     * 目标价格
     */
    private Double targetPrice;

    /**
     * 止损价格
     */
    private Double protectPrice;
}


package com.helei.tradedatacenter.datasource;

import com.helei.tradedatacenter.constants.KLineInterval;
import com.helei.tradedatacenter.conventor.KLineMapper;
import com.helei.tradedatacenter.dto.SubscribeData;
import com.helei.tradedatacenter.entity.KLine;
import lombok.extern.slf4j.Slf4j;



/**
 * 内存的k线数据源
 */
@Slf4j
public class MemoryKLineSource extends BaseKLineSource {
    private final MemoryKLineDataPublisher memoryKLineDataPublisher;

    private final SubscribeData subscribeData;

    public MemoryKLineSource(
            String symbol,
            KLineInterval interval,
            MemoryKLineDataPublisher memoryKLineDataPublisher
    ) {
        this.memoryKLineDataPublisher = memoryKLineDataPublisher;
        this.subscribeData = memoryKLineDataPublisher.registry(symbol, interval);
    }


    @Override
    protected KLine loadKLine() throws Exception {
        return KLineMapper.mapJsonToKLine(subscribeData.getData());
    }

}
package com.helei.tradedatacenter.datasource;

import com.alibaba.fastjson.JSONObject;
import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.binanceapi.BinanceWSApiClientClient;
import com.helei.cexapi.binanceapi.api.BinanceWSStreamApi;
import com.helei.cexapi.binanceapi.constants.WebSocketStreamParamKey;
import com.helei.cexapi.binanceapi.constants.WebSocketStreamType;
import com.helei.cexapi.binanceapi.dto.StreamSubscribeEntity;
import com.helei.tradedatacenter.constants.KLineInterval;
import com.helei.tradedatacenter.dto.SubscribeData;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;


/**
 * 订阅k线，分发数据。
 * 1。创建类时自动链接Binance
 * 2.调用addListenKLine会向Binance api请求k线数据推送
 * 3.需要k线数据需要调用registry() 方法注册订阅
 * 最后，2步骤中得到推送的k线数据后，会遍历订阅者进行发送
 */
public class MemoryKLineDataPublisher implements KLineDataPublisher{
    private static final ExecutorService PUBLISH_EXECUTOR = Executors.newFixedThreadPool(1);

    private final BinanceWSStreamApi.StreamCommandBuilder streamCommandBuilder;

    private final ConcurrentMap<String, List<SubscribeData>> subscribeMap = new ConcurrentHashMap<>();

    public MemoryKLineDataPublisher(
            int threadPoolSize,
            String url
    ) throws Exception {
        BinanceWSApiClientClient binanceWSApiClient = CEXApiFactory.binanceApiClient(threadPoolSize, url);
        binanceWSApiClient.connect();

        streamCommandBuilder = binanceWSApiClient
                .getStreamApi()
                .builder();
    }

    /**
     * 获取哪些k线
     * @param symbol symbol
     * @param intervalList intervalList
     * @return  KLineDataPublisher
     */
    @Override
    public MemoryKLineDataPublisher addListenKLine(String symbol, List<KLineInterval> intervalList) {
        intervalList.forEach(kLineInterval -> {
            String key = getKLineMapKey(symbol, kLineInterval);

            streamCommandBuilder
                    .symbol(symbol)
                    .addSubscribeEntity(
                    StreamSubscribeEntity
                            .builder()
                            .symbol(symbol)
                            .subscribeType(WebSocketStreamType.KLINE)
                            .invocationHandler((streamName, result) -> {
                                //分发订阅的k线
                                dispatchKLineData(key, result);
                            })
                            .build()
                            .addParam(WebSocketStreamParamKey.KLINE_INTERVAL, kLineInterval.getDescribe())
                    )
                    .subscribe();
            //TODO subscribe加回调，成功才put
            subscribeMap.putIfAbsent(key, new ArrayList<>());
        });
        return this;
    }

    /**
     * 对订阅者分发k线数据
     * @param key key
     * @param result result
     */
    private void dispatchKLineData(String key, JSONObject result) {
        PUBLISH_EXECUTOR.execute(()->{
            subscribeMap.computeIfPresent(key, (k,v)->{
                for (SubscribeData subscribeData : v) {
                    subscribeData.setData(result);
                }
                return v;
            });
        });
    }


    /**
     * 注册监听k线
     * @param symbol symbol
     * @param interval interval
     * @return SubscribeData
     */
    public SubscribeData registry(String symbol, KLineInterval interval) {
        SubscribeData subscribeData = new SubscribeData();

        subscribeMap.compute(getKLineMapKey(symbol, interval), (k, v) -> {
            if (v == null) { //没有获取这条k线的数据，抛出异常
                throw new IllegalArgumentException("symbol '" + symbol + "' kline interval '" + interval + "' didn't listened");
            }

            //添加监听
            v.add(subscribeData);
            return v;
        });
        return subscribeData;
    }


    /**
     * 计算key
     * @param symbol symbol
     * @param kLineInterval  kLineInterval
     * @return key
     */
    private static String getKLineMapKey(String symbol, KLineInterval kLineInterval) {
        return symbol + "-" + kLineInterval.getDescribe();
    }

}

package com.helei.tradedatacenter.datasource;

import com.helei.tradedatacenter.constants.KLineInterval;

import java.util.List;

public interface KLineDataPublisher {

    KLineDataPublisher addListenKLine(String symbol, List<KLineInterval> intervalList);

}

package com.helei.tradedatacenter.datasource;

import com.helei.tradedatacenter.entity.KLine;
import org.apache.flink.streaming.api.functions.source.SourceFunction;

public abstract class BaseKLineSource implements SourceFunction<KLine> {
    private volatile boolean isRunning = true;

    @Override
    public void run(SourceContext<KLine> sourceContext) throws Exception {
        while (isRunning) {
            KLine kLine = loadKLine();

            if (kLine != null) {
                sourceContext.collect(kLine);
            }
        }
    }

    protected abstract KLine loadKLine() throws Exception;


    @Override
    public void cancel() {
        isRunning = false;
    }
}


package com.helei.tradedatacenter.constants;

public enum TradeSide {
    BUY,
    SALE
}


package com.helei.tradedatacenter.constants;

import lombok.Getter;

public enum KLineInterval {
    m_1("1m", 60),
    m_3("3m", 3 * 60),
    m_5("5m", 5 * 60),
    m_15("15m", 15 * 60),
    m_30("30m", 30 * 60),
    h_1("1h", 60 * 60),
    h_2("2h", 2 * 60 * 60),
    h_4("4h", 4 * 60 * 60),
    h_6("6h", 6 * 60 * 60),
    h_8("8h", 8 * 60 * 60),
    h_12("12h", 12 * 60 * 60),
    d_1("1d", 24 * 60 * 60),
    d_3("3d", 3 * 24 *60 *60),
    w_1("1w", 7 * 24 * 60 * 60),
    M_1("1M", 30 * 24 * 60 * 60),
    ;

    @Getter
    private final String describe;
    @Getter
    private final long second;


    KLineInterval(String describe, long second) {
        this.describe = describe;
        this.second = second;
    }
}


package com.helei.cexapi.binanceapi.dto;

import com.helei.cexapi.binanceapi.base.SubscribeResultInvocationHandler;
import com.helei.cexapi.binanceapi.constants.WebSocketStreamType;
import lombok.*;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;


/**
 * 流订阅的实体
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
@Builder
public class StreamSubscribeEntity {

    /**
     * 币种
     */
    private String symbol;

    /**
     * 流订阅的类型
     */
    private WebSocketStreamType subscribeType;

    /**
     * 订阅结果回调
     */
    private SubscribeResultInvocationHandler invocationHandler;

    /**
     * 执行回调的线程池
     */
    private ExecutorService callbackExecutor;

    /**
     * 参数
     */
    private Map<String, Object> params;

    private boolean signature;


    /**
     * 添加参数
     * @param key key
     * @param value value
     * @return StreamSubscribeEntity
     */
    public synchronized StreamSubscribeEntity addParam(String key, java.lang.Object value) {
        if (params == null) params = new HashMap<>();
        params.put(key, value);
        return this;
    }

    /**
     * 生成参数行,也就是stream name
     * @return 参数行
     */
    public String getStreamName() {
        return subscribeType.getHandler().buildStreamName(symbol, params);
    }

}
