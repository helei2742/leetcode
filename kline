package com.helei.dto.account;


import com.helei.dto.ASKey;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserInfo {

    /**
     * 用户id
     */
    private String id;

    /**
     * 验证key
     */
    private ASKey asKey;

    /**
     * 是否可用
     */
    private final AtomicBoolean usable = new AtomicBoolean(false);

    /**
     * 订阅的交易对
     */
    private List<String> subscribeSymbol;

    /**
     * 账户仓位设置
     */
    private AccountLocationConfig accountLocationConfig;
}

package com.helei.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Boolean success;
    private String errorMsg;
    private Object data;
    private Long total;

    public static Result ok(){
        return new Result(true, null, null, null);
    }
    public static Result ok(Object data){
        return new Result(true, null, data, null);
    }
    public static Result ok(List<?> data, Long total){
        return new Result(true, null, data, total);
    }
    public static Result fail(String errorMsg){
        return new Result(false, errorMsg, null, null);
    }
}

package com.helei.netty.base;


import com.alibaba.fastjson.JSON;
import com.helei.netty.NettyConstants;
import com.helei.netty.handler.RequestResponseHandler;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.Socks5ProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.task.VirtualThreadTaskExecutor;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    protected String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    protected final VirtualThreadTaskExecutor callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected InetSocketAddress proxy = null;

    /**
     * 重链接次数
     */
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);

    /**
     * 当前是否在允许
     */
    @Getter
    private final AtomicBoolean isRunning = new AtomicBoolean(false);

    private Bootstrap bootstrap;

    private EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    private final RequestResponseHandler<T> requestResponseHandler;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        this.callbackInvoker = new VirtualThreadTaskExecutor();

        requestResponseHandler = new RequestResponseHandler<>();
    }

    private void init() throws SSLException, URISyntaxException {

        resolveParamFromUrl();

        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, new DefaultHttpHeaders()
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            p.addLast(new Socks5ProxyHandler(proxy));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new IdleStateHandler(0, 0, 10, TimeUnit.SECONDS));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }

    /**
     * 链接服务端
     * @throws SSLException Exception
     */
    public CompletableFuture<Void> connect() throws SSLException, URISyntaxException {
        log.info("开始初始化WS客户端");
        init();
        log.info("初始化WS客户端完成，开始链接服务器");

        return reconnect();
    }


    /**
     * 重链接
     * @return  CompletableFuture<Void>
     */
    public CompletableFuture<Void> reconnect() {
        return CompletableFuture.runAsync(() -> {
            AtomicBoolean isSuccess = new AtomicBoolean(false);
            while (reconnectTimes.incrementAndGet() <= NettyConstants.RECONNECT_LIMIT) {
                eventLoopGroup.schedule(() -> {
                    reconnectTimes.decrementAndGet();
                }, 60, TimeUnit.SECONDS);

                log.info("start connect [{}], current times [{}]", uri, reconnectTimes.get());
                CountDownLatch latch = new CountDownLatch(1);


                eventLoopGroup.schedule(() -> {
                    try {
                        channel = bootstrap.connect().sync().channel();
                        // 8. 等待 WebSocket 握手完成
                        handler.handshakeFuture().sync();

                        isSuccess.set(true);
                    } catch (Exception e) {
                        log.error("connect [{}] error, times [{}]", uri, reconnectTimes.get(), e);
                    }
                    latch.countDown();
                }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                try {
                    latch.await();
                } catch (InterruptedException e) {
                    log.error("connect [{}] error, times [{}]", uri, reconnectTimes.get(), e);
                }

                if (isSuccess.get()) {

                    log.info("connect [{}] success, current times [{}]", uri, reconnectTimes.get());
                    isRunning.set(true);
                    break;
                }
            }
            if (!isSuccess.get()) {
                isRunning.set(false);
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
            }
        }, callbackInvoker);
    }


    /**
     * 关闭WebSocketClient
     */
    public void close() {
        log.info("start close websocket client");
        if (channel != null) {
            channel.close();
        }
        if (eventLoopGroup != null) {
            eventLoopGroup.shutdownGracefully();
        }

        reconnectTimes.set(0);
        isRunning.set(false);
        log.info("web socket client closed");
    }


    /**
     * 从request获取id
     *
     * @param request request
     * @return id
     */
    public abstract String getIdFromRequest(P request);

    /**
     * 发送请求, 注册响应监听
     *
     * @param request  请求体
     * @param callback 请求结果的回调
     */
    public void sendRequest(P request, Consumer<T> callback) {
        sendRequest(request, callback, callbackInvoker);
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request         请求体
     * @param callback        请求结果的回调
     * @param executorService 执行回调的线程池，传入为空则会尝试使用本类的线程池以及netty线程池
     */
    public void sendRequest(P request, Consumer<T> callback, VirtualThreadTaskExecutor executorService) {
        boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
            if (executorService == null) {
                if (callbackInvoker == null) { //netty线程处理
                    callback.accept(response);
                } else { //此类线程处理
                    callbackInvoker.submit(() -> {
                        callback.accept(response);
                    });
                }
            } else { //参数线程池处理
                executorService.submit(() -> {
                    callback.accept(response);
                });
            }

        });

        if (flag) {
            log.debug("send request [{}]", request);
            channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
        } else {
            throw new IllegalArgumentException("request id registered");
        }
    }

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = requestResponseHandler.registryRequest(getIdFromRequest(request), response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        log.info("send ping");
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        log.info("send pong");
        channel.writeAndFlush(new PongWebSocketFrame());
    }

    /**
     * 发送请求,不组册监听
     *
     * @param request 请求体
     */
    public void sendRequestNoListener(P request) {
        channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
    }


    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }


    /**
     * 提交请求的响应
     *
     * @param id       id
     * @param response response
     * @return 是否成功
     */
    public boolean submitResponse(String id, T response) {
        return requestResponseHandler.submitResponse(id, response);
    }

    /**
     * 提交stream流的响应
     *
     * @param streamName streamName, 通常由symbol和WebSocketStreamType组合成
     * @param message    message
     */
    public abstract void submitStreamResponse(String streamName, T message);
}


package com.helei.binanceapi;

import com.helei.binanceapi.api.ws.BinanceWSBaseApi;
import com.helei.binanceapi.base.AbstractBinanceWSApiClient;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.dto.ASKey;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

/**
 * 币安账户信息流推送客户端
 */
@Slf4j
public class BinanceWSAccountStreamClient extends AbstractBinanceWSApiClient {

    /**
     * 账户信息的asKey
     */
    @Getter
    private final ASKey asKey;

    /**
     * BaseApi，用来维护listenKey
     */
    private final BinanceWSBaseApi baseApi;

    /**
     * 当前的listenKey
     */
    @Getter
    private String listenKey;


    @Getter
    private final Consumer<AccountEvent> whenReceiveEvent;


    public BinanceWSAccountStreamClient(
            String streamUrl,
            IpWeightSupporter ipWeightSupporter,
            ASKey asKey,
            Consumer<AccountEvent> whenReceiveEvent,
            BinanceWSBaseApi baseApi
    ) throws URISyntaxException {
        super(streamUrl, ipWeightSupporter, null, new BinanceWSAccountStreamClientHandler(whenReceiveEvent));
        this.whenReceiveEvent = whenReceiveEvent;
        this.asKey = asKey;
        this.baseApi = baseApi;
    }

    /**
     * 开始获取账户信息流
     *
     * @return CompletableFuture<Boolean> 是否成功
     */
    public CompletableFuture<Boolean> startAccountInfoStream() {
        log.info("开始获取账户信息流， apiKey = [{}]", asKey.getApiKey());

        return baseApi.requestListenKey(asKey)//获取listenKey
                .thenApplyAsync(listenKey -> { //请求ws连接
                    log.info("listenKey = [{}]", listenKey);
                    if (listenKey == null) {
                        log.error("获取listenKey结果为null，");
                        return false;
                    }
                    this.listenKey = listenKey;
                    super.url = url + "/" + listenKey;
                    try {
                        connect().get();
                        log.info("账户信息流也开启，listenKey = [{}]", listenKey);
                        return true;
                    } catch (Exception e) {
                        log.error("连接服务器[{}}发生错误", url, e);
                    }
                    return false;
                });
    }


    /**
     * 延长listenKey的时间
     * @return future
     */
    public CompletableFuture<String> lengthenListenKey() {
        return baseApi.lengthenListenKey(listenKey, asKey);
    }

}


package com.helei.binanceapi;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.base.AbstractBinanceWSApiClientHandler;
import com.helei.binanceapi.constants.AccountEventType;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import lombok.extern.slf4j.Slf4j;

import java.util.function.Consumer;

/**
 * 币安账户信息流客户端处理消息的handler
 */
@Slf4j
class BinanceWSAccountStreamClientHandler extends AbstractBinanceWSApiClientHandler {

    private final Consumer<AccountEvent> whenReceiveEvent;

    BinanceWSAccountStreamClientHandler( Consumer<AccountEvent> whenReceiveEvent) {
        this.whenReceiveEvent = whenReceiveEvent;
    }

    @Override
    protected void whenReceiveMessage(String text) {
        JSONObject response = JSONObject.parseObject(text);
        if (response.get("id") != null) {
            log.warn("get an response, not stream message! [{}]", text);
        } else if (response.get("e") != null){
            log.debug("get stream message [{}}", text);
            whenReceiveEvent.accept(AccountEventType.STATUS_MAP.get(response.getString("e")).getConverter().convertFromJsonObject(response));
        }
    }
}



asKey:
  test:
    spot:
      apiKey: 1JIhkPyK07xadG9x8hIwqitN95MgpypPzA4b6TLraTonRnJ8BBJQlaO2iL9tPH0Y
      secretKey: t84TYFR1zieMGncbw3kYq4zAPLxIJHJeMdD8V0FMKxij9fApojV6bhbDpyyjNDWt
    contract:
      apiKey: b252246c6c6e81b64b8ff52caf6b8f37471187b1b9086399e27f6911242cbc66
      secretKey: a4ed1b1addad2a49d13e08644f0cc8fc02a5c14c3511d374eac4e37763cadf5f



package com.helei.cexapi.client;

import cn.hutool.core.util.BooleanUtil;
import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.BinanceWSApiClientHandler;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.dto.ASKey;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.task.VirtualThreadTaskExecutor;

import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.function.Consumer;


@Slf4j
public class BinanceAccountMergeClient {

    @Getter
    private final VirtualThreadTaskExecutor publishExecutor = new VirtualThreadTaskExecutor();

    private final ConcurrentMap<ASKey, BinanceWSAccountStreamClient> accountStreamClientMap = new ConcurrentHashMap<>();

    private final BinanceWSApiClient requestClient;

    private final String accountStreamUrl;

    private InetSocketAddress proxy;


    public BinanceAccountMergeClient(BinanceWSApiClient requestClient, String accountStreamUrl) throws Exception {
        this.requestClient = requestClient;
        this.accountStreamUrl = accountStreamUrl;

        log.info("开始连接请求服务器");
        requestClient.connect().get();
    }

    public BinanceAccountMergeClient(String requestUrl, String accountStreamUrl) throws Exception {
        this(
                new BinanceWSApiClient(
                        requestUrl,
                        new IpWeightSupporter("localIp"),
                        new BinanceWSApiClientHandler()
                ),
                accountStreamUrl
        );
    }

    public BinanceAccountMergeClient setProxy(InetSocketAddress proxy) {
        this.proxy = proxy;
        requestClient.setProxy(proxy);
        return this;
    }


    /**
     * 添加账户流，根据asKey创建BinanceWSAccountStreamClient对象进行连接，并绑定收到事件的回调。
     *
     * @param asKey                   asKey
     * @param whenReceiveAccountEvent channel收到事件消息时的回调
     * @return this
     * @throws URISyntaxException exception
     */
    public BinanceWSAccountStreamClient addAccountStream(ASKey asKey, Consumer<AccountEvent> whenReceiveAccountEvent) throws URISyntaxException {

        BinanceWSAccountStreamClient binanceWSAccountStreamClient = accountStreamClientMap.compute(
                asKey,
                (k, v) -> {
                    if (v == null) {
                        try {
                            v = new BinanceWSAccountStreamClient(
                                    accountStreamUrl,
                                    new IpWeightSupporter("localIp"),
                                    asKey,
                                    whenReceiveAccountEvent,
                                    requestClient.getBaseApi()
                            );
                        } catch (URISyntaxException e) {
                            log.error("创建account连接出错, apiKey[{}]", asKey.getApiKey(), e);
                            throw new RuntimeException(e);
                        }
                        v.setProxy(proxy);
                    }
                    return v;
                }
        );
        log.info("创建account连接成功，apiKey[{}]", asKey.getApiKey());

        return binanceWSAccountStreamClient;
    }

    /**
     * 刷新连接
     */
    public void refreshLink() {
        for (Map.Entry<ASKey, BinanceWSAccountStreamClient> entry : accountStreamClientMap.entrySet()) {
            BinanceWSAccountStreamClient streamClient = entry.getValue();

            CompletableFuture
                    //刷新，延长listenKey
                    .supplyAsync(() -> refreshClient(streamClient), publishExecutor)
                    //失败了就尝试重连接,重连接失败，在map中去掉他
                    .thenAcceptAsync(success->{
                        if (!success) {
                            log.warn("开始重新获取listenKey并连接");
                            if (reConnectStream(streamClient, 3)) {
                                accountStreamClientMap.remove(entry.getKey());
                                log.warn("重连接次数超过限制，不再尝试重连该账户的信息流");
                            }
                        }
                    }, publishExecutor);
        }
    }

    /**
     * 刷新BinanceWSAccountStreamClient
     * @param streamClient streamClient
     * @return boolean
     */
    private static boolean refreshClient(BinanceWSAccountStreamClient streamClient) {
        try {
            String s = streamClient.lengthenListenKey().get();
            if (s == null) {
                log.error("延长listenKey[{}]得到结果为null", streamClient.getListenKey());
                return false;
            }
            return true;
        } catch (InterruptedException | ExecutionException e) {
            log.error("延长listenKey[{}]发生错误", streamClient.getListenKey(), e);
            return false;
        }
    }


    /**
     * 重连接账户信息推送流
     * @param streamClient streamClient
     * @param retryTimes retryTimes
     */
    private static boolean reConnectStream(BinanceWSAccountStreamClient streamClient, int retryTimes) {
        for (int i = 1; i <= retryTimes; i++) {
            log.info("开始重连接account stream， [{}/{}]，旧的listenKey[{}]", i, retryTimes, streamClient.getListenKey());
            Boolean b = null;
            try {

                //关闭，重置
                streamClient.close();

                //开始连接
                b = streamClient.startAccountInfoStream().get();
            } catch (InterruptedException | ExecutionException e) {
                log.error("重新连接account stream发生错误，", e);
            }
            if (BooleanUtil.isTrue(b)) {
                log.info("重连接account stream成功, 新的listenKey[{}]", streamClient.getListenKey());
                return true;
            }
        }

        log.error("重连接失败,apiKey[{}]", streamClient.getAsKey().getApiKey());
        return false;
    }
}




package com.helei.cexapi.binanceapi;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.dto.accountevent.AccountEvent;
import com.helei.binanceapi.dto.accountevent.GridUpdateEvent;
import com.helei.binanceapi.dto.accountevent.OrderTradeUpdateEvent;
import com.helei.cexapi.CEXApiFactory;
import com.helei.dto.ASKey;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.binanceapi.constants.BinanceApiUrl;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.*;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

@Slf4j
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class BinanceWSAccountStreamClientTest {

    private static BinanceWSApiClient apiClient;

    private static BinanceWSAccountStreamClient binanceWSAccountStreamClient;

    private static ASKey asKey;

    private static volatile String listenKey;

    @BeforeAll
    public static void beforAll() throws URISyntaxException, SSLException, ExecutionException, InterruptedException {
        apiClient = CEXApiFactory.binanceApiClient(BinanceApiUrl.WS_NORMAL_URL_TEST);
        apiClient.connect().get();
//        String ak = "TUFsFL4YrBsR4fnBqgewxiGfL3Su5L9plcjZuyRO3cq6M1yuwV3eiNX1LcMamYxz";
//        String sk = "YsLzVacYo8eOGlZZ7RjznyWVjPHltIXzZJz2BrggCmCUDcW75FyFEv0uKyLBVAuU";
        //spot test
//        String ak = "1JIhkPyK07xadG9x8hIwqitN95MgpypPzA4b6TLraTonRnJ8BBJQlaO2iL9tPH0Y";
//        String sk = "t84TYFR1zieMGncbw3kYq4zAPLxIJHJeMdD8V0FMKxij9fApojV6bhbDpyyjNDWt";

        String ak = "b252246c6c6e81b64b8ff52caf6b8f37471187b1b9086399e27f6911242cbc66";
        String sk = "a4ed1b1addad2a49d13e08644f0cc8fc02a5c14c3511d374eac4e37763cadf5f";
        asKey = new ASKey(ak, sk);

        InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7890);

        binanceWSAccountStreamClient = new BinanceWSAccountStreamClient(
                BinanceApiUrl.WS_ACCOUNT_INFO_STREAM_URL_TEST,
                new IpWeightSupporter(BinanceApiUrl.WS_U_CONTRACT_STREAM_URL),
                asKey,
                System.out::println,
                apiClient.getBaseApi()
        );

        binanceWSAccountStreamClient.setProxy(proxy);
    }

    @Test
    @Order(1)
    void requestListenKey() throws ExecutionException, InterruptedException {
        String s = apiClient.getBaseApi().requestListenKey(asKey).get();
        System.out.println("获取listenKey成功 ： ");
        System.out.println(s);
        listenKey = s;
        System.out.println("");
    }

    @Test
    @Order(2)
    void lengthenListenKey() throws ExecutionException, InterruptedException {
        String s = apiClient.getBaseApi().lengthenListenKey(listenKey, asKey).get();
        System.out.println("延长listenKey成功 ： ");
        System.out.println(s);
        System.out.println("");
    }

    @Test
    @Order(3)
    void closeListenKey() throws ExecutionException, InterruptedException {
        Boolean s = apiClient.getBaseApi().closeListenKey(listenKey, asKey).get();
        System.out.println("关闭listenKey成功 ： ");
        System.out.println(s);
        System.out.println("");
    }

    @Test
    void startAccountInfoStream() throws Exception {
        CompletableFuture<Boolean> booleanCompletableFuture = binanceWSAccountStreamClient.startAccountInfoStream();

        Boolean b = booleanCompletableFuture.get();

        System.out.println("开启信息流结果： " + b);

        AccountEvent accountEvent = null;

    }
}


package com.helei.tradesignalcenter.config;

import com.helei.dto.ASKey;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
@ConditionalOnProperty
public class TestASKeyConfig {

    @Bean
    public ASKey contractTestnetASKey(@Value("${asKey.test.contract.apiKey}") String ak, @Value("${asKey.test.contract.secretKey}") String sk) {
        return new ASKey(ak, sk);
    }

    @Bean
    public ASKey spotTestnetASKey(@Value("${asKey.test.spot.apiKey}") String ak, @Value("${asKey.test.spot.secretKey}") String sk) {
        return new ASKey(ak, sk);
    }
}


package com.helei.tradesignalcenter.dto;

import com.helei.binanceapi.dto.accountevent.AccountEvent;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserAccountEvent {

    private String uid;

    private AccountEvent event;
}


package com.helei.tradesignalcenter.resolvestream.a_datasource;

import com.helei.tradesignalcenter.dto.UserAccountEvent;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.streaming.api.functions.source.SourceFunction;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;


@Slf4j
public abstract class AccountEventSource implements SourceFunction<UserAccountEvent> {

    private volatile boolean isRunning = true;


    @Override
    public void run(SourceContext<UserAccountEvent> sourceContext) throws Exception {
        isRunning = init(sourceContext);
        while (isRunning) {
            TimeUnit.MINUTES.sleep(50);

            refreshState();
        }
        log.warn("账户事件流关闭");
    }

    @Override
    public void cancel() {
        isRunning = false;
    }

    abstract boolean init(SourceContext<UserAccountEvent> sourceContext) throws ExecutionException, InterruptedException;

    abstract void refreshState();
}


package com.helei.tradesignalcenter.resolvestream.a_datasource;

import com.helei.cexapi.client.BinanceAccountMergeClient;
import com.helei.dto.account.UserInfo;
import com.helei.tradesignalcenter.dto.UserAccountEvent;
import com.helei.tradesignalcenter.service.AccountInfoService;
import lombok.extern.slf4j.Slf4j;

import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicInteger;


@Slf4j
public class BinanceAccountEventSource extends AccountEventSource {


    private final BinanceAccountMergeClient accountMergeClient;

    private final AccountInfoService accountInfoService;


    public BinanceAccountEventSource(
            BinanceAccountMergeClient accountMergeClient, AccountInfoService accountInfoService
    ) {
        this.accountMergeClient = accountMergeClient;
        this.accountInfoService = accountInfoService;
    }


    @Override
    boolean init(SourceContext<UserAccountEvent> sourceContext) throws ExecutionException, InterruptedException {

        Map<String, UserInfo> uid2UserInfo = accountInfoService.getUid2UserInfo();

        List<CompletableFuture<Void>> list = new ArrayList<>();

        AtomicInteger count = new AtomicInteger(0);

        for (Map.Entry<String, UserInfo> entry : uid2UserInfo.entrySet()) {
            CompletableFuture<Void> future = CompletableFuture
                    //每个账户创建连接client，并绑定回调，将事件连同账户uid写入flink source
                    .supplyAsync(
                            () -> {
                                try {
                                    return accountMergeClient.addAccountStream(entry.getValue().getAsKey(), (event) -> {
                                        if (event != null) {
                                            UserAccountEvent userAccountEvent = new UserAccountEvent(entry.getKey(), event);
                                            log.info("收到用户账户事件[{}}", userAccountEvent);
                                            sourceContext.collect(userAccountEvent);
                                        }
                                    });
                                } catch (URISyntaxException e) {
                                    throw new RuntimeException(e);
                                }
                            },
                            accountMergeClient.getPublishExecutor()
                    )
                    //开始连接
                    .thenAcceptAsync(
                            streamClient -> {
                                Boolean success = null;
                                try {
                                    success = streamClient.startAccountInfoStream().get();
                                } catch (InterruptedException | ExecutionException e) {
                                    throw new RuntimeException(e);
                                }
                                if (success) {
                                    log.info("开启账户uid[{}]信息流成功, [{}/{}}", entry.getKey(), count.incrementAndGet(), uid2UserInfo.size());
                                } else {
                                    throw new RuntimeException("开启账户信息推送流出错");
                                }
                            },
                            accountMergeClient.getPublishExecutor()
                    )
                    .whenCompleteAsync(
                            (v, e) -> {
                                if (e != null) {
                                    entry.getValue().getUsable().set(false);
                                    log.error("创建账户信息推送连接发生错误，uid[{}]", entry.getKey(), e);
                                }
                            },
                            accountMergeClient.getPublishExecutor()
                    );
            list.add(future);
        }

        CompletableFuture.allOf(list.toArray(new CompletableFuture[0])).get();

        if (count.get() == 0) {
            log.warn("账户信息流建立数量为0");
            return false;
        }
        return true;
    }


    @Override
    void refreshState() {
        accountMergeClient.refreshLink();
    }

}

package com.helei.tradesignalcenter.resolvestream.e_order;

import com.alibaba.fastjson.JSONObject;
import com.helei.binanceapi.dto.order.BaseOrder;
import com.helei.tradesignalcenter.config.TradeConfig;
import com.helei.tradesignalcenter.conventor.AccountInfoMapper;
import com.helei.dto.account.AccountInfo;
import com.helei.dto.account.AccountLocationConfig;
import com.helei.tradesignalcenter.dto.OriginOrder;
import com.helei.tradesignalcenter.service.AccountInfoService;
import com.helei.tradesignalcenter.support.OrderBuildSupporter;
import com.helei.util.CalculatorUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.functions.ProcessFunction;
import org.apache.flink.util.Collector;

import java.util.concurrent.CompletableFuture;

/**
 * 订单提交服务
 */
@Slf4j
public class OrderCommitService {

    private final AccountInfoService accountInfoService;
    private final OrderBuildSupporter orderBuildSupporter;

    public OrderCommitService(AccountInfoService accountInfoService, OrderBuildSupporter orderBuildSupporter) {
        this.accountInfoService = accountInfoService;
        this.orderBuildSupporter = orderBuildSupporter;
    }

    public DataStream<BaseOrder> commitOrder(DataStream<OriginOrder> originOrderStream) {
        return originOrderStream.process(new OriginOrderStreamProcessor(accountInfoService, orderBuildSupporter));
    }


    static class OriginOrderStreamProcessor extends ProcessFunction<OriginOrder, BaseOrder> {
        private static AccountInfoService accountInfoService;

        private static  OrderBuildSupporter orderBuildSupporter;

        OriginOrderStreamProcessor(AccountInfoService accountInfoService, OrderBuildSupporter orderBuildSupporter) {
            this.accountInfoService = accountInfoService;
            this.orderBuildSupporter = orderBuildSupporter;
        }

        @Override
        public void open(Configuration parameters) throws Exception {
            accountInfoService.init();
        }

        @Override
        public void processElement(OriginOrder originOrder, ProcessFunction<OriginOrder, BaseOrder>.Context context, Collector<BaseOrder> collector) throws Exception {

            for (CompletableFuture<JSONObject> future : accountInfoService.getNewestSubscribedAccount(originOrder.getSymbol())) {
                future.thenAcceptAsync((accountInfoJSON) -> {
                    AccountInfo accountInfo = AccountInfoMapper.mapJsonToAccountInfo(accountInfoJSON);

                    log.info("获取到最新的账户信息[{}]", accountInfo);

                    String uid = accountInfo.getUId();

                    Double freeUsdt = accountInfo.getFreeUsdt();
                    if (freeUsdt < TradeConfig.MIN_ORDER_USDT_COUNT_LIMIT) {
                        log.warn("账户[{}]的剩余USDT[{}]小于限制[{}]，取消下单", uid, freeUsdt, TradeConfig.MIN_ORDER_USDT_COUNT_LIMIT);
                        return;
                    }

                    //1，获取仓位设置
                    AccountLocationConfig locationConfig = accountInfoService.getAccountLocationConfig(uid);
                    //2.计算仓位大小
                    double positionSize = CalculatorUtil.calculatePositionSize(freeUsdt, locationConfig, originOrder.getTargetPrice().doubleValue());

                    //3.构建订单
                    BaseOrder order = orderBuildSupporter.buildOrder(originOrder, positionSize);
                    //4。发送
                    collector.collect(order);
                });
            }
        }
    }
}

package com.helei.tradesignalcenter.service;


import com.alibaba.fastjson.JSONObject;
import com.helei.dto.ASKey;
import com.helei.dto.account.AccountLocationConfig;
import com.helei.dto.account.UserInfo;
import lombok.Getter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;


/**
 * 账户信息服务
 */
@Getter
public class AccountInfoService {

    /**
     * uid  map  userInfo
     */
    private final Map<String, UserInfo> uid2UserInfo = new HashMap<>();

    /**
     * symbol map 订阅的uid
     */
    private final Map<String, List<String>> symbol2UIdsMap = new HashMap<>();


    /**
     * 获取订阅 symbol 交易对的账户的最新信息
     * @param symbol symbol
     * @return List<CompletableFuture<JSONObject>>
     */
    public List<CompletableFuture<JSONObject>> getNewestSubscribedAccount(String symbol) {

        List<CompletableFuture<JSONObject>> list = new ArrayList<>();

        return list;
    }

    /**
     * 根据uId获取账户的仓位设置
     * @param uid uid
     * @return AccountLocationConfig
     */
    public AccountLocationConfig getAccountLocationConfig(String uid) {
        return uid2UserInfo.get(uid).getAccountLocationConfig();
    }

    /**
     * 根据uid获取账户的 asKey
     * @param uid uid
     * @return ASKey
     */
    public ASKey getASKey(String uid) {
        return uid2UserInfo.get(uid).getAsKey();
    }

    /**
     * 初始化 ws
     */
    public void init() {
    }
}


asKey:
  test:
    spot:
      apiKey: 1JIhkPyK07xadG9x8hIwqitN95MgpypPzA4b6TLraTonRnJ8BBJQlaO2iL9tPH0Y
      secretKey: t84TYFR1zieMGncbw3kYq4zAPLxIJHJeMdD8V0FMKxij9fApojV6bhbDpyyjNDWt
    contract:
      apiKey: b252246c6c6e81b64b8ff52caf6b8f37471187b1b9086399e27f6911242cbc66
      secretKey: a4ed1b1addad2a49d13e08644f0cc8fc02a5c14c3511d374eac4e37763cadf5f


package com.helei.tradesignalcenter.support;


import com.helei.cexapi.CEXApiFactory;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.constants.KLineInterval;
import com.helei.constants.TradeSide;
import com.helei.dto.ASKey;
import com.helei.binanceapi.constants.BinanceApiUrl;
import com.helei.tradesignalcenter.resolvestream.*;
import com.helei.tradesignalcenter.resolvestream.a_datasource.RandomKLineSource;
import com.helei.dto.account.AccountLocationConfig;
import com.helei.tradesignalcenter.dto.OriginOrder;
import com.helei.dto.account.UserInfo;
import com.helei.dto.KLine;
import com.helei.dto.TradeSignal;
import com.helei.tradesignalcenter.resolvestream.c_signal.TradeSignalService;
import com.helei.tradesignalcenter.resolvestream.d_decision.DecisionMakerService;
import com.helei.tradesignalcenter.resolvestream.d_decision.maker.AbstractDecisionMaker;
import com.helei.dto.indicator.Indicator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.BollCalculator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.MACDCalculator;
import com.helei.tradesignalcenter.resolvestream.b_indicator.calculater.PSTCalculator;
import com.helei.dto.indicator.config.BollConfig;
import com.helei.dto.indicator.config.IndicatorConfig;
import com.helei.dto.indicator.config.MACDConfig;
import com.helei.dto.indicator.config.PSTConfig;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.AbstractSignalMaker;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.BollSignalMaker;
import com.helei.tradesignalcenter.resolvestream.c_signal.maker.PSTSignalMaker;
import com.helei.tradesignalcenter.resolvestream.e_order.OrderCommitService;
import com.helei.tradesignalcenter.service.AccountInfoService;
import org.apache.flink.api.common.functions.OpenContext;
import org.apache.flink.streaming.api.TimerService;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

@SpringBootTest
public class RandomKLineSourceTest {
    private static final Logger log = LoggerFactory.getLogger(RandomKLineSourceTest.class);
    private static String btcusdt = "btcusdt";

    private static String ethusdt = "ethusdt";

    private static RandomKLineSource btc_1h_source;
    private static RandomKLineSource btc_15m_source;
    private static RandomKLineSource btc_1m_source;

    private static BinanceWSApiClient normalClient;

    @Autowired
    @Qualifier("flinkEnv")
    private StreamExecutionEnvironment env;

    @Autowired
    @Qualifier("flinkEnv2")
    private StreamExecutionEnvironment env2;




    @BeforeAll
    public static void before() {
        try {
            normalClient = CEXApiFactory.binanceApiClient(BinanceApiUrl.WS_NORMAL_URL);

            normalClient.connect().get();

            btc_1h_source = new RandomKLineSource(btcusdt, KLineInterval.h_1, LocalDateTime.of(2022, 10, 3, 0, 0), 2000.0, 19000.0);
            btc_15m_source = new RandomKLineSource(btcusdt, KLineInterval.m_15, LocalDateTime.of(2022, 10, 3, 0, 0), 2000.0, 19000.0);
            btc_1m_source = new RandomKLineSource(btcusdt, KLineInterval.m_1, LocalDateTime.of(2022, 10, 3, 0, 0), 2000.0, 19000.0);

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testAutoTradeV2() throws Exception {
        PSTConfig pstConfig = new PSTConfig(60, 3, 3);
        BollConfig bollConfig = new BollConfig(15);

        btc_1h_source.setRealTime(true);
        btc_15m_source.setRealTime(true);
        btc_1m_source.setRealTime(true);

        TradeSignalService tradeSignalService = buildTradeSignalService(pstConfig, bollConfig);
        DecisionMakerService decisionMakerService = new DecisionMakerService(new AbstractDecisionMaker("测试用决策生成器") {
            @Override
            protected OriginOrder decisionAndBuilderOrder(String symbol, List<TradeSignal> windowSignal, HashMap<IndicatorConfig<? extends Indicator>, Indicator> indicatorMap) {
                log.info("收到信号【{}】\n{}", symbol, windowSignal);
                return OriginOrder
                        .builder()
                        .symbol(symbol)
                        .tradeSide(TradeSide.BUY)
//                        .targetPrice(BigDecimal.valueOf(windowSignal.getFirst().getTargetPrice()))
//                        .stopPrice(BigDecimal.valueOf(windowSignal.getFirst().getStopPrice()))
                        .build();
            }
        });

        String sk = "C1ihCOkWEECpnsbx4HcFLZubOyZX2CvPVaIvxlHtDNwfai8WsEzIxV6rLIizvgl9";
        String ak = "HZzsqyA0uBTC4GzaykzeUL5ml7V0jzGXGwU38WGDUmH8JLzPIw3ZfbGxa4ZzuzFm";

        AccountInfoService accountInfoService = new AccountInfoService();
        String testId = "testId";
        accountInfoService.getUid2UserInfo().put(testId, new UserInfo(testId, new ASKey(ak, sk), List.of("BTCUSDT"), new AccountLocationConfig(0.2, 10 , 50)));
        accountInfoService.getSymbol2UIdsMap().put("BTCUSDT", List.of(testId));
        OrderCommitService orderCommitService = new OrderCommitService(accountInfoService, new LimitOrderBuildSupporter());


        AutoTradeTask autoTradeTask = new AutoTradeTask(tradeSignalService, decisionMakerService, orderCommitService);
        autoTradeTask.execute("test");
    }

    private TradeSignalService buildTradeSignalService(PSTConfig pstConfig, BollConfig bollConfig) {
        return TradeSignalService
                .builder(env)
                .buildResolver()
                .setWindowLengthRationOfKLine(1.0 / 60)
                .addKLineSource(btc_1m_source)
                .addIndicator(new PSTCalculator(pstConfig))
                .addIndicator(new MACDCalculator(new MACDConfig(12, 26, 9)))
                .addIndicator(new BollCalculator(bollConfig))
                .addSignalMaker(new BollSignalMaker(bollConfig))
                .addSignalMaker(new PSTSignalMaker(pstConfig))
                .addSignalMaker(new AbstractSignalMaker(true) {
                    private Random random = new Random();

                    @Override
                    public void onOpen(OpenContext openContext) throws Exception {

                    }

                    @Override
                    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws Exception {
                        if (random.nextBoolean()) {
                            return null;
                        }
                        return TradeSignal.builder().description("这是一条测试信号1h").name("测试信号1h").tradeSide(TradeSide.BUY).build();
                    }

                    @Override
                    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws Exception {
                        if (random.nextBoolean()) {
                            return null;
                        }

                        return TradeSignal.builder().description("这是一条测试信号1h").name("测试信号1h").tradeSide(TradeSide.BUY).build();
                    }
                })
                .addInService()

                .buildResolver()
                .setWindowLengthRationOfKLine(1.0 / 15)
                .addKLineSource(btc_15m_source)
                .addIndicator(new PSTCalculator(pstConfig))
                .addIndicator(new MACDCalculator(new MACDConfig(12, 26, 9)))
                .addIndicator(new BollCalculator(bollConfig))
                .addSignalMaker(new BollSignalMaker(bollConfig))
                .addSignalMaker(new PSTSignalMaker(pstConfig))
                .addSignalMaker(new AbstractSignalMaker(true) {
                    private Random random = new Random();

                    @Override
                    public void onOpen(OpenContext openContext) throws Exception {

                    }

                    @Override
                    protected TradeSignal resolveHistoryKLine(KLine kLine, TimerService timerService) throws Exception {
                        if (random.nextBoolean()) {
                            return null;
                        }
                        return TradeSignal.builder().description("这是一条测试信号").name("测试信号15m").tradeSide(TradeSide.BUY).build();
                    }

                    @Override
                    protected TradeSignal resolveRealTimeKLine(KLine kLine, TimerService timerService) throws Exception {
                        if (random.nextBoolean()) {
                            return null;
                        }

                        return TradeSignal.builder().description("这是一条测试信号").name("测试信号15m").tradeSide(TradeSide.BUY).build();
                    }
                })
                .addInService()
                .build();
    }

}


package com.helei.tradesignalcenter.resolvestream.a_datasource;

import com.helei.binanceapi.BinanceWSAccountStreamClient;
import com.helei.binanceapi.BinanceWSApiClient;
import com.helei.binanceapi.constants.BinanceApiUrl;
import com.helei.binanceapi.supporter.IpWeightSupporter;
import com.helei.cexapi.CEXApiFactory;
import com.helei.cexapi.client.BinanceAccountMergeClient;
import com.helei.dto.ASKey;
import com.helei.dto.account.AccountLocationConfig;
import com.helei.dto.account.UserInfo;
import com.helei.tradesignalcenter.dto.UserAccountEvent;
import com.helei.tradesignalcenter.service.AccountInfoService;
import org.apache.flink.streaming.api.datastream.DataStreamSource;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;

import javax.net.ssl.SSLException;
import java.net.InetSocketAddress;
import java.net.URISyntaxException;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;


@SpringBootTest
class BinanceAccountEventSourceTest {

    @Autowired
    @Qualifier("flinkEnv")
    private StreamExecutionEnvironment env;
    @Autowired
    @Qualifier("flinkEnv2")
    private StreamExecutionEnvironment env2;


    private static BinanceWSApiClient apiClient;

    private static BinanceAccountMergeClient accountMergeClient;

    private static AccountInfoService accountInfoService;

    private static ASKey asKey;

    private static volatile String listenKey;

    @BeforeAll
    public static void beforAll() throws Exception {
        apiClient = CEXApiFactory.binanceApiClient(BinanceApiUrl.WS_NORMAL_URL_TEST);
        apiClient.connect().get();
        String ak = "b252246c6c6e81b64b8ff52caf6b8f37471187b1b9086399e27f6911242cbc66";
        String sk = "a4ed1b1addad2a49d13e08644f0cc8fc02a5c14c3511d374eac4e37763cadf5f";

        asKey = new ASKey(ak, sk);

        InetSocketAddress proxy = new InetSocketAddress("127.0.0.1", 7890);

        accountInfoService = new AccountInfoService();

        accountInfoService.getUid2UserInfo().put("test1", new UserInfo("test1", asKey, List.of("BTCUSDT", "ETHUSDT"), new AccountLocationConfig(0.2, 10, 100)));

        accountMergeClient = new BinanceAccountMergeClient(apiClient, BinanceApiUrl.WS_ACCOUNT_INFO_STREAM_URL_TEST);
    }

    @Test
    public void testAccountEventSource() throws ExecutionException, InterruptedException {

        BinanceAccountEventSource eventSource = new BinanceAccountEventSource(accountMergeClient, accountInfoService);

        DataStreamSource<UserAccountEvent> accountEventDataStream = env.addSource(eventSource);

        accountEventDataStream.print();


        TimeUnit.MINUTES.sleep(100);
    }
}
