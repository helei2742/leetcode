package cn.com.helei.depin.app.openLedger;

import cn.com.helei.depin.core.BaseDepinBotConfig;
import cn.com.helei.depin.core.dto.DepinClientAccount;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.ToString;
import lombok.extern.slf4j.Slf4j;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

@EqualsAndHashCode(callSuper = true)
@Data
@Slf4j
@ToString
public class OpenLedgerConfig extends BaseDepinBotConfig {


    /**
     * 浏览器标识
     */
    private String origin;

    /**
     * 账户列表
     */
    private List<OpenLedgerAccount> openLedgerAccounts;


    public static void main(String[] args) {
        OpenLedgerConfig openLedgerConfig = loadYamlConfig("app/openledger.yaml");
        System.out.println(openLedgerConfig);
    }

    public static OpenLedgerConfig loadYamlConfig(String classpath) {
        Yaml yaml = new Yaml();
        log.info("开始加载OpenLedger配置信息-file classpath:[{}}", classpath);
        try (InputStream inputStream = OpenLedgerConfig.class.getClassLoader().getResourceAsStream(classpath)) {
            Map<String, Object> yamlData = yaml.load(inputStream);
            Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
            Map<String, Object> openledger = (Map<String, Object>) depin.get("openledger");

            //Step 1 基础配置文件
            OpenLedgerConfig openLedgerConfig = yaml.loadAs(yaml.dump(openledger), OpenLedgerConfig.class);

            //Step 4 账户列表完善
            openLedgerConfig.getOpenLedgerAccounts().forEach(openLedgerAccount -> {
                openLedgerAccount.setOpenLedgerConfig(openLedgerConfig);
            });

            log.info("OpenLedger配置信息加载完毕: 共{}个账号", openLedgerConfig.getOpenLedgerAccounts().size());

            return openLedgerConfig;
        } catch (IOException e) {
            throw new RuntimeException(String.format("价值配置网络代理池文件[%s]发生错误", classpath));
        }
    }

    @Override
    public List<DepinClientAccount> getAccountList() {
        return openLedgerAccounts.stream().map(openLedgerAccount -> (DepinClientAccount) openLedgerAccount).toList();
    }


    @EqualsAndHashCode(callSuper = true)
    @Data
    public static class OpenLedgerAccount extends DepinClientAccount {

        private final static String printTemplate = "%-25s\t%-25s\t%-5s";

        private transient OpenLedgerConfig openLedgerConfig;

        private String token;

        private String identity;

        private String ownerAddress;


        public static String printTittle() {
            return String.format(printTemplate, "账户名", "代理", "环境ID");
        }

        @Override
        public String getConnectUrl() {
            return openLedgerConfig.getWsBaseUrl() + "?authToken=" + token;
        }

        @Override
        public HttpHeaders getHeaders() {
            HttpHeaders headers = new DefaultHttpHeaders();
            headers.add("Upgrade", "websocket")
                    .add("Origin", openLedgerConfig.origin)
                    .add("Cache-Control", "no-cache")
                    .add("Accept-Language", "zh-CN,zh;q=0.9,en;q=0.8")
                    .add("Pragma", "no-cache")
                    .add("Connection", "Upgrade");
            return headers;
        }

        @Override
        public String toString() {
            return "OpenLedgerAccount{" +
                    "token='" + token + '\'' +
                    ", identity='" + identity + '\'' +
                    ", ownerAddress='" + ownerAddress + '\'' +
                    "} " + super.toString();
        }
    }
}

package cn.com.helei.depin.app.openLedger;

import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.concurrent.Semaphore;

@Slf4j
public class OpenLedgerDepinApp {

    private final OpenLedgerConfig openLedgerConfig;

    private final Semaphore semaphore;

    public OpenLedgerDepinApp(String configClasspath) {
        this.openLedgerConfig = OpenLedgerConfig.loadYamlConfig(configClasspath);

        this.semaphore = new Semaphore(openLedgerConfig.getConcurrentCount());
    }


    public void startAll() {
        log.info("开始创建OpenLedger客户端");

        List<OpenLedgerDepinClient> ledgerDepinClients = null;

        log.info("OpenLedger客户端创建完毕");

        for (OpenLedgerDepinClient ledgerDepinClient : ledgerDepinClients) {
            try {
                String name = ledgerDepinClient.getName();

                log.info("账号[{}]开始连接", name);
                ledgerDepinClient
                        .connect()
                        .thenAcceptAsync(success -> {
                            if (!success) {
                                log.error("账号[{}]连接失败", name);
                            } else {
                                log.info("账号[{}]连接成功", name);
                            }
                        });

            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }
    }
}
package cn.com.helei.depin.app.openLedger;


import cn.com.helei.depin.core.dto.AccountContext;
import cn.com.helei.depin.core.dto.ConnectStatusInfo;
import cn.com.helei.depin.core.AbstractDepinClient;
import cn.com.helei.depin.core.AbstractDepinWSClientHandler;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;

import java.time.LocalDateTime;
import java.util.Random;

/**
 * OpenLedgerDepinClient
 */
@Slf4j
public class OpenLedgerDepinClient extends AbstractDepinClient<String, String> {

    public OpenLedgerDepinClient(AccountContext accountContext) {
        super(accountContext, new OpenLedgerDepinClientHandler(accountContext));
    }


    /**
     * OpenLedgerDepinClient 的 Netty Handler
     */
    public static class OpenLedgerDepinClientHandler extends AbstractDepinWSClientHandler<String, String> {

        private final Random random = new Random();

        private final AccountContext accountContext;

        public OpenLedgerDepinClientHandler(AccountContext accountContext) {
            this.accountContext = accountContext;
        }

        @Override
        protected void handleOtherMessage(String message) {

        }

        @Override
        public String convertMessageToRespType(String message) {
            return message;
        }


        @Override
        protected String heartBeatMessage() {
            //发送心跳时更新状态
            ConnectStatusInfo statusInfo = accountContext.getConnectStatusInfo();

            statusInfo.setUpdateDateTime(LocalDateTime.now());
            statusInfo.getHeartBeatCount().incrementAndGet();

            JSONObject heartBeatMessage = buildHeartBeatMessageContext();

            return heartBeatMessage.toJSONString();
        }


        /**
         * 构建心跳消息体
         *
         * @return JSONObject
         */
        private @NotNull JSONObject buildHeartBeatMessageContext() {
            OpenLedgerConfig.OpenLedgerAccount openLedgerAccount = (OpenLedgerConfig.OpenLedgerAccount)
                    accountContext.getClientAccount();


            JSONObject heartBeatMessage = new JSONObject();
            heartBeatMessage.put("msgType", "HEARTBEAT");
            heartBeatMessage.put("workerType", "LWEXT");
            heartBeatMessage.put("workerID", openLedgerAccount.getIdentity());

            JSONObject message = new JSONObject();
            JSONObject worker = new JSONObject();
            worker.put("Identity", openLedgerAccount.getIdentity());
            worker.put("ownerAddress", openLedgerAccount.getOwnerAddress());
            worker.put("type", "LWEXT");
            worker.put("Host", openLedgerAccount.getOpenLedgerConfig().getOrigin());
            message.put("Worker", worker);

            JSONObject capacity = new JSONObject();
            capacity.put("AvailableMemory", randomAM(0.5, 0.99));
            capacity.put("AvailableStorage", "99.99");
            capacity.put("AvailableGPU", "");
            capacity.put("AvailableModels", new JSONArray());

            message.put("Capacity", capacity);
            heartBeatMessage.put("message", message);
            return heartBeatMessage;
        }


        /**
         * 获取随机AvailableMemory
         */
        public double randomAM(double min, double max) {
            // 生成范围内的两位小数
            double randomValue = min + random.nextDouble((max - min) * 100); // 乘以 100 是为了得到两位小数
            randomValue = Math.round(randomValue * 100.0) / 100.0; // 四舍五入并保留两位小数
            return randomValue;
        }
    }

}
package cn.com.helei.depin.core.command;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

@AllArgsConstructor
@NoArgsConstructor
@Data
public class CommandMenuNode {


    /**
     * 当前节点被选择时显示的文本
     */
    private String tittle;

    /**
     * 当前节点进入后的describe
     */
    private String describe;

    /**
     * 当前节点调用的函数, 返回内容会显示在describe 和 子节点选项之间
     */
    private Supplier<String> action;

    /**
     * 当前节点的子节点
     */
    private final List<CommandMenuNode> subNodeList = new ArrayList<>();

    public void addSubMenu(CommandMenuNode subMenu) {
        this.subNodeList.add(subMenu);
    }
}
package cn.com.helei.depin.core.config;


public class BotBaseConfig {


    /**
     * 网络代理配置默认classpath
     */
    public static final String NETWORK_PROXY_CONFIG_DEFAULT_CLASSPATH = "network-proxy.yaml";


    /**
     * 浏览器环境配置默认classpath
     */
    public static final String BROWSER_ENV_CONFIG_DEFAULT_CLASSPATH = "browser-env.yaml";

}
package cn.com.helei.depin.core.dto;

import cn.com.helei.depin.core.env.BrowserEnv;
import cn.com.helei.depin.core.network.NetworkProxy;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AccountContext {

    /**
     * 账户是否可用
     */
    private boolean usable = true;

    /**
     * client 账户
     */
    private DepinClientAccount clientAccount;

    /**
     * 代理
     */
    private NetworkProxy proxy;

    /**
     * 浏览器环境
     */
    private BrowserEnv browserEnv;

    /**
     * 连接状态
     */
    private final ConnectStatusInfo connectStatusInfo = new ConnectStatusInfo();
}
package cn.com.helei.depin.core.dto;

/**
 * 连接状态
 */
public enum ConnectStatus {
    NEW,
    STARTING,
    RUNNING,
    STOP
}


package cn.com.helei.depin.core.dto;

import lombok.Data;

import java.time.LocalDateTime;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Account的连接状态
 */
@Data
public class ConnectStatusInfo {

    /**
     * 开始时间
     */
    private volatile LocalDateTime startDateTime;

    /**
     * 更新时间
     */
    private volatile LocalDateTime updateDateTime;

    /**
     * 心跳数
     */
    private volatile AtomicInteger heartBeatCount = new AtomicInteger(0);

    /**
     * 连接状态
     */
    private volatile ConnectStatus connectStatus = ConnectStatus.NEW;
}

package cn.com.helei.depin.core.dto;


import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpHeaders;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;



@Data
@AllArgsConstructor
@NoArgsConstructor
public abstract class DepinClientAccount {

    /**
     * 账户名
     */
    private String name;

    /**
     * 代理id
     */
    private Integer proxyId;


    /**
     * 浏览器环境id
     */
    private Integer browserEnvId;


    public HttpHeaders getHeaders() {
        return new DefaultHttpHeaders();
    }

    public String getConnectUrl() {
        return "";
    }
}

package cn.com.helei.depin.core.env;

import lombok.Data;

import java.util.Map;

@Data
public class BrowserEnv {

    private Integer id;

    private Map<String, String> headers;

}



package cn.com.helei.depin.core.env;


import com.jakewharton.fliptables.FlipTable;
import lombok.Getter;
import lombok.Setter;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class BrowserEnvPool {

    private static final String[] BROWSER_ENV_LIST_PRINT_TABLE_HEADER = new String[]{"ID", "Headers"};

    private static final Map<String, BrowserEnvPool> LOADED_POOL_MAP = new ConcurrentHashMap<>();

    @Getter
    private String configClassPath;

    @Setter
    private Set<BrowserEnv> envs;

    private ConcurrentMap<Integer, BrowserEnv> idMapEnv;

    public static BrowserEnvPool loadYamlBrowserEnvPool(String classpath) {
        return LOADED_POOL_MAP.compute(classpath, (k, pool) -> {
            if (pool == null) {
                Yaml yaml = new Yaml();
                try (InputStream inputStream = BrowserEnvPool.class.getClassLoader().getResourceAsStream(classpath)) {
                    Map<String, Object> yamlData = yaml.load(inputStream);
                    Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
                    Map<String, Object> browser = (Map<String, Object>) depin.get("browser");

                    BrowserEnvPool envPool = yaml.loadAs(yaml.dump(browser), BrowserEnvPool.class);
                    envPool.idMapEnv = new ConcurrentHashMap<>();
                    envPool.envs.forEach(browserEnv -> envPool.idMapEnv.put(browserEnv.getId(), browserEnv));
                    envPool.configClassPath = classpath;

                    pool = envPool;
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return pool;
        });
    }

    public BrowserEnv getBrowserEnv(Integer id) {
        return idMapEnv.get(id);
    }

    public String printPool() {
        String[][] table = new String[envs.size()][BROWSER_ENV_LIST_PRINT_TABLE_HEADER.length];

        List<BrowserEnv> list = envs.stream().toList();
        for (int i = 0; i < list.size(); i++) {
            BrowserEnv env = list.get(i);
            table[i] = new String[]{String.valueOf(env.getId()), env.getHeaders().toString()};
        }

        return FlipTable.of(BROWSER_ENV_LIST_PRINT_TABLE_HEADER, table);
    }
}


package cn.com.helei.depin.core.netty.base;


import cn.com.helei.depin.core.netty.handler.WSCloseHandler;
import cn.com.helei.depin.core.network.NetworkProxy;
import cn.com.helei.depin.core.netty.constants.NettyConstants;
import cn.com.helei.depin.core.netty.constants.WebsocketClientStatus;
import com.alibaba.fastjson.JSON;
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.http.DefaultHttpHeaders;
import io.netty.handler.codec.http.HttpClientCodec;
import io.netty.handler.codec.http.HttpHeaders;
import io.netty.handler.codec.http.HttpObjectAggregator;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.proxy.Socks5ProxyHandler;
import io.netty.handler.ssl.SslContext;
import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import io.netty.handler.stream.ChunkedWriteHandler;
import io.netty.handler.timeout.IdleStateHandler;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

import javax.net.ssl.SSLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.function.Consumer;

/**
 * Websocket客户端
 *
 * @param <P> 请求体的类型
 * @param <T> 返回值的类型
 */
@Slf4j
public abstract class AbstractWebsocketClient<P, T> {

    private static final int MAX_FRAME_SIZE = 10 * 1024 * 1024;  // 10 MB or set to your desired size

    /**
     * websocket的url字符串
     */
    protected String url;

    /**
     * netty pipeline 最后一个执行的handler
     */
    protected final AbstractWebSocketClientHandler<P, T> handler;

    /**
     * 执行回调的线程池
     */
    @Getter
    protected final ExecutorService callbackInvoker;

    /**
     * 代理
     */
    @Setter
    protected NetworkProxy proxy = null;

    @Setter
    protected HttpHeaders headers = new DefaultHttpHeaders();

    /**
     * 空闲时间
     */
    @Setter
    protected int allIdleTimeSecond = 10;

    /**
     * 重链接次数
     */
    private final AtomicInteger reconnectTimes = new AtomicInteger(0);

    /**
     * 重连锁
     */
    private final ReentrantLock reconnectLock = new ReentrantLock();

    /**
     * 启动中阻塞的condition
     */
    private final Condition startingWaitCondition = reconnectLock.newCondition();

    /**
     * 客户端当前状态
     */
    @Getter
    private volatile WebsocketClientStatus clientStatus = WebsocketClientStatus.NEW;

    /**
     * clientStatus更新的回调
     */
    @Setter
    private Consumer<WebsocketClientStatus> clientStatusChangeHandler = socketCloseStatus -> {
    };


    /**
     * 关闭时的回调列表
     */
    private final List<WSCloseHandler> closeHandlerList = new ArrayList<>();

    @Setter
    @Getter
    private String name;

    private Bootstrap bootstrap;

    private EventLoopGroup eventLoopGroup;

    private URI uri;

    private String host;

    private int port;

    private boolean useSSL;

    private Channel channel;

    public AbstractWebsocketClient(
            String url,
            AbstractWebSocketClientHandler<P, T> handler
    ) {
        this.url = url;
        this.handler = handler;
        this.handler.websocketClient = this;

        this.callbackInvoker = Executors.newVirtualThreadPerTaskExecutor();
    }

    private void init() throws SSLException, URISyntaxException {

        resolveParamFromUrl();

        WebSocketClientHandshaker handshaker = WebSocketClientHandshakerFactory.newHandshaker(
                uri, WebSocketVersion.V13, null, true, headers, MAX_FRAME_SIZE
        );
        handler.init(handshaker);

        final SslContext sslCtx;
        if (useSSL) {
            sslCtx = SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE).build();
        } else {
            sslCtx = null;
        }

        bootstrap = new Bootstrap();

        eventLoopGroup = new NioEventLoopGroup();
        bootstrap.group(eventLoopGroup)
                .channel(NioSocketChannel.class)
                .remoteAddress(host, port)
                .option(ChannelOption.TCP_NODELAY, true)
                .option(ChannelOption.SO_KEEPALIVE, true)
                .handler(new ChannelInitializer<NioSocketChannel>() {
                    @Override
                    protected void initChannel(NioSocketChannel ch) {
                        ChannelPipeline p = ch.pipeline();
                        if (proxy != null) {
                            p.addLast(new Socks5ProxyHandler(proxy.getAddress(), proxy.getUsername(), proxy.getPassword()));
                        }

                        if (sslCtx != null) {
                            p.addLast(sslCtx.newHandler(ch.alloc(), uri.getHost(), port));
                        }

                        p.addLast("http-chunked", new ChunkedWriteHandler()); // 支持大数据流


                        p.addLast(new HttpClientCodec());
                        p.addLast(new HttpObjectAggregator(81920));
                        p.addLast(new IdleStateHandler(0, 0, allIdleTimeSecond, TimeUnit.SECONDS));
                        p.addLast(new ChunkedWriteHandler());

                        p.addLast(new WebSocketFrameAggregator(MAX_FRAME_SIZE));  // 设置聚合器的最大帧大小


                        p.addLast(handler);
                    }
                });
    }

    /**
     * 链接服务端
     */
    public CompletableFuture<Boolean> connect() {
        return connect(null);
    }

    /**
     * 链接服务端
     */
    public CompletableFuture<Boolean> connect(WSCloseHandler wsCloseHandler) {

        /*
         * 添加关闭的回调
         */
        if (wsCloseHandler != null) {
            synchronized (closeHandlerList) {
                closeHandlerList.add(wsCloseHandler);
            }
        }

        return switch (clientStatus) {
            case NEW, STOP -> reconnect();
            case STARTING -> waitForStarting();
            case RUNNING -> {
                log.warn("WS客户端[{}}正在运行, clientStatus[{}]", url, clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> throw new RuntimeException("");
        };
    }


    /**
     * 重链接
     *
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Boolean> reconnect() {
        return switch (clientStatus) {
            case NEW, STOP -> doReconnect();
            case STARTING -> waitForStarting();
            case RUNNING -> {
                log.warn("WS客户端[{}}正在启动或运行, 不能reconnect. clientStatus[{}]", url, clientStatus);
                yield CompletableFuture.supplyAsync(() -> true);
            }
            case SHUTDOWN -> CompletableFuture.supplyAsync(() -> {
                log.error("client[{}] already shutdown", name);
                return false;
            });
        };
    }

    /**
     * 执行重连接，带重试逻辑
     *
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Boolean> doReconnect() {
        updateClientStatus(WebsocketClientStatus.STARTING);

        return CompletableFuture.supplyAsync(() -> {
            //Step 1 重连次数超过限制，关闭
            if (reconnectTimes.get() > NettyConstants.RECONNECT_LIMIT) {
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
                return false;
            }

            AtomicBoolean isSuccess = new AtomicBoolean(false);

            //Step 2 重连逻辑
            //Step 2.1 加锁保证只要一个线程进行重连
            reconnectLock.lock();
            try {

                //Step 2.2 已经再running状态，直接返回true。变为shutdown、stop状态，直接返回false
                if (clientStatus.equals(WebsocketClientStatus.RUNNING)) {
                    log.info("client started by other thread");
                    return true;
                } else if (clientStatus.equals(WebsocketClientStatus.SHUTDOWN) || clientStatus.equals(WebsocketClientStatus.STOP)) {
                    log.error("clint stop/shutdown when client starting");
                    return false;
                }

                //Step 3 初始化
                log.info("开始初始化WS客户端");
                try {
                    init();
                } catch (SSLException | URISyntaxException e) {
                    throw new RuntimeException("初始化WS客户端发生错误", e);
                }
                log.info("初始化WS客户端完成，开始链接服务器 [{}]", url);


                //Step 4 链接服务器
                while (reconnectTimes.incrementAndGet() <= NettyConstants.RECONNECT_LIMIT) {

                    //Step 4.1 每进行重连都会先将次数加1并设置定时任务将重连次数减1
                    eventLoopGroup.schedule(() -> {
                        reconnectTimes.decrementAndGet();
                    }, 180, TimeUnit.SECONDS);

                    log.info("start connect client [{}], url[{}], current times [{}]", name, url, reconnectTimes.get());

                    //Step 4.2 latch用于同步等等链接完成
                    CountDownLatch latch = new CountDownLatch(1);

                    //Step 4.3 延迟再进行连接
                    eventLoopGroup.schedule(() -> {
                        try {
                            channel = bootstrap.connect().sync().channel();

                            handler.handshakeFuture().sync();

                            channel.attr(NettyConstants.CLIENT_NAME).set(name);

                            //Step 4.4 连接成功设置标识
                            isSuccess.set(true);
                        } catch (Exception e) {
                            log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                        } finally {
                            latch.countDown();
                        }
                    }, NettyConstants.RECONNECT_DELAY_SECONDS, TimeUnit.SECONDS);

                    //Step 4.5 等待链接完成
                    try {
                        latch.await();
                    } catch (InterruptedException e) {
                        log.error("connect client [{}], url[{}] error, times [{}]", name, url, reconnectTimes.get(), e);
                    }

                    //Step 4.6 链接成功则跳出循环
                    if (isSuccess.get()) {
                        log.info("connect client [{}], url[{}] success, current times [{}]", name, url, reconnectTimes.get());

                        updateClientStatus(WebsocketClientStatus.RUNNING);
                        reconnectTimes.set(0);
                        break;
                    }
                }
            } catch (Exception e) {
                //exception 遇到未处理异常，直接关闭
                close();
                throw new RuntimeException(String.format("connect client [%s] appear unknown error", name), e);
            } finally {
                //Step 5 释放等待启动的线程
                startingWaitCondition.signalAll();
                reconnectLock.unlock();
            }

            //Step 6 未成功启动，关闭并抛出异常
            if (!isSuccess.get()) {
                log.error("reconnect times out of limit [{}], close websocket client", NettyConstants.RECONNECT_LIMIT);
                close();
                throw new RuntimeException("reconnect times out of limit");
            }

            return true;
        }, callbackInvoker);
    }


    /**
     * 停止WebSocketClient
     */
    public void close() {
        synchronized (closeHandlerList) {
            log.info("closing websocket client [{}]", name);
            if (channel != null) {
                channel.close();
            }

            if (eventLoopGroup != null) {
                eventLoopGroup.shutdownGracefully();
            }
            reconnectTimes.set(0);

            updateClientStatus(WebsocketClientStatus.STOP);

            //执行关闭回调
            Iterator<WSCloseHandler> iterator = closeHandlerList.iterator();
            while (iterator.hasNext()) {
                WSCloseHandler closeHandler = iterator.next();
                iterator.remove();

                CompletableFuture.runAsync(closeHandler::onClosed, callbackInvoker);
            }

            log.warn("web socket client [{}] closed", name);
        }
    }

    /**
     * 彻底关闭客户端
     */
    public void shutdown() {
        close();
        updateClientStatus(WebsocketClientStatus.SHUTDOWN);
        log.warn("web socket client [{}] already shutdown !", name);
    }

    /**
     * 等待启动完成
     *
     * @return CompletableFuture<Void>
     */
    private CompletableFuture<Boolean> waitForStarting() {
        return CompletableFuture.supplyAsync(() -> {
            log.warn("client [{}] is starting, waiting for complete", name);
            reconnectLock.lock();
            try {
                while (clientStatus.equals(WebsocketClientStatus.RUNNING)) {
                    startingWaitCondition.await();
                }

                if (clientStatus.equals(WebsocketClientStatus.STOP) || clientStatus.equals(WebsocketClientStatus.SHUTDOWN)) {
                    log.error("启动WS客户端[{}]失败, ClientStatus [{}}", name, clientStatus);
                    return false;
                }
                return true;
            } catch (InterruptedException e) {
                log.error("waiting for start client [{}] error", name);
                throw new RuntimeException(e);
            } finally {
                reconnectLock.unlock();
            }
        }, callbackInvoker);
    }


    /**
     * 发送消息，没有回调
     *
     * @param message message
     * @return CompletableFuture<Void>
     */
    public CompletableFuture<Void> sendMessage(P message) {
        return CompletableFuture.runAsync(() -> {
            if (message == null) {
                throw new IllegalArgumentException("message is null");
            }

            try {
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(message)));
            } catch (Exception e) {
                throw new RuntimeException("send message [" + message + "] error");
            }
        }, callbackInvoker);
    }

    ;

    /**
     * 发送请求, 注册响应监听
     *
     * @param request 请求体
     */
    public CompletableFuture<T> sendRequest(P request) {
        return CompletableFuture.supplyAsync(() -> {
            if (request == null) {
                log.error("request is null");
                return null;
            }

            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<T> jb = new AtomicReference<>(null);

            boolean flag = handler.registryRequest(request, response -> {
                latch.countDown();
                jb.set(response);
            });

            if (flag) {
                log.info("send request [{}]", request);
                channel.writeAndFlush(new TextWebSocketFrame(JSON.toJSONString(request)));
                log.debug("send request [{}] success", request);
            } else {
                log.error("request id registered");
                return null;
            }

            try {
                if (!latch.await(NettyConstants.REQUEST_WAITE_SECONDS, TimeUnit.SECONDS)) return null;

                return jb.get();
            } catch (InterruptedException e) {
                log.error("send request interrupted", e);
                return null;
            }
        }, callbackInvoker);
    }

    /**
     * 发送ping
     */
    public void sendPing() {
        log.debug("client [{}] send ping {}", name, url);
        channel.writeAndFlush(new PingWebSocketFrame());
    }

    /**
     * 发送pong
     */
    public void sendPong() {
        log.debug("client [{}] send pong {}", name, url);
        channel.writeAndFlush(new PongWebSocketFrame());
    }


    /**
     * 更新status
     *
     * @param newStatus newStatus
     */
    public void updateClientStatus(WebsocketClientStatus newStatus) {
        synchronized ("CLIENT_STATUS_LOCK") {
            try {
                if (clientStatusChangeHandler != null) {
                    clientStatusChangeHandler.accept(newStatus);
                }
            } finally {
                clientStatus = newStatus;
            }
        }
    }

    /**
     * 解析参数
     *
     * @throws URISyntaxException url解析错误
     */
    private void resolveParamFromUrl() throws URISyntaxException {
        uri = new URI(url);
        String scheme = uri.getScheme() == null ? "ws" : uri.getScheme();
        host = uri.getHost() == null ? "127.0.0.1" : uri.getHost();
        if (uri.getPort() == -1) {
            if ("ws".equalsIgnoreCase(scheme)) {
                port = 80;
            } else if ("wss".equalsIgnoreCase(scheme)) {
                port = 443;
            } else {
                port = -1;
            }
        } else {
            port = uri.getPort();
        }

        if (!"ws".equalsIgnoreCase(scheme) && !"wss".equalsIgnoreCase(scheme)) {
            log.error("Only WS(S) is supported.");
            throw new IllegalArgumentException("url error, Only WS(S) is supported.");
        }

        useSSL = "wss".equalsIgnoreCase(scheme);
    }
}

package cn.com.helei.depin.core.netty.base;

import cn.com.helei.depin.core.netty.constants.NettyConstants;
import cn.hutool.core.util.StrUtil;
import io.netty.channel.*;

import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;


/**
 * WebSocket客户端处理器抽象类
 * 能够处理请求响应类型的消息。
 * 其它类型的消息要通过handleOtherMessage()抽象方法处理
 *
 * @param <Resp>
 */
@Slf4j
@ChannelHandler.Sharable
public abstract class AbstractWebSocketClientHandler<Req, Resp> extends BaseWebSocketClientHandler<Req, Resp> {

    /**
     * 存放请求响应的回调
     */
    protected final ConcurrentMap<String, HandlerEntity<Resp>> requestIdMap = new ConcurrentHashMap<>();


    @Override
    protected void whenReceiveMessage(String text) {
        Resp message = convertMessageToRespType(text);

        String responseId = getResponseId(message);

        if (StrUtil.isNotBlank(responseId)) {
            //有id，是发送请求的响应
            //提交response
            handleResponseMessage(responseId, message);
        } else {
            //没有id，按其它格式处理
            handleOtherMessage(message);
        }
    }


    /**
     * 注册request
     *
     * @param request request
     * @return 是否注册成功
     */
    public boolean registryRequest(Req request, Consumer<Resp> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        String requestId = getRequestId(request);

        if (StrUtil.isBlank(requestId)) return false;

        requestIdMap.compute(requestId, (k, v) -> {
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", requestId, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 处理请求响应的消息
     *
     * @param id       id
     * @param response 响应消息体
     */
    protected void handleResponseMessage(String id, Resp response) {
        HandlerEntity<Resp> handlerEntity = requestIdMap.get(id);

        if (System.currentTimeMillis() > handlerEntity.getExpireTime()) {
            log.warn("请求[{}]得到响应超时", id);
        } else {
            websocketClient.callbackInvoker.execute(() -> handlerEntity.getCallback().accept(response));
        }
    }

    /**
     * 处理其他类型消息
     *
     * @param message 消息
     */
    protected abstract void handleOtherMessage(Resp message);


    /**
     * 将websocket收到的文本消息转换为响应类型 Resp
     *
     * @param message websocket收到的原始消息
     * @return typedMessage
     */
    public abstract Resp convertMessageToRespType(String message);


    /**
     * 获取请求id
     *
     * @param request request
     * @return id
     */
    public abstract String getRequestId(Req request);

    /**
     * 获取响应id
     *
     * @param response 响应
     * @return id
     */
    public abstract String getResponseId(Resp response);
}

package cn.com.helei.depin.core.netty.base;

import cn.com.helei.depin.core.netty.constants.NettyConstants;
import io.netty.channel.*;
import io.netty.handler.codec.http.FullHttpResponse;
import io.netty.handler.codec.http.websocketx.*;
import io.netty.handler.timeout.IdleStateEvent;
import io.netty.util.CharsetUtil;
import lombok.extern.slf4j.Slf4j;


/**
 * WebSocket客户端处理器基础类
 * 处理连接握手
 *
 * @param <P>
 * @param <T>
 */
@Slf4j
@ChannelHandler.Sharable
public abstract class BaseWebSocketClientHandler<P, T> extends SimpleChannelInboundHandler<Object> {
    private WebSocketClientHandshaker handshaker;

    private ChannelPromise handshakeFuture;

    protected AbstractWebsocketClient<P, T> websocketClient;

    /**
     * 收到消息处理
     *
     * @param text 消息字符串
     */
    protected abstract void whenReceiveMessage(String text);


    public void init(WebSocketClientHandshaker handshaker) {
        this.handshaker = handshaker;
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        handshakeFuture = ctx.newPromise();
    }

    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        Channel channel = ctx.channel();
        log.info("WebSocket Client [{}] connected!", websocketClient.getName());
        channel.attr(NettyConstants.CLIENT_NAME).set(websocketClient.getName());
        handshaker.handshake(channel);
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) {
        log.warn("WebSocket Client [{}] disconnected!", ctx.channel().attr(NettyConstants.CLIENT_NAME).get());

        websocketClient.close();
    }

    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
        log.warn("WebSocket Client [{}] unregistered!, start reconnect", ctx.channel().attr(NettyConstants.CLIENT_NAME).get());

        websocketClient.reconnect();
    }

    @Override
    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception {
        Channel ch = ctx.channel();
        // 如果握手未完成，处理 FullHttpResponse
        if (!handshaker.isHandshakeComplete()) {
            if (msg instanceof FullHttpResponse response) {
                try {
                    handshaker.finishHandshake(ch, response);
                    log.info("WebSocket client [{}] Handshake complete!", ch.attr(NettyConstants.CLIENT_NAME).get());
                    handshakeFuture.setSuccess();
                } catch (WebSocketHandshakeException e) {
                    log.info("WebSocket client [{}] Handshake failed!", ch.attr(NettyConstants.CLIENT_NAME).get());
                    handshakeFuture.setFailure(e);
                }
                return;
            }
        }

        if (msg instanceof FullHttpResponse response) {
            if (response.status().code() / 100 > 3) {
                throw new IllegalStateException(
                        "Unexpected FullHttpResponse (getStatus=" + response.status() +
                                ", content=" + response.content().toString(CharsetUtil.UTF_8) + ')');
            }
        } else if (msg instanceof WebSocketFrame frame) {
            switch (frame) {
                case TextWebSocketFrame textFrame -> {
                    log.debug("websocket client [{}] 接收到的消息：{}", ch.attr(NettyConstants.CLIENT_NAME).get(), textFrame.text());
                    whenReceiveMessage(textFrame.text());
                }
                case PongWebSocketFrame pongWebSocketFrame -> handlerPong(ch, pongWebSocketFrame);
                case PingWebSocketFrame pingWebSocketFrame -> handlerPing(ch, pingWebSocketFrame);
                case CloseWebSocketFrame closeWebSocketFrame -> handlerClose(ch, closeWebSocketFrame);
                default -> {
                    log.warn("channel[{}]收到位置类型的消息[{}]", ch.attr(NettyConstants.CLIENT_NAME).get(), frame.getClass().getName());
                }
            }
        }
    }


    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        if (!handshakeFuture.isDone()) {
            handshakeFuture.setFailure(cause);
        }
        ctx.close();
        log.error("业务处理错误，websocket client关闭", cause);
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
        // IdleStateHandler 所产生的 IdleStateEvent 的处理逻辑.
        if (evt instanceof IdleStateEvent e) {
            switch (e.state()) {
                case READER_IDLE:
                    handleReaderIdle(ctx);
                    break;
                case WRITER_IDLE:
                    handleWriterIdle(ctx);
                    break;
                case ALL_IDLE:
                    handleAllIdle(ctx);
                    break;
                default:
                    break;
            }
        }
    }


    /**
     * 处理close消息
     *
     * @param ch                  Channel ch
     * @param closeWebSocketFrame closeWebSocketFrame
     */
    protected void handlerClose(Channel ch, CloseWebSocketFrame closeWebSocketFrame) {
        log.warn("websocket client关闭");
        ch.close();
    }


    /**
     * 处理pong消息
     *
     * @param ch                 Channel ch
     * @param pongWebSocketFrame pongWebSocketFrame
     */
    protected void handlerPong(Channel ch, PongWebSocketFrame pongWebSocketFrame) {
        log.debug("WebSocket Client [{}] received pong", ch.attr(NettyConstants.CLIENT_NAME).get());

    }


    /**
     * 处理ping消息
     *
     * @param ch                 ch
     * @param pingWebSocketFrame pingWebSocketFrame
     */
    protected void handlerPing(Channel ch, PingWebSocketFrame pingWebSocketFrame) {
        log.debug("WebSocket Client [{}] received ping", ch.attr(NettyConstants.CLIENT_NAME).get());
        websocketClient.sendPong();
    }

    /**
     * 超过限定时间channel没有读时触发
     *
     * @param ctx ctx
     */
    protected void handleReaderIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有写时触发
     *
     * @param ctx ctx
     */
    protected void handleWriterIdle(ChannelHandlerContext ctx) {
    }

    /**
     * 超过限定时间channel没有读写时触发
     *
     * @param ctx ctx
     */
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        websocketClient.sendPing();
    }

    public ChannelFuture handshakeFuture() {
        return handshakeFuture;
    }
}

package cn.com.helei.depin.core.netty.base;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;

import java.util.function.Consumer;

@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode
public class HandlerEntity<T> {
    private long expireTime;

    private Consumer<T> callback;
}
package cn.com.helei.depin.core.netty.base;


import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;

/**
 * netty事件处理器
 */
public interface NettyClientEventHandler {

    /**
     * 激活事件
     * @param ctx ctx
     */
    default void activeHandler(ChannelHandlerContext ctx){}

    /**
     * 关闭事件
     * @param channel channel
     */
    default void closeHandler(Channel channel){}

    /**
     * 异常事件
     * @param ctx ctx
     * @param cause cause
     */
    void exceptionHandler(ChannelHandlerContext ctx, Throwable cause);
}

package cn.com.helei.depin.core.netty.constants;

import io.netty.util.AttributeKey;

public class NettyConstants {

    /**
     * 一朕的最大长度
     */
    public final static int MAX_FRAME_LENGTH = 1024;


    /**
     * 放在netty channel 里的 client_name 的 key
     */
    public static final AttributeKey<String> CLIENT_NAME = AttributeKey.valueOf("client_name");

    /**
     * 请求等待时间
     */
    public static final long REQUEST_WAITE_SECONDS = 60;

    /**
     * netty客户端断线重连时间
     */
    public static final int RECONNECT_DELAY_SECONDS = 5;


    /**
     * netty客户端断线重连次数
     */
    public static final int RECONNECT_LIMIT = 3;
}


package cn.com.helei.depin.core.netty.constants;


/**
 * WS客户端状态
 */
public enum WebsocketClientStatus {

    /**
     * 新建
     */
    NEW,

    /**
     * 正在启动
     */
    STARTING,

    /**
     * 正在运行
     */
    RUNNING,

    /**
     * 已暂停
     */
    STOP,

    /**
     * 已禁止使用
     */
    SHUTDOWN
}

package cn.com.helei.depin.core.netty.handler;

import cn.com.helei.depin.core.netty.constants.NettyConstants;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Consumer;


@Slf4j
public class RequestResponseHandler<T> {

    private final ConcurrentMap<String, HandlerEntity<T>> requestIdMap = new ConcurrentHashMap<>();


    /**
     * 注册request
     *
     * @param id request的id
     * @return 是否注册成功
     */
    public boolean registryRequest(String id, Consumer<T> callback) {
        AtomicBoolean res = new AtomicBoolean(false);
        requestIdMap.compute(id, (k, v) -> {
            if (v == null) {
                res.set(true);
                long expireTime = System.currentTimeMillis() + NettyConstants.REQUEST_WAITE_SECONDS * 1000;
                v = new HandlerEntity<>(expireTime, callback);
                log.debug("registry request id[{}] success, expire time [{}]", id, expireTime);
            }
            return v;
        });

        return res.get();
    }

    /**
     * 提交resoonse
     *
     * @param id       id
     * @param response response
     */
    public boolean submitResponse(String id, T response) {
        HandlerEntity<T> entity = requestIdMap.get(id);
        if (entity == null) {
            log.warn("request id[{}} didn't exist", id);
            return false;
        } else {
            long currentTimeMillis = System.currentTimeMillis();
            if (entity.expireTime < currentTimeMillis) {
                log.warn("request id[{}] expired, expire time[{}], currentTime[{}] cancel invoke callback",
                        id, entity.expireTime, currentTimeMillis);
                return false;
            } else {
                entity.callback.accept(response);
                log.debug("invoke request id[{}] callback success", id);
                return true;
            }
        }
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @EqualsAndHashCode
    static class HandlerEntity<T> {
        private long expireTime;

        private Consumer<T> callback;
    }
}

package cn.com.helei.depin.core.netty.handler;

public interface WSCloseHandler {


    void onClosed();
}


package cn.com.helei.depin.core.netty.util;

import io.protostuff.LinkedBuffer;
import io.protostuff.ProtobufIOUtil;
import io.protostuff.Schema;
import io.protostuff.runtime.RuntimeSchema;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;

public class ProtostuffUtils {
    /**
     * 避免每次序列化都重新申请Buffer空间
     * 这句话在实际生产上没有意义，耗时减少的极小，但高并发下，如果还用这个buffer，会报异常说buffer还没清空，就又被使用了
     */
//    private static LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
    /**
     * 缓存Schema
     */
    private static Map<Class<?>, Schema<?>> schemaCache = new ConcurrentHashMap<>();

    /**
     * 序列化方法，把指定对象序列化成字节数组
     *
     * @param obj
     * @param <T>
     * @return
     */
    @SuppressWarnings("unchecked")
    public static <T> byte[] serialize(T obj) {
        Class<T> clazz = (Class<T>) obj.getClass();
        Schema<T> schema = getSchema(clazz);
        LinkedBuffer buffer = LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);
        byte[] data;
        try {
            data = ProtobufIOUtil.toByteArray(obj, schema, buffer);
//            data = ProtostuffIOUtil.toByteArray(obj, schema, buffer);
        } finally {
            buffer.clear();
        }

        return data;
    }

    /**
     * 反序列化方法，将字节数组反序列化成指定Class类型
     *
     * @param data
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T deserialize(byte[] data, Class<T> clazz) {
        Schema<T> schema = getSchema(clazz);
        T obj = schema.newMessage();
        ProtobufIOUtil.mergeFrom(data, obj, schema);
//        ProtostuffIOUtil.mergeFrom(data, obj, schema);
        return obj;
    }

    @SuppressWarnings("unchecked")
    private static <T> Schema<T> getSchema(Class<T> clazz) {
        Schema<T> schema = (Schema<T>) schemaCache.get(clazz);
        if (Objects.isNull(schema)) {
            //这个schema通过RuntimeSchema进行懒创建并缓存
            //所以可以一直调用RuntimeSchema.getSchema(),这个方法是线程安全的
            schema = RuntimeSchema.getSchema(clazz);
            if (Objects.nonNull(schema)) {
                schemaCache.put(clazz, schema);
            }
        }

        return schema;
    }
}

package cn.com.helei.depin.core.network;

import lombok.Data;

import java.net.InetSocketAddress;
import java.net.SocketAddress;

@Data
public class NetworkProxy {
    private Integer id;

    private String host;

    private int port;

    private String username;

    private String password;

    public SocketAddress getAddress() {
        return new InetSocketAddress(host, port);
    }
}

package cn.com.helei.depin.core.network;

import com.jakewharton.fliptables.FlipTable;
import lombok.Getter;
import lombok.Setter;
import org.yaml.snakeyaml.Yaml;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class NetworkProxyPool {

    private static final String[] PROXY_LIST_PRINT_TABLE_HEADER = new String[]{"ID", "Host", "Port", "Username", "Password"};

    private static final Map<String, NetworkProxyPool> LOADED_POOL_MAP = new ConcurrentHashMap<>();

    @Getter
    private String configClassPath;

    @Setter
    private HashSet<NetworkProxy> pool;

    private final ConcurrentMap<Integer, NetworkProxy> idMapProxy = new ConcurrentHashMap<>();

    /**
     * 使用次数
     */
    private final Map<Integer, Integer> useCount = new HashMap<>();


    public static NetworkProxyPool loadYamlNetworkPool(String classpath) {
        return LOADED_POOL_MAP.compute(classpath, (k, pool) -> {
            if (pool == null) {
                Yaml yaml = new Yaml();
                try (InputStream inputStream = NetworkProxyPool.class.getClassLoader().getResourceAsStream(classpath)) {
                    Map<String, Object> yamlData = yaml.load(inputStream);
                    Map<String, Object> depin = (Map<String, Object>) yamlData.get("depin");
                    Map<String, Object> network = (Map<String, Object>) depin.get("network");
                    Map<String, Object> proxy = (Map<String, Object>) network.get("proxy");

                    NetworkProxyPool networkProxyPool = yaml.loadAs(yaml.dump(proxy), NetworkProxyPool.class);

                    networkProxyPool.pool.forEach(networkProxy -> {
                        networkProxyPool.idMapProxy.put(networkProxy.getId(), networkProxy);
                        networkProxyPool.useCount.put(networkProxy.getId(), 0);
                    });

                    networkProxyPool.configClassPath = classpath;

                    pool = networkProxyPool;
                } catch (IOException e) {
                    throw new RuntimeException(String.format("价值配置网络代理池文件[%s]发生错误", classpath));
                }
            }
            return pool;
        });
    }


    /**
     * 获取最少使用的代理
     *
     * @param count 数量
     * @return List<NetworkProxy>
     */
    public synchronized List<NetworkProxy> getLessUsedProxy(int count) {
         int batchSize = Math.min(count, useCount.size());

        List<NetworkProxy> res = new ArrayList<>(count);

        int needCount = count;
         while (needCount > 0) {
             int currentSize = Math.min(needCount, batchSize);

             List<NetworkProxy> batch = useCount.entrySet().stream()
                     .sorted((e1, e2) -> e1.getValue().compareTo(e2.getValue()))
                     .limit(currentSize)
                     .map(e -> {
                         useCount.compute(e.getKey(), (k, v) -> v == null ? 0 : v + 1);
                         return idMapProxy.get(e.getKey());
                     }).toList();
             res.addAll(batch);

             needCount -= batch.size();
         }

         return res;
    }

    /**
     * 获取代理
     *
     * @param id id
     * @return NetworkProxy
     */
    public synchronized NetworkProxy getProxy(Integer id) {
        return idMapProxy.compute(id, (k, v) -> {
            if (v == null) return null;

            useCount.compute(id, (k1, v1) -> {
                if (v1 == null) v1 = 0;

                return v1 + 1;
            });

            return v;
        });
    }


    /**
     * 打印池
     *
     * @return String
     */
    public String printPool() {
        String[][] table = new String[pool.size()][PROXY_LIST_PRINT_TABLE_HEADER.length];

        List<NetworkProxy> list = pool.stream().toList();
        for (int i = 0; i < list.size(); i++) {
            NetworkProxy proxy = list.get(i);
            table[i] = new String[]{String.valueOf(proxy.getId()), proxy.getHost(), String.valueOf(proxy.getPort()), proxy.getUsername(), proxy.getPassword()};
        }

        return FlipTable.of(PROXY_LIST_PRINT_TABLE_HEADER, table);
    }
}



package cn.com.helei.depin.core.supporter;

import cn.com.helei.depin.core.BaseDepinBotConfig;
import cn.com.helei.depin.core.dto.AccountContext;
import cn.com.helei.depin.core.dto.DepinClientAccount;
import cn.com.helei.depin.core.env.BrowserEnvPool;
import cn.com.helei.depin.core.network.NetworkProxy;
import cn.com.helei.depin.core.network.NetworkProxyPool;
import com.jakewharton.fliptables.FlipTable;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.ArrayList;
import java.util.List;

@Slf4j
public class AccountContextManager {

    private final String[] ACCOUNT_PRINT_TABLE_HEADER = {"row", "name", "proxy", "browser env","usable", "start time", "update time", "heartbeat", "status"};

    /**
     * 代理池
     */
    private final NetworkProxyPool proxyPool;

    /**
     * 浏览器环境池
     */
    private final BrowserEnvPool browserEnvPool;

    /**
     * 配置
     */
    private final BaseDepinBotConfig baseDepinBotConfig;

    /**
     * 账号列表
     */
    @Getter
    private final List<AccountContext> accounts = new ArrayList<>();

    public AccountContextManager(NetworkProxyPool proxyPool, BrowserEnvPool browserEnvPool, BaseDepinBotConfig baseDepinBotConfig) {
        this.proxyPool = proxyPool;
        this.browserEnvPool = browserEnvPool;
        this.baseDepinBotConfig = baseDepinBotConfig;
    }


    public void initAccount() {
        //Step 1 初始化账号
        List<AccountContext> notUsableAccounts = new ArrayList<>();
        baseDepinBotConfig
                .getAccountList()
                .forEach(depinClientAccount -> {
                    AccountContext.AccountContextBuilder builder = AccountContext.builder().clientAccount(depinClientAccount);

                    //账号没有配置代理，则将其设置为不可用
                    if (depinClientAccount.getProxyId() == null) {
                        builder.usable(false);
                    } else {
                        builder.browserEnv(browserEnvPool.getBrowserEnv(depinClientAccount.getBrowserEnvId()))
                                .usable(true)
                                .proxy(proxyPool.getProxy(depinClientAccount.getProxyId())).build();
                    }

                    AccountContext build = builder.build();
                    if (!build.isUsable()) notUsableAccounts.add(build);

                    accounts.add(build);
                });

        //Step 2 账号没代理的尝试给他设置代理
        if (!notUsableAccounts.isEmpty()) {
            log.warn("以下账号没有配置代理，将随机选择一个代理进行使用");
            List<NetworkProxy> lessUsedProxy = proxyPool.getLessUsedProxy(notUsableAccounts.size());
            for (int i = 0; i < notUsableAccounts.size(); i++) {
                notUsableAccounts.get(i).setProxy(lessUsedProxy.get(i));
                notUsableAccounts.get(i).setUsable(true);
                log.error("账号:{},将使用代理:{}", notUsableAccounts.get(i).getClientAccount().getName(), lessUsedProxy.get(i));
            }
        }
    }


    /**
     * 打印账号列表
     *
     * @return String
     */
    public String printAccountList() {
        StringBuilder sb = new StringBuilder();


        String[][] table = new String[accounts.size()][ACCOUNT_PRINT_TABLE_HEADER.length];

        for (int i = 0; i < accounts.size(); i++) {
            AccountContext accountContext = accounts.get(i);
            DepinClientAccount clientAccount = accountContext.getClientAccount();
            table[i] = new String[]{
                    String.valueOf(i),
                    clientAccount.getName(),
                    accountContext.getProxy().getHost() + ":" + accountContext.getProxy().getPort(),
                    String.valueOf(clientAccount.getBrowserEnvId()),
                    String.valueOf(accountContext.isUsable()),
                    String.valueOf(accountContext.getConnectStatusInfo().getStartDateTime()),
                    String.valueOf(accountContext.getConnectStatusInfo().getUpdateDateTime()),
                    String.valueOf(accountContext.getConnectStatusInfo().getHeartBeatCount()),
                    String.valueOf(accountContext.getConnectStatusInfo().getConnectStatus())
            };
        }

        sb.append("账号列表:\n").append(FlipTable.of(ACCOUNT_PRINT_TABLE_HEADER, table)).append("\n");

        return sb.toString();
    }
}

package cn.com.helei.depin.core.util;

import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

public class NamedThreadFactory implements ThreadFactory {

    private final String namePrefix;
    private final AtomicInteger threadNumber = new AtomicInteger(1);

    public NamedThreadFactory(String namePrefix) {
        this.namePrefix = namePrefix;
    }

    @Override
    public Thread newThread(Runnable r) {
        // 使用指定的名称前缀和自动编号来创建线程名称
        Thread thread = new Thread(r, namePrefix + "-" + threadNumber.getAndIncrement());
        // 设置为守护线程（可选）
        thread.setDaemon(false);
        return thread;
    }
}
package cn.com.helei.depin.core.util;

import cn.com.helei.depin.core.network.NetworkProxy;
import com.alibaba.fastjson.JSONObject;
import lombok.extern.slf4j.Slf4j;
import okhttp3.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.io.IOException;
import java.net.Proxy;
import java.net.SocketTimeoutException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;

@Slf4j
public class RestApiClient {

    private static final int RETRY_TIMES = 3;

    private final OkHttpClient okHttpClient;

    private final ExecutorService executorService;

    public RestApiClient(
            NetworkProxy proxy,
            ExecutorService executorService
    ) {
        this.executorService = executorService;
        OkHttpClient.Builder builder = new OkHttpClient.Builder();
        if (proxy != null) {
            builder.proxy(new Proxy(Proxy.Type.HTTP, proxy.getAddress()))
                    .authenticator(new Authenticator() {
                        @NotNull
                        @Override
                        public Request authenticate(@Nullable Route route, @NotNull Response response) throws IOException {
                            String credential = Credentials.basic(proxy.getUsername(), proxy.getPassword());
                            return response.request().newBuilder()
                                    .header("Authorization", credential)
                                    .build();
                        }
                    });
        }
        this.okHttpClient = builder.build();
    }


    /**
     * 发送请求，如果有asKey参数不为null，则会鉴权
     *
     * @param method method
     * @param params params
     * @param body   body
     * @return CompletableFuture<JSONObject>
     */
    public CompletableFuture<String> request(
            String url,
            String method,
            JSONObject params,
            JSONObject body
    ) {
        return CompletableFuture.supplyAsync(() -> {
            // 创建表单数据
            StringBuilder queryString = new StringBuilder();


            if (params != null) {
                params.keySet().forEach(key -> {
                    queryString.append(key).append("=").append(params.get(key)).append("&");
                });

                if (!queryString.isEmpty()) {
                    queryString.deleteCharAt(queryString.length() - 1);
                }
            }

            String requestUrl = url + "?" + queryString;
            FormBody.Builder bodyBuilder = new FormBody.Builder();

            if (body != null) {
                body.forEach((k, v) -> bodyBuilder.add(k, String.valueOf(v)));
            }

            Request.Builder builder = new Request.Builder();
            builder.header("Content-Type", "application/json");

            // 创建 POST 请求
            builder.url(requestUrl);
            String upperCase = method.toUpperCase();
            if (upperCase.equals("GET")) {
                builder.get();
            } else {
                builder.method(upperCase, bodyBuilder.build());
            }

            Request request = builder.build();

            log.info("创建请求 url[{}], method[{}]成功，开始请求服务器", url, method);

            for (int i = 0; i < RETRY_TIMES; i++) {
                // 发送请求并获取响应
                try (Response response = okHttpClient.newCall(request).execute()) {
                    if (response.isSuccessful()) {
                        return response.body() == null ? "{}" : response.body().string();
                    } else {
                        log.error("请求url [{}] 失败， code [{}]， {}", url, response.code(), response.body());
                        break;
                    }
                } catch (SocketTimeoutException e) {
                    log.warn("请求[{}]超时，尝试重新请求 [{}/{}]", url, i, RETRY_TIMES);
                } catch (IOException e) {
                    log.error("请求url [{}] 失败", url, e);
                    throw new RuntimeException(e);
                }
            }

            return null;
        }, executorService);
    }
}

package cn.com.helei.depin.core;

import cn.com.helei.depin.core.dto.AccountContext;
import cn.com.helei.depin.core.dto.ConnectStatus;
import cn.com.helei.depin.core.dto.DepinClientAccount;
import cn.com.helei.depin.core.netty.base.AbstractWebsocketClient;
import cn.com.helei.depin.core.netty.constants.WebsocketClientStatus;
import cn.com.helei.depin.core.netty.handler.WSCloseHandler;
import cn.com.helei.depin.core.util.RestApiClient;
import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.util.concurrent.CompletableFuture;


@Slf4j
@Getter
public class AbstractDepinClient<Req, Resp> extends AbstractWebsocketClient<Req, Resp> {

    /**
     * 网络请求客户端
     */
    private final RestApiClient restApiClient;

    /**
     * client对应的账号
     */
    private final AccountContext accountContext;

    public AbstractDepinClient(
            AccountContext accountContext,
            AbstractDepinWSClientHandler<Req, Resp> handler
    ) {
        super(accountContext.getClientAccount().getConnectUrl(), handler);
        super.setName(accountContext.getClientAccount().getName());
        super.setHeaders(accountContext.getClientAccount().getHeaders());

        super.setProxy(accountContext.getProxy());

        super.setClientStatusChangeHandler(this::whenClientStatusChange);

        this.accountContext = accountContext;
        this.restApiClient = new RestApiClient(accountContext.getProxy(), super.getCallbackInvoker());
    }


    @Override
    public CompletableFuture<Boolean> connect(WSCloseHandler wsCloseHandler) {


        return super.connect(wsCloseHandler);
    }


    /**
     * ws客户端状态改变，同步更新账户状态
     *
     * @param newClientStatus 最新的客户端状态
     */
    public void whenClientStatusChange(WebsocketClientStatus newClientStatus) {
        accountContext.getConnectStatusInfo().setConnectStatus(
                switch (newClientStatus) {
                    case NEW -> ConnectStatus.NEW;
                    case STARTING -> ConnectStatus.STARTING;
                    case RUNNING -> ConnectStatus.RUNNING;
                    case STOP -> ConnectStatus.STOP;
                    case SHUTDOWN -> ConnectStatus.STOP;
                }
        );
    }
}
package cn.com.helei.depin.core;

import cn.com.helei.depin.core.netty.base.AbstractWebSocketClientHandler;
import io.netty.channel.ChannelHandlerContext;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class AbstractDepinWSClientHandler<Req, Resp> extends AbstractWebSocketClientHandler<Req, Resp> {


    /**
     * channel 空闲，向其发送心跳
     * @param ctx ctx
     */
    @Override
    protected void handleAllIdle(ChannelHandlerContext ctx) {
        websocketClient
                .sendMessage(heartBeatMessage())
                .exceptionallyAsync(throwable -> {
                    // 心跳发送异常，打印日志
                    log.error("client[{}] 发送心跳异常", websocketClient.getName(), throwable);
                    return null;
                }, websocketClient.getCallbackInvoker());
    }

    @Override
    public String getRequestId(Req request) {
        return "";
    }

    @Override
    public String getResponseId(Resp response) {
        return "";
    }

    protected abstract Req heartBeatMessage();
}
package cn.com.helei.depin.core;


import cn.com.helei.depin.core.dto.DepinClientAccount;
import lombok.Data;

import java.util.List;

@Data
public abstract class BaseDepinBotConfig {


    /**
     * 并发数量
     */
    private int concurrentCount = 20;


    /**
     * 网络代理池配置文件名
     */
    private String networkPoolConfig = "network-proxy.yaml";

    /**
     * 浏览器环境池配置文件名
     */
    private String browserEnvPoolConfig = "browser-env.yaml";

    /**
     * 连接url
     */
    private String wsBaseUrl;


    public abstract List<DepinClientAccount> getAccountList();
}
